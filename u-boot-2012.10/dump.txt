
u-boot:     file format elf32-littlearm


Disassembly of section .text:

34800000 <__image_copy_start>:
#include <version.h>
#include <asm/system.h>
#include <linux/linkage.h>

.globl _start
_start: b	reset
34800000:	ea000014 	b	34800058 <reset>
	ldr	pc, _undefined_instruction
34800004:	e59ff014 	ldr	pc, [pc, #20]	; 34800020 <_undefined_instruction>
	ldr	pc, _software_interrupt
34800008:	e59ff014 	ldr	pc, [pc, #20]	; 34800024 <_software_interrupt>
	ldr	pc, _prefetch_abort
3480000c:	e59ff014 	ldr	pc, [pc, #20]	; 34800028 <_prefetch_abort>
	ldr	pc, _data_abort
34800010:	e59ff014 	ldr	pc, [pc, #20]	; 3480002c <_data_abort>
	ldr	pc, _not_used
34800014:	e59ff014 	ldr	pc, [pc, #20]	; 34800030 <_not_used>
	ldr	pc, _irq
34800018:	e59ff014 	ldr	pc, [pc, #20]	; 34800034 <_irq>
	ldr	pc, _fiq
3480001c:	e59ff014 	ldr	pc, [pc, #20]	; 34800038 <_fiq>

34800020 <_undefined_instruction>:
34800020:	34800220 	.word	0x34800220

34800024 <_software_interrupt>:
34800024:	34800280 	.word	0x34800280

34800028 <_prefetch_abort>:
34800028:	348002e0 	.word	0x348002e0

3480002c <_data_abort>:
3480002c:	34800340 	.word	0x34800340

34800030 <_not_used>:
34800030:	348003a0 	.word	0x348003a0

34800034 <_irq>:
34800034:	34800400 	.word	0x34800400

34800038 <_fiq>:
34800038:	34800460 	.word	0x34800460

3480003c <_pad>:
3480003c:	12345678 	.word	0x12345678

34800040 <_TEXT_BASE>:
34800040:	34800000 	.word	0x34800000

34800044 <_bss_start_ofs>:
34800044:	00029ba0 	.word	0x00029ba0

34800048 <_image_copy_end_ofs>:
34800048:	00029ba0 	.word	0x00029ba0

3480004c <_bss_end_ofs>:
3480004c:	0002bf08 	.word	0x0002bf08

34800050 <_end_ofs>:
34800050:	0002df28 	.word	0x0002df28

34800054 <IRQ_STACK_START_IN>:
34800054:	0badc0de 	.word	0x0badc0de

34800058 <reset>:
/*
 * the actual reset code
 */

reset:
	bl	save_boot_params
34800058:	eb00005b 	bl	348001cc <save_boot_params>
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0, cpsr
3480005c:	e10f0000 	mrs	r0, CPSR
	bic	r0, r0, #0x1f
34800060:	e3c0001f 	bic	r0, r0, #31
	orr	r0, r0, #0xd3
34800064:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
34800068:	e129f000 	msr	CPSR_fc, r0
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register
3480006c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, #CR_V		@ V = 0
34800070:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register
34800074:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start
34800078:	e59f046c 	ldr	r0, [pc, #1132]	; 348004ec <led2_on+0x14>
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
3480007c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif

	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_cp15
34800080:	eb000052 	bl	348001d0 <cpu_init_cp15>
	bl	cpu_init_crit
34800084:	eb00005f 	bl	34800208 <cpu_init_crit>

34800088 <call_board_init_f>:
#endif

/* Set stackpointer in internal RAM to call board_init_f */
call_board_init_f:
	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
34800088:	e3a0d423 	mov	sp, #587202560	; 0x23000000
	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
3480008c:	e3cdd007 	bic	sp, sp, #7
	ldr	r0,=0x00000000
34800090:	e3a00000 	mov	r0, #0
//	bl	board_init_f

	ldr r0, =_start
34800094:	e59f0450 	ldr	r0, [pc, #1104]	; 348004ec <led2_on+0x14>
	ldr r1, _board_init_f_ofs
34800098:	e59f1008 	ldr	r1, [pc, #8]	; 348000a8 <_board_init_f_ofs>

	add lr, r0, r1
3480009c:	e080e001 	add	lr, r0, r1
	ldr	r0,=0x00000000
348000a0:	e3a00000 	mov	r0, #0
	mov pc, lr
348000a4:	e1a0f00e 	mov	pc, lr

348000a8 <_board_init_f_ofs>:
348000a8:	00001c34 	.word	0x00001c34

348000ac <relocate_code>:
 * This "function" does not return, instead it continues in RAM
 * after relocating the monitor code.
 *
 */
ENTRY(relocate_code)
	mov	r4, r0	/* save addr_sp */
348000ac:	e1a04000 	mov	r4, r0
	mov	r5, r1	/* save addr of gd */
348000b0:	e1a05001 	mov	r5, r1
	mov	r6, r2	/* save addr of destination */
348000b4:	e1a06002 	mov	r6, r2

348000b8 <stack_setup>:

	/* Set up the stack						    */
stack_setup:
	mov	sp, r4
348000b8:	e1a0d004 	mov	sp, r4

	adr	r0, _start
348000bc:	e24f00c4 	sub	r0, pc, #196	; 0xc4
	cmp	r0, r6
348000c0:	e1500006 	cmp	r0, r6
	moveq	r9, #0		/* no relocation. relocation offset(r9) = 0 */
348000c4:	03a09000 	moveq	r9, #0
	beq	clear_bss		/* skip relocation */
348000c8:	0a000026 	beq	34800168 <clear_bss>
	mov	r1, r6			/* r1 <- scratch for copy_loop */
348000cc:	e1a01006 	mov	r1, r6
	ldr	r3, _image_copy_end_ofs
348000d0:	e51f3090 	ldr	r3, [pc, #-144]	; 34800048 <_image_copy_end_ofs>
	add	r2, r0, r3		/* r2 <- source end address	    */
348000d4:	e0802003 	add	r2, r0, r3

348000d8 <copy_loop>:

copy_loop:
	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
348000d8:	e8b00600 	ldm	r0!, {r9, sl}
	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
348000dc:	e8a10600 	stmia	r1!, {r9, sl}
	cmp	r0, r2			/* until source end address [r2]    */
348000e0:	e1500002 	cmp	r0, r2
	blo	copy_loop
348000e4:	3afffffb 	bcc	348000d8 <copy_loop>

	/*
	 * fix .rel.dyn relocations
	 */
	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
348000e8:	e51f00b0 	ldr	r0, [pc, #-176]	; 34800040 <_TEXT_BASE>
	sub	r9, r6, r0		/* r9 <- relocation offset */
348000ec:	e0469000 	sub	r9, r6, r0
	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
348000f0:	e59fa06c 	ldr	sl, [pc, #108]	; 34800164 <_dynsym_start_ofs>
	add	r10, r10, r0		/* r10 <- sym table in FLASH */
348000f4:	e08aa000 	add	sl, sl, r0
	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
348000f8:	e59f205c 	ldr	r2, [pc, #92]	; 3480015c <_rel_dyn_start_ofs>
	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
348000fc:	e0822000 	add	r2, r2, r0
	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
34800100:	e59f3058 	ldr	r3, [pc, #88]	; 34800160 <_rel_dyn_end_ofs>
	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
34800104:	e0833000 	add	r3, r3, r0

34800108 <fixloop>:
fixloop:
	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
34800108:	e5920000 	ldr	r0, [r2]
	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
3480010c:	e0800009 	add	r0, r0, r9
	ldr	r1, [r2, #4]
34800110:	e5921004 	ldr	r1, [r2, #4]
	and	r7, r1, #0xff
34800114:	e20170ff 	and	r7, r1, #255	; 0xff
	cmp	r7, #23			/* relative fixup? */
34800118:	e3570017 	cmp	r7, #23
	beq	fixrel
3480011c:	0a000007 	beq	34800140 <fixrel>
	cmp	r7, #2			/* absolute fixup? */
34800120:	e3570002 	cmp	r7, #2
	beq	fixabs
34800124:	0a000000 	beq	3480012c <fixabs>
	/* ignore unknown type of fixup */
	b	fixnext
34800128:	ea000006 	b	34800148 <fixnext>

3480012c <fixabs>:
fixabs:
	/* absolute fix: set location to (offset) symbol value */
	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
3480012c:	e1a01221 	lsr	r1, r1, #4
	add	r1, r10, r1		/* r1 <- address of symbol in table */
34800130:	e08a1001 	add	r1, sl, r1
	ldr	r1, [r1, #4]		/* r1 <- symbol value */
34800134:	e5911004 	ldr	r1, [r1, #4]
	add	r1, r1, r9		/* r1 <- relocated sym addr */
34800138:	e0811009 	add	r1, r1, r9
	b	fixnext
3480013c:	ea000001 	b	34800148 <fixnext>

34800140 <fixrel>:
fixrel:
	/* relative fix: increase location by offset */
	ldr	r1, [r0]
34800140:	e5901000 	ldr	r1, [r0]
	add	r1, r1, r9
34800144:	e0811009 	add	r1, r1, r9

34800148 <fixnext>:
fixnext:
	str	r1, [r0]
34800148:	e5801000 	str	r1, [r0]
	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
3480014c:	e2822008 	add	r2, r2, #8
	cmp	r2, r3
34800150:	e1520003 	cmp	r2, r3
	blo	fixloop
34800154:	3affffeb 	bcc	34800108 <fixloop>
	b	clear_bss
34800158:	ea000002 	b	34800168 <clear_bss>

3480015c <_rel_dyn_start_ofs>:
3480015c:	00029ba0 	.word	0x00029ba0

34800160 <_rel_dyn_end_ofs>:
34800160:	0002de58 	.word	0x0002de58

34800164 <_dynsym_start_ofs>:
34800164:	0002de58 	.word	0x0002de58

34800168 <clear_bss>:
	.word __rel_dyn_end - _start
_dynsym_start_ofs:
	.word __dynsym_start - _start

clear_bss:
	ldr	r0, _bss_start_ofs
34800168:	e51f012c 	ldr	r0, [pc, #-300]	; 34800044 <_bss_start_ofs>
	ldr	r1, _bss_end_ofs
3480016c:	e51f1128 	ldr	r1, [pc, #-296]	; 3480004c <_bss_end_ofs>
	mov	r4, r6			/* reloc addr */
34800170:	e1a04006 	mov	r4, r6
	add	r0, r0, r4
34800174:	e0800004 	add	r0, r0, r4
	add	r1, r1, r4
34800178:	e0811004 	add	r1, r1, r4
	mov	r2, #0x00000000		/* clear			    */
3480017c:	e3a02000 	mov	r2, #0

34800180 <clbss_l>:

clbss_l:cmp	r0, r1			/* clear loop... */
34800180:	e1500001 	cmp	r0, r1
	bhs	clbss_e			/* if reached end of bss, exit */
34800184:	2a000002 	bcs	34800194 <clbss_e>
	str	r2, [r0]
34800188:	e5802000 	str	r2, [r0]
	add	r0, r0, #4
3480018c:	e2800004 	add	r0, r0, #4
	b	clbss_l
34800190:	eafffffa 	b	34800180 <clbss_l>

34800194 <clbss_e>:
jump_2_ram:
/*
 * If I-cache is enabled invalidate it
 */
#ifndef CONFIG_SYS_ICACHE_OFF
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
34800194:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
34800198:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
3480019c:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}
/*
 * Move vector table
 */
#if !defined(CONFIG_TEGRA20)
	/* Set vector address in CP15 VBAR register */
	ldr     r0, =_start
348001a0:	e59f0344 	ldr	r0, [pc, #836]	; 348004ec <led2_on+0x14>
	add     r0, r0, r9
348001a4:	e0800009 	add	r0, r0, r9
	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR
348001a8:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif /* !Tegra20 */

	ldr	r0, _board_init_r_ofs
348001ac:	e59f0014 	ldr	r0, [pc, #20]	; 348001c8 <_board_init_r_ofs>
	adr	r1, _start
348001b0:	e24f1f6e 	sub	r1, pc, #440	; 0x1b8
	add	lr, r0, r1
348001b4:	e080e001 	add	lr, r0, r1
	add	lr, lr, r9
348001b8:	e08ee009 	add	lr, lr, r9
	/* setup parameters for board_init_r */
	mov	r0, r5		/* gd_t */
348001bc:	e1a00005 	mov	r0, r5
	mov	r1, r6		/* dest_addr */
348001c0:	e1a01006 	mov	r1, r6
	/* jump to it ... */
	mov	pc, lr
348001c4:	e1a0f00e 	mov	pc, lr

348001c8 <_board_init_r_ofs>:
348001c8:	00001b80 	.word	0x00001b80

348001cc <save_boot_params>:
 * Stack pointer is not yet initialized at this moment
 * Don't save anything to stack even if compiled with -O0
 *
 *************************************************************************/
ENTRY(save_boot_params)
	bx	lr			@ back to my caller
348001cc:	e12fff1e 	bx	lr

348001d0 <cpu_init_cp15>:
 *************************************************************************/
ENTRY(cpu_init_cp15)
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
348001d0:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
348001d4:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
348001d8:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
348001dc:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
348001e0:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
348001e4:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
348001e8:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
348001ec:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
348001f0:	e3c00007 	bic	r0, r0, #7
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
348001f4:	e3800002 	orr	r0, r0, #2
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
348001f8:	e3800b02 	orr	r0, r0, #2048	; 0x800
#ifdef CONFIG_SYS_ICACHE_OFF
	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
#else
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
348001fc:	e3800a01 	orr	r0, r0, #4096	; 0x1000
#endif
	mcr	p15, 0, r0, c1, c0, 0
34800200:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	mov	pc, lr			@ back to my caller
34800204:	e1a0f00e 	mov	pc, lr

34800208 <cpu_init_crit>:
	bl led1_on
ii:
	b ii
*/

	b	lowlevel_init		@ go setup pll,mux,memory
34800208:	ea0000bd 	b	34800504 <lowlevel_init>
3480020c:	e320f000 	nop	{0}
34800210:	e320f000 	nop	{0}
34800214:	e320f000 	nop	{0}
34800218:	e320f000 	nop	{0}
3480021c:	e320f000 	nop	{0}

34800220 <undefined_instruction>:
/*
 * exception handlers
 */
	.align	5
undefined_instruction:
	get_bad_stack
34800220:	e51fd1d4 	ldr	sp, [pc, #-468]	; 34800054 <IRQ_STACK_START_IN>
34800224:	e58de000 	str	lr, [sp]
34800228:	e14fe000 	mrs	lr, SPSR
3480022c:	e58de004 	str	lr, [sp, #4]
34800230:	e3a0d013 	mov	sp, #19
34800234:	e169f00d 	msr	SPSR_fc, sp
34800238:	e1a0e00f 	mov	lr, pc
3480023c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800240:	e24dd048 	sub	sp, sp, #72	; 0x48
34800244:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800248:	e51f21fc 	ldr	r2, [pc, #-508]	; 34800054 <IRQ_STACK_START_IN>
3480024c:	e892000c 	ldm	r2, {r2, r3}
34800250:	e28d0048 	add	r0, sp, #72	; 0x48
34800254:	e28d5034 	add	r5, sp, #52	; 0x34
34800258:	e1a0100e 	mov	r1, lr
3480025c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800260:	e1a0000d 	mov	r0, sp
	bl	do_undefined_instruction
34800264:	eb0007b5 	bl	34802140 <do_undefined_instruction>
34800268:	e320f000 	nop	{0}
3480026c:	e320f000 	nop	{0}
34800270:	e320f000 	nop	{0}
34800274:	e320f000 	nop	{0}
34800278:	e320f000 	nop	{0}
3480027c:	e320f000 	nop	{0}

34800280 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack_swi
34800280:	e24dd004 	sub	sp, sp, #4
34800284:	e58d0000 	str	r0, [sp]
34800288:	e51f023c 	ldr	r0, [pc, #-572]	; 34800054 <IRQ_STACK_START_IN>
3480028c:	e580e000 	str	lr, [r0]
34800290:	e14f0000 	mrs	r0, SPSR
34800294:	e580e004 	str	lr, [r0, #4]
34800298:	e59d0000 	ldr	r0, [sp]
3480029c:	e28dd004 	add	sp, sp, #4
	bad_save_user_regs
348002a0:	e24dd048 	sub	sp, sp, #72	; 0x48
348002a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348002a8:	e51f225c 	ldr	r2, [pc, #-604]	; 34800054 <IRQ_STACK_START_IN>
348002ac:	e892000c 	ldm	r2, {r2, r3}
348002b0:	e28d0048 	add	r0, sp, #72	; 0x48
348002b4:	e28d5034 	add	r5, sp, #52	; 0x34
348002b8:	e1a0100e 	mov	r1, lr
348002bc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348002c0:	e1a0000d 	mov	r0, sp
	bl	do_software_interrupt
348002c4:	eb0007a6 	bl	34802164 <do_software_interrupt>
348002c8:	e320f000 	nop	{0}
348002cc:	e320f000 	nop	{0}
348002d0:	e320f000 	nop	{0}
348002d4:	e320f000 	nop	{0}
348002d8:	e320f000 	nop	{0}
348002dc:	e320f000 	nop	{0}

348002e0 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
348002e0:	e51fd294 	ldr	sp, [pc, #-660]	; 34800054 <IRQ_STACK_START_IN>
348002e4:	e58de000 	str	lr, [sp]
348002e8:	e14fe000 	mrs	lr, SPSR
348002ec:	e58de004 	str	lr, [sp, #4]
348002f0:	e3a0d013 	mov	sp, #19
348002f4:	e169f00d 	msr	SPSR_fc, sp
348002f8:	e1a0e00f 	mov	lr, pc
348002fc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800300:	e24dd048 	sub	sp, sp, #72	; 0x48
34800304:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800308:	e51f22bc 	ldr	r2, [pc, #-700]	; 34800054 <IRQ_STACK_START_IN>
3480030c:	e892000c 	ldm	r2, {r2, r3}
34800310:	e28d0048 	add	r0, sp, #72	; 0x48
34800314:	e28d5034 	add	r5, sp, #52	; 0x34
34800318:	e1a0100e 	mov	r1, lr
3480031c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800320:	e1a0000d 	mov	r0, sp
	bl	do_prefetch_abort
34800324:	eb000797 	bl	34802188 <do_prefetch_abort>
34800328:	e320f000 	nop	{0}
3480032c:	e320f000 	nop	{0}
34800330:	e320f000 	nop	{0}
34800334:	e320f000 	nop	{0}
34800338:	e320f000 	nop	{0}
3480033c:	e320f000 	nop	{0}

34800340 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
34800340:	e51fd2f4 	ldr	sp, [pc, #-756]	; 34800054 <IRQ_STACK_START_IN>
34800344:	e58de000 	str	lr, [sp]
34800348:	e14fe000 	mrs	lr, SPSR
3480034c:	e58de004 	str	lr, [sp, #4]
34800350:	e3a0d013 	mov	sp, #19
34800354:	e169f00d 	msr	SPSR_fc, sp
34800358:	e1a0e00f 	mov	lr, pc
3480035c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800360:	e24dd048 	sub	sp, sp, #72	; 0x48
34800364:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800368:	e51f231c 	ldr	r2, [pc, #-796]	; 34800054 <IRQ_STACK_START_IN>
3480036c:	e892000c 	ldm	r2, {r2, r3}
34800370:	e28d0048 	add	r0, sp, #72	; 0x48
34800374:	e28d5034 	add	r5, sp, #52	; 0x34
34800378:	e1a0100e 	mov	r1, lr
3480037c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800380:	e1a0000d 	mov	r0, sp
	bl	do_data_abort
34800384:	eb000788 	bl	348021ac <do_data_abort>
34800388:	e320f000 	nop	{0}
3480038c:	e320f000 	nop	{0}
34800390:	e320f000 	nop	{0}
34800394:	e320f000 	nop	{0}
34800398:	e320f000 	nop	{0}
3480039c:	e320f000 	nop	{0}

348003a0 <not_used>:

	.align	5
not_used:
	get_bad_stack
348003a0:	e51fd354 	ldr	sp, [pc, #-852]	; 34800054 <IRQ_STACK_START_IN>
348003a4:	e58de000 	str	lr, [sp]
348003a8:	e14fe000 	mrs	lr, SPSR
348003ac:	e58de004 	str	lr, [sp, #4]
348003b0:	e3a0d013 	mov	sp, #19
348003b4:	e169f00d 	msr	SPSR_fc, sp
348003b8:	e1a0e00f 	mov	lr, pc
348003bc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
348003c0:	e24dd048 	sub	sp, sp, #72	; 0x48
348003c4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348003c8:	e51f237c 	ldr	r2, [pc, #-892]	; 34800054 <IRQ_STACK_START_IN>
348003cc:	e892000c 	ldm	r2, {r2, r3}
348003d0:	e28d0048 	add	r0, sp, #72	; 0x48
348003d4:	e28d5034 	add	r5, sp, #52	; 0x34
348003d8:	e1a0100e 	mov	r1, lr
348003dc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348003e0:	e1a0000d 	mov	r0, sp
	bl	do_not_used
348003e4:	eb000779 	bl	348021d0 <do_not_used>
348003e8:	e320f000 	nop	{0}
348003ec:	e320f000 	nop	{0}
348003f0:	e320f000 	nop	{0}
348003f4:	e320f000 	nop	{0}
348003f8:	e320f000 	nop	{0}
348003fc:	e320f000 	nop	{0}

34800400 <irq>:

#else

	.align	5
irq:
	get_bad_stack
34800400:	e51fd3b4 	ldr	sp, [pc, #-948]	; 34800054 <IRQ_STACK_START_IN>
34800404:	e58de000 	str	lr, [sp]
34800408:	e14fe000 	mrs	lr, SPSR
3480040c:	e58de004 	str	lr, [sp, #4]
34800410:	e3a0d013 	mov	sp, #19
34800414:	e169f00d 	msr	SPSR_fc, sp
34800418:	e1a0e00f 	mov	lr, pc
3480041c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800420:	e24dd048 	sub	sp, sp, #72	; 0x48
34800424:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800428:	e51f23dc 	ldr	r2, [pc, #-988]	; 34800054 <IRQ_STACK_START_IN>
3480042c:	e892000c 	ldm	r2, {r2, r3}
34800430:	e28d0048 	add	r0, sp, #72	; 0x48
34800434:	e28d5034 	add	r5, sp, #52	; 0x34
34800438:	e1a0100e 	mov	r1, lr
3480043c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800440:	e1a0000d 	mov	r0, sp
	bl	do_irq
34800444:	eb000773 	bl	34802218 <do_irq>
34800448:	e320f000 	nop	{0}
3480044c:	e320f000 	nop	{0}
34800450:	e320f000 	nop	{0}
34800454:	e320f000 	nop	{0}
34800458:	e320f000 	nop	{0}
3480045c:	e320f000 	nop	{0}

34800460 <fiq>:

	.align	5
fiq:
	get_bad_stack
34800460:	e51fd414 	ldr	sp, [pc, #-1044]	; 34800054 <IRQ_STACK_START_IN>
34800464:	e58de000 	str	lr, [sp]
34800468:	e14fe000 	mrs	lr, SPSR
3480046c:	e58de004 	str	lr, [sp, #4]
34800470:	e3a0d013 	mov	sp, #19
34800474:	e169f00d 	msr	SPSR_fc, sp
34800478:	e1a0e00f 	mov	lr, pc
3480047c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800480:	e24dd048 	sub	sp, sp, #72	; 0x48
34800484:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800488:	e51f243c 	ldr	r2, [pc, #-1084]	; 34800054 <IRQ_STACK_START_IN>
3480048c:	e892000c 	ldm	r2, {r2, r3}
34800490:	e28d0048 	add	r0, sp, #72	; 0x48
34800494:	e28d5034 	add	r5, sp, #52	; 0x34
34800498:	e1a0100e 	mov	r1, lr
3480049c:	e885000f 	stm	r5, {r0, r1, r2, r3}
348004a0:	e1a0000d 	mov	r0, sp
	bl	do_fiq
348004a4:	eb000752 	bl	348021f4 <do_fiq>

348004a8 <gpio_out>:

#endif /* CONFIG_USE_IRQ */
#endif /* CONFIG_SPL_BUILD */

gpio_out:
	ldr r11, =0xE0200280
348004a8:	e59fb040 	ldr	fp, [pc, #64]	; 348004f0 <led2_on+0x18>
	ldr r12, =0x00001111
348004ac:	e59fc040 	ldr	ip, [pc, #64]	; 348004f4 <led2_on+0x1c>
	str r12, [r11]   
348004b0:	e58bc000 	str	ip, [fp]
	
	ldr r11, =0xE0200284 
348004b4:	e59fb03c 	ldr	fp, [pc, #60]	; 348004f8 <led2_on+0x20>
	ldr r12, =0xf
348004b8:	e3a0c00f 	mov	ip, #15
	str r12, [r11]   
348004bc:	e58bc000 	str	ip, [fp]
	mov pc, lr
348004c0:	e1a0f00e 	mov	pc, lr

348004c4 <led1_on>:
	
.global led1_on
led1_on:
	ldr r11, =0xE0200284
348004c4:	e59fb02c 	ldr	fp, [pc, #44]	; 348004f8 <led2_on+0x20>
	ldr r12, [r11]
348004c8:	e59bc000 	ldr	ip, [fp]
	bic r12, r12, #1
348004cc:	e3ccc001 	bic	ip, ip, #1
	str r12, [r11]
348004d0:	e58bc000 	str	ip, [fp]
	mov pc, lr
348004d4:	e1a0f00e 	mov	pc, lr

348004d8 <led2_on>:

.global led2_on
led2_on:
	ldr r11, =0xE0200284
348004d8:	e59fb018 	ldr	fp, [pc, #24]	; 348004f8 <led2_on+0x20>
	ldr r12, [r11]
348004dc:	e59bc000 	ldr	ip, [fp]
	bic r12, r12, #2
348004e0:	e3ccc002 	bic	ip, ip, #2
	str r12, [r11]
348004e4:	e58bc000 	str	ip, [fp]
	mov pc, lr
348004e8:	e1a0f00e 	mov	pc, lr
348004ec:	34800000 	.word	0x34800000
348004f0:	e0200280 	.word	0xe0200280
348004f4:	00001111 	.word	0x00001111
348004f8:	e0200284 	.word	0xe0200284
348004fc:	e320f000 	nop	{0}

34800500 <_TEXT_BASE>:
34800500:	34800000 	.word	0x34800000

34800504 <lowlevel_init>:
_TEXT_BASE:
	.word	CONFIG_SYS_TEXT_BASE

	.globl lowlevel_init
lowlevel_init:
	mov	r11, lr
34800504:	e1a0b00e 	mov	fp, lr

	/* r5 has always zero */
	mov	r5, #0
34800508:	e3a05000 	mov	r5, #0

	ldr	r7, =S5PC100_GPIO_BASE
3480050c:	e59f7648 	ldr	r7, [pc, #1608]	; 34800b5c <find_lock_val+0x138>
	ldr	r8, =S5PC100_GPIO_BASE
34800510:	e59f8644 	ldr	r8, [pc, #1604]	; 34800b5c <find_lock_val+0x138>
	/* Read CPU ID */
	ldr	r2, =S5PC110_PRO_ID
34800514:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
	ldr	r0, [r2]
34800518:	e5920000 	ldr	r0, [r2]
	mov	r1, #0x00010000
3480051c:	e3a01801 	mov	r1, #65536	; 0x10000
	and	r0, r0, r1
34800520:	e0000001 	and	r0, r0, r1
	cmp	r0, r5
34800524:	e1500005 	cmp	r0, r5
	beq	100f
34800528:	0a000000 	beq	34800530 <lowlevel_init+0x2c>
	ldr	r8, =S5PC110_GPIO_BASE
3480052c:	e59f862c 	ldr	r8, [pc, #1580]	; 34800b60 <find_lock_val+0x13c>
100:
	/* Turn on KEY_LED_ON [GPJ4(1)] XMSMWEN */
	cmp	r7, r8
34800530:	e1570008 	cmp	r7, r8
	beq	skip_check_didle			@ Support C110 only
34800534:	0a000005 	beq	34800550 <skip_check_didle>

	ldr	r0, =S5PC110_RST_STAT
34800538:	e59f0624 	ldr	r0, [pc, #1572]	; 34800b64 <find_lock_val+0x140>
	ldr	r1, [r0]
3480053c:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #0x000D0000
34800540:	e201180d 	and	r1, r1, #851968	; 0xd0000
	cmp	r1, #(0x1 << 19)			@ DEEPIDLE_WAKEUP
34800544:	e3510702 	cmp	r1, #524288	; 0x80000
	beq	didle_wakeup
34800548:	0a000078 	beq	34800730 <didle_wakeup>
	cmp	r7, r8
3480054c:	e1570008 	cmp	r7, r8

34800550 <skip_check_didle>:

skip_check_didle:
	addeq	r0, r8, #0x280				@ S5PC100_GPIO_J4
34800550:	02880d0a 	addeq	r0, r8, #640	; 0x280
	addne	r0, r8, #0x2C0				@ S5PC110_GPIO_J4
34800554:	12880d0b 	addne	r0, r8, #704	; 0x2c0
	ldr	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800558:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 4)			@ 1 * 4-bit
3480055c:	e3c110f0 	bic	r1, r1, #240	; 0xf0
	orr	r1, r1, #(0x1 << 4)
34800560:	e3811010 	orr	r1, r1, #16
	str	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800564:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
34800568:	e5901004 	ldr	r1, [r0, #4]
	bic	r1, r1, #(1 << 1)
3480056c:	e3c11002 	bic	r1, r1, #2
	str	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
34800570:	e5801004 	str	r1, [r0, #4]

	/* Don't setup at s5pc100 */
	beq	100f
34800574:	0a00002e 	beq	34800634 <skip_check_didle+0xe4>
	 *	0xF1D0_0000
	 *	0xF1E0_0000
	 *	0xF1F0_0000
	 *	0xFAF0_0000
	 */
	ldr     r0, =0xe0f00000
34800578:	e59f05e8 	ldr	r0, [pc, #1512]	; 34800b68 <find_lock_val+0x144>
	ldr     r1, [r0]
3480057c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800580:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800584:	e5801000 	str	r1, [r0]

	ldr     r0, =0xe1f00000
34800588:	e59f05dc 	ldr	r0, [pc, #1500]	; 34800b6c <find_lock_val+0x148>
	ldr     r1, [r0]
3480058c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800590:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800594:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1800000
34800598:	e59f05d0 	ldr	r0, [pc, #1488]	; 34800b70 <find_lock_val+0x14c>
	ldr     r1, [r0]
3480059c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005a0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005a4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1900000
348005a8:	e59f05c4 	ldr	r0, [pc, #1476]	; 34800b74 <find_lock_val+0x150>
	ldr     r1, [r0]
348005ac:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005b0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005b4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1a00000
348005b8:	e59f05b8 	ldr	r0, [pc, #1464]	; 34800b78 <find_lock_val+0x154>
	ldr     r1, [r0]
348005bc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005c0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005c4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1b00000
348005c8:	e59f05ac 	ldr	r0, [pc, #1452]	; 34800b7c <find_lock_val+0x158>
	ldr     r1, [r0]
348005cc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005d0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005d4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1c00000
348005d8:	e59f05a0 	ldr	r0, [pc, #1440]	; 34800b80 <find_lock_val+0x15c>
	ldr     r1, [r0]
348005dc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005e0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005e4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1d00000
348005e8:	e59f0594 	ldr	r0, [pc, #1428]	; 34800b84 <find_lock_val+0x160>
	ldr     r1, [r0]
348005ec:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005f0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005f4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1e00000
348005f8:	e59f0588 	ldr	r0, [pc, #1416]	; 34800b88 <find_lock_val+0x164>
	ldr     r1, [r0]
348005fc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800600:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800604:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1f00000
34800608:	e59f057c 	ldr	r0, [pc, #1404]	; 34800b8c <find_lock_val+0x168>
	ldr     r1, [r0]
3480060c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800610:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800614:	e5801000 	str	r1, [r0]

	ldr     r0, =0xfaf00000
34800618:	e59f0570 	ldr	r0, [pc, #1392]	; 34800b90 <find_lock_val+0x16c>
	ldr     r1, [r0]
3480061c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
34800620:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800624:	e5801000 	str	r1, [r0]

	/*
	 * Diable ABB block to reduce sleep current at low temperature
	 * Note that it's hidden register setup don't modify it
	 */
	ldr	r0, =0xE010C300
34800628:	e59f0564 	ldr	r0, [pc, #1380]	; 34800b94 <find_lock_val+0x170>
	ldr	r1, =0x00800000
3480062c:	e3a01502 	mov	r1, #8388608	; 0x800000
	str	r1, [r0]
34800630:	e5801000 	str	r1, [r0]

100:
	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
34800634:	059f055c 	ldreq	r0, [pc, #1372]	; 34800b98 <find_lock_val+0x174>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
34800638:	159f055c 	ldrne	r0, [pc, #1372]	; 34800b9c <find_lock_val+0x178>
	ldr	r1, [r0]
3480063c:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
34800640:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
34800644:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
34800648:	e1811002 	orr	r1, r1, r2
	/* Do not release retention here for S5PC110 */
	streq	r1, [r0]
3480064c:	05801000 	streq	r1, [r0]

	/* Disable Watchdog */
	ldreq	r0, =S5PC100_WATCHDOG_BASE		@ 0xEA200000
34800650:	059f0548 	ldreq	r0, [pc, #1352]	; 34800ba0 <find_lock_val+0x17c>
	ldrne	r0, =S5PC110_WATCHDOG_BASE		@ 0xE2700000
34800654:	159f0548 	ldrne	r0, [pc, #1352]	; 34800ba4 <find_lock_val+0x180>
	str	r5, [r0]
34800658:	e5805000 	str	r5, [r0]

	/* setting SRAM */
	ldreq	r0, =S5PC100_SROMC_BASE
3480065c:	03a004e7 	moveq	r0, #-419430400	; 0xe7000000
	ldrne	r0, =S5PC110_SROMC_BASE
34800660:	13a0033a 	movne	r0, #-402653184	; 0xe8000000
	ldr	r1, =0x9
34800664:	e3a01009 	mov	r1, #9
	str	r1, [r0]
34800668:	e5801000 	str	r1, [r0]

	/* S5PC100 has 3 groups of interrupt sources */
	ldreq	r0, =S5PC100_VIC0_BASE			@ 0xE4000000
3480066c:	03a00339 	moveq	r0, #-469762048	; 0xe4000000
	ldrne	r0, =S5PC110_VIC0_BASE			@ 0xF2000000
34800670:	13a004f2 	movne	r0, #-234881024	; 0xf2000000
	add	r1, r0, #0x00100000
34800674:	e2801601 	add	r1, r0, #1048576	; 0x100000
	add	r2, r0, #0x00200000
34800678:	e2802602 	add	r2, r0, #2097152	; 0x200000

	/* Disable all interrupts (VIC0, VIC1 and VIC2) */
	mvn	r3, #0x0
3480067c:	e3e03000 	mvn	r3, #0
	str	r3, [r0, #0x14]				@ INTENCLEAR
34800680:	e5803014 	str	r3, [r0, #20]
	str	r3, [r1, #0x14]				@ INTENCLEAR
34800684:	e5813014 	str	r3, [r1, #20]
	str	r3, [r2, #0x14]				@ INTENCLEAR
34800688:	e5823014 	str	r3, [r2, #20]

	/* Set all interrupts as IRQ */
	str	r5, [r0, #0xc]				@ INTSELECT
3480068c:	e580500c 	str	r5, [r0, #12]
	str	r5, [r1, #0xc]				@ INTSELECT
34800690:	e581500c 	str	r5, [r1, #12]
	str	r5, [r2, #0xc]				@ INTSELECT
34800694:	e582500c 	str	r5, [r2, #12]

	/* Pending Interrupt Clear */
	str	r5, [r0, #0xf00]			@ INTADDRESS
34800698:	e5805f00 	str	r5, [r0, #3840]	; 0xf00
	str	r5, [r1, #0xf00]			@ INTADDRESS
3480069c:	e5815f00 	str	r5, [r1, #3840]	; 0xf00
	str	r5, [r2, #0xf00]			@ INTADDRESS
348006a0:	e5825f00 	str	r5, [r2, #3840]	; 0xf00

	/* for UART */
	bl	uart_asm_init
348006a4:	eb000086 	bl	348008c4 <uart_asm_init>
	
	/* for DDR */
	bl ddrmem_init
348006a8:	eb0000d6 	bl	34800a08 <ddrmem_init>

	/* test ddr 3000 0000 */
	ldr r0, =0x30000000
348006ac:	e3a00203 	mov	r0, #805306368	; 0x30000000
	ldr r1, =0x12345678
348006b0:	e59f14f0 	ldr	r1, [pc, #1264]	; 34800ba8 <find_lock_val+0x184>
	str r1, [r0]                @store data
348006b4:	e5801000 	str	r1, [r0]
																									
	ldr r0, [r0]
348006b8:	e5900000 	ldr	r0, [r0]
	bl display_hex              @output data
348006bc:	eb0000c1 	bl	348009c8 <display_hex>

	ldr r0, =0xE2900020
348006c0:	e59f04e4 	ldr	r0, [pc, #1252]	; 34800bac <find_lock_val+0x188>
	ldr r1, =0xa                               @UTH0 = '\r'
348006c4:	e3a0100a 	mov	r1, #10
	str r1, [r0]
348006c8:	e5801000 	str	r1, [r0]

	ldr r1, =0xd                               @UTH0 = '\n'
348006cc:	e3a0100d 	mov	r1, #13
	str r1, [r0]
348006d0:	e5801000 	str	r1, [r0]

	bl	internal_ram_init
348006d4:	eb000075 	bl	348008b0 <internal_ram_init>

	/* for copy_sd_to_ddr */
	bl copy_code_to_dram
348006d8:	eb0001f1 	bl	34800ea4 <copy_code_to_dram>

	ldr r0, =0x34800000
348006dc:	e3a005d2 	mov	r0, #880803840	; 0x34800000
	ldr r0, [r0]
348006e0:	e5900000 	ldr	r0, [r0]
	bl display_hex
348006e4:	eb0000b7 	bl	348009c8 <display_hex>

	ldr r0, =0xE2900020
348006e8:	e59f04bc 	ldr	r0, [pc, #1212]	; 34800bac <find_lock_val+0x188>
	ldr r1, =0xa                               @UTH0 = '\r'
348006ec:	e3a0100a 	mov	r1, #10
	str r1, [r0]
348006f0:	e5801000 	str	r1, [r0]

	ldr r1, =0xd                               @UTH0 = '\n'
348006f4:	e3a0100d 	mov	r1, #13
	str r1, [r0]
348006f8:	e5801000 	str	r1, [r0]


	cmp	r7, r8
348006fc:	e1570008 	cmp	r7, r8
	/* Clear wakeup status register */
	ldreq	r0, =S5PC100_WAKEUP_STAT
34800700:	059f04a8 	ldreq	r0, [pc, #1192]	; 34800bb0 <find_lock_val+0x18c>
	ldrne	r0, =S5PC110_WAKEUP_STAT
34800704:	159f04a8 	ldrne	r0, [pc, #1192]	; 34800bb4 <find_lock_val+0x190>
	ldr	r1, [r0]
34800708:	e5901000 	ldr	r1, [r0]
	str	r1, [r0]
3480070c:	e5801000 	str	r1, [r0]

	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
34800710:	059f0480 	ldreq	r0, [pc, #1152]	; 34800b98 <find_lock_val+0x174>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
34800714:	159f0480 	ldrne	r0, [pc, #1152]	; 34800b9c <find_lock_val+0x178>
	ldr	r1, [r0]
34800718:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
3480071c:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
34800720:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
34800724:	e1811002 	orr	r1, r1, r2
	str	r1, [r0]
34800728:	e5801000 	str	r1, [r0]

	b	1f
3480072c:	ea00000c 	b	34800764 <lockloop+0x30>

34800730 <didle_wakeup>:

didle_wakeup:
	/* Wait when APLL is locked */
	ldr	r0, =0xE0100100			@ S5PC110_APLL_CON
34800730:	e59f0480 	ldr	r0, [pc, #1152]	; 34800bb8 <find_lock_val+0x194>

34800734 <lockloop>:
lockloop:
	ldr	r1, [r0]
34800734:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #(1 << 29)
34800738:	e2011202 	and	r1, r1, #536870912	; 0x20000000
	cmp	r1, #(1 << 29)
3480073c:	e3510202 	cmp	r1, #536870912	; 0x20000000
	bne	lockloop
34800740:	1afffffb 	bne	34800734 <lockloop>

	ldr	r0, =S5PC110_INFORM0
34800744:	e59f0470 	ldr	r0, [pc, #1136]	; 34800bbc <find_lock_val+0x198>
	ldr	r1, [r0]
34800748:	e5901000 	ldr	r1, [r0]
	mov	pc, r1
3480074c:	e1a0f001 	mov	pc, r1
	nop
34800750:	e320f000 	nop	{0}
	nop
34800754:	e320f000 	nop	{0}
	nop
34800758:	e320f000 	nop	{0}
	nop
3480075c:	e320f000 	nop	{0}
	nop
34800760:	e320f000 	nop	{0}

1:
	mov	lr, r11
34800764:	e1a0e00b 	mov	lr, fp
	mov	pc, lr
34800768:	e1a0f00e 	mov	pc, lr

3480076c <system_clock_init>:
/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
3480076c:	e59f044c 	ldr	r0, [pc, #1100]	; 34800bc0 <find_lock_val+0x19c>

	/* Check S5PC100 */
	cmp	r7, r8
34800770:	e1570008 	cmp	r7, r8
	bne	110f
34800774:	1a00001b 	bne	348007e8 <system_clock_init+0x7c>
100:
	/* Set Lock Time */
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
34800778:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x000]		@ S5PC100_APLL_LOCK
3480077c:	e5801000 	str	r1, [r0]
	str	r1, [r0, #0x004]		@ S5PC100_MPLL_LOCK
34800780:	e5801004 	str	r1, [r0, #4]
	str	r1, [r0, #0x008]		@ S5PC100_EPLL_LOCK
34800784:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x00C]		@ S5PC100_HPLL_LOCK
34800788:	e580100c 	str	r1, [r0, #12]

	/* S5P_APLL_CON */
	ldr	r1, =0x81bc0400		@ SDIV 0, PDIV 4, MDIV 444 (1333MHz)
3480078c:	e59f1430 	ldr	r1, [pc, #1072]	; 34800bc4 <find_lock_val+0x1a0>
	str	r1, [r0, #0x100]
34800790:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5P_MPLL_CON */
	ldr	r1, =0x80590201		@ SDIV 1, PDIV 2, MDIV 89 (267MHz)
34800794:	e59f142c 	ldr	r1, [pc, #1068]	; 34800bc8 <find_lock_val+0x1a4>
	str	r1, [r0, #0x104]
34800798:	e5801104 	str	r1, [r0, #260]	; 0x104
	/* S5P_EPLL_CON */
	ldr	r1, =0x80870303		@ SDIV 3, PDIV 3, MDIV 135 (67.5MHz)
3480079c:	e59f1428 	ldr	r1, [pc, #1064]	; 34800bcc <find_lock_val+0x1a8>
	str	r1, [r0, #0x108]
348007a0:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5P_HPLL_CON */
	ldr	r1, =0x80600603		@ SDIV 3, PDIV 6, MDIV 96
348007a4:	e59f1424 	ldr	r1, [pc, #1060]	; 34800bd0 <find_lock_val+0x1ac>
	str	r1, [r0, #0x10C]
348007a8:	e580110c 	str	r1, [r0, #268]	; 0x10c

	ldr     r1, [r0, #0x300]
348007ac:	e5901300 	ldr	r1, [r0, #768]	; 0x300
	ldr     r2, =0x00003fff
348007b0:	e59f241c 	ldr	r2, [pc, #1052]	; 34800bd4 <find_lock_val+0x1b0>
	bic     r1, r1, r2
348007b4:	e1c11002 	bic	r1, r1, r2
	ldr     r2, =0x00011301
348007b8:	e59f2418 	ldr	r2, [pc, #1048]	; 34800bd8 <find_lock_val+0x1b4>

	orr	r1, r1, r2
348007bc:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #0x300]
348007c0:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr     r1, [r0, #0x304]
348007c4:	e5901304 	ldr	r1, [r0, #772]	; 0x304
	ldr     r2, =0x00011110
348007c8:	e59f240c 	ldr	r2, [pc, #1036]	; 34800bdc <find_lock_val+0x1b8>
	orr     r1, r1, r2
348007cc:	e1811002 	orr	r1, r1, r2
	str     r1, [r0, #0x304]
348007d0:	e5801304 	str	r1, [r0, #772]	; 0x304
	ldr     r1, =0x00000001
348007d4:	e3a01001 	mov	r1, #1
	str     r1, [r0, #0x308]
348007d8:	e5801308 	str	r1, [r0, #776]	; 0x308

	/* Set Source Clock */
	ldr	r1, =0x00001111			@ A, M, E, HPLL Muxing
348007dc:	e59f13fc 	ldr	r1, [pc, #1020]	; 34800be0 <find_lock_val+0x1bc>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
348007e0:	e5801200 	str	r1, [r0, #512]	; 0x200

	b	200f
348007e4:	ea00002d 	b	348008a0 <system_clock_init+0x134>
110:
	ldr	r0, =0xE010C000			@ S5PC110_PWR_CFG
348007e8:	e59f03f4 	ldr	r0, [pc, #1012]	; 34800be4 <find_lock_val+0x1c0>

	/* Set OSC_FREQ value */
	ldr	r1, =0xf
348007ec:	e3a0100f 	mov	r1, #15
	str	r1, [r0, #0x100]		@ S5PC110_OSC_FREQ
348007f0:	e5801100 	str	r1, [r0, #256]	; 0x100

	/* Set MTC_STABLE value */
	ldr	r1, =0xffffffff
348007f4:	e3e01000 	mvn	r1, #0
	str	r1, [r0, #0x110]		@ S5PC110_MTC_STABLE
348007f8:	e5801110 	str	r1, [r0, #272]	; 0x110

	/* Set CLAMP_STABLE value */
	ldr	r1, =0x3ff03ff
348007fc:	e59f13e4 	ldr	r1, [pc, #996]	; 34800be8 <find_lock_val+0x1c4>
	str	r1, [r0, #0x114]		@ S5PC110_CLAMP_STABLE
34800800:	e5801114 	str	r1, [r0, #276]	; 0x114

	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
34800804:	e59f03b4 	ldr	r0, [pc, #948]	; 34800bc0 <find_lock_val+0x19c>

	/* Set Clock divider */
	ldr	r1, =0x14131330			@ 1:1:4:4, 1:4:5
34800808:	e59f13dc 	ldr	r1, [pc, #988]	; 34800bec <find_lock_val+0x1c8>
	str	r1, [r0, #0x300]
3480080c:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr	r1, =0x11110111			@ UART[3210]: MMC[3210]
34800810:	e59f13d8 	ldr	r1, [pc, #984]	; 34800bf0 <find_lock_val+0x1cc>
	str	r1, [r0, #0x310]
34800814:	e5801310 	str	r1, [r0, #784]	; 0x310

	/* Set Lock Time */
	ldr	r1, =0x2cf			@ Locktime : 30us
34800818:	e59f13d4 	ldr	r1, [pc, #980]	; 34800bf4 <find_lock_val+0x1d0>
	str	r1, [r0, #0x000]		@ S5PC110_APLL_LOCK
3480081c:	e5801000 	str	r1, [r0]
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
34800820:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x008]		@ S5PC110_MPLL_LOCK
34800824:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x010]		@ S5PC110_EPLL_LOCK
34800828:	e5801010 	str	r1, [r0, #16]
	str	r1, [r0, #0x020]		@ S5PC110_VPLL_LOCK
3480082c:	e5801020 	str	r1, [r0, #32]

	/* S5PC110_APLL_CON */
	ldr	r1, =0x80C80601			@ 800MHz
34800830:	e59f13c0 	ldr	r1, [pc, #960]	; 34800bf8 <find_lock_val+0x1d4>
	str	r1, [r0, #0x100]
34800834:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5PC110_MPLL_CON */
	ldr	r1, =0x829B0C01			@ 667MHz
34800838:	e59f13bc 	ldr	r1, [pc, #956]	; 34800bfc <find_lock_val+0x1d8>
	str	r1, [r0, #0x108]
3480083c:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5PC110_EPLL_CON */
	ldr	r1, =0x80600602			@  96MHz VSEL 0 P 6 M 96 S 2
34800840:	e59f13b8 	ldr	r1, [pc, #952]	; 34800c00 <find_lock_val+0x1dc>
	str	r1, [r0, #0x110]
34800844:	e5801110 	str	r1, [r0, #272]	; 0x110
	/* S5PC110_VPLL_CON */
	ldr	r1, =0x806C0603			@  54MHz
34800848:	e59f13b4 	ldr	r1, [pc, #948]	; 34800c04 <find_lock_val+0x1e0>
	str	r1, [r0, #0x120]
3480084c:	e5801120 	str	r1, [r0, #288]	; 0x120

	/* Set Source Clock */
	ldr	r1, =0x10001111			@ A, M, E, VPLL Muxing
34800850:	e59f13b0 	ldr	r1, [pc, #944]	; 34800c08 <find_lock_val+0x1e4>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
34800854:	e5801200 	str	r1, [r0, #512]	; 0x200

	/* OneDRAM(DMC0) clock setting */
	ldr	r1, =0x01000000			@ ONEDRAM_SEL[25:24] 1 SCLKMPLL
34800858:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #0x218]		@ S5PC110_CLK_SRC6
3480085c:	e5801218 	str	r1, [r0, #536]	; 0x218
	ldr	r1, =0x30000000			@ ONEDRAM_RATIO[31:28] 3 + 1
34800860:	e3a01203 	mov	r1, #805306368	; 0x30000000
	str	r1, [r0, #0x318]		@ S5PC110_CLK_DIV6
34800864:	e5801318 	str	r1, [r0, #792]	; 0x318

	/* XCLKOUT = XUSBXTI 24MHz */
	add	r2, r0, #0xE000			@ S5PC110_OTHERS
34800868:	e2802a0e 	add	r2, r0, #57344	; 0xe000
	ldr     r1, [r2]
3480086c:	e5921000 	ldr	r1, [r2]
	orr	r1, r1, #(0x3 << 8)		@ CLKOUT[9:8] 3 XUSBXTI
34800870:	e3811c03 	orr	r1, r1, #768	; 0x300
	str	r1, [r2]
34800874:	e5821000 	str	r1, [r2]

	/* CLK_IP0 */
	ldr	r1, =0x8fefeeb			@ DMC[1:0] PDMA0[3] IMEM[5]
34800878:	e59f138c 	ldr	r1, [pc, #908]	; 34800c0c <find_lock_val+0x1e8>
	str	r1, [r0, #0x460]		@ S5PC110_CLK_IP0
3480087c:	e5801460 	str	r1, [r0, #1120]	; 0x460

	/* CLK_IP1 */
	ldr	r1, =0xe9fdf0f9			@ FIMD[0] USBOTG[16]
34800880:	e59f1388 	ldr	r1, [pc, #904]	; 34800c10 <find_lock_val+0x1ec>
						@ NANDXL[24]
	str	r1, [r0, #0x464]		@ S5PC110_CLK_IP1
34800884:	e5801464 	str	r1, [r0, #1124]	; 0x464

	/* CLK_IP2 */
	ldr	r1, =0xf75f7fc			@ CORESIGHT[8] MODEM[9]
34800888:	e59f1384 	ldr	r1, [pc, #900]	; 34800c14 <find_lock_val+0x1f0>
						@ HOSTIF[10] HSMMC0[16]
						@ HSMMC2[18] VIC[27:24]
	str	r1, [r0, #0x468]		@ S5PC110_CLK_IP2
3480088c:	e5801468 	str	r1, [r0, #1128]	; 0x468

	/* CLK_IP3 */
	ldr	r1, =0x8eff038c			@ I2C[8:6]
34800890:	e59f1380 	ldr	r1, [pc, #896]	; 34800c18 <find_lock_val+0x1f4>
						@ SYSTIMER[16] UART0[17]
						@ UART1[18] UART2[19]
						@ UART3[20] WDT[22]
						@ PWM[23] GPIO[26] SYSCON[27]
	str	r1, [r0, #0x46c]		@ S5PC110_CLK_IP3
34800894:	e580146c 	str	r1, [r0, #1132]	; 0x46c

	/* CLK_IP4 */
	ldr	r1, =0xfffffff1			@ CHIP_ID[0] TZPC[8:5]
34800898:	e3e0100e 	mvn	r1, #14
	str	r1, [r0, #0x470]		@ S5PC110_CLK_IP3
3480089c:	e5801470 	str	r1, [r0, #1136]	; 0x470

200:
	/* wait at least 200us to stablize all clock */
	mov	r2, #0x10000
348008a0:	e3a02801 	mov	r2, #65536	; 0x10000
1:	subs	r2, r2, #1
348008a4:	e2522001 	subs	r2, r2, #1
	bne	1b
348008a8:	1afffffd 	bne	348008a4 <system_clock_init+0x138>

	mov	pc, lr
348008ac:	e1a0f00e 	mov	pc, lr

348008b0 <internal_ram_init>:

internal_ram_init:
	ldreq	r0, =0xE3800000
348008b0:	059f0364 	ldreq	r0, [pc, #868]	; 34800c1c <find_lock_val+0x1f8>
	ldrne	r0, =0xF1500000
348008b4:	159f0364 	ldrne	r0, [pc, #868]	; 34800c20 <find_lock_val+0x1fc>
	ldr	r1, =0x0
348008b8:	e3a01000 	mov	r1, #0
	str	r1, [r0]
348008bc:	e5801000 	str	r1, [r0]

	mov	pc, lr
348008c0:	e1a0f00e 	mov	pc, lr

348008c4 <uart_asm_init>:
/*
 * uart_asm_init: Initialize UART's pins
 */
uart_asm_init:
	/* set GPIO to enable UART0-UART4 */
	mov	r0, r8
348008c4:	e1a00008 	mov	r0, r8
	ldr	r1, =0x22222222
348008c8:	e59f1354 	ldr	r1, [pc, #852]	; 34800c24 <find_lock_val+0x200>
	str	r1, [r0, #0x0]			@ S5PC100_GPIO_A0_OFFSET
348008cc:	e5801000 	str	r1, [r0]
	ldr	r1, =0x00002222
348008d0:	e59f1350 	ldr	r1, [pc, #848]	; 34800c28 <find_lock_val+0x204>
	str	r1, [r0, #0x20]			@ S5PC100_GPIO_A1_OFFSET
348008d4:	e5801020 	str	r1, [r0, #32]

	/* Check S5PC100 */
	cmp	r7, r8
348008d8:	e1570008 	cmp	r7, r8
	bne	110f
348008dc:	1a00000c 	bne	34800914 <uart_asm_init+0x50>

	/* UART_SEL GPK0[5] at S5PC100 */
	add	r0, r8, #0x2A0			@ S5PC100_GPIO_K0_OFFSET
348008e0:	e2880e2a 	add	r0, r8, #672	; 0x2a0
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
348008e4:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 20)		@ 20 = 5 * 4-bit
348008e8:	e3c1160f 	bic	r1, r1, #15728640	; 0xf00000
	orr	r1, r1, #(0x1 << 20)		@ Output
348008ec:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
348008f0:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
348008f4:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 10)		@ 10 = 5 * 2-bit
348008f8:	e3c11b03 	bic	r1, r1, #3072	; 0xc00
	orr	r1, r1, #(0x2 << 10)		@ Pull-up enabled
348008fc:	e3811b02 	orr	r1, r1, #2048	; 0x800
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
34800900:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
34800904:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 5)		@ 5 = 5 * 1-bit
34800908:	e3811020 	orr	r1, r1, #32
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
3480090c:	e5801004 	str	r1, [r0, #4]

	b	200f
34800910:	ea00002b 	b	348009c4 <uart_asm_init+0x100>
	/*
	 * Note that the following address
	 * 0xE020'0360 is reserved address at S5PC100
	 */
	/* UART_SEL MP0_5[7] at S5PC110 */
	add	r0, r8, #0x360			@ S5PC110_GPIO_MP0_5_OFFSET
34800914:	e2880e36 	add	r0, r8, #864	; 0x360
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
34800918:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 28)		@ 28 = 7 * 4-bit
3480091c:	e3c1120f 	bic	r1, r1, #-268435456	; 0xf0000000
	orr	r1, r1, #(0x1 << 28)		@ Output
34800920:	e3811201 	orr	r1, r1, #268435456	; 0x10000000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
34800924:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
34800928:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 14)		@ 14 = 7 * 2-bit
3480092c:	e3c11903 	bic	r1, r1, #49152	; 0xc000
	orr	r1, r1, #(0x2 << 14)		@ Pull-up enabled
34800930:	e3811902 	orr	r1, r1, #32768	; 0x8000
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
34800934:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
34800938:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 7)		@ 7 = 7 * 1-bit
3480093c:	e3811080 	orr	r1, r1, #128	; 0x80
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
34800940:	e5801004 	str	r1, [r0, #4]

	/*init uart for s5pv210*/

	ldr r0, =0xE2900000                 @CON BASE
34800944:	e59f02e0 	ldr	r0, [pc, #736]	; 34800c2c <find_lock_val+0x208>
	ldr r1, =0x3
34800948:	e3a01003 	mov	r1, #3
	str r1, [r0]                        @ULCON = 3
3480094c:	e5801000 	str	r1, [r0]

	ldr r1, =0x1
34800950:	e3a01001 	mov	r1, #1
	str r1, [r0, #0x8]                        @UFCON = 1
34800954:	e5801008 	str	r1, [r0, #8]

	ldr r1, =0x5
34800958:	e3a01005 	mov	r1, #5
	str r1, [r0, #0x4]                   @UCON = 5
3480095c:	e5801004 	str	r1, [r0, #4]

	ldr r1, =34
34800960:	e3a01022 	mov	r1, #34	; 0x22
	str r1, [r0, #0x28]                  @UBARDIV = 34
34800964:	e5801028 	str	r1, [r0, #40]	; 0x28
				
	ldr r1, =0xDDDD
34800968:	e59f12c0 	ldr	r1, [pc, #704]	; 34800c30 <find_lock_val+0x20c>
	str r1, [r0, #0x2C]                  @UDIVSLOT = 0xDDDD
3480096c:	e580102c 	str	r1, [r0, #44]	; 0x2c

	/*test uart for s5pv210*/

	ldr r0,=0xE2900020
34800970:	e59f0234 	ldr	r0, [pc, #564]	; 34800bac <find_lock_val+0x188>
	ldr r1, =0x55                             @UTH0 = 'U'
34800974:	e3a01055 	mov	r1, #85	; 0x55
	str r1, [r0]
34800978:	e5801000 	str	r1, [r0]
						
	ldr r1, =0x61                             @UTH0 = 'a'
3480097c:	e3a01061 	mov	r1, #97	; 0x61
	str r1, [r0]
34800980:	e5801000 	str	r1, [r0]
												
	ldr r1, =0x72                             @UTH0 = 'r'
34800984:	e3a01072 	mov	r1, #114	; 0x72
	str r1, [r0]
34800988:	e5801000 	str	r1, [r0]
															
	ldr r1, =0x74                             @UTH0 = 't'
3480098c:	e3a01074 	mov	r1, #116	; 0x74
	str r1, [r0]
34800990:	e5801000 	str	r1, [r0]
															
	ldr r1, =0x20                               @UTH0 = ' '
34800994:	e3a01020 	mov	r1, #32
	str r1, [r0]
34800998:	e5801000 	str	r1, [r0]

	ldr r1, =0x4f                               @UTH0 = 'O'
3480099c:	e3a0104f 	mov	r1, #79	; 0x4f
	str r1, [r0]
348009a0:	e5801000 	str	r1, [r0]

	ldr r1, =0x4b                               @UTH0 = 'K'
348009a4:	e3a0104b 	mov	r1, #75	; 0x4b
	str r1, [r0]
348009a8:	e5801000 	str	r1, [r0]

	ldr r1, =0x21                               @UTH0 = '!'
348009ac:	e3a01021 	mov	r1, #33	; 0x21
	str r1, [r0]
348009b0:	e5801000 	str	r1, [r0]

	ldr r1, =0xa                               @UTH0 = '\r'
348009b4:	e3a0100a 	mov	r1, #10
	str r1, [r0]																								
348009b8:	e5801000 	str	r1, [r0]
	ldr r1, =0xd                               @UTH0 = '\n'
348009bc:	e3a0100d 	mov	r1, #13
	str r1, [r0]
348009c0:	e5801000 	str	r1, [r0]
	
200:
	mov	pc, lr
348009c4:	e1a0f00e 	mov	pc, lr

348009c8 <display_hex>:

display_hex:

	ldr r1, =0xE2900020
348009c8:	e59f11dc 	ldr	r1, [pc, #476]	; 34800bac <find_lock_val+0x188>

	ldr r2, =0x30                               @UTH0 = '0'
348009cc:	e3a02030 	mov	r2, #48	; 0x30
	str r2, [r1]
348009d0:	e5812000 	str	r2, [r1]

	ldr r2, =0x78                               @UTH0 = 'x'
348009d4:	e3a02078 	mov	r2, #120	; 0x78
	str r2, [r1]
348009d8:	e5812000 	str	r2, [r1]

	ldr r3, =28
348009dc:	e3a0301c 	mov	r3, #28

348009e0 <display_loop_cnt>:

display_loop_cnt:

	lsr r2, r0, r3
348009e0:	e1a02330 	lsr	r2, r0, r3
	and r2, r2, #0xf
348009e4:	e202200f 	and	r2, r2, #15
	cmp r2, #0xa
348009e8:	e352000a 	cmp	r2, #10
	addmi r2, r2, #0x30
348009ec:	42822030 	addmi	r2, r2, #48	; 0x30
	addpl r2, r2, #0x37
348009f0:	52822037 	addpl	r2, r2, #55	; 0x37
	str r2, [r1]
348009f4:	e5812000 	str	r2, [r1]
	
	sub r3, r3, #4
348009f8:	e2433004 	sub	r3, r3, #4
	cmp r3, #0
348009fc:	e3530000 	cmp	r3, #0
	bpl display_loop_cnt
34800a00:	5afffff6 	bpl	348009e0 <display_loop_cnt>

	mov pc, lr
34800a04:	e1a0f00e 	mov	pc, lr

34800a08 <ddrmem_init>:
#define DMC_TIMINGDATA			0x38
#define DMC_TIMINGPOWER			0x3C
#define DMC_PHYSTATUS			0x40

	// 初始化PHY DLL
	ldr	r0, =APB_DMC_0_BASE
34800a08:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
	//step 3: PhyControl0 DLL parameter setting, manual 0x00101000
	ldr	r1, =0x0010100A           					
34800a0c:	e59f1220 	ldr	r1, [pc, #544]	; 34800c34 <find_lock_val+0x210>
	str	r1, [r0, #DMC_PHYCONTROL0]
34800a10:	e5801018 	str	r1, [r0, #24]
	//PhyControl1 DLL parameter setting, LPDDR/LPDDR2 Case
	ldr	r1, =0x00000086					
34800a14:	e3a01086 	mov	r1, #134	; 0x86
	str	r1, [r0, #DMC_PHYCONTROL1]
34800a18:	e580101c 	str	r1, [r0, #28]
	
	//step 4: PhyControl0 DLL start
	ldr	r1, =0x0010100B					
34800a1c:	e59f1214 	ldr	r1, [pc, #532]	; 34800c38 <find_lock_val+0x214>
	str	r1, [r0, #DMC_PHYCONTROL0]
34800a20:	e5801018 	str	r1, [r0, #24]

34800a24 <find_lock_val>:

find_lock_val:
	//step 11: Loop until DLL is locked
	ldr	r1, [r0, #DMC_PHYSTATUS]			
34800a24:	e5901040 	ldr	r1, [r0, #64]	; 0x40
	and	r2, r1, #0x7
34800a28:	e2012007 	and	r2, r1, #7
	cmp	r2, #0x7					
34800a2c:	e3520007 	cmp	r2, #7
	bne	find_lock_val
34800a30:	1afffffb 	bne	34800a24 <find_lock_val>

	//step 12: Force Value locking
	and	r1, #0x3fc0
34800a34:	e2011dff 	and	r1, r1, #16320	; 0x3fc0
	mov	r2, r1, LSL #18
34800a38:	e1a02901 	lsl	r2, r1, #18
	orr	r2, r2, #0x100000
34800a3c:	e3822601 	orr	r2, r2, #1048576	; 0x100000
	orr	r2 ,r2, #0x1000
34800a40:	e3822a01 	orr	r2, r2, #4096	; 0x1000
	orr	r1, r2, #0x3					
34800a44:	e3821003 	orr	r1, r2, #3
	str	r1, [r0, #DMC_PHYCONTROL0]
34800a48:	e5801018 	str	r1, [r0, #24]

	// 3. 初始化DMC0
	//step 5: ConControl auto refresh off
	ldr	r1, =0x0FFF1010					
34800a4c:	e59f11e8 	ldr	r1, [pc, #488]	; 34800c3c <find_lock_val+0x218>
	str	r1, [r0, #DMC_CONCONTROL]
34800a50:	e5801000 	str	r1, [r0]
	
	
	//step 6: MemControl BL=4, 1 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
	ldr	r1, =0x00202400				
34800a54:	e59f11e4 	ldr	r1, [pc, #484]	; 34800c40 <find_lock_val+0x21c>
	str	r1, [r0, #DMC_MEMCONTROL]
34800a58:	e5801004 	str	r1, [r0, #4]
	
	
	//step 7: MemConfig0 256MB config, 8 banks,Mapping Method[12:15]0:linear, 1:linterleaved, 2:Mixed
	ldr	r1, =0x20E00323	
34800a5c:	e59f11e0 	ldr	r1, [pc, #480]	; 34800c44 <find_lock_val+0x220>
	str	r1, [r0, #DMC_MEMCONFIG0]
34800a60:	e5801008 	str	r1, [r0, #8]
	
	
	//MemConfig1
	ldr	r1, =0x00F00313				
34800a64:	e59f11dc 	ldr	r1, [pc, #476]	; 34800c48 <find_lock_val+0x224>
	str	r1, [r0, #DMC_MEMCONFIG1]
34800a68:	e580100c 	str	r1, [r0, #12]
	
	
	//step 8:PrechConfig
	ldr	r1, =0xFF000000					
34800a6c:	e3a014ff 	mov	r1, #-16777216	; 0xff000000
	str	r1, [r0, #DMC_PRECHCONFIG]
34800a70:	e5801014 	str	r1, [r0, #20]
	
	
	//step 9:TimingAref	7.8us//133MHz=1038(0x40E), 100MHz=780(0x30C), 20MHz=156(0x9C), 10MHz=78(0x4E)
	ldr	r1, =0x0000040E		
34800a74:	e59f11d0 	ldr	r1, [pc, #464]	; 34800c4c <find_lock_val+0x228>
	str	r1, [r0, #DMC_TIMINGAREF]
34800a78:	e5801030 	str	r1, [r0, #48]	; 0x30
	
	
	//TimingRow	for //200MHz
	ldr	r1, =0x11122206				
34800a7c:	e59f11cc 	ldr	r1, [pc, #460]	; 34800c50 <find_lock_val+0x22c>
	str	r1, [r0, #DMC_TIMINGROW]
34800a80:	e5801034 	str	r1, [r0, #52]	; 0x34
	
	
	//TimingData	CL=4
	ldr	r1, =0x12240000				
34800a84:	e59f11c8 	ldr	r1, [pc, #456]	; 34800c54 <find_lock_val+0x230>
	str	r1, [r0, #DMC_TIMINGDATA]
34800a88:	e5801038 	str	r1, [r0, #56]	; 0x38
	
	
	//TimingPower
	ldr	r1, =0x05DC0343				
34800a8c:	e59f11c4 	ldr	r1, [pc, #452]	; 34800c58 <find_lock_val+0x234>
	str	r1, [r0, #DMC_TIMINGPOWER]
34800a90:	e580103c 	str	r1, [r0, #60]	; 0x3c

	// 4. 初始化DDR2 DRAM
	//DirectCmd	chip0 Deselect
	ldr	r1, =0x07000000					
34800a94:	e3a01407 	mov	r1, #117440512	; 0x7000000
	str	r1, [r0, #DMC_DIRECTCMD]	
34800a98:	e5801010 	str	r1, [r0, #16]
	//step 16:DirectCmd	chip0 PALL
	ldr	r1, =0x01000000					
34800a9c:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #DMC_DIRECTCMD]
34800aa0:	e5801010 	str	r1, [r0, #16]
	//step 17:DirectCmd	chip0 EMRS2
	ldr	r1, =0x00020000					
34800aa4:	e3a01802 	mov	r1, #131072	; 0x20000
	str	r1, [r0, #DMC_DIRECTCMD]
34800aa8:	e5801010 	str	r1, [r0, #16]
	//step 18:DirectCmd	chip0 EMRS3
	ldr	r1, =0x00030000					
34800aac:	e3a01803 	mov	r1, #196608	; 0x30000
	str	r1, [r0, #DMC_DIRECTCMD]
34800ab0:	e5801010 	str	r1, [r0, #16]
	//step 19:DirectCmd	chip0 EMRS1 (MEM DLL on, DQS# disable)
	ldr	r1, =0x00010000					
34800ab4:	e3a01801 	mov	r1, #65536	; 0x10000
	str	r1, [r0, #DMC_DIRECTCMD]
34800ab8:	e5801010 	str	r1, [r0, #16]
	//step 20:DirectCmd	chip0 MRS (MEM DLL reset) CL=4, BL=4
	ldr	r1, =0x00000542					
34800abc:	e59f1198 	ldr	r1, [pc, #408]	; 34800c5c <find_lock_val+0x238>
	str	r1, [r0, #DMC_DIRECTCMD]
34800ac0:	e5801010 	str	r1, [r0, #16]
	//DirectCmd	chip0 PALL
	ldr	r1, =0x01000000					
34800ac4:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #DMC_DIRECTCMD]
34800ac8:	e5801010 	str	r1, [r0, #16]
	//DirectCmd	chip0 REFA
	ldr	r1, =0x05000000					
34800acc:	e3a01405 	mov	r1, #83886080	; 0x5000000
	str	r1, [r0, #DMC_DIRECTCMD]
34800ad0:	e5801010 	str	r1, [r0, #16]
	//DirectCmd	chip0 REFA
	ldr	r1, =0x05000000					
34800ad4:	e3a01405 	mov	r1, #83886080	; 0x5000000
	str	r1, [r0, #DMC_DIRECTCMD]
34800ad8:	e5801010 	str	r1, [r0, #16]
	//DirectCmd	chip0 MRS (MEM DLL unreset)
	ldr	r1, =0x00000442		
34800adc:	e59f117c 	ldr	r1, [pc, #380]	; 34800c60 <find_lock_val+0x23c>
	str	r1, [r0, #DMC_DIRECTCMD]
34800ae0:	e5801010 	str	r1, [r0, #16]
	//DirectCmd	chip0 EMRS1 (OCD default)
	ldr	r1, =0x00010380					
34800ae4:	e59f1178 	ldr	r1, [pc, #376]	; 34800c64 <find_lock_val+0x240>
	str	r1, [r0, #DMC_DIRECTCMD]
34800ae8:	e5801010 	str	r1, [r0, #16]
	//DirectCmd	chip0 EMRS1 (OCD exit)
	ldr	r1, =0x00010400		
34800aec:	e3a01b41 	mov	r1, #66560	; 0x10400
	str	r1, [r0, #DMC_DIRECTCMD]
34800af0:	e5801010 	str	r1, [r0, #16]
	
	//ConControl	auto refresh on
	ldr	r1, =0x0FF01030					
34800af4:	e59f116c 	ldr	r1, [pc, #364]	; 34800c68 <find_lock_val+0x244>
	str	r1, [r0, #DMC_CONCONTROL]
34800af8:	e5801000 	str	r1, [r0]
	//PwrdnConfig
	ldr	r1, =0xFFFF00FF					
34800afc:	e3e01cff 	mvn	r1, #65280	; 0xff00
	str	r1, [r0, #DMC_PWRDNCONFIG]
34800b00:	e5801028 	str	r1, [r0, #40]	; 0x28
	//MemControl	BL=4, 1 chip, DDR2 type, dynamic self refresh, force precharge, dynamic power down off
	ldr	r1, =0x00202400					
34800b04:	e59f1134 	ldr	r1, [pc, #308]	; 34800c40 <find_lock_val+0x21c>
	str	r1, [r0, #DMC_MEMCONTROL]
34800b08:	e5801004 	str	r1, [r0, #4]

	/*************ddr init finish***********/
	ldr r0,=0xE2900020
34800b0c:	e59f0098 	ldr	r0, [pc, #152]	; 34800bac <find_lock_val+0x188>
	ldr r1, =0x44                             @UTH0 = 'D'
34800b10:	e3a01044 	mov	r1, #68	; 0x44
	str r1, [r0]
34800b14:	e5801000 	str	r1, [r0]

	ldr r1, =0x44                             @UTH0 = 'D'
34800b18:	e3a01044 	mov	r1, #68	; 0x44
	str r1, [r0]
34800b1c:	e5801000 	str	r1, [r0]

	ldr r1, =0x52                             @UTH0 = 'R'
34800b20:	e3a01052 	mov	r1, #82	; 0x52
	str r1, [r0]
34800b24:	e5801000 	str	r1, [r0]
	
	ldr r1, =0x20                             @UTH0 = ' '
34800b28:	e3a01020 	mov	r1, #32
	str r1, [r0]
34800b2c:	e5801000 	str	r1, [r0]

	ldr r1, =0x4f                               @UTH0 = 'O'
34800b30:	e3a0104f 	mov	r1, #79	; 0x4f
	str r1, [r0]
34800b34:	e5801000 	str	r1, [r0]

	ldr r1, =0x4b                               @UTH0 = 'K'
34800b38:	e3a0104b 	mov	r1, #75	; 0x4b
	str r1, [r0]
34800b3c:	e5801000 	str	r1, [r0]

	ldr r1, =0x21                               @UTH0 = '!'
34800b40:	e3a01021 	mov	r1, #33	; 0x21
	str r1, [r0]
34800b44:	e5801000 	str	r1, [r0]

	ldr r1, =0xa                               @UTH0 = '\r'
34800b48:	e3a0100a 	mov	r1, #10
	str r1, [r0]
34800b4c:	e5801000 	str	r1, [r0]
																									
	ldr r1, =0xd                               @UTH0 = '\n'
34800b50:	e3a0100d 	mov	r1, #13
	str r1, [r0]
34800b54:	e5801000 	str	r1, [r0]
	
	mov	pc, lr
34800b58:	e1a0f00e 	mov	pc, lr
34800b5c:	e0300000 	.word	0xe0300000
34800b60:	e0200000 	.word	0xe0200000
34800b64:	e010a000 	.word	0xe010a000
34800b68:	e0f00000 	.word	0xe0f00000
34800b6c:	e1f00000 	.word	0xe1f00000
34800b70:	f1800000 	.word	0xf1800000
34800b74:	f1900000 	.word	0xf1900000
34800b78:	f1a00000 	.word	0xf1a00000
34800b7c:	f1b00000 	.word	0xf1b00000
34800b80:	f1c00000 	.word	0xf1c00000
34800b84:	f1d00000 	.word	0xf1d00000
34800b88:	f1e00000 	.word	0xf1e00000
34800b8c:	f1f00000 	.word	0xf1f00000
34800b90:	faf00000 	.word	0xfaf00000
34800b94:	e010c300 	.word	0xe010c300
34800b98:	e0108200 	.word	0xe0108200
34800b9c:	e010e000 	.word	0xe010e000
34800ba0:	ea200000 	.word	0xea200000
34800ba4:	e2700000 	.word	0xe2700000
34800ba8:	12345678 	.word	0x12345678
34800bac:	e2900020 	.word	0xe2900020
34800bb0:	e0108304 	.word	0xe0108304
34800bb4:	e010c200 	.word	0xe010c200
34800bb8:	e0100100 	.word	0xe0100100
34800bbc:	e010f000 	.word	0xe010f000
34800bc0:	e0100000 	.word	0xe0100000
34800bc4:	81bc0400 	.word	0x81bc0400
34800bc8:	80590201 	.word	0x80590201
34800bcc:	80870303 	.word	0x80870303
34800bd0:	80600603 	.word	0x80600603
34800bd4:	00003fff 	.word	0x00003fff
34800bd8:	00011301 	.word	0x00011301
34800bdc:	00011110 	.word	0x00011110
34800be0:	00001111 	.word	0x00001111
34800be4:	e010c000 	.word	0xe010c000
34800be8:	03ff03ff 	.word	0x03ff03ff
34800bec:	14131330 	.word	0x14131330
34800bf0:	11110111 	.word	0x11110111
34800bf4:	000002cf 	.word	0x000002cf
34800bf8:	80c80601 	.word	0x80c80601
34800bfc:	829b0c01 	.word	0x829b0c01
34800c00:	80600602 	.word	0x80600602
34800c04:	806c0603 	.word	0x806c0603
34800c08:	10001111 	.word	0x10001111
34800c0c:	08fefeeb 	.word	0x08fefeeb
34800c10:	e9fdf0f9 	.word	0xe9fdf0f9
34800c14:	0f75f7fc 	.word	0x0f75f7fc
34800c18:	8eff038c 	.word	0x8eff038c
34800c1c:	e3800000 	.word	0xe3800000
34800c20:	f1500000 	.word	0xf1500000
34800c24:	22222222 	.word	0x22222222
34800c28:	00002222 	.word	0x00002222
34800c2c:	e2900000 	.word	0xe2900000
34800c30:	0000dddd 	.word	0x0000dddd
34800c34:	0010100a 	.word	0x0010100a
34800c38:	0010100b 	.word	0x0010100b
34800c3c:	0fff1010 	.word	0x0fff1010
34800c40:	00202400 	.word	0x00202400
34800c44:	20e00323 	.word	0x20e00323
34800c48:	00f00313 	.word	0x00f00313
34800c4c:	0000040e 	.word	0x0000040e
34800c50:	11122206 	.word	0x11122206
34800c54:	12240000 	.word	0x12240000
34800c58:	05dc0343 	.word	0x05dc0343
34800c5c:	00000542 	.word	0x00000542
34800c60:	00000442 	.word	0x00000442
34800c64:	00010380 	.word	0x00010380
34800c68:	0ff01030 	.word	0x0ff01030

34800c6c <s5pc1xx_phy_control>:
}
#endif

#ifdef CONFIG_USB_GADGET
static int s5pc1xx_phy_control(int on)
{
34800c6c:	e92d4070 	push	{r4, r5, r6, lr}
34800c70:	e1a06000 	mov	r6, r0
	int ret;
	static int status;
	struct pmic *p = get_pmic();
34800c74:	eb004264 	bl	3481160c <get_pmic>
34800c78:	e1a05000 	mov	r5, r0

	if (pmic_probe(p))
34800c7c:	eb0042bf 	bl	34811780 <pmic_probe>
34800c80:	e3500000 	cmp	r0, #0
34800c84:	1a00002c 	bne	34800d3c <s5pc1xx_phy_control+0xd0>
		return -1;

	if (on && !status) {
34800c88:	e3560000 	cmp	r6, #0
34800c8c:	e59f40b0 	ldr	r4, [pc, #176]	; 34800d44 <s5pc1xx_phy_control+0xd8>
34800c90:	0a000011 	beq	34800cdc <s5pc1xx_phy_control+0x70>
34800c94:	e5943000 	ldr	r3, [r4]
34800c98:	e3530000 	cmp	r3, #0
34800c9c:	1a000022 	bne	34800d2c <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
34800ca0:	e3a01011 	mov	r1, #17
34800ca4:	e3a02004 	mov	r2, #4
34800ca8:	e2833001 	add	r3, r3, #1
34800cac:	e1a00005 	mov	r0, r5
34800cb0:	eb00423f 	bl	348115b4 <pmic_set_output>
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
34800cb4:	e3a03001 	mov	r3, #1
34800cb8:	e1a00005 	mov	r0, r5
34800cbc:	e3a01012 	mov	r1, #18
34800cc0:	e3a02020 	mov	r2, #32
34800cc4:	eb00423a 	bl	348115b4 <pmic_set_output>
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
34800cc8:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
34800ccc:	03a03001 	moveq	r3, #1
34800cd0:	05843000 	streq	r3, [r4]
	if (on && !status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
34800cd4:	0a000014 	beq	34800d2c <s5pc1xx_phy_control+0xc0>
34800cd8:	ea00000f 	b	34800d1c <s5pc1xx_phy_control+0xb0>
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
	} else if (!on && status) {
34800cdc:	e5943000 	ldr	r3, [r4]
34800ce0:	e3530000 	cmp	r3, #0
34800ce4:	0a000010 	beq	34800d2c <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
34800ce8:	e3a01011 	mov	r1, #17
34800cec:	e3a02004 	mov	r2, #4
34800cf0:	e1a03006 	mov	r3, r6
34800cf4:	e1a00005 	mov	r0, r5
34800cf8:	eb00422d 	bl	348115b4 <pmic_set_output>
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
34800cfc:	e1a00005 	mov	r0, r5
34800d00:	e3a01012 	mov	r1, #18
34800d04:	e3a02020 	mov	r2, #32
34800d08:	e1a03006 	mov	r3, r6
34800d0c:	eb004228 	bl	348115b4 <pmic_set_output>
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
34800d10:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 0;
34800d14:	05840000 	streq	r0, [r4]
	} else if (!on && status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
34800d18:	0a000003 	beq	34800d2c <s5pc1xx_phy_control+0xc0>
			puts("MAX8998 LDO setting error!\n");
34800d1c:	e59f0024 	ldr	r0, [pc, #36]	; 34800d48 <s5pc1xx_phy_control+0xdc>
34800d20:	eb00239a 	bl	34809b90 <puts>
			return -1;
34800d24:	e3e00000 	mvn	r0, #0
34800d28:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
		status = 0;
	}
	udelay(10000);
34800d2c:	e3020710 	movw	r0, #10000	; 0x2710
34800d30:	eb006fa0 	bl	3481cbb8 <udelay>

	return 0;
34800d34:	e3a00000 	mov	r0, #0
34800d38:	e8bd8070 	pop	{r4, r5, r6, pc}
	int ret;
	static int status;
	struct pmic *p = get_pmic();

	if (pmic_probe(p))
		return -1;
34800d3c:	e3e00000 	mvn	r0, #0
		status = 0;
	}
	udelay(10000);

	return 0;
}
34800d40:	e8bd8070 	pop	{r4, r5, r6, pc}
34800d44:	34829ba0 	.word	0x34829ba0
34800d48:	34822ae0 	.word	0x34822ae0

34800d4c <board_init>:
DECLARE_GLOBAL_DATA_PTR;

static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
34800d4c:	e92d4008 	push	{r3, lr}
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800d50:	e59f2028 	ldr	r2, [pc, #40]	; 34800d80 <board_init+0x34>
34800d54:	e59f3028 	ldr	r3, [pc, #40]	; 34800d84 <board_init+0x38>

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800d58:	e3001b2e 	movw	r1, #2862	; 0xb2e
static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800d5c:	e5832004 	str	r2, [r3, #4]

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800d60:	e5982000 	ldr	r2, [r8]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
34800d64:	e5983000 	ldr	r3, [r8]
int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800d68:	e5821004 	str	r1, [r2, #4]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
34800d6c:	e59f2014 	ldr	r2, [pc, #20]	; 34800d88 <board_init+0x3c>
34800d70:	e5832008 	str	r2, [r3, #8]

#if defined(CONFIG_PMIC)
	pmic_init();
34800d74:	eb00428f 	bl	348117b8 <pmic_init>
#endif
	return 0;
}
34800d78:	e3a00000 	mov	r0, #0
34800d7c:	e8bd8008 	pop	{r3, pc}
34800d80:	e0200000 	.word	0xe0200000
34800d84:	34829ba0 	.word	0x34829ba0
34800d88:	20000100 	.word	0x20000100

34800d8c <dram_init>:

int dram_init(void)
{
	gd->ram_size = PHYS_SDRAM_1_SIZE;
34800d8c:	e3a02202 	mov	r2, #536870912	; 0x20000000
34800d90:	e5882038 	str	r2, [r8, #56]	; 0x38
//	gd->ram_size = PHYS_SDRAM_1_SIZE + PHYS_SDRAM_2_SIZE +
//			PHYS_SDRAM_3_SIZE;

	return 0;
}
34800d94:	e3a00000 	mov	r0, #0
34800d98:	e12fff1e 	bx	lr

34800d9c <dram_init_banksize>:

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
34800d9c:	e5981000 	ldr	r1, [r8]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
34800da0:	e5982000 	ldr	r2, [r8]
	return 0;
}

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
34800da4:	e3a03202 	mov	r3, #536870912	; 0x20000000
34800da8:	e5813018 	str	r3, [r1, #24]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
34800dac:	e582301c 	str	r3, [r2, #28]
//	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
//	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
//	gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
//	gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
}
34800db0:	e12fff1e 	bx	lr

34800db4 <checkboard>:

#ifdef CONFIG_DISPLAY_BOARDINFO
int checkboard(void)
{
34800db4:	e92d4008 	push	{r3, lr}
	puts("Board:\tGoni\n");
34800db8:	e59f0008 	ldr	r0, [pc, #8]	; 34800dc8 <checkboard+0x14>
34800dbc:	eb002373 	bl	34809b90 <puts>
	return 0;
}
34800dc0:	e3a00000 	mov	r0, #0
34800dc4:	e8bd8008 	pop	{r3, pc}
34800dc8:	34822afc 	.word	0x34822afc

34800dcc <board_mmc_init>:
#endif

#ifdef CONFIG_GENERIC_MMC
int board_mmc_init(bd_t *bis)
{
34800dcc:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	/* MASSMEMORY_EN: XMSMDATA7: GPJ2[7] output high */
	s5p_gpio_direction_output(&s5pc110_gpio->j2, 7, 1);
34800dd0:	e59f5098 	ldr	r5, [pc, #152]	; 34800e70 <board_mmc_init+0xa4>
34800dd4:	e3a01007 	mov	r1, #7
34800dd8:	e5950004 	ldr	r0, [r5, #4]
34800ddc:	e3a02001 	mov	r2, #1
34800de0:	e2800d0a 	add	r0, r0, #640	; 0x280
34800de4:	eb003e8f 	bl	34810828 <s5p_gpio_direction_output>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
34800de8:	e3a04000 	mov	r4, #0
		if (i == 2)
34800dec:	e3540002 	cmp	r4, #2
34800df0:	0a00000e 	beq	34800e30 <board_mmc_init+0x64>
			continue;
		/* GPG0[0:6] special function 2 */
		s5p_gpio_cfg_pin(&s5pc110_gpio->g0, i, 0x2);
34800df4:	e5950004 	ldr	r0, [r5, #4]
34800df8:	e1a01004 	mov	r1, r4
34800dfc:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800e00:	e3a02002 	mov	r2, #2
34800e04:	eb003e80 	bl	3481080c <s5p_gpio_cfg_pin>
		/* GPG0[0:6] pull disable */
		s5p_gpio_set_pull(&s5pc110_gpio->g0, i, GPIO_PULL_NONE);
34800e08:	e5950004 	ldr	r0, [r5, #4]
34800e0c:	e1a01004 	mov	r1, r4
34800e10:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800e14:	e3a02000 	mov	r2, #0
34800e18:	eb003ea0 	bl	348108a0 <s5p_gpio_set_pull>
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
34800e1c:	e5950004 	ldr	r0, [r5, #4]
34800e20:	e1a01004 	mov	r1, r4
34800e24:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800e28:	e3a02003 	mov	r2, #3
34800e2c:	eb003ea4 	bl	348108c4 <s5p_gpio_set_drv>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
34800e30:	e2844001 	add	r4, r4, #1
34800e34:	e3540007 	cmp	r4, #7
34800e38:	1affffeb 	bne	34800dec <board_mmc_init+0x20>
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800e3c:	e59f3030 	ldr	r3, [pc, #48]	; 34800e74 <board_mmc_init+0xa8>
34800e40:	e5933000 	ldr	r3, [r3]
}

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
34800e44:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800e48:	059f0028 	ldreq	r0, [pc, #40]	; 34800e78 <board_mmc_init+0xac>
34800e4c:	0a000003 	beq	34800e60 <board_mmc_init+0x94>
34800e50:	e30c0110 	movw	r0, #49424	; 0xc110
34800e54:	e1530000 	cmp	r3, r0
34800e58:	03a004eb 	moveq	r0, #-352321536	; 0xeb000000
34800e5c:	13a00000 	movne	r0, #0
int s5p_sdhci_init(u32 regbase, int index, int bus_width);

static inline unsigned int s5p_mmc_init(int index, int bus_width)
{
	unsigned int base = samsung_get_base_mmc() + (0x10000 * index);
	return s5p_sdhci_init(base, index, bus_width);
34800e60:	e3a01000 	mov	r1, #0
34800e64:	e3a02004 	mov	r2, #4
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
	}

	return s5p_mmc_init(0, 4);
}
34800e68:	e8bd4070 	pop	{r4, r5, r6, lr}
34800e6c:	ea004a32 	b	3481373c <s5p_sdhci_init>
34800e70:	34829ba0 	.word	0x34829ba0
34800e74:	348285d0 	.word	0x348285d0
34800e78:	ed800000 	.word	0xed800000

34800e7c <onenand_board_init>:
#include <linux/mtd/samsung_onenand.h>
#include <onenand_uboot.h>

void onenand_board_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
34800e7c:	e5903094 	ldr	r3, [r0, #148]	; 0x94

	this->base = (void *)CONFIG_SYS_ONENAND_BASE;
34800e80:	e3a0220b 	mov	r2, #-1342177280	; 0xb0000000
34800e84:	e5832000 	str	r2, [r3]
	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
34800e88:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
34800e8c:	e3822c02 	orr	r2, r2, #512	; 0x200
34800e90:	e583202c 	str	r2, [r3, #44]	; 0x2c
	this->chip_probe = s5pc110_chip_probe;
34800e94:	e59f2004 	ldr	r2, [pc, #4]	; 34800ea0 <onenand_board_init+0x24>
34800e98:	e5832070 	str	r2, [r3, #112]	; 0x70
}
34800e9c:	e12fff1e 	bx	lr
34800ea0:	348186cc 	.word	0x348186cc

34800ea4 <copy_code_to_dram>:
{
	unsigned long ch;
	unsigned long dest = 0x34800000;  //加载的目标地址
	unsigned int sec_no = 49;  //扇区初始地址

	ch = *(volatile unsigned int *)(0xD0037488);
34800ea4:	e59f3060 	ldr	r3, [pc, #96]	; 34800f0c <copy_code_to_dram+0x68>
typedef unsigned int (*copy_sd_mmc_to_mem) (unsigned int  channel, unsigned int  start_block, unsigned char block_size, unsigned int  *trg, unsigned int  init);


void copy_code_to_dram(void)
{
34800ea8:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	unsigned long ch;
	unsigned long dest = 0x34800000;  //加载的目标地址
	unsigned int sec_no = 49;  //扇区初始地址

	ch = *(volatile unsigned int *)(0xD0037488);
34800eac:	e5932488 	ldr	r2, [r3, #1160]	; 0x488

	// 函数指针
	copy_sd_mmc_to_mem copy_bl2 = (copy_sd_mmc_to_mem) (*(unsigned int *) (0xD0037F98));
34800eb0:	e5935f98 	ldr	r5, [r3, #3992]	; 0xf98

	unsigned int ret;
	
	// 通道0
	if (ch == 0xEB000000)
34800eb4:	e35204eb 	cmp	r2, #-352321536	; 0xeb000000
34800eb8:	1a000012 	bne	34800f08 <copy_code_to_dram+0x64>
	{
		// 0:channel 0
		// 49:源代码位于扇区49,1 sector = 512 bytes
		// 32:长度，拷贝32 sector，即16K
		// 0x23E00000:目的,链接地址0x23E00000
		ret = copy_bl2(0, sec_no,       128, (unsigned int *)dest, 0);  //64k
34800ebc:	e3a04000 	mov	r4, #0
34800ec0:	e3a01031 	mov	r1, #49	; 0x31
34800ec4:	e3a02080 	mov	r2, #128	; 0x80
34800ec8:	e3a035d2 	mov	r3, #880803840	; 0x34800000
34800ecc:	e58d4000 	str	r4, [sp]
34800ed0:	e1a00004 	mov	r0, r4
34800ed4:	e12fff35 	blx	r5
		ret = copy_bl2(0, sec_no + 128, 128, (unsigned int *)(dest+ 0x10000), 0);  //64k
34800ed8:	e3a010b1 	mov	r1, #177	; 0xb1
34800edc:	e3a02080 	mov	r2, #128	; 0x80
34800ee0:	e59f3028 	ldr	r3, [pc, #40]	; 34800f10 <copy_code_to_dram+0x6c>
34800ee4:	e58d4000 	str	r4, [sp]
34800ee8:	e1a00004 	mov	r0, r4
34800eec:	e12fff35 	blx	r5
		ret = copy_bl2(0, sec_no + 256, 128, (unsigned int *)(dest + 0x20000), 0);    //64k
34800ef0:	e58d4000 	str	r4, [sp]
34800ef4:	e1a00004 	mov	r0, r4
34800ef8:	e3001131 	movw	r1, #305	; 0x131
34800efc:	e3a02080 	mov	r2, #128	; 0x80
34800f00:	e59f300c 	ldr	r3, [pc, #12]	; 34800f14 <copy_code_to_dram+0x70>
34800f04:	e12fff35 	blx	r5
	}
}
34800f08:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
34800f0c:	d0037000 	.word	0xd0037000
34800f10:	34810000 	.word	0x34810000
34800f14:	34820000 	.word	0x34820000

34800f18 <v7_maint_dcache_all>:
						   way_shift, log2_line_len);
	}
}

static void v7_maint_dcache_all(u32 operation)
{
34800f18:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
34800f1c:	ee301f30 	mrc	15, 1, r1, cr0, cr0, {1}
	}
}

static void v7_maint_dcache_all(u32 operation)
{
	u32 level, cache_type, level_start_bit = 0;
34800f20:	e3a03000 	mov	r3, #0
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
34800f24:	e58d1004 	str	r1, [sp, #4]
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
34800f28:	e1a0c003 	mov	ip, r3
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800f2c:	e1a05003 	mov	r5, r3
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
34800f30:	e59d1004 	ldr	r1, [sp, #4]
34800f34:	e1a02331 	lsr	r2, r1, r3
34800f38:	e2022007 	and	r2, r2, #7
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
34800f3c:	e2422002 	sub	r2, r2, #2

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
34800f40:	e3520002 	cmp	r2, #2
34800f44:	8a00002a 	bhi	34800ff4 <v7_maint_dcache_all+0xdc>
/*
 * Write the level and type you want to Cache Size Selection Register(CSSELR)
 * to get size details from Current Cache Size ID Register(CCSIDR)
 */
static void set_csselr(u32 level, u32 type)
{	u32 csselr = level << 1 | type;
34800f48:	e1a0408c 	lsl	r4, ip, #1

	/* Write to Cache Size Selection Register(CSSELR) */
	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r" (csselr));
34800f4c:	ee404f10 	mcr	15, 2, r4, cr0, cr0, {0}
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800f50:	ee307f10 	mrc	15, 1, r7, cr0, cr0, {0}
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800f54:	e7e921d7 	ubfx	r2, r7, #3, #10

	set_csselr(level, ARMV7_CSSELR_IND_DATA_UNIFIED);

	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800f58:	e2076007 	and	r6, r7, #7
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800f5c:	e2829001 	add	r9, r2, #1
	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;
34800f60:	e2866004 	add	r6, r6, #4

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
			CCSIDR_ASSOCIATIVITY_OFFSET) + 1;
	num_sets  = ((ccsidr & CCSIDR_NUM_SETS_MASK) >>
34800f64:	e7ee76d7 	ubfx	r7, r7, #13, #15
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800f68:	e1a01009 	mov	r1, r9
#ifndef _UTILS_H_
#define _UTILS_H_

static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
34800f6c:	e3e0a000 	mvn	sl, #0
	u32 temp = n;

	while (temp) {
34800f70:	e1b010a1 	lsrs	r1, r1, #1
		log2n++;
34800f74:	e28aa001 	add	sl, sl, #1
static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
	u32 temp = n;

	while (temp) {
34800f78:	1afffffc 	bne	34800f70 <v7_maint_dcache_all+0x58>
		log2n++;
		temp >>= 1;
	}

	if (n & (n - 1))
34800f7c:	e1190002 	tst	r9, r2
		return log2n + 1; /* not power of 2 - round up */
34800f80:	128aa001 	addne	sl, sl, #1
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800f84:	e3500001 	cmp	r0, #1
	 * According to ARMv7 ARM number of sets and number of ways need
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
34800f88:	e26aa020 	rsb	sl, sl, #32
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800f8c:	1a00000b 	bne	34800fc0 <v7_maint_dcache_all+0xa8>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800f90:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800f94:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800f98:	e1a09004 	mov	r9, r4
34800f9c:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/* Invalidate data/unified cache line by set/way */
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
34800fa0:	ee074f56 	mcr	15, 0, r4, cr7, cr6, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800fa4:	e2511001 	subs	r1, r1, #1
34800fa8:	2afffffb 	bcs	34800f9c <v7_maint_dcache_all+0x84>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
34800fac:	e2522001 	subs	r2, r2, #1
34800fb0:	e1a04009 	mov	r4, r9
34800fb4:	2afffff5 	bcs	34800f90 <v7_maint_dcache_all+0x78>
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800fb8:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
34800fbc:	ea00000c 	b	34800ff4 <v7_maint_dcache_all+0xdc>

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
		v7_inval_dcache_level_setway(level, num_sets, num_ways,
				      way_shift, log2_line_len);
	} else if (operation == ARMV7_DCACHE_CLEAN_INVAL_ALL) {
34800fc0:	e3500002 	cmp	r0, #2
34800fc4:	1a00000a 	bne	34800ff4 <v7_maint_dcache_all+0xdc>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800fc8:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800fcc:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800fd0:	e1a09004 	mov	r9, r4
34800fd4:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/*
			 * Clean & Invalidate data/unified
			 * cache line by set/way
			 */
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
34800fd8:	ee074f5e 	mcr	15, 0, r4, cr7, cr14, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800fdc:	e2511001 	subs	r1, r1, #1
34800fe0:	2afffffb 	bcs	34800fd4 <v7_maint_dcache_all+0xbc>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
34800fe4:	e2522001 	subs	r2, r2, #1
34800fe8:	e1a04009 	mov	r4, r9
34800fec:	2afffff5 	bcs	34800fc8 <v7_maint_dcache_all+0xb0>
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800ff0:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
34800ff4:	e3530012 	cmp	r3, #18
34800ff8:	e28cc001 	add	ip, ip, #1
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_UNIFIED))
			v7_maint_dcache_level_setway(level, operation);
		level_start_bit += 3;
34800ffc:	12833003 	addne	r3, r3, #3
34801000:	1affffca 	bne	34800f30 <v7_maint_dcache_all+0x18>
	}
}
34801004:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

34801008 <v7_dcache_maint_range>:
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
	}
}

static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
34801008:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480100c:	e1a04000 	mov	r4, r0
34801010:	e1a06001 	mov	r6, r1
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34801014:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
	u32 line_len, ccsidr;

	ccsidr = get_ccsidr();
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34801018:	e2055007 	and	r5, r5, #7
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
3480101c:	e2855004 	add	r5, r5, #4
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
34801020:	e3a03001 	mov	r3, #1

	switch (range_op) {
34801024:	e3520003 	cmp	r2, #3
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
34801028:	e1a05513 	lsl	r5, r3, r5

	switch (range_op) {
3480102c:	0a000009 	beq	34801058 <v7_dcache_maint_range+0x50>
34801030:	e3520004 	cmp	r2, #4
					u32 stop, u32 line_len)
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
34801034:	02653000 	rsbeq	r3, r5, #0
34801038:	00034000 	andeq	r4, r3, r0
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;

	switch (range_op) {
3480103c:	1a00001d 	bne	348010b8 <v7_dcache_maint_range+0xb0>
34801040:	ea000001 	b	3480104c <v7_dcache_maint_range+0x44>

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCCIMVAC - Clean & Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
34801044:	ee074f3e 	mcr	15, 0, r4, cr7, cr14, {1}
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
34801048:	e0844005 	add	r4, r4, r5
3480104c:	e1540006 	cmp	r4, r6
34801050:	3afffffb 	bcc	34801044 <v7_dcache_maint_range+0x3c>
34801054:	ea000017 	b	348010b8 <v7_dcache_maint_range+0xb0>

	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
34801058:	e2457001 	sub	r7, r5, #1
3480105c:	e1170000 	tst	r7, r0
34801060:	0a000007 	beq	34801084 <v7_dcache_maint_range+0x7c>
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
34801064:	e1a02004 	mov	r2, r4
34801068:	e59f0054 	ldr	r0, [pc, #84]	; 348010c4 <v7_dcache_maint_range+0xbc>
3480106c:	e59f1054 	ldr	r1, [pc, #84]	; 348010c8 <v7_dcache_maint_range+0xc0>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
34801070:	e2444001 	sub	r4, r4, #1
	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
34801074:	eb0022cf 	bl	34809bb8 <printf>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
34801078:	e0844005 	add	r4, r4, r5
3480107c:	e2653000 	rsb	r3, r5, #0
34801080:	e0034004 	and	r4, r3, r4

	/*
	 * If stop address is not aligned to cache-line do not
	 * invalidate the last cache-line
	 */
	if (stop & (line_len - 1)) {
34801084:	e1170006 	tst	r7, r6
34801088:	0a000008 	beq	348010b0 <v7_dcache_maint_range+0xa8>
		printf("ERROR: %s - stop address is not aligned - 0x%08x\n",
3480108c:	e1a02006 	mov	r2, r6
34801090:	e59f0034 	ldr	r0, [pc, #52]	; 348010cc <v7_dcache_maint_range+0xc4>
34801094:	e59f102c 	ldr	r1, [pc, #44]	; 348010c8 <v7_dcache_maint_range+0xc0>
34801098:	eb0022c6 	bl	34809bb8 <printf>
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
3480109c:	e2653000 	rsb	r3, r5, #0
348010a0:	e0066003 	and	r6, r6, r3
348010a4:	ea000001 	b	348010b0 <v7_dcache_maint_range+0xa8>
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCIMVAC - Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
348010a8:	ee074f36 	mcr	15, 0, r4, cr7, cr6, {1}
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
348010ac:	e0844005 	add	r4, r4, r5
348010b0:	e1540006 	cmp	r4, r6
348010b4:	3afffffb 	bcc	348010a8 <v7_dcache_maint_range+0xa0>
		v7_dcache_inval_range(start, stop, line_len);
		break;
	}

	/* DSB to make sure the operation is complete */
	CP15DSB;
348010b8:	e3a03000 	mov	r3, #0
348010bc:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
348010c0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348010c4:	34822b09 	.word	0x34822b09
348010c8:	3482035c 	.word	0x3482035c
348010cc:	34822b3c 	.word	0x34822b3c

348010d0 <invalidate_dcache_all>:
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
}

void invalidate_dcache_all(void)
{
348010d0:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);
348010d4:	e3a00001 	mov	r0, #1
348010d8:	ebffff8e 	bl	34800f18 <v7_maint_dcache_all>

	v7_outer_cache_inval_all();
}
348010dc:	e8bd4010 	pop	{r4, lr}

void invalidate_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);

	v7_outer_cache_inval_all();
348010e0:	ea00002b 	b	34801194 <__v7_outer_cache_inval_all>

348010e4 <flush_dcache_all>:
/*
 * Performs a clean & invalidation of the entire data cache
 * at all levels
 */
void flush_dcache_all(void)
{
348010e4:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);
348010e8:	e3a00002 	mov	r0, #2
348010ec:	ebffff89 	bl	34800f18 <v7_maint_dcache_all>

	v7_outer_cache_flush_all();
}
348010f0:	e8bd4010 	pop	{r4, lr}
 */
void flush_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);

	v7_outer_cache_flush_all();
348010f4:	ea000025 	b	34801190 <__v7_outer_cache_flush_all>

348010f8 <invalidate_dcache_range>:
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
348010f8:	e92d4070 	push	{r4, r5, r6, lr}

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
348010fc:	e3a02003 	mov	r2, #3
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
34801100:	e1a05000 	mov	r5, r0
34801104:	e1a04001 	mov	r4, r1

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
34801108:	ebffffbe 	bl	34801008 <v7_dcache_maint_range>

	v7_outer_cache_inval_range(start, stop);
3480110c:	e1a00005 	mov	r0, r5
34801110:	e1a01004 	mov	r1, r4
}
34801114:	e8bd4070 	pop	{r4, r5, r6, lr}
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);

	v7_outer_cache_inval_range(start, stop);
34801118:	ea00001f 	b	3480119c <__v7_outer_cache_inval_range>

3480111c <flush_dcache_range>:
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
3480111c:	e92d4070 	push	{r4, r5, r6, lr}
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
34801120:	e3a02004 	mov	r2, #4
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
34801124:	e1a05000 	mov	r5, r0
34801128:	e1a04001 	mov	r4, r1
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
3480112c:	ebffffb5 	bl	34801008 <v7_dcache_maint_range>

	v7_outer_cache_flush_range(start, stop);
34801130:	e1a00005 	mov	r0, r5
34801134:	e1a01004 	mov	r1, r4
}
34801138:	e8bd4070 	pop	{r4, r5, r6, lr}
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);

	v7_outer_cache_flush_range(start, stop);
3480113c:	ea000015 	b	34801198 <__v7_outer_cache_flush_range>

34801140 <arm_init_before_mmu>:
}

void arm_init_before_mmu(void)
{
34801140:	e92d4008 	push	{r3, lr}
	v7_outer_cache_enable();
34801144:	eb00023d 	bl	34801a40 <v7_outer_cache_enable>
	invalidate_dcache_all();
34801148:	ebffffe0 	bl	348010d0 <invalidate_dcache_all>

/* Invalidate TLB */
static void v7_inval_tlb(void)
{
	/* Invalidate entire unified TLB */
	asm volatile ("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
3480114c:	e3a03000 	mov	r3, #0
34801150:	ee083f17 	mcr	15, 0, r3, cr8, cr7, {0}
	/* Invalidate entire data TLB */
	asm volatile ("mcr p15, 0, %0, c8, c6, 0" : : "r" (0));
34801154:	ee083f16 	mcr	15, 0, r3, cr8, cr6, {0}
	/* Invalidate entire instruction TLB */
	asm volatile ("mcr p15, 0, %0, c8, c5, 0" : : "r" (0));
34801158:	ee083f15 	mcr	15, 0, r3, cr8, cr5, {0}
	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
3480115c:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
34801160:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
void arm_init_before_mmu(void)
{
	v7_outer_cache_enable();
	invalidate_dcache_all();
	v7_inval_tlb();
}
34801164:	e8bd8008 	pop	{r3, pc}

34801168 <flush_cache>:
 * Flush range from all levels of d-cache/unified-cache used:
 * Affects the range [start, start + size - 1]
 */
void  flush_cache(unsigned long start, unsigned long size)
{
	flush_dcache_range(start, start + size);
34801168:	e0811000 	add	r1, r1, r0
3480116c:	eaffffea 	b	3480111c <flush_dcache_range>

34801170 <invalidate_icache_all>:
{
	/*
	 * Invalidate all instruction caches to PoU.
	 * Also flushes branch target cache.
	 */
	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
34801170:	e3a03000 	mov	r3, #0
34801174:	ee073f15 	mcr	15, 0, r3, cr7, cr5, {0}

	/* Invalidate entire branch predictor array */
	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
34801178:	ee073fd5 	mcr	15, 0, r3, cr7, cr5, {6}

	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
3480117c:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}

	/* ISB - make sure the instruction stream sees it */
	CP15ISB;
34801180:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
}
34801184:	e12fff1e 	bx	lr

34801188 <__v7_outer_cache_enable>:
/*
 * Stub implementations for outer cache operations
 */
void __v7_outer_cache_enable(void)
{
}
34801188:	e12fff1e 	bx	lr

3480118c <__v7_outer_cache_disable>:
void v7_outer_cache_enable(void)
	__attribute__((weak, alias("__v7_outer_cache_enable")));

void __v7_outer_cache_disable(void)
{
}
3480118c:	e12fff1e 	bx	lr

34801190 <__v7_outer_cache_flush_all>:
void v7_outer_cache_disable(void)
	__attribute__((weak, alias("__v7_outer_cache_disable")));

void __v7_outer_cache_flush_all(void)
{
}
34801190:	e12fff1e 	bx	lr

34801194 <__v7_outer_cache_inval_all>:
void v7_outer_cache_flush_all(void)
	__attribute__((weak, alias("__v7_outer_cache_flush_all")));

void __v7_outer_cache_inval_all(void)
{
}
34801194:	e12fff1e 	bx	lr

34801198 <__v7_outer_cache_flush_range>:
void v7_outer_cache_inval_all(void)
	__attribute__((weak, alias("__v7_outer_cache_inval_all")));

void __v7_outer_cache_flush_range(u32 start, u32 end)
{
}
34801198:	e12fff1e 	bx	lr

3480119c <__v7_outer_cache_inval_range>:
void v7_outer_cache_flush_range(u32 start, u32 end)
	__attribute__((weak, alias("__v7_outer_cache_flush_range")));

void __v7_outer_cache_inval_range(u32 start, u32 end)
{
}
3480119c:	e12fff1e 	bx	lr

348011a0 <cpu_cache_initialization>:
#include <asm/system.h>
#include <asm/cache.h>
#include <asm/armv7.h>
#include <linux/compiler.h>

void __weak cpu_cache_initialization(void){}
348011a0:	e12fff1e 	bx	lr

348011a4 <cleanup_before_linux>:

int cleanup_before_linux(void)
{
348011a4:	e92d4008 	push	{r3, lr}
	 * it prepares the processor for linux
	 *
	 * we turn off caches etc ...
	 */
#ifndef CONFIG_SPL_BUILD
	disable_interrupts();
348011a8:	eb00038e 	bl	34801fe8 <disable_interrupts>
#endif

	/*
	 * Turn off I-cache and invalidate it
	 */
	icache_disable();
348011ac:	eb000485 	bl	348023c8 <icache_disable>
	invalidate_icache_all();
348011b0:	ebffffee 	bl	34801170 <invalidate_icache_all>

	/*
	 * turn off D-cache
	 * dcache_disable() in turn flushes the d-cache and disables MMU
	 */
	dcache_disable();
348011b4:	eb00048a 	bl	348023e4 <dcache_disable>
	v7_outer_cache_disable();
348011b8:	eb000225 	bl	34801a54 <v7_outer_cache_disable>
	 * is all we did during this. We have not pushed anything on to the
	 * stack. Neither have we affected any static data)
	 * So just invalidate the entire d-cache again to avoid coherency
	 * problems for kernel
	 */
	invalidate_dcache_all();
348011bc:	ebffffc3 	bl	348010d0 <invalidate_dcache_all>

	/*
	 * Some CPU need more cache attention before starting the kernel.
	 */
	cpu_cache_initialization();
348011c0:	ebfffff6 	bl	348011a0 <cpu_cache_initialization>

	return 0;
}
348011c4:	e3a00000 	mov	r0, #0
348011c8:	e8bd8008 	pop	{r3, pc}

348011cc <sdelay>:
 *
 *  not inline to increase chances its in cache when called
 *************************************************************/
void sdelay(unsigned long loops)
{
	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
348011cc:	e2500001 	subs	r0, r0, #1
348011d0:	1afffffd 	bne	348011cc <sdelay>
			  "bne 1b":"=r" (loops):"0"(loops));
}
348011d4:	e12fff1e 	bx	lr

348011d8 <sr32>:
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
348011d8:	e3a0c001 	mov	ip, #1

/*****************************************************************
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
348011dc:	e92d4010 	push	{r4, lr}
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
348011e0:	e1a0c21c 	lsl	ip, ip, r2
	--msk;
	tmp = readl((u32)addr) & ~(msk << start_bit);
348011e4:	e5904000 	ldr	r4, [r0]
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
	--msk;
348011e8:	e24cc001 	sub	ip, ip, #1
	tmp = readl((u32)addr) & ~(msk << start_bit);
348011ec:	e1c4c11c 	bic	ip, r4, ip, lsl r1
	tmp |= value << start_bit;
348011f0:	e18c1113 	orr	r1, ip, r3, lsl r1
	writel(tmp, (u32)addr);
348011f4:	e5801000 	str	r1, [r0]
}
348011f8:	e8bd8010 	pop	{r4, pc}

348011fc <wait_on_value>:
 * wait_on_value() - common routine to allow waiting for changes in
 *   volatile regs.
 *********************************************************************/
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
348011fc:	e92d4010 	push	{r4, lr}
	u32 i = 0, val;
34801200:	e3a0c000 	mov	ip, #0
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
34801204:	e5924000 	ldr	r4, [r2]
34801208:	e0044000 	and	r4, r4, r0
		if (val == match_value)
3480120c:	e1540001 	cmp	r4, r1
34801210:	0a000004 	beq	34801228 <wait_on_value+0x2c>
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
	u32 i = 0, val;
	do {
		++i;
34801214:	e28cc001 	add	ip, ip, #1
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
		if (i == bound)
34801218:	e15c0003 	cmp	ip, r3
3480121c:	1afffff8 	bne	34801204 <wait_on_value+0x8>
			return 0;
34801220:	e3a00000 	mov	r0, #0
34801224:	e8bd8010 	pop	{r4, pc}
	u32 i = 0, val;
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
34801228:	e3a00001 	mov	r0, #1
		if (i == bound)
			return 0;
	} while (1);
}
3480122c:	e8bd8010 	pop	{r4, pc}

34801230 <arch_cpu_init>:
/* CPU detection macros */
extern unsigned int s5p_cpu_id;

static inline void s5p_set_cpu_id(void)
{
	s5p_cpu_id = readl(S5PC100_PRO_ID);
34801230:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
34801234:	e5932000 	ldr	r2, [r3]
	s5p_cpu_id = 0xC000 | ((s5p_cpu_id & 0x00FFF000) >> 12);
34801238:	e59f3010 	ldr	r3, [pc, #16]	; 34801250 <arch_cpu_init+0x20>
3480123c:	e7eb2652 	ubfx	r2, r2, #12, #12
34801240:	e3822903 	orr	r2, r2, #49152	; 0xc000
34801244:	e5832000 	str	r2, [r3]
int arch_cpu_init(void)
{
	s5p_set_cpu_id();

	return 0;
}
34801248:	e3a00000 	mov	r0, #0
3480124c:	e12fff1e 	bx	lr
34801250:	348285d0 	.word	0x348285d0

34801254 <get_device_type>:
#endif

u32 get_device_type(void)
{
	return s5p_cpu_id;
}
34801254:	e59f3004 	ldr	r3, [pc, #4]	; 34801260 <get_device_type+0xc>
34801258:	e5930000 	ldr	r0, [r3]
3480125c:	e12fff1e 	bx	lr
34801260:	348285d0 	.word	0x348285d0

34801264 <print_cpuinfo>:

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
34801264:	e92d4010 	push	{r4, lr}
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
34801268:	e59f3034 	ldr	r3, [pc, #52]	; 348012a4 <print_cpuinfo+0x40>
	return s5p_cpu_id;
}

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
3480126c:	e24dd020 	sub	sp, sp, #32
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
34801270:	e5934000 	ldr	r4, [r3]
34801274:	eb0001c5 	bl	34801990 <get_arm_clk>
34801278:	e1a01000 	mov	r1, r0
3480127c:	e1a0000d 	mov	r0, sp
34801280:	eb006e31 	bl	3481cb4c <strmhz>
34801284:	e59f101c 	ldr	r1, [pc, #28]	; 348012a8 <print_cpuinfo+0x44>
34801288:	e1a03000 	mov	r3, r0
3480128c:	e1a02004 	mov	r2, r4
34801290:	e59f0014 	ldr	r0, [pc, #20]	; 348012ac <print_cpuinfo+0x48>
34801294:	eb002247 	bl	34809bb8 <printf>
			s5p_get_cpu_name(), s5p_cpu_id,
			strmhz(buf, get_arm_clk()));

	return 0;
}
34801298:	e3a00000 	mov	r0, #0
3480129c:	e28dd020 	add	sp, sp, #32
348012a0:	e8bd8010 	pop	{r4, pc}
348012a4:	348285d0 	.word	0x348285d0
348012a8:	34822b7f 	.word	0x34822b7f
348012ac:	34822b6e 	.word	0x34822b6e

348012b0 <s5p_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348012b0:	e59f3028 	ldr	r3, [pc, #40]	; 348012e0 <s5p_get_base_timer+0x30>
348012b4:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
348012b8:	e3530cc1 	cmp	r3, #49408	; 0xc100
348012bc:	0a000005 	beq	348012d8 <s5p_get_base_timer+0x28>
348012c0:	e30c0110 	movw	r0, #49424	; 0xc110
348012c4:	e59f2018 	ldr	r2, [pc, #24]	; 348012e4 <s5p_get_base_timer+0x34>
348012c8:	e1530000 	cmp	r3, r0
348012cc:	01a00002 	moveq	r0, r2
348012d0:	13a00000 	movne	r0, #0
348012d4:	e12fff1e 	bx	lr
348012d8:	e3a004ea 	mov	r0, #-369098752	; 0xea000000

/* macro to read the 16 bit timer */
static inline struct s5p_timer *s5p_get_base_timer(void)
{
	return (struct s5p_timer *)samsung_get_base_timer();
}
348012dc:	e12fff1e 	bx	lr
348012e0:	348285d0 	.word	0x348285d0
348012e4:	e2500000 	.word	0xe2500000

348012e8 <reset_timer_masked>:
	while (get_current_tick() < tmo)
		;	/* nop */
}

void reset_timer_masked(void)
{
348012e8:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
348012ec:	ebffffef 	bl	348012b0 <s5p_get_base_timer>

	/* reset time */
	gd->lastinc = readl(&timer->tcnto4);
348012f0:	e5902040 	ldr	r2, [r0, #64]	; 0x40
348012f4:	e5882030 	str	r2, [r8, #48]	; 0x30
	gd->tbl = 0;
348012f8:	e3a02000 	mov	r2, #0
348012fc:	e5882020 	str	r2, [r8, #32]
}
34801300:	e8bd8008 	pop	{r3, pc}

34801304 <timer_init>:
{
	return (struct s5p_timer *)samsung_get_base_timer();
}

int timer_init(void)
{
34801304:	e92d4008 	push	{r3, lr}
	/* PWM Timer 4 */
	pwm_init(4, MUX_DIV_2, 0);
34801308:	e3a01001 	mov	r1, #1
3480130c:	e3a02000 	mov	r2, #0
34801310:	e3a00004 	mov	r0, #4
34801314:	eb0000f2 	bl	348016e4 <pwm_init>
	pwm_config(4, 0, 0);
34801318:	e3a01000 	mov	r1, #0
3480131c:	e1a02001 	mov	r2, r1
34801320:	e3a00004 	mov	r0, #4
34801324:	eb0000a3 	bl	348015b8 <pwm_config>
	pwm_enable(4);
34801328:	e3a00004 	mov	r0, #4
3480132c:	eb000088 	bl	34801554 <pwm_enable>

	reset_timer_masked();
34801330:	ebffffec 	bl	348012e8 <reset_timer_masked>

	return 0;
}
34801334:	e3a00000 	mov	r0, #0
34801338:	e8bd8008 	pop	{r3, pc}

3480133c <get_current_tick>:

	return get_current_tick() / count_value;
}

unsigned long get_current_tick(void)
{
3480133c:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
34801340:	ebffffda 	bl	348012b0 <s5p_get_base_timer>
	unsigned long now = readl(&timer->tcnto4);
34801344:	e5902040 	ldr	r2, [r0, #64]	; 0x40
	unsigned long count_value = readl(&timer->tcntb4);
34801348:	e590103c 	ldr	r1, [r0, #60]	; 0x3c

	if (gd->lastinc >= now)
3480134c:	e5980030 	ldr	r0, [r8, #48]	; 0x30
34801350:	e1500002 	cmp	r0, r2
		gd->tbl += gd->lastinc - now;
	else
		gd->tbl += gd->lastinc + count_value - now;
34801354:	3598c020 	ldrcc	ip, [r8, #32]
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
34801358:	25981020 	ldrcs	r1, [r8, #32]
	else
		gd->tbl += gd->lastinc + count_value - now;
3480135c:	35980030 	ldrcc	r0, [r8, #48]	; 0x30
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
34801360:	25980030 	ldrcs	r0, [r8, #48]	; 0x30
	else
		gd->tbl += gd->lastinc + count_value - now;
34801364:	308c1001 	addcc	r1, ip, r1
34801368:	e0811000 	add	r1, r1, r0
3480136c:	e0621001 	rsb	r1, r2, r1
34801370:	e5881020 	str	r1, [r8, #32]

	gd->lastinc = now;
34801374:	e5882030 	str	r2, [r8, #48]	; 0x30

	return gd->tbl;
34801378:	e5980020 	ldr	r0, [r8, #32]
}
3480137c:	e8bd8008 	pop	{r3, pc}

34801380 <get_timer_masked>:
	gd->lastinc = readl(&timer->tcnto4);
	gd->tbl = 0;
}

unsigned long get_timer_masked(void)
{
34801380:	e92d4010 	push	{r4, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
34801384:	ebffffc9 	bl	348012b0 <s5p_get_base_timer>
	unsigned long count_value = readl(&timer->tcntb4);
34801388:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	return get_current_tick() / count_value;
3480138c:	ebffffea 	bl	3480133c <get_current_tick>
34801390:	e1a01004 	mov	r1, r4
34801394:	eb007ac4 	bl	3481feac <__udivsi3>
}
34801398:	e8bd8010 	pop	{r4, pc}

3480139c <get_timer>:

/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
3480139c:	e92d4010 	push	{r4, lr}
348013a0:	e1a04000 	mov	r4, r0
	return get_timer_masked() - base;
348013a4:	ebfffff5 	bl	34801380 <get_timer_masked>
}
348013a8:	e0640000 	rsb	r0, r4, r0
348013ac:	e8bd8010 	pop	{r4, pc}

348013b0 <__udelay>:

/* delay x useconds */
void __udelay(unsigned long usec)
{
348013b0:	e92d4038 	push	{r3, r4, r5, lr}
348013b4:	e1a05000 	mov	r5, r0
	struct s5p_timer *const timer = s5p_get_base_timer();
348013b8:	ebffffbc 	bl	348012b0 <s5p_get_base_timer>
	unsigned long tmo, tmp, count_value;

	count_value = readl(&timer->tcntb4);
348013bc:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	if (usec >= 1000) {
348013c0:	e3550ffa 	cmp	r5, #1000	; 0x3e8
348013c4:	3a000006 	bcc	348013e4 <__udelay+0x34>
		 * to seconds
		 * 1. start to normalize for usec to ticks per sec
		 * 2. find number of "ticks" to wait to achieve target
		 * 3. finish normalize.
		 */
		tmo = usec / 1000;
348013c8:	e3a01ffa 	mov	r1, #1000	; 0x3e8
348013cc:	e1a00005 	mov	r0, r5
348013d0:	eb007ab5 	bl	3481feac <__udivsi3>
		tmo *= (CONFIG_SYS_HZ * count_value);
348013d4:	e3a01ffa 	mov	r1, #1000	; 0x3e8
348013d8:	e0040491 	mul	r4, r1, r4
		tmo /= 1000;
348013dc:	e0000490 	mul	r0, r0, r4
348013e0:	ea000003 	b	348013f4 <__udelay+0x44>
	} else {
		/* else small number, don't kill it prior to HZ multiply */
		tmo = usec * CONFIG_SYS_HZ * count_value;
348013e4:	e3a03ffa 	mov	r3, #1000	; 0x3e8
348013e8:	e0040493 	mul	r4, r3, r4
		tmo /= (1000 * 1000);
348013ec:	e0000495 	mul	r0, r5, r4
348013f0:	e59f1030 	ldr	r1, [pc, #48]	; 34801428 <__udelay+0x78>
348013f4:	eb007aac 	bl	3481feac <__udivsi3>
348013f8:	e1a05000 	mov	r5, r0
	}

	/* get current timestamp */
	tmp = get_current_tick();
348013fc:	ebffffce 	bl	3480133c <get_current_tick>

	/* if setting this fordward will roll time stamp */
	/* reset "advancing" timestamp to 0, set lastinc value */
	/* else, set advancing stamp wake up time */
	if ((tmo + tmp + 1) < tmp)
34801400:	e0804005 	add	r4, r0, r5
34801404:	e2843001 	add	r3, r4, #1
34801408:	e1530000 	cmp	r3, r0
3480140c:	2a000001 	bcs	34801418 <__udelay+0x68>
		reset_timer_masked();
34801410:	ebffffb4 	bl	348012e8 <reset_timer_masked>
34801414:	e1a04005 	mov	r4, r5
	else
		tmo += tmp;

	/* loop till event */
	while (get_current_tick() < tmo)
34801418:	ebffffc7 	bl	3480133c <get_current_tick>
3480141c:	e1500004 	cmp	r0, r4
34801420:	3afffffc 	bcc	34801418 <__udelay+0x68>
		;	/* nop */
}
34801424:	e8bd8038 	pop	{r3, r4, r5, pc}
34801428:	000f4240 	.word	0x000f4240

3480142c <get_ticks>:
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
3480142c:	e92d4008 	push	{r3, lr}
/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
	return get_timer_masked() - base;
34801430:	ebffffd2 	bl	34801380 <get_timer_masked>
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
	return get_timer(0);
}
34801434:	e3a01000 	mov	r1, #0
34801438:	e8bd8008 	pop	{r3, pc}

3480143c <get_tbclk>:
 * On ARM it returns the number of timer ticks per second.
 */
unsigned long get_tbclk(void)
{
	return CONFIG_SYS_HZ;
}
3480143c:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34801440:	e12fff1e 	bx	lr

34801444 <s5p_config_sromc>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801444:	e59f3040 	ldr	r3, [pc, #64]	; 3480148c <s5p_config_sromc+0x48>
 * srom_bank	- SROM
 * srom_bw_conf  - SMC Band witdh reg configuration value
 * srom_bc_conf  - SMC Bank Control reg configuration value
 */
void s5p_config_sromc(u32 srom_bank, u32 srom_bw_conf, u32 srom_bc_conf)
{
34801448:	e92d4010 	push	{r4, lr}
3480144c:	e5933000 	ldr	r3, [r3]

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
34801450:	e3530cc1 	cmp	r3, #49408	; 0xc100
34801454:	03a034e7 	moveq	r3, #-419430400	; 0xe7000000
34801458:	0a000003 	beq	3480146c <s5p_config_sromc+0x28>
3480145c:	e30cc110 	movw	ip, #49424	; 0xc110
34801460:	e153000c 	cmp	r3, ip
34801464:	03a0333a 	moveq	r3, #-402653184	; 0xe8000000
34801468:	13a03000 	movne	r3, #0
	u32 tmp;
	struct s5p_sromc *srom =
		(struct s5p_sromc *)samsung_get_base_sromc();

	/* Configure SMC_BW register to handle proper SROMC bank */
	tmp = srom->bw;
3480146c:	e593c000 	ldr	ip, [r3]
	tmp &= ~(0xF << (srom_bank * 4));
34801470:	e1a00100 	lsl	r0, r0, #2
34801474:	e3a0400f 	mov	r4, #15
34801478:	e1ccc014 	bic	ip, ip, r4, lsl r0
	tmp |= srom_bw_conf;
3480147c:	e18c1001 	orr	r1, ip, r1
	srom->bw = tmp;
34801480:	e6831000 	str	r1, [r3], r0

	/* Configure SMC_BC register */
	srom->bc[srom_bank] = srom_bc_conf;
34801484:	e5832004 	str	r2, [r3, #4]
}
34801488:	e8bd8010 	pop	{r4, pc}
3480148c:	348285d0 	.word	0x348285d0

34801490 <samsung_get_base_watchdog>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801490:	e59f3028 	ldr	r3, [pc, #40]	; 348014c0 <samsung_get_base_watchdog+0x30>
34801494:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
SAMSUNG_BASE(watchdog, WATCHDOG_BASE)
34801498:	e3530cc1 	cmp	r3, #49408	; 0xc100
3480149c:	0a000005 	beq	348014b8 <samsung_get_base_watchdog+0x28>
348014a0:	e30c0110 	movw	r0, #49424	; 0xc110
348014a4:	e59f2018 	ldr	r2, [pc, #24]	; 348014c4 <samsung_get_base_watchdog+0x34>
348014a8:	e1530000 	cmp	r3, r0
348014ac:	01a00002 	moveq	r0, r2
348014b0:	13a00000 	movne	r0, #0
348014b4:	e12fff1e 	bx	lr
348014b8:	e59f0008 	ldr	r0, [pc, #8]	; 348014c8 <samsung_get_base_watchdog+0x38>
348014bc:	e12fff1e 	bx	lr
348014c0:	348285d0 	.word	0x348285d0
348014c4:	e2700000 	.word	0xe2700000
348014c8:	ea200000 	.word	0xea200000

348014cc <wdt_stop>:
#include <asm/arch/watchdog.h>

#define PRESCALER_VAL 255

void wdt_stop(void)
{
348014cc:	e92d4008 	push	{r3, lr}
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
348014d0:	ebffffee 	bl	34801490 <samsung_get_base_watchdog>
	unsigned int wtcon;

	wtcon = readl(&wdt->wtcon);
348014d4:	e5903000 	ldr	r3, [r0]
	wtcon &= ~(WTCON_EN | WTCON_INT | WTCON_RESET);
348014d8:	e3c33025 	bic	r3, r3, #37	; 0x25

	writel(wtcon, &wdt->wtcon);
348014dc:	e5803000 	str	r3, [r0]
}
348014e0:	e8bd8008 	pop	{r3, pc}

348014e4 <wdt_start>:

void wdt_start(unsigned int timeout)
{
348014e4:	e92d4038 	push	{r3, r4, r5, lr}
348014e8:	e1a04000 	mov	r4, r0
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
348014ec:	ebffffe7 	bl	34801490 <samsung_get_base_watchdog>
348014f0:	e1a05000 	mov	r5, r0
	unsigned int wtcon;

	wdt_stop();
348014f4:	ebfffff4 	bl	348014cc <wdt_stop>

	wtcon = readl(&wdt->wtcon);
348014f8:	e5953000 	ldr	r3, [r5]
	wtcon |= (WTCON_EN | WTCON_CLK(WTCON_CLK_128));
348014fc:	e3833038 	orr	r3, r3, #56	; 0x38
	wtcon &= ~WTCON_INT;
34801500:	e3c33004 	bic	r3, r3, #4
	wtcon |= WTCON_RESET;
	wtcon |= WTCON_PRESCALER(PRESCALER_VAL);
34801504:	e3833cff 	orr	r3, r3, #65280	; 0xff00
34801508:	e3833001 	orr	r3, r3, #1

	writel(timeout, &wdt->wtdat);
3480150c:	e5854004 	str	r4, [r5, #4]
	writel(timeout, &wdt->wtcnt);
34801510:	e5854008 	str	r4, [r5, #8]
	writel(wtcon, &wdt->wtcon);
34801514:	e5853000 	str	r3, [r5]
}
34801518:	e8bd8038 	pop	{r3, r4, r5, pc}

3480151c <samsung_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
3480151c:	e59f3028 	ldr	r3, [pc, #40]	; 3480154c <samsung_get_base_timer+0x30>
34801520:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34801524:	e3530cc1 	cmp	r3, #49408	; 0xc100
34801528:	0a000005 	beq	34801544 <samsung_get_base_timer+0x28>
3480152c:	e30c0110 	movw	r0, #49424	; 0xc110
34801530:	e59f2018 	ldr	r2, [pc, #24]	; 34801550 <samsung_get_base_timer+0x34>
34801534:	e1530000 	cmp	r3, r0
34801538:	01a00002 	moveq	r0, r2
3480153c:	13a00000 	movne	r0, #0
34801540:	e12fff1e 	bx	lr
34801544:	e3a004ea 	mov	r0, #-369098752	; 0xea000000
34801548:	e12fff1e 	bx	lr
3480154c:	348285d0 	.word	0x348285d0
34801550:	e2500000 	.word	0xe2500000

34801554 <pwm_enable>:
#include <asm/io.h>
#include <asm/arch/pwm.h>
#include <asm/arch/clk.h>

int pwm_enable(int pwm_id)
{
34801554:	e92d4010 	push	{r4, lr}
34801558:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
3480155c:	ebffffee 	bl	3480151c <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
34801560:	e5903008 	ldr	r3, [r0, #8]
	tcon |= TCON_START(pwm_id);
34801564:	e3540000 	cmp	r4, #0
34801568:	12844001 	addne	r4, r4, #1
3480156c:	03a04000 	moveq	r4, #0
34801570:	e3a02001 	mov	r2, #1
34801574:	e1a04104 	lsl	r4, r4, #2
34801578:	e1834412 	orr	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
3480157c:	e5804008 	str	r4, [r0, #8]

	return 0;
}
34801580:	e3a00000 	mov	r0, #0
34801584:	e8bd8010 	pop	{r4, pc}

34801588 <pwm_disable>:

void pwm_disable(int pwm_id)
{
34801588:	e92d4010 	push	{r4, lr}
3480158c:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801590:	ebffffe1 	bl	3480151c <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
34801594:	e5903008 	ldr	r3, [r0, #8]
	tcon &= ~TCON_START(pwm_id);
34801598:	e3540000 	cmp	r4, #0
3480159c:	12844001 	addne	r4, r4, #1
348015a0:	03a04000 	moveq	r4, #0
348015a4:	e3a02001 	mov	r2, #1
348015a8:	e1a04104 	lsl	r4, r4, #2
348015ac:	e1c34412 	bic	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
348015b0:	e5804008 	str	r4, [r0, #8]
}
348015b4:	e8bd8010 	pop	{r4, pc}

348015b8 <pwm_config>:
}

#define NS_IN_HZ (1000000000UL)

int pwm_config(int pwm_id, int duty_ns, int period_ns)
{
348015b8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348015bc:	e1a05001 	mov	r5, r1
348015c0:	e1a07002 	mov	r7, r2
348015c4:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348015c8:	ebffffd3 	bl	3480151c <samsung_get_base_timer>
348015cc:	e1a06000 	mov	r6, r0
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
348015d0:	e59f0108 	ldr	r0, [pc, #264]	; 348016e0 <pwm_config+0x128>
348015d4:	e1550000 	cmp	r5, r0
348015d8:	91570000 	cmpls	r7, r0
		return -ERANGE;
348015dc:	83e00021 	mvnhi	r0, #33	; 0x21
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
348015e0:	8a00003d 	bhi	348016dc <pwm_config+0x124>
		return -ERANGE;

	if (duty_ns > period_ns)
348015e4:	e1550007 	cmp	r5, r7
		return -EINVAL;
348015e8:	c3e00015 	mvngt	r0, #21
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
		return -ERANGE;

	if (duty_ns > period_ns)
348015ec:	ca00003a 	bgt	348016dc <pwm_config+0x124>
		return -EINVAL;

	period = NS_IN_HZ / period_ns;
348015f0:	e1a01007 	mov	r1, r7
348015f4:	eb007a2c 	bl	3481feac <__udivsi3>
348015f8:	e58d0004 	str	r0, [sp, #4]
static unsigned long pwm_calc_tin(int pwm_id, unsigned long freq)
{
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();
348015fc:	eb0000fd 	bl	348019f8 <get_pwm_clk>
34801600:	e3a0b004 	mov	fp, #4
34801604:	e1a09000 	mov	r9, r0

	for (div = 2; div <= 16; div *= 2) {
34801608:	e3a0a002 	mov	sl, #2
		if ((tin_parent_rate / (div << 16)) < freq)
3480160c:	e1a00009 	mov	r0, r9
34801610:	e1a0180a 	lsl	r1, sl, #16
34801614:	eb007a24 	bl	3481feac <__udivsi3>
34801618:	e59d3004 	ldr	r3, [sp, #4]
3480161c:	e1500003 	cmp	r0, r3
34801620:	2a000004 	bcs	34801638 <pwm_config+0x80>
			return tin_parent_rate / div;
34801624:	e1a0100a 	mov	r1, sl
34801628:	e1a00009 	mov	r0, r9
3480162c:	eb007a1e 	bl	3481feac <__udivsi3>
34801630:	e1a01000 	mov	r1, r0
34801634:	ea000003 	b	34801648 <pwm_config+0x90>
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();

	for (div = 2; div <= 16; div *= 2) {
34801638:	e25bb001 	subs	fp, fp, #1
3480163c:	e1a0a08a 	lsl	sl, sl, #1
34801640:	1afffff1 	bne	3480160c <pwm_config+0x54>
		if ((tin_parent_rate / (div << 16)) < freq)
			return tin_parent_rate / div;
	}

	return tin_parent_rate / 16;
34801644:	e1a01229 	lsr	r1, r9, #4
	period = NS_IN_HZ / period_ns;

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
34801648:	e59f0090 	ldr	r0, [pc, #144]	; 348016e0 <pwm_config+0x128>
3480164c:	eb007a16 	bl	3481feac <__udivsi3>
34801650:	e1a0a000 	mov	sl, r0
	tcnt = period_ns / tin_ns;
34801654:	e1a0100a 	mov	r1, sl
34801658:	e1a00007 	mov	r0, r7
3480165c:	eb007a12 	bl	3481feac <__udivsi3>

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
34801660:	e1a0100a 	mov	r1, sl

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
	tcnt = period_ns / tin_ns;
34801664:	e1a07000 	mov	r7, r0

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
34801668:	e1a00005 	mov	r0, r5
3480166c:	eb007a0e 	bl	3481feac <__udivsi3>
	tcmp = tcnt - tcmp;
34801670:	e0600007 	rsb	r0, r0, r7

	/*
	 * the pwm hw only checks the compare register after a decrement,
	 * so the pin never toggles if tcmp = tcnt
	 */
	if (tcmp == tcnt)
34801674:	e1500007 	cmp	r0, r7
		tcmp--;
34801678:	02400001 	subeq	r0, r0, #1
	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
	if (pwm_id < 4) {
3480167c:	e3540003 	cmp	r4, #3
34801680:	ca000004 	bgt	34801698 <pwm_config+0xe0>

	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
34801684:	e0843084 	add	r3, r4, r4, lsl #1
	if (pwm_id < 4) {
		writel(tcnt, &pwm->tcntb0 + offset);
34801688:	e286200c 	add	r2, r6, #12
3480168c:	e7827103 	str	r7, [r2, r3, lsl #2]
		writel(tcmp, &pwm->tcmpb0 + offset);
34801690:	e2862010 	add	r2, r6, #16
34801694:	e7820103 	str	r0, [r2, r3, lsl #2]
	}

	tcon = readl(&pwm->tcon);
34801698:	e5961008 	ldr	r1, [r6, #8]
	tcon |= TCON_UPDATE(pwm_id);
3480169c:	e3540000 	cmp	r4, #0
348016a0:	1284c001 	addne	ip, r4, #1
348016a4:	03a0c000 	moveq	ip, #0
348016a8:	e1a0c10c 	lsl	ip, ip, #2
348016ac:	e3a00001 	mov	r0, #1
348016b0:	e28c2001 	add	r2, ip, #1
348016b4:	e1a02210 	lsl	r2, r0, r2
	if (pwm_id < 4)
348016b8:	e3540003 	cmp	r4, #3
		writel(tcnt, &pwm->tcntb0 + offset);
		writel(tcmp, &pwm->tcmpb0 + offset);
	}

	tcon = readl(&pwm->tcon);
	tcon |= TCON_UPDATE(pwm_id);
348016bc:	e1821001 	orr	r1, r2, r1
	if (pwm_id < 4)
		tcon |= TCON_AUTO_RELOAD(pwm_id);
348016c0:	d28c3003 	addle	r3, ip, #3
348016c4:	d1813310 	orrle	r3, r1, r0, lsl r3
	else
		tcon |= TCON4_AUTO_RELOAD;
348016c8:	c3813501 	orrgt	r3, r1, #4194304	; 0x400000
	writel(tcon, &pwm->tcon);
348016cc:	e5863008 	str	r3, [r6, #8]

	tcon &= ~TCON_UPDATE(pwm_id);
348016d0:	e1c33002 	bic	r3, r3, r2
	writel(tcon, &pwm->tcon);

	return 0;
348016d4:	e3a00000 	mov	r0, #0
	else
		tcon |= TCON4_AUTO_RELOAD;
	writel(tcon, &pwm->tcon);

	tcon &= ~TCON_UPDATE(pwm_id);
	writel(tcon, &pwm->tcon);
348016d8:	e5863008 	str	r3, [r6, #8]

	return 0;
}
348016dc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348016e0:	3b9aca00 	.word	0x3b9aca00

348016e4 <pwm_init>:

int pwm_init(int pwm_id, int div, int invert)
{
348016e4:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
348016e8:	e1a04000 	mov	r4, r0
348016ec:	e1a07001 	mov	r7, r1
348016f0:	e1a0a002 	mov	sl, r2
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348016f4:	ebffff88 	bl	3480151c <samsung_get_base_timer>
	/*
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
348016f8:	e5903000 	ldr	r3, [r0]

int pwm_init(int pwm_id, int div, int invert)
{
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348016fc:	e1a05000 	mov	r5, r0
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
34801700:	e3540001 	cmp	r4, #1
		prescaler = PRESCALER_0;
		val &= ~0xff;
34801704:	d3c330ff 	bicle	r3, r3, #255	; 0xff
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
34801708:	c3c33cff 	bicgt	r3, r3, #65280	; 0xff00

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
3480170c:	d3833007 	orrle	r3, r3, #7
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
34801710:	d3a09007 	movle	r9, #7
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
34801714:	c3833c0f 	orrgt	r3, r3, #3840	; 0xf00
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
34801718:	c3a0900f 	movgt	r9, #15
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
	}
	writel(val, &pwm->tcfg0);
3480171c:	e5803000 	str	r3, [r0]
	val = readl(&pwm->tcfg1);
34801720:	e5902004 	ldr	r2, [r0, #4]
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
34801724:	e3a0600f 	mov	r6, #15
34801728:	e1a03104 	lsl	r3, r4, #2
3480172c:	e1c22316 	bic	r2, r2, r6, lsl r3
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
34801730:	e0071006 	and	r1, r7, r6
34801734:	e1823311 	orr	r3, r2, r1, lsl r3
	writel(val, &pwm->tcfg1);
34801738:	e5803004 	str	r3, [r0, #4]

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
3480173c:	eb0000ad 	bl	348019f8 <get_pwm_clk>
34801740:	e2899001 	add	r9, r9, #1
			(div + 1));
34801744:	e2871001 	add	r1, r7, #1
	val = readl(&pwm->tcfg1);
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
	writel(val, &pwm->tcfg1);

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
34801748:	e0010991 	mul	r1, r1, r9
3480174c:	eb0079d6 	bl	3481feac <__udivsi3>
			(div + 1));

	timer_rate_hz = timer_rate_hz / CONFIG_SYS_HZ;
34801750:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34801754:	eb0079d4 	bl	3481feac <__udivsi3>

	/* set count value */
	offset = pwm_id * 3;
34801758:	e0842084 	add	r2, r4, r4, lsl #1
	writel(timer_rate_hz, &pwm->tcntb0 + offset);
3480175c:	e285300c 	add	r3, r5, #12
34801760:	e7830102 	str	r0, [r3, r2, lsl #2]

	val = readl(&pwm->tcon) & ~(0xf << TCON_OFFSET(pwm_id));
34801764:	e5952008 	ldr	r2, [r5, #8]
34801768:	e3540000 	cmp	r4, #0
3480176c:	12843001 	addne	r3, r4, #1
34801770:	03a03000 	moveq	r3, #0
34801774:	e1a03103 	lsl	r3, r3, #2
34801778:	e1c26316 	bic	r6, r2, r6, lsl r3
	if (invert && (pwm_id < 4))
3480177c:	e25aa000 	subs	sl, sl, #0
34801780:	13a0a001 	movne	sl, #1
34801784:	e3540003 	cmp	r4, #3
34801788:	c3a0a000 	movgt	sl, #0
3480178c:	e35a0000 	cmp	sl, #0
		val |= TCON_INVERTER(pwm_id);
34801790:	12833002 	addne	r3, r3, #2
34801794:	13a02001 	movne	r2, #1
34801798:	11866312 	orrne	r6, r6, r2, lsl r3
	writel(val, &pwm->tcon);
3480179c:	e5856008 	str	r6, [r5, #8]

	pwm_enable(pwm_id);
348017a0:	e1a00004 	mov	r0, r4
348017a4:	ebffff6a 	bl	34801554 <pwm_enable>

	return 0;
}
348017a8:	e3a00000 	mov	r0, #0
348017ac:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	...

348017c0 <samsung_get_base_clock>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348017c0:	e59f3028 	ldr	r3, [pc, #40]	; 348017f0 <samsung_get_base_clock+0x30>
348017c4:	e5933000 	ldr	r3, [r3]
		return S5PC110_##base;				\
	else							\
		return 0;					\
}

SAMSUNG_BASE(clock, CLOCK_BASE)
348017c8:	e3530cc1 	cmp	r3, #49408	; 0xc100
348017cc:	0a000005 	beq	348017e8 <samsung_get_base_clock+0x28>
348017d0:	e30c0110 	movw	r0, #49424	; 0xc110
348017d4:	e59f2018 	ldr	r2, [pc, #24]	; 348017f4 <samsung_get_base_clock+0x34>
348017d8:	e1530000 	cmp	r3, r0
348017dc:	01a00002 	moveq	r0, r2
348017e0:	13a00000 	movne	r0, #0
348017e4:	e12fff1e 	bx	lr
348017e8:	e59f0004 	ldr	r0, [pc, #4]	; 348017f4 <samsung_get_base_clock+0x34>
348017ec:	e12fff1e 	bx	lr
348017f0:	348285d0 	.word	0x348285d0
348017f4:	e0100000 	.word	0xe0100000

348017f8 <get_pll_clk>:
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
348017f8:	e92d4038 	push	{r3, r4, r5, lr}
	if (cpu_is_s5pc110())
348017fc:	e59f3114 	ldr	r3, [pc, #276]	; 34801918 <get_pll_clk+0x120>
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
34801800:	e1a05000 	mov	r5, r0
	if (cpu_is_s5pc110())
34801804:	e5932000 	ldr	r2, [r3]
34801808:	e30c3110 	movw	r3, #49424	; 0xc110
3480180c:	e1520003 	cmp	r2, r3
34801810:	1a000020 	bne	34801898 <get_pll_clk+0xa0>

/* s5pc100: return pll clock frequency */
static unsigned long s5pc110_get_pll_clk(int pllreg)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34801814:	ebffffe9 	bl	348017c0 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
34801818:	e3550004 	cmp	r5, #4
3480181c:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
34801820:	ea00002d 	b	348018dc <get_pll_clk+0xe4>
34801824:	34801838 	.word	0x34801838
34801828:	34801840 	.word	0x34801840
3480182c:	34801848 	.word	0x34801848
34801830:	348018dc 	.word	0x348018dc
34801834:	34801850 	.word	0x34801850
	case APLL:
		r = readl(&clk->apll_con);
34801838:	e5903100 	ldr	r3, [r0, #256]	; 0x100
3480183c:	ea000004 	b	34801854 <get_pll_clk+0x5c>
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
34801840:	e5903108 	ldr	r3, [r0, #264]	; 0x108
34801844:	ea000002 	b	34801854 <get_pll_clk+0x5c>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
34801848:	e5903110 	ldr	r3, [r0, #272]	; 0x110
3480184c:	ea000000 	b	34801854 <get_pll_clk+0x5c>
		break;
	case VPLL:
		r = readl(&clk->vpll_con);
34801850:	e5903120 	ldr	r3, [r0, #288]	; 0x120
	 * MPLL_CON: MIDV [25:16]
	 * EPLL_CON: MIDV [24:16]
	 * VPLL_CON: MIDV [24:16]
	 */
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
34801854:	e3550001 	cmp	r5, #1
34801858:	e30023ff 	movw	r2, #1023	; 0x3ff
3480185c:	e30041ff 	movw	r4, #511	; 0x1ff
34801860:	91a04002 	movls	r4, r2
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
34801864:	e3550000 	cmp	r5, #0
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
	else
		mask = 0x1ff;

	m = (r >> 16) & mask;
34801868:	e0044823 	and	r4, r4, r3, lsr #16

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
3480186c:	e7e51453 	ubfx	r1, r3, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;
34801870:	e2033007 	and	r3, r3, #7

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
34801874:	1a000002 	bne	34801884 <get_pll_clk+0x8c>
		if (s < 1)
			s = 1;
34801878:	e3530000 	cmp	r3, #0
3480187c:	03a03001 	moveq	r3, #1
		/* FOUT = MDIV * FIN / (PDIV * 2^(SDIV - 1)) */
		fout = m * (freq / (p * (1 << (s - 1))));
34801880:	e2433001 	sub	r3, r3, #1
	} else
		/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
		fout = m * (freq / (p * (1 << s)));
34801884:	e59f0090 	ldr	r0, [pc, #144]	; 3480191c <get_pll_clk+0x124>
34801888:	e1a01311 	lsl	r1, r1, r3
3480188c:	eb007986 	bl	3481feac <__udivsi3>
34801890:	e0000490 	mul	r0, r0, r4
34801894:	e8bd8038 	pop	{r3, r4, r5, pc}

/* s5pc110: return pll clock frequency */
static unsigned long s5pc100_get_pll_clk(int pllreg)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
34801898:	ebffffc8 	bl	348017c0 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
3480189c:	e3550003 	cmp	r5, #3
348018a0:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
348018a4:	ea00000c 	b	348018dc <get_pll_clk+0xe4>
348018a8:	348018b8 	.word	0x348018b8
348018ac:	348018c4 	.word	0x348018c4
348018b0:	348018cc 	.word	0x348018cc
348018b4:	348018d4 	.word	0x348018d4
	case APLL:
		r = readl(&clk->apll_con);
348018b8:	e5904100 	ldr	r4, [r0, #256]	; 0x100
	 * MPLL_CON: MIDV [23:16]
	 * EPLL_CON: MIDV [23:16]
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
348018bc:	e30053ff 	movw	r5, #1023	; 0x3ff
348018c0:	ea00000a 	b	348018f0 <get_pll_clk+0xf8>
	switch (pllreg) {
	case APLL:
		r = readl(&clk->apll_con);
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
348018c4:	e5904104 	ldr	r4, [r0, #260]	; 0x104
348018c8:	ea000010 	b	34801910 <get_pll_clk+0x118>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
348018cc:	e5904108 	ldr	r4, [r0, #264]	; 0x108
348018d0:	ea00000e 	b	34801910 <get_pll_clk+0x118>
		break;
	case HPLL:
		r = readl(&clk->hpll_con);
348018d4:	e590410c 	ldr	r4, [r0, #268]	; 0x10c
348018d8:	ea00000c 	b	34801910 <get_pll_clk+0x118>
		break;
	default:
		printf("Unsupported PLL (%d)\n", pllreg);
348018dc:	e59f003c 	ldr	r0, [pc, #60]	; 34801920 <get_pll_clk+0x128>
348018e0:	e1a01005 	mov	r1, r5
348018e4:	eb0020b3 	bl	34809bb8 <printf>
		return 0;
348018e8:	e3a00000 	mov	r0, #0
348018ec:	e8bd8038 	pop	{r3, r4, r5, pc}
	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;
348018f0:	e2043007 	and	r3, r4, #7
		mask = 0x0ff;

	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
348018f4:	e7e51454 	ubfx	r1, r4, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
348018f8:	e1a01311 	lsl	r1, r1, r3
348018fc:	e59f0020 	ldr	r0, [pc, #32]	; 34801924 <get_pll_clk+0x12c>
34801900:	eb007969 	bl	3481feac <__udivsi3>
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;

	m = (r >> 16) & mask;
34801904:	e0054824 	and	r4, r5, r4, lsr #16
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
34801908:	e0000094 	mul	r0, r4, r0
{
	if (cpu_is_s5pc110())
		return s5pc110_get_pll_clk(pllreg);
	else
		return s5pc100_get_pll_clk(pllreg);
}
3480190c:	e8bd8038 	pop	{r3, r4, r5, pc}
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;
34801910:	e3a050ff 	mov	r5, #255	; 0xff
34801914:	eafffff5 	b	348018f0 <get_pll_clk+0xf8>
34801918:	348285d0 	.word	0x348285d0
3480191c:	016e3600 	.word	0x016e3600
34801920:	34822b83 	.word	0x34822b83
34801924:	00b71b00 	.word	0x00b71b00

34801928 <s5pc100_get_pclk>:
	return get_pclk_sys(CLK_P);
}

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
34801928:	e92d4010 	push	{r4, lr}

/* s5pc100: return PCLKD1 frequency */
static unsigned long get_pclkd1(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
3480192c:	ebffffa3 	bl	348017c0 <samsung_get_base_clock>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
34801930:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34801934:	e3a00001 	mov	r0, #1
34801938:	ebffffae 	bl	348017f8 <get_pll_clk>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
3480193c:	e7e21654 	ubfx	r1, r4, #12, #3
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34801940:	e2811001 	add	r1, r1, #1
34801944:	eb007958 	bl	3481feac <__udivsi3>

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;
34801948:	e7e21854 	ubfx	r1, r4, #16, #3

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
	pclkd1 = d1_bus / (pclkd1_ratio + 1);
3480194c:	e2811001 	add	r1, r1, #1
34801950:	eb007955 	bl	3481feac <__udivsi3>

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
	return get_pclkd1();
}
34801954:	e8bd8010 	pop	{r4, pc}

34801958 <s5pc110_get_pclk>:
	return pclk;
}

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
34801958:	e92d4038 	push	{r3, r4, r5, lr}

/* s5pc110: return PCLKs frequency */
static unsigned long get_pclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
3480195c:	ebffff97 	bl	348017c0 <samsung_get_base_clock>
	unsigned long pclk;
	unsigned int div;
	unsigned int offset;
	unsigned int pclk_sys_ratio;

	div = readl(&clk->div0);
34801960:	e5904300 	ldr	r4, [r0, #768]	; 0x300

/* s5pc110: return HCLKs frequency */
static unsigned long get_hclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34801964:	ebffff95 	bl	348017c0 <samsung_get_base_clock>
	unsigned int hclk_sys_ratio;

	if (dom == CLK_M)
		return get_hclk();

	div = readl(&clk->div0);
34801968:	e5905300 	ldr	r5, [r0, #768]	; 0x300
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
3480196c:	e3a00001 	mov	r0, #1
34801970:	ebffffa0 	bl	348017f8 <get_pll_clk>
	 * HCLK_DSYS_RATIO: [19:16]
	 * HCLK_PSYS_RATIO: [27:24]
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;
34801974:	e7e31c55 	ubfx	r1, r5, #24, #4

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
34801978:	e2811001 	add	r1, r1, #1
3480197c:	eb00794a 	bl	3481feac <__udivsi3>
	 * PCLK_DSYS_RATIO: [22:20]
	 * PCLK_PSYS_RATIO: [30:28]
	 */
	offset = 12 + (dom << 0x3);

	pclk_sys_ratio = (div >> offset) & 0x7;
34801980:	e7e21e54 	ubfx	r1, r4, #28, #3

	pclk = get_hclk_sys(dom) / (pclk_sys_ratio + 1);
34801984:	e2811001 	add	r1, r1, #1
34801988:	eb007947 	bl	3481feac <__udivsi3>

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
	return get_pclk_sys(CLK_P);
}
3480198c:	e8bd8038 	pop	{r3, r4, r5, pc}

34801990 <get_arm_clk>:
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
34801990:	e59f305c 	ldr	r3, [pc, #92]	; 348019f4 <get_arm_clk+0x64>
	else
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
34801994:	e92d4010 	push	{r4, lr}
	if (cpu_is_s5pc110())
34801998:	e5932000 	ldr	r2, [r3]
3480199c:	e30c3110 	movw	r3, #49424	; 0xc110
348019a0:	e1520003 	cmp	r2, r3
348019a4:	1a000007 	bne	348019c8 <get_arm_clk+0x38>

/* s5pc110: return ARM clock frequency */
static unsigned long s5pc110_get_arm_clk(void)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
348019a8:	ebffff84 	bl	348017c0 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio;

	div = readl(&clk->div0);
348019ac:	e5904300 	ldr	r4, [r0, #768]	; 0x300

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
348019b0:	e3a00000 	mov	r0, #0
348019b4:	ebffff8f 	bl	348017f8 <get_pll_clk>
	unsigned int apll_ratio;

	div = readl(&clk->div0);

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;
348019b8:	e2041007 	and	r1, r4, #7

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
348019bc:	e2811001 	add	r1, r1, #1
348019c0:	eb007939 	bl	3481feac <__udivsi3>
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
348019c4:	e8bd8010 	pop	{r4, pc}

/* s5pc100: return ARM clock frequency */
static unsigned long s5pc100_get_arm_clk(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
348019c8:	ebffff7c 	bl	348017c0 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);
348019cc:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
348019d0:	e3a00000 	mov	r0, #0
348019d4:	ebffff87 	bl	348017f8 <get_pll_clk>
	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;
348019d8:	e2041001 	and	r1, r4, #1

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
348019dc:	e2811001 	add	r1, r1, #1
348019e0:	eb007931 	bl	3481feac <__udivsi3>
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
348019e4:	e7e21254 	ubfx	r1, r4, #4, #3
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
	armclk = dout_apll / (arm_ratio + 1);
348019e8:	e2811001 	add	r1, r1, #1
348019ec:	eb00792e 	bl	3481feac <__udivsi3>
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
	else
		return s5pc100_get_arm_clk();
}
348019f0:	e8bd8010 	pop	{r4, pc}
348019f4:	348285d0 	.word	0x348285d0

348019f8 <get_pwm_clk>:
}

/* s5pc1xx: return pwm clock frequency */
static unsigned long s5pc1xx_get_pwm_clk(void)
{
	if (cpu_is_s5pc110())
348019f8:	e59f3014 	ldr	r3, [pc, #20]	; 34801a14 <get_pwm_clk+0x1c>
348019fc:	e5932000 	ldr	r2, [r3]
34801a00:	e30c3110 	movw	r3, #49424	; 0xc110
34801a04:	e1520003 	cmp	r2, r3
34801a08:	1a000000 	bne	34801a10 <get_pwm_clk+0x18>
		return s5pc110_get_pclk();
34801a0c:	eaffffd1 	b	34801958 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
34801a10:	eaffffc4 	b	34801928 <s5pc100_get_pclk>
34801a14:	348285d0 	.word	0x348285d0

34801a18 <get_uart_clk>:
}

/* s5pc1xx: return uart clock frequency */
static unsigned long s5pc1xx_get_uart_clk(int dev_index)
{
	if (cpu_is_s5pc110())
34801a18:	e59f3014 	ldr	r3, [pc, #20]	; 34801a34 <get_uart_clk+0x1c>
34801a1c:	e5932000 	ldr	r2, [r3]
34801a20:	e30c3110 	movw	r3, #49424	; 0xc110
34801a24:	e1520003 	cmp	r2, r3
34801a28:	1a000000 	bne	34801a30 <get_uart_clk+0x18>
		return s5pc110_get_pclk();
34801a2c:	eaffffc9 	b	34801958 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
34801a30:	eaffffbc 	b	34801928 <s5pc100_get_pclk>
34801a34:	348285d0 	.word	0x348285d0

34801a38 <set_mmc_clk>:
}

void set_mmc_clk(int dev_index, unsigned int div)
{
	/* Do NOTHING */
}
34801a38:	e12fff1e 	bx	lr
34801a3c:	00000000 	andeq	r0, r0, r0

34801a40 <v7_outer_cache_enable>:

#include <linux/linkage.h>

#ifndef CONFIG_SYS_L2CACHE_OFF
ENTRY(v7_outer_cache_enable)
	push	{r0, r1, r2, lr}
34801a40:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34801a44:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	orr	r3, r3, #2
34801a48:	e3833002 	orr	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
34801a4c:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34801a50:	e8bd800e 	pop	{r1, r2, r3, pc}

34801a54 <v7_outer_cache_disable>:
ENDPROC(v7_outer_cache_enable)

ENTRY(v7_outer_cache_disable)
	push	{r0, r1, r2, lr}
34801a54:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34801a58:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	bic	r3, r3, #2
34801a5c:	e3c33002 	bic	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
34801a60:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34801a64:	e8bd800e 	pop	{r1, r2, r3, pc}
34801a68:	e320f000 	nop	{0}
34801a6c:	e320f000 	nop	{0}
34801a70:	e320f000 	nop	{0}
34801a74:	e320f000 	nop	{0}
34801a78:	e320f000 	nop	{0}
34801a7c:	e320f000 	nop	{0}

34801a80 <reset_cpu>:

#define S5PC100_SWRESET			0xE0200000
#define S5PC110_SWRESET			0xE0102000

ENTRY(reset_cpu)
	ldr	r1, =S5PC100_PRO_ID
34801a80:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	ldr	r2, [r1]
34801a84:	e5912000 	ldr	r2, [r1]
	ldr	r4, =0x00010000
34801a88:	e3a04801 	mov	r4, #65536	; 0x10000
	and	r4, r2, r4
34801a8c:	e0024004 	and	r4, r2, r4
	cmp	r4, #0
34801a90:	e3540000 	cmp	r4, #0
	bne	110f
34801a94:	1a000002 	bne	34801aa4 <reset_cpu+0x24>
	/* S5PC100 */
	ldr	r1, =S5PC100_SWRESET
34801a98:	e59f1014 	ldr	r1, [pc, #20]	; 34801ab4 <_loop_forever+0x4>
	ldr	r2, =0xC100
34801a9c:	e3a02cc1 	mov	r2, #49408	; 0xc100
	b	200f
34801aa0:	ea000001 	b	34801aac <reset_cpu+0x2c>
110:	/* S5PC110 */
	ldr	r1, =S5PC110_SWRESET
34801aa4:	e59f100c 	ldr	r1, [pc, #12]	; 34801ab8 <_loop_forever+0x8>
	mov	r2, #1
34801aa8:	e3a02001 	mov	r2, #1
200:
	str	r2, [r1]
34801aac:	e5812000 	str	r2, [r1]

34801ab0 <_loop_forever>:
_loop_forever:
	b	_loop_forever
34801ab0:	eafffffe 	b	34801ab0 <_loop_forever>
34801ab4:	e0200000 	.word	0xe0200000
34801ab8:	e0102000 	.word	0xe0102000

34801abc <init_func_i2c>:
	return (0);
}

#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
static int init_func_i2c(void)
{
34801abc:	e92d4008 	push	{r3, lr}
	puts("I2C:   ");
34801ac0:	e59f001c 	ldr	r0, [pc, #28]	; 34801ae4 <init_func_i2c+0x28>
34801ac4:	eb002031 	bl	34809b90 <puts>
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
34801ac8:	e3a010fe 	mov	r1, #254	; 0xfe
34801acc:	e30c0350 	movw	r0, #50000	; 0xc350
34801ad0:	eb003c2d 	bl	34810b8c <i2c_init>
	puts("ready\n");
34801ad4:	e59f000c 	ldr	r0, [pc, #12]	; 34801ae8 <init_func_i2c+0x2c>
34801ad8:	eb00202c 	bl	34809b90 <puts>
	return (0);
}
34801adc:	e3a00000 	mov	r0, #0
34801ae0:	e8bd8008 	pop	{r3, pc}
34801ae4:	34822b99 	.word	0x34822b99
34801ae8:	3482726b 	.word	0x3482726b

34801aec <display_banner>:
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
	return 0;
}

static int display_banner(void)
{
34801aec:	e92d4008 	push	{r3, lr}
	printf("\n\n%s\n\n", version_string);
34801af0:	e59f100c 	ldr	r1, [pc, #12]	; 34801b04 <display_banner+0x18>
34801af4:	e59f000c 	ldr	r0, [pc, #12]	; 34801b08 <display_banner+0x1c>
34801af8:	eb00202e 	bl	34809bb8 <printf>
	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

	return (0);
}
34801afc:	e3a00000 	mov	r0, #0
34801b00:	e8bd8008 	pop	{r3, pc}
34801b04:	34820544 	.word	0x34820544
34801b08:	34822ba1 	.word	0x34822ba1

34801b0c <init_baudrate>:
#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
#define CONFIG_BAUDRATE 115200
#endif

static int init_baudrate(void)
{
34801b0c:	e92d4010 	push	{r4, lr}
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
34801b10:	e3a0100a 	mov	r1, #10
34801b14:	e59f2014 	ldr	r2, [pc, #20]	; 34801b30 <init_baudrate+0x24>
34801b18:	e59f0014 	ldr	r0, [pc, #20]	; 34801b34 <init_baudrate+0x28>
34801b1c:	e1a04008 	mov	r4, r8
34801b20:	eb001951 	bl	3480806c <getenv_ulong>
34801b24:	e5840008 	str	r0, [r4, #8]
	return 0;
}
34801b28:	e3a00000 	mov	r0, #0
34801b2c:	e8bd8010 	pop	{r4, pc}
34801b30:	0001c200 	.word	0x0001c200
34801b34:	34822ba8 	.word	0x34822ba8

34801b38 <__coloured_LED_init>:
/************************************************************************
 * Coloured LED functionality
 ************************************************************************
 * May be supplied by boards if desired
 */
inline void __coloured_LED_init(void) {}
34801b38:	e12fff1e 	bx	lr

34801b3c <__red_led_on>:
void coloured_LED_init(void)
	__attribute__((weak, alias("__coloured_LED_init")));
inline void __red_led_on(void) {}
34801b3c:	e12fff1e 	bx	lr

34801b40 <__red_led_off>:
void red_led_on(void) __attribute__((weak, alias("__red_led_on")));
inline void __red_led_off(void) {}
34801b40:	e12fff1e 	bx	lr

34801b44 <__green_led_on>:
void red_led_off(void) __attribute__((weak, alias("__red_led_off")));
inline void __green_led_on(void) {}
34801b44:	e12fff1e 	bx	lr

34801b48 <__green_led_off>:
void green_led_on(void) __attribute__((weak, alias("__green_led_on")));
inline void __green_led_off(void) {}
34801b48:	e12fff1e 	bx	lr

34801b4c <__yellow_led_on>:
void green_led_off(void) __attribute__((weak, alias("__green_led_off")));
inline void __yellow_led_on(void) {}
34801b4c:	e12fff1e 	bx	lr

34801b50 <__yellow_led_off>:
void yellow_led_on(void) __attribute__((weak, alias("__yellow_led_on")));
inline void __yellow_led_off(void) {}
34801b50:	e12fff1e 	bx	lr

34801b54 <__blue_led_on>:
void yellow_led_off(void) __attribute__((weak, alias("__yellow_led_off")));
inline void __blue_led_on(void) {}
34801b54:	e12fff1e 	bx	lr

34801b58 <__blue_led_off>:
void blue_led_on(void) __attribute__((weak, alias("__blue_led_on")));
inline void __blue_led_off(void) {}
34801b58:	e12fff1e 	bx	lr

34801b5c <__dram_init_banksize>:

int print_cpuinfo(void);

void __dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
34801b5c:	e5982000 	ldr	r2, [r8]
34801b60:	e3a01202 	mov	r1, #536870912	; 0x20000000
34801b64:	e5821018 	str	r1, [r2, #24]
	gd->bd->bi_dram[0].size =  gd->ram_size;
34801b68:	e5982000 	ldr	r2, [r8]
34801b6c:	e5983038 	ldr	r3, [r8, #56]	; 0x38
34801b70:	e582301c 	str	r3, [r2, #28]
}
34801b74:	e12fff1e 	bx	lr

34801b78 <__arch_cpu_init>:
	__attribute__((weak, alias("__dram_init_banksize")));

int __arch_cpu_init(void)
{
	return 0;
}
34801b78:	e3a00000 	mov	r0, #0
34801b7c:	e12fff1e 	bx	lr

34801b80 <board_init_r>:
	ulong malloc_start;
#if !defined(CONFIG_SYS_NO_FLASH)
	ulong flash_size;
#endif

	gd = id;
34801b80:	e1a08000 	mov	r8, r0
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
34801b84:	e92d4008 	push	{r3, lr}
	ulong flash_size;
#endif

	gd = id;

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801b88:	e5983004 	ldr	r3, [r8, #4]
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
34801b8c:	e1a04001 	mov	r4, r1
	ulong flash_size;
#endif

	gd = id;

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801b90:	e3833001 	orr	r3, r3, #1
34801b94:	e5883004 	str	r3, [r8, #4]
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

	monitor_flash_len = _end_ofs;
34801b98:	e59f306c 	ldr	r3, [pc, #108]	; 34801c0c <board_init_r+0x8c>
34801b9c:	e5932000 	ldr	r2, [r3]
34801ba0:	e59f3068 	ldr	r3, [pc, #104]	; 34801c10 <board_init_r+0x90>
34801ba4:	e5832000 	str	r2, [r3]

	/* Enable caches */
	enable_caches();
34801ba8:	eb0001b2 	bl	34802278 <__enable_caches>

	debug("monitor flash len: %08lX\n", monitor_flash_len);
	board_init();	/* Setup chipselects */
34801bac:	ebfffc66 	bl	34800d4c <board_init>
	 */
#ifdef CONFIG_CLOCKS
	set_cpu_clk_info(); /* Setup clock information */
#endif
#ifdef CONFIG_SERIAL_MULTI
	serial_initialize();
34801bb0:	eb00351a 	bl	3480f020 <serial_initialize>
	post_output_backlog();
#endif

	/* The Malloc area is immediately below the monitor copy in DRAM */
	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
34801bb4:	e3a01706 	mov	r1, #1572864	; 0x180000
34801bb8:	e2440706 	sub	r0, r4, #1572864	; 0x180000
34801bbc:	eb0020ff 	bl	34809fc0 <mem_malloc_init>
	puts("NAND:  ");
	nand_init();		/* go init the NAND */
#endif

#if defined(CONFIG_CMD_ONENAND)
	onenand_init();
34801bc0:	eb004ade 	bl	34814740 <onenand_init>
#endif

#ifdef CONFIG_GENERIC_MMC
       puts("MMC:   ");
34801bc4:	e59f0048 	ldr	r0, [pc, #72]	; 34801c14 <board_init_r+0x94>
34801bc8:	eb001ff0 	bl	34809b90 <puts>
       mmc_initialize(gd->bd);
34801bcc:	e5980000 	ldr	r0, [r8]
34801bd0:	eb00449e 	bl	34812e50 <mmc_initialize>
	AT91F_DataflashInit();
	dataflash_print_info();
#endif

	/* initialize environment */
	env_relocate();
34801bd4:	eb002582 	bl	3480b1e4 <env_relocate>

#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
	arm_pci_init();
#endif

	stdio_init();	/* get the devices list going. */
34801bd8:	eb00358c 	bl	3480f210 <stdio_init>

	jumptable_init();
34801bdc:	eb00260c 	bl	3480b414 <jumptable_init>
#if defined(CONFIG_API)
	/* Initialize API */
	api_init();
#endif

	console_init_r();	/* fully init console as a device */
34801be0:	eb00208a 	bl	34809e10 <console_init_r>
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
34801be4:	e59f402c 	ldr	r4, [pc, #44]	; 34801c18 <board_init_r+0x98>
	/* miscellaneous platform dependent initialisations */
	misc_init_r();
#endif

	 /* set up exceptions */
	interrupt_init();
34801be8:	eb0000f6 	bl	34801fc8 <interrupt_init>
	/* enable exceptions */
	enable_interrupts();
34801bec:	eb0000fc 	bl	34801fe4 <enable_interrupts>
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
34801bf0:	e59f0024 	ldr	r0, [pc, #36]	; 34801c1c <board_init_r+0x9c>
34801bf4:	e3a01010 	mov	r1, #16
34801bf8:	e5942000 	ldr	r2, [r4]
34801bfc:	eb00191a 	bl	3480806c <getenv_ulong>
34801c00:	e5840000 	str	r0, [r4]
	}
#endif

	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;) {
		main_loop();
34801c04:	eb00335e 	bl	3480e984 <main_loop>
34801c08:	eafffffd 	b	34801c04 <board_init_r+0x84>
34801c0c:	34800050 	.word	0x34800050
34801c10:	34829ba8 	.word	0x34829ba8
34801c14:	34822bb1 	.word	0x34822bb1
34801c18:	34828780 	.word	0x34828780
34801c1c:	34822bb9 	.word	0x34822bb9

34801c20 <hang>:

	/* NOTREACHED - no way out of command loop except booting */
}

void hang(void)
{
34801c20:	e92d4008 	push	{r3, lr}
	puts("### ERROR ### Please RESET the board ###\n");
34801c24:	e59f0004 	ldr	r0, [pc, #4]	; 34801c30 <hang+0x10>
34801c28:	eb001fd8 	bl	34809b90 <puts>
34801c2c:	eafffffe 	b	34801c2c <hang+0xc>
34801c30:	34822bc2 	.word	0x34822bc2

34801c34 <board_init_f>:
	dram_init,		/* configure available RAM banks */
	NULL,
};

void board_init_f(ulong bootflag)
{
34801c34:	e92d4080 	push	{r7, lr}
#endif

	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
34801c38:	e3a08423 	mov	r8, #587202560	; 0x23000000
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));
34801c3c:	e3a01000 	mov	r1, #0
34801c40:	e3a02078 	mov	r2, #120	; 0x78
34801c44:	e1a00008 	mov	r0, r8
34801c48:	eb006b2b 	bl	3481c8fc <memset>

	gd->mon_len = _bss_end_ofs;
34801c4c:	e59f3100 	ldr	r3, [pc, #256]	; 34801d54 <board_init_f+0x120>
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801c50:	e59f0100 	ldr	r0, [pc, #256]	; 34801d58 <board_init_f+0x124>
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
34801c54:	e5933000 	ldr	r3, [r3]
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801c58:	e3a01010 	mov	r1, #16
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
34801c5c:	e588303c 	str	r3, [r8, #60]	; 0x3c
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);
34801c60:	e5982050 	ldr	r2, [r8, #80]	; 0x50
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
34801c64:	e1a04008 	mov	r4, r8
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801c68:	eb0018ff 	bl	3480806c <getenv_ulong>
34801c6c:	e5840050 	str	r0, [r4, #80]	; 0x50
34801c70:	e59f40e4 	ldr	r4, [pc, #228]	; 34801d5c <board_init_f+0x128>
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
34801c74:	ea000003 	b	34801c88 <board_init_f+0x54>
		if ((*init_fnc_ptr)() != 0) {
34801c78:	e12fff37 	blx	r7
34801c7c:	e3500000 	cmp	r0, #0
34801c80:	0a000000 	beq	34801c88 <board_init_f+0x54>
			hang ();
34801c84:	ebffffe5 	bl	34801c20 <hang>
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
34801c88:	e5b47004 	ldr	r7, [r4, #4]!
34801c8c:	e3570000 	cmp	r7, #0
34801c90:	1afffff8 	bne	34801c78 <board_init_f+0x44>
	 * get fixed.
	 */
	gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
#endif

	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
34801c94:	e5984038 	ldr	r4, [r8, #56]	; 0x38
	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
#endif /* CONFIG_PRAM */

#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	/* reserve TLB table */
	addr -= (4096 * 4);
34801c98:	e284457f 	add	r4, r4, #532676608	; 0x1fc00000
34801c9c:	e28449ff 	add	r4, r4, #4177920	; 0x3fc000

	/* round down to next 64 kB limit */
	addr &= ~(0x10000 - 1);
34801ca0:	e1a04824 	lsr	r4, r4, #16
34801ca4:	e1a04804 	lsl	r4, r4, #16

	gd->tlb_addr = addr;
34801ca8:	e588404c 	str	r4, [r8, #76]	; 0x4c

	/*
	 * reserve memory for U-Boot code, data & bss
	 * round down to next 4 kB limit
	 */
	addr -= gd->mon_len;
34801cac:	e598203c 	ldr	r2, [r8, #60]	; 0x3c
34801cb0:	e0624004 	rsb	r4, r2, r4
	addr &= ~(4096 - 1);
34801cb4:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
34801cb8:	e3c4400f 	bic	r4, r4, #15
			TOTAL_MALLOC_LEN >> 10, addr_sp);
	/*
	 * (permanently) allocate a Board Info struct
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof (bd_t);
34801cbc:	e2446706 	sub	r6, r4, #1572864	; 0x180000

#ifdef CONFIG_MACH_TYPE
	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
#endif

	addr_sp -= sizeof (gd_t);
34801cc0:	e24650a8 	sub	r5, r6, #168	; 0xa8
			TOTAL_MALLOC_LEN >> 10, addr_sp);
	/*
	 * (permanently) allocate a Board Info struct
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof (bd_t);
34801cc4:	e2462030 	sub	r2, r6, #48	; 0x30
	bd = (bd_t *) addr_sp;
	gd->bd = bd;
34801cc8:	e5882000 	str	r2, [r8]
	id = (gd_t *) addr_sp;
	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
			sizeof (gd_t), addr_sp);

	/* setup stackpointer for exeptions */
	gd->irq_sp = addr_sp;
34801ccc:	e5885040 	str	r5, [r8, #64]	; 0x40
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
34801cd0:	e5982000 	ldr	r2, [r8]
34801cd4:	e5983008 	ldr	r3, [r8, #8]
#endif
	/* leave 3 words for abort-stack    */
	addr_sp -= 12;

	/* 8-byte alignment for ABI compliance */
	addr_sp &= ~0x07;
34801cd8:	e24660b8 	sub	r6, r6, #184	; 0xb8
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
34801cdc:	e5823000 	str	r3, [r2]
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
34801ce0:	ebfffc2d 	bl	34800d9c <dram_init_banksize>
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
		size += gd->bd->bi_dram[i].size;
34801ce4:	e5981000 	ldr	r1, [r8]
34801ce8:	e5982000 	ldr	r2, [r8]
34801cec:	e5983000 	ldr	r3, [r8]
34801cf0:	e591a01c 	ldr	sl, [r1, #28]
34801cf4:	e5922024 	ldr	r2, [r2, #36]	; 0x24
34801cf8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
34801cfc:	e08aa002 	add	sl, sl, r2
34801d00:	e08aa003 	add	sl, sl, r3

	puts("DRAM:  ");
34801d04:	e59f0054 	ldr	r0, [pc, #84]	; 34801d60 <board_init_f+0x12c>
34801d08:	eb001fa0 	bl	34809b90 <puts>
	print_size(size, "\n");
34801d0c:	e1a0000a 	mov	r0, sl
34801d10:	e1a01007 	mov	r1, r7
34801d14:	e59f2048 	ldr	r2, [pc, #72]	; 34801d64 <board_init_f+0x130>
34801d18:	eb0063b1 	bl	3481abe4 <print_size>
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801d1c:	e59f3044 	ldr	r3, [pc, #68]	; 34801d68 <board_init_f+0x134>
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
34801d20:	e5884034 	str	r4, [r8, #52]	; 0x34
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801d24:	e5933000 	ldr	r3, [r3]
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
34801d28:	e1a01008 	mov	r1, r8
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801d2c:	e0633004 	rsb	r3, r3, r4
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
34801d30:	e5886044 	str	r6, [r8, #68]	; 0x44
	gd->reloc_off = addr - _TEXT_BASE;
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	memcpy(id, (void *)gd, sizeof(gd_t));
34801d34:	e3a02078 	mov	r2, #120	; 0x78
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
34801d38:	e5883048 	str	r3, [r8, #72]	; 0x48
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	memcpy(id, (void *)gd, sizeof(gd_t));
34801d3c:	e1a00005 	mov	r0, r5
34801d40:	eb006b11 	bl	3481c98c <memcpy>

	relocate_code(addr_sp, id, addr);
34801d44:	e1a00006 	mov	r0, r6
34801d48:	e1a01005 	mov	r1, r5
34801d4c:	e1a02004 	mov	r2, r4
34801d50:	ebfff8d5 	bl	348000ac <relocate_code>
34801d54:	3480004c 	.word	0x3480004c
34801d58:	34822bec 	.word	0x34822bec
34801d5c:	348285d4 	.word	0x348285d4
34801d60:	34822bfb 	.word	0x34822bfb
34801d64:	348264dd 	.word	0x348264dd
34801d68:	34800040 	.word	0x34800040

34801d6c <boot_prep_linux>:
}
#endif

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
{
34801d6c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34801d70:	e1a05000 	mov	r5, r0
#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv("bootargs");
34801d74:	e59f0144 	ldr	r0, [pc, #324]	; 34801ec0 <boot_prep_linux+0x154>
34801d78:	eb0018a0 	bl	34808000 <getenv>
	defined(CONFIG_CMDLINE_TAG) || \
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
		debug("using: ATAGS\n");
		setup_start_tag(gd->bd);
34801d7c:	e5983000 	ldr	r3, [r8]

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next (params);
34801d80:	e59f113c 	ldr	r1, [pc, #316]	; 34801ec4 <boot_prep_linux+0x158>
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;
34801d84:	e5934008 	ldr	r4, [r3, #8]

	params->hdr.tag = ATAG_CORE;
34801d88:	e59f3138 	ldr	r3, [pc, #312]	; 34801ec8 <boot_prep_linux+0x15c>
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
34801d8c:	e3500000 	cmp	r0, #0
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;

	params->hdr.tag = ATAG_CORE;
34801d90:	e5843004 	str	r3, [r4, #4]
	params->hdr.size = tag_size (tag_core);
34801d94:	e3a03005 	mov	r3, #5
34801d98:	e5843000 	str	r3, [r4]

	params->u.core.flags = 0;
34801d9c:	e3a03000 	mov	r3, #0
34801da0:	e5843008 	str	r3, [r4, #8]
	params->u.core.pagesize = 0;
34801da4:	e584300c 	str	r3, [r4, #12]
	params->u.core.rootdev = 0;
34801da8:	e5843010 	str	r3, [r4, #16]

	params = tag_next (params);
34801dac:	e2843014 	add	r3, r4, #20
34801db0:	e5813000 	str	r3, [r1]
		setup_start_tag(gd->bd);
#ifdef CONFIG_SERIAL_TAG
		setup_serial_tag(&params);
#endif
#ifdef CONFIG_CMDLINE_TAG
		setup_commandline_tag(gd->bd, commandline);
34801db4:	e5982000 	ldr	r2, [r8]
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
34801db8:	0a000015 	beq	34801e14 <boot_prep_linux+0xa8>
34801dbc:	e1a06000 	mov	r6, r0
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);
34801dc0:	e4d02001 	ldrb	r2, [r0], #1
34801dc4:	e3520020 	cmp	r2, #32
34801dc8:	0afffffb 	beq	34801dbc <boot_prep_linux+0x50>

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
34801dcc:	e3520000 	cmp	r2, #0
34801dd0:	0a00000f 	beq	34801e14 <boot_prep_linux+0xa8>
		return;

	params->hdr.tag = ATAG_CMDLINE;
34801dd4:	e59f20f0 	ldr	r2, [pc, #240]	; 34801ecc <boot_prep_linux+0x160>
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801dd8:	e1a00006 	mov	r0, r6
	 * use its default command line.
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
34801ddc:	e5832004 	str	r2, [r3, #4]
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801de0:	eb006a25 	bl	3481c67c <strlen>
34801de4:	e280000d 	add	r0, r0, #13
34801de8:	e1a00120 	lsr	r0, r0, #2
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
	params->hdr.size =
34801dec:	e5840014 	str	r0, [r4, #20]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);
34801df0:	e59f40cc 	ldr	r4, [pc, #204]	; 34801ec4 <boot_prep_linux+0x158>
34801df4:	e1a01006 	mov	r1, r6
34801df8:	e5940000 	ldr	r0, [r4]
34801dfc:	e2800008 	add	r0, r0, #8
34801e00:	eb0069b8 	bl	3481c4e8 <strcpy>

	params = tag_next (params);
34801e04:	e5943000 	ldr	r3, [r4]
34801e08:	e5932000 	ldr	r2, [r3]
34801e0c:	e0833102 	add	r3, r3, r2, lsl #2
34801e10:	e5843000 	str	r3, [r4]
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801e14:	e59f30a8 	ldr	r3, [pc, #168]	; 34801ec4 <boot_prep_linux+0x158>
34801e18:	e5981000 	ldr	r1, [r8]
34801e1c:	e5932000 	ldr	r2, [r3]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801e20:	e59f40a8 	ldr	r4, [pc, #168]	; 34801ed0 <boot_prep_linux+0x164>
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801e24:	e1a00008 	mov	r0, r8
	return 0;
}
#endif

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
34801e28:	e2823010 	add	r3, r2, #16
34801e2c:	e3a0c003 	mov	ip, #3
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);
34801e30:	e3a06004 	mov	r6, #4

		params->u.mem.start = bd->bi_dram[i].start;
34801e34:	e5917018 	ldr	r7, [r1, #24]
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
34801e38:	e25cc001 	subs	ip, ip, #1
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
34801e3c:	e5037004 	str	r7, [r3, #-4]
		params->u.mem.size = bd->bi_dram[i].size;
34801e40:	e591701c 	ldr	r7, [r1, #28]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801e44:	e503400c 	str	r4, [r3, #-12]
		params->hdr.size = tag_size (tag_mem32);
34801e48:	e5036010 	str	r6, [r3, #-16]

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;
34801e4c:	e5037008 	str	r7, [r3, #-8]
34801e50:	e2811008 	add	r1, r1, #8
34801e54:	e2833010 	add	r3, r3, #16
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
34801e58:	1afffff5 	bne	34801e34 <boot_prep_linux+0xc8>
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801e5c:	e5951064 	ldr	r1, [r5, #100]	; 0x64
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
34801e60:	e59fc05c 	ldr	ip, [pc, #92]	; 34801ec4 <boot_prep_linux+0x158>
34801e64:	e2823030 	add	r3, r2, #48	; 0x30
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801e68:	e3510000 	cmp	r1, #0
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
34801e6c:	e58c3000 	str	r3, [ip]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801e70:	0a00000b 	beq	34801ea4 <boot_prep_linux+0x138>
34801e74:	e5954068 	ldr	r4, [r5, #104]	; 0x68
34801e78:	e3540000 	cmp	r4, #0
34801e7c:	0a000008 	beq	34801ea4 <boot_prep_linux+0x138>
			setup_initrd_tag(gd->bd, images->rd_start,
34801e80:	e5905000 	ldr	r5, [r0]
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801e84:	e59f5048 	ldr	r5, [pc, #72]	; 34801ed4 <boot_prep_linux+0x168>
	params->hdr.size = tag_size (tag_initrd);
34801e88:	e5826030 	str	r6, [r2, #48]	; 0x30

	params->u.initrd.start = initrd_start;
34801e8c:	e5831008 	str	r1, [r3, #8]
	params->u.initrd.size = initrd_end - initrd_start;

	params = tag_next (params);
34801e90:	e2822040 	add	r2, r2, #64	; 0x40
	 */
	params->hdr.tag = ATAG_INITRD2;
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;
34801e94:	e0611004 	rsb	r1, r1, r4
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801e98:	e5835004 	str	r5, [r3, #4]
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;
34801e9c:	e583100c 	str	r1, [r3, #12]

	params = tag_next (params);
34801ea0:	e58c2000 	str	r2, [ip]
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
			setup_initrd_tag(gd->bd, images->rd_start,
			images->rd_end);
#endif
		setup_end_tag(gd->bd);
34801ea4:	e5903000 	ldr	r3, [r0]
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_end_tag(bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
34801ea8:	e59f3014 	ldr	r3, [pc, #20]	; 34801ec4 <boot_prep_linux+0x158>
34801eac:	e3a02000 	mov	r2, #0
34801eb0:	e5933000 	ldr	r3, [r3]
34801eb4:	e5832004 	str	r2, [r3, #4]
	params->hdr.size = 0;
34801eb8:	e5832000 	str	r2, [r3]
#else /* all tags */
		printf("FDT and ATAGS support not compiled in - hanging\n");
		hang();
#endif /* all tags */
	}
}
34801ebc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34801ec0:	34822c03 	.word	0x34822c03
34801ec4:	34829bac 	.word	0x34829bac
34801ec8:	54410001 	.word	0x54410001
34801ecc:	54410009 	.word	0x54410009
34801ed0:	54410002 	.word	0x54410002
34801ed4:	54420005 	.word	0x54420005

34801ed8 <boot_jump_linux.clone.5>:

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801ed8:	e92d4013 	push	{r0, r1, r4, lr}
{
	unsigned long machid = gd->bd->bi_arch_number;
34801edc:	e5983000 	ldr	r3, [r8]
#endif /* all tags */
	}
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801ee0:	e1a04000 	mov	r4, r0
{
	unsigned long machid = gd->bd->bi_arch_number;
34801ee4:	e5933004 	ldr	r3, [r3, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801ee8:	e59f0050 	ldr	r0, [pc, #80]	; 34801f40 <boot_jump_linux.clone.5+0x68>
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
{
	unsigned long machid = gd->bd->bi_arch_number;
34801eec:	e58d3004 	str	r3, [sp, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801ef0:	eb001842 	bl	34808000 <getenv>
	if (s) {
34801ef4:	e3500000 	cmp	r0, #0
34801ef8:	0a000005 	beq	34801f14 <boot_jump_linux.clone.5+0x3c>
		strict_strtoul(s, 16, &machid);
34801efc:	e3a01010 	mov	r1, #16
34801f00:	e28d2004 	add	r2, sp, #4
34801f04:	eb006d9a 	bl	3481d574 <strict_strtoul>
		printf("Using machid 0x%lx from environment\n", machid);
34801f08:	e59f0034 	ldr	r0, [pc, #52]	; 34801f44 <boot_jump_linux.clone.5+0x6c>
34801f0c:	e59d1004 	ldr	r1, [sp, #4]
34801f10:	eb001f28 	bl	34809bb8 <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34801f14:	e3a0000f 	mov	r0, #15
34801f18:	eb00301a 	bl	3480df88 <__show_boot_progress>
}
#endif

static void announce_and_cleanup(void)
{
	printf("\nStarting kernel ...\n\n");
34801f1c:	e59f0024 	ldr	r0, [pc, #36]	; 34801f48 <boot_jump_linux.clone.5+0x70>
34801f20:	eb001f24 	bl	34809bb8 <printf>
#endif

#ifdef CONFIG_USB_DEVICE
	udc_disconnect();
#endif
	cleanup_before_linux();
34801f24:	ebfffc9e 	bl	348011a4 <cleanup_before_linux>
#ifdef CONFIG_OF_LIBFDT
	if (images->ft_len)
		r2 = (unsigned long)images->ft_addr;
	else
#endif
		r2 = gd->bd->bi_boot_params;
34801f28:	e5983000 	ldr	r3, [r8]

	kernel_entry(0, machid, r2);
34801f2c:	e3a00000 	mov	r0, #0
34801f30:	e59d1004 	ldr	r1, [sp, #4]
34801f34:	e5932008 	ldr	r2, [r3, #8]
34801f38:	e12fff34 	blx	r4
}
34801f3c:	e8bd801c 	pop	{r2, r3, r4, pc}
34801f40:	34822c0c 	.word	0x34822c0c
34801f44:	34822c13 	.word	0x34822c13
34801f48:	34822c38 	.word	0x34822c38

34801f4c <arch_lmb_reserve>:
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801f4c:	e598c000 	ldr	ip, [r8]
34801f50:	e5983000 	ldr	r3, [r8]

static ulong get_sp(void)
{
	ulong ret;

	asm("mov %0, sp" : "=r"(ret) : );
34801f54:	e1a0100d 	mov	r1, sp
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801f58:	e593201c 	ldr	r2, [r3, #28]
34801f5c:	e59c3018 	ldr	r3, [ip, #24]
	 */
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
34801f60:	e2411a01 	sub	r1, r1, #4096	; 0x1000
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801f64:	e0822003 	add	r2, r2, r3
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
34801f68:	e0612002 	rsb	r2, r1, r2
34801f6c:	ea006879 	b	3481c158 <lmb_reserve>

34801f70 <do_bootm_linux>:
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
34801f70:	e92d4070 	push	{r4, r5, r6, lr}
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801f74:	e2105030 	ands	r5, r0, #48	; 0x30
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
34801f78:	e1a04003 	mov	r4, r3
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
		return -1;
34801f7c:	13e05000 	mvnne	r5, #0
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801f80:	1a00000e 	bne	34801fc0 <do_bootm_linux+0x50>
		return -1;

	if (flag & BOOTM_STATE_OS_PREP) {
34801f84:	e2106040 	ands	r6, r0, #64	; 0x40
34801f88:	0a000002 	beq	34801f98 <do_bootm_linux+0x28>
		boot_prep_linux(images);
34801f8c:	e1a00003 	mov	r0, r3
34801f90:	ebffff75 	bl	34801d6c <boot_prep_linux>
		return 0;
34801f94:	ea000009 	b	34801fc0 <do_bootm_linux+0x50>
	}

	if (flag & BOOTM_STATE_OS_GO) {
34801f98:	e2105080 	ands	r5, r0, #128	; 0x80
34801f9c:	0a000003 	beq	34801fb0 <do_bootm_linux+0x40>
		boot_jump_linux(images);
34801fa0:	e5930060 	ldr	r0, [r3, #96]	; 0x60
34801fa4:	ebffffcb 	bl	34801ed8 <boot_jump_linux.clone.5>
		return 0;
34801fa8:	e1a05006 	mov	r5, r6
34801fac:	ea000003 	b	34801fc0 <do_bootm_linux+0x50>
	}

	boot_prep_linux(images);
34801fb0:	e1a00003 	mov	r0, r3
34801fb4:	ebffff6c 	bl	34801d6c <boot_prep_linux>
	boot_jump_linux(images);
34801fb8:	e5940060 	ldr	r0, [r4, #96]	; 0x60
34801fbc:	ebffffc5 	bl	34801ed8 <boot_jump_linux.clone.5>
	return 0;
}
34801fc0:	e1a00005 	mov	r0, r5
34801fc4:	e8bd8070 	pop	{r4, r5, r6, pc}

34801fc8 <interrupt_init>:
int interrupt_init (void)
{
	/*
	 * setup up stacks if necessary
	 */
	IRQ_STACK_START_IN = gd->irq_sp + 8;
34801fc8:	e5982040 	ldr	r2, [r8, #64]	; 0x40
34801fcc:	e59f300c 	ldr	r3, [pc, #12]	; 34801fe0 <interrupt_init+0x18>
34801fd0:	e2822008 	add	r2, r2, #8
34801fd4:	e5832000 	str	r2, [r3]

	return 0;
}
34801fd8:	e3a00000 	mov	r0, #0
34801fdc:	e12fff1e 	bx	lr
34801fe0:	34800054 	.word	0x34800054

34801fe4 <enable_interrupts>:

void enable_interrupts (void)
{
	return;
}
34801fe4:	e12fff1e 	bx	lr

34801fe8 <disable_interrupts>:
int disable_interrupts (void)
{
	return 0;
}
34801fe8:	e3a00000 	mov	r0, #0
34801fec:	e12fff1e 	bx	lr

34801ff0 <bad_mode>:
#endif


void bad_mode (void)
{
34801ff0:	e92d4008 	push	{r3, lr}
	panic ("Resetting CPU ...\n");
34801ff4:	e59f0000 	ldr	r0, [pc, #0]	; 34801ffc <bad_mode+0xc>
34801ff8:	eb006de1 	bl	3481d784 <panic>
34801ffc:	34822c4f 	.word	0x34822c4f

34802000 <show_regs>:
	reset_cpu (0);
}

void show_regs (struct pt_regs *regs)
{
34802000:	e92d4070 	push	{r4, r5, r6, lr}
34802004:	e24dd088 	sub	sp, sp, #136	; 0x88
34802008:	e1a04000 	mov	r4, r0
	unsigned long flags;
	const char *processor_modes[] = {
3480200c:	e59f1104 	ldr	r1, [pc, #260]	; 34802118 <show_regs+0x118>
34802010:	e28d0008 	add	r0, sp, #8
34802014:	e3a02080 	mov	r2, #128	; 0x80
34802018:	eb006a5b 	bl	3481c98c <memcpy>
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
3480201c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34802020:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34802024:	e58d3000 	str	r3, [sp]
34802028:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3480202c:	e5942038 	ldr	r2, [r4, #56]	; 0x38
34802030:	e58d3004 	str	r3, [sp, #4]
34802034:	e59f00e0 	ldr	r0, [pc, #224]	; 3480211c <show_regs+0x11c>
34802038:	e5943034 	ldr	r3, [r4, #52]	; 0x34
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
3480203c:	e5945040 	ldr	r5, [r4, #64]	; 0x40

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
34802040:	eb001edc 	bl	34809bb8 <printf>
		"sp : %08lx  ip : %08lx	 fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
34802044:	e5941028 	ldr	r1, [r4, #40]	; 0x28
34802048:	e5942024 	ldr	r2, [r4, #36]	; 0x24
3480204c:	e5943020 	ldr	r3, [r4, #32]
34802050:	e59f00c8 	ldr	r0, [pc, #200]	; 34802120 <show_regs+0x120>
34802054:	eb001ed7 	bl	34809bb8 <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
34802058:	e5943010 	ldr	r3, [r4, #16]
3480205c:	e594101c 	ldr	r1, [r4, #28]
34802060:	e58d3000 	str	r3, [sp]
34802064:	e5942018 	ldr	r2, [r4, #24]
34802068:	e5943014 	ldr	r3, [r4, #20]
3480206c:	e59f00b0 	ldr	r0, [pc, #176]	; 34802124 <show_regs+0x124>
34802070:	eb001ed0 	bl	34809bb8 <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
34802074:	e5943000 	ldr	r3, [r4]
34802078:	e594100c 	ldr	r1, [r4, #12]
3480207c:	e58d3000 	str	r3, [sp]
34802080:	e5942008 	ldr	r2, [r4, #8]
34802084:	e5943004 	ldr	r3, [r4, #4]
34802088:	e59f0098 	ldr	r0, [pc, #152]	; 34802128 <show_regs+0x128>
3480208c:	eb001ec9 	bl	34809bb8 <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
34802090:	e3150101 	tst	r5, #1073741824	; 0x40000000
34802094:	03a0207a 	moveq	r2, #122	; 0x7a
34802098:	13a0205a 	movne	r2, #90	; 0x5a
3480209c:	e3150202 	tst	r5, #536870912	; 0x20000000
348020a0:	03a03063 	moveq	r3, #99	; 0x63
348020a4:	13a03043 	movne	r3, #67	; 0x43
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
348020a8:	e205620f 	and	r6, r5, #-268435456	; 0xf0000000
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
348020ac:	e3150201 	tst	r5, #268435456	; 0x10000000
348020b0:	03a01076 	moveq	r1, #118	; 0x76
348020b4:	13a01056 	movne	r1, #86	; 0x56
348020b8:	e3560000 	cmp	r6, #0
348020bc:	e58d1000 	str	r1, [sp]
348020c0:	e59f0064 	ldr	r0, [pc, #100]	; 3480212c <show_regs+0x12c>
348020c4:	a3a0106e 	movge	r1, #110	; 0x6e
348020c8:	b3a0104e 	movlt	r1, #78	; 0x4e
348020cc:	eb001eb9 	bl	34809bb8 <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
		interrupts_enabled (regs) ? "on" : "off",
348020d0:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
348020d4:	e59fc054 	ldr	ip, [pc, #84]	; 34802130 <show_regs+0x130>
348020d8:	e59f2054 	ldr	r2, [pc, #84]	; 34802134 <show_regs+0x134>
348020dc:	e3130080 	tst	r3, #128	; 0x80
348020e0:	01a0100c 	moveq	r1, ip
348020e4:	11a01002 	movne	r1, r2
348020e8:	e28d0088 	add	r0, sp, #136	; 0x88
348020ec:	e3130040 	tst	r3, #64	; 0x40
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
348020f0:	e203301f 	and	r3, r3, #31
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
348020f4:	e0803103 	add	r3, r0, r3, lsl #2
348020f8:	e59f0038 	ldr	r0, [pc, #56]	; 34802138 <show_regs+0x138>
348020fc:	01a0200c 	moveq	r2, ip
34802100:	e58d0000 	str	r0, [sp]
34802104:	e5133080 	ldr	r3, [r3, #-128]	; 0x80
34802108:	e59f002c 	ldr	r0, [pc, #44]	; 3480213c <show_regs+0x13c>
3480210c:	eb001ea9 	bl	34809bb8 <printf>
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
		thumb_mode (regs) ? " (T)" : "");
}
34802110:	e28dd088 	add	sp, sp, #136	; 0x88
34802114:	e8bd8070 	pop	{r4, r5, r6, pc}
34802118:	34820374 	.word	0x34820374
3480211c:	34822c62 	.word	0x34822c62
34802120:	34822ca7 	.word	0x34822ca7
34802124:	34822ccb 	.word	0x34822ccb
34802128:	34822cfb 	.word	0x34822cfb
3480212c:	34822d2b 	.word	0x34822d2b
34802130:	34828554 	.word	0x34828554
34802134:	34822f4d 	.word	0x34822f4d
34802138:	34824003 	.word	0x34824003
3480213c:	34822d3b 	.word	0x34822d3b

34802140 <do_undefined_instruction>:

void do_undefined_instruction (struct pt_regs *pt_regs)
{
34802140:	e92d4010 	push	{r4, lr}
34802144:	e1a04000 	mov	r4, r0
	printf ("undefined instruction\n");
34802148:	e59f0010 	ldr	r0, [pc, #16]	; 34802160 <do_undefined_instruction+0x20>
3480214c:	eb001e99 	bl	34809bb8 <printf>
	show_regs (pt_regs);
34802150:	e1a00004 	mov	r0, r4
34802154:	ebffffa9 	bl	34802000 <show_regs>
	bad_mode ();
}
34802158:	e8bd4010 	pop	{r4, lr}

void do_undefined_instruction (struct pt_regs *pt_regs)
{
	printf ("undefined instruction\n");
	show_regs (pt_regs);
	bad_mode ();
3480215c:	eaffffa3 	b	34801ff0 <bad_mode>
34802160:	34822d5a 	.word	0x34822d5a

34802164 <do_software_interrupt>:
}

void do_software_interrupt (struct pt_regs *pt_regs)
{
34802164:	e92d4010 	push	{r4, lr}
34802168:	e1a04000 	mov	r4, r0
	printf ("software interrupt\n");
3480216c:	e59f0010 	ldr	r0, [pc, #16]	; 34802184 <do_software_interrupt+0x20>
34802170:	eb001e90 	bl	34809bb8 <printf>
	show_regs (pt_regs);
34802174:	e1a00004 	mov	r0, r4
34802178:	ebffffa0 	bl	34802000 <show_regs>
	bad_mode ();
}
3480217c:	e8bd4010 	pop	{r4, lr}

void do_software_interrupt (struct pt_regs *pt_regs)
{
	printf ("software interrupt\n");
	show_regs (pt_regs);
	bad_mode ();
34802180:	eaffff9a 	b	34801ff0 <bad_mode>
34802184:	34822d71 	.word	0x34822d71

34802188 <do_prefetch_abort>:
}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
34802188:	e92d4010 	push	{r4, lr}
3480218c:	e1a04000 	mov	r4, r0
	printf ("prefetch abort\n");
34802190:	e59f0010 	ldr	r0, [pc, #16]	; 348021a8 <do_prefetch_abort+0x20>
34802194:	eb001e87 	bl	34809bb8 <printf>
	show_regs (pt_regs);
34802198:	e1a00004 	mov	r0, r4
3480219c:	ebffff97 	bl	34802000 <show_regs>
	bad_mode ();
}
348021a0:	e8bd4010 	pop	{r4, lr}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
	printf ("prefetch abort\n");
	show_regs (pt_regs);
	bad_mode ();
348021a4:	eaffff91 	b	34801ff0 <bad_mode>
348021a8:	34822d85 	.word	0x34822d85

348021ac <do_data_abort>:
}

void do_data_abort (struct pt_regs *pt_regs)
{
348021ac:	e92d4010 	push	{r4, lr}
348021b0:	e1a04000 	mov	r4, r0
	printf ("data abort\n");
348021b4:	e59f0010 	ldr	r0, [pc, #16]	; 348021cc <do_data_abort+0x20>
348021b8:	eb001e7e 	bl	34809bb8 <printf>
	show_regs (pt_regs);
348021bc:	e1a00004 	mov	r0, r4
348021c0:	ebffff8e 	bl	34802000 <show_regs>
	bad_mode ();
}
348021c4:	e8bd4010 	pop	{r4, lr}

void do_data_abort (struct pt_regs *pt_regs)
{
	printf ("data abort\n");
	show_regs (pt_regs);
	bad_mode ();
348021c8:	eaffff88 	b	34801ff0 <bad_mode>
348021cc:	34822d95 	.word	0x34822d95

348021d0 <do_not_used>:
}

void do_not_used (struct pt_regs *pt_regs)
{
348021d0:	e92d4010 	push	{r4, lr}
348021d4:	e1a04000 	mov	r4, r0
	printf ("not used\n");
348021d8:	e59f0010 	ldr	r0, [pc, #16]	; 348021f0 <do_not_used+0x20>
348021dc:	eb001e75 	bl	34809bb8 <printf>
	show_regs (pt_regs);
348021e0:	e1a00004 	mov	r0, r4
348021e4:	ebffff85 	bl	34802000 <show_regs>
	bad_mode ();
}
348021e8:	e8bd4010 	pop	{r4, lr}

void do_not_used (struct pt_regs *pt_regs)
{
	printf ("not used\n");
	show_regs (pt_regs);
	bad_mode ();
348021ec:	eaffff7f 	b	34801ff0 <bad_mode>
348021f0:	34822da1 	.word	0x34822da1

348021f4 <do_fiq>:
}

void do_fiq (struct pt_regs *pt_regs)
{
348021f4:	e92d4010 	push	{r4, lr}
348021f8:	e1a04000 	mov	r4, r0
	printf ("fast interrupt request\n");
348021fc:	e59f0010 	ldr	r0, [pc, #16]	; 34802214 <do_fiq+0x20>
34802200:	eb001e6c 	bl	34809bb8 <printf>
	show_regs (pt_regs);
34802204:	e1a00004 	mov	r0, r4
34802208:	ebffff7c 	bl	34802000 <show_regs>
	bad_mode ();
}
3480220c:	e8bd4010 	pop	{r4, lr}

void do_fiq (struct pt_regs *pt_regs)
{
	printf ("fast interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
34802210:	eaffff76 	b	34801ff0 <bad_mode>
34802214:	34822dab 	.word	0x34822dab

34802218 <do_irq>:
}

#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
34802218:	e92d4010 	push	{r4, lr}
3480221c:	e1a04000 	mov	r4, r0
	printf ("interrupt request\n");
34802220:	e59f0010 	ldr	r0, [pc, #16]	; 34802238 <do_irq+0x20>
34802224:	eb001e63 	bl	34809bb8 <printf>
	show_regs (pt_regs);
34802228:	e1a00004 	mov	r0, r4
3480222c:	ebffff73 	bl	34802000 <show_regs>
	bad_mode ();
}
34802230:	e8bd4010 	pop	{r4, lr}
#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
	printf ("interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
34802234:	eaffff6d 	b	34801ff0 <bad_mode>
34802238:	34822db0 	.word	0x34822db0

3480223c <do_reset>:
 */

#include <common.h>

int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480223c:	e92d4008 	push	{r3, lr}
	puts ("resetting ...\n");
34802240:	e59f001c 	ldr	r0, [pc, #28]	; 34802264 <do_reset+0x28>
34802244:	eb001e51 	bl	34809b90 <puts>

	udelay (50000);				/* wait 50 ms */
34802248:	e30c0350 	movw	r0, #50000	; 0xc350
3480224c:	eb006a59 	bl	3481cbb8 <udelay>

	disable_interrupts();
34802250:	ebffff64 	bl	34801fe8 <disable_interrupts>
	reset_cpu(0);
34802254:	e3a00000 	mov	r0, #0
34802258:	ebfffe08 	bl	34801a80 <reset_cpu>

	/*NOTREACHED*/
	return 0;
}
3480225c:	e3a00000 	mov	r0, #0
34802260:	e8bd8008 	pop	{r3, pc}
34802264:	34822eaf 	.word	0x34822eaf

34802268 <__flush_cache>:
	asm("0: mrc p15, 0, r15, c7, c10, 3\n\t" "bne 0b\n" : : : "memory");
	/* disable write buffer as well (page 2-22) */
	asm("mcr p15, 0, %0, c7, c10, 4" : : "r" (0));
#endif
	return;
}
34802268:	e12fff1e 	bx	lr

3480226c <__flush_dcache_all>:
 * Default implementation:
 * do a range flush for the entire range
 */
void	__flush_dcache_all(void)
{
	flush_cache(0, ~0);
3480226c:	e3a00000 	mov	r0, #0
34802270:	e3e01000 	mvn	r1, #0
34802274:	eafffbbb 	b	34801168 <flush_cache>

34802278 <__enable_caches>:
 * Default implementation of enable_caches()
 * Real implementation should be in platform code
 */
void __enable_caches(void)
{
	puts("WARNING: Caches not enabled\n");
34802278:	e59f0000 	ldr	r0, [pc, #0]	; 34802280 <__enable_caches+0x8>
3480227c:	ea001e43 	b	34809b90 <puts>
34802280:	34822ebe 	.word	0x34822ebe

34802284 <cp_delay>:
}
void arm_init_before_mmu(void)
	__attribute__((weak, alias("__arm_init_before_mmu")));

static void cp_delay (void)
{
34802284:	e24dd008 	sub	sp, sp, #8
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
34802288:	e3a03000 	mov	r3, #0
3480228c:	ea000002 	b	3480229c <cp_delay+0x18>
		nop();
34802290:	e1a00000 	nop			; (mov r0, r0)
static void cp_delay (void)
{
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
34802294:	e59d3004 	ldr	r3, [sp, #4]
34802298:	e2833001 	add	r3, r3, #1
3480229c:	e58d3004 	str	r3, [sp, #4]
348022a0:	e59d3004 	ldr	r3, [sp, #4]
348022a4:	e3530063 	cmp	r3, #99	; 0x63
348022a8:	dafffff8 	ble	34802290 <cp_delay+0xc>
		nop();
	asm volatile("" : : : "memory");
}
348022ac:	e28dd008 	add	sp, sp, #8
348022b0:	e12fff1e 	bx	lr

348022b4 <cache_enable>:
static void cache_enable(uint32_t cache_bit)
{
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
348022b4:	e3500004 	cmp	r0, #4
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
{
348022b8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348022bc:	e1a05000 	mov	r5, r0
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
348022c0:	1a00002b 	bne	34802374 <cache_enable+0xc0>
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
348022c4:	ee117f10 	mrc	15, 0, r7, cr1, cr0, {0}
348022c8:	e2177001 	ands	r7, r7, #1
348022cc:	1a000028 	bne	34802374 <cache_enable+0xc0>
}

/* to activate the MMU we need to set up virtual memory: use 1M areas */
static inline void mmu_setup(void)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
348022d0:	e598404c 	ldr	r4, [r8, #76]	; 0x4c
348022d4:	e1a06004 	mov	r6, r4
	int i;
	u32 reg;

	arm_init_before_mmu();
348022d8:	ebfffb98 	bl	34801140 <arm_init_before_mmu>
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
		page_table[i] = i << 20 | (3 << 10) | 0x12;
348022dc:	e1a03a07 	lsl	r3, r7, #20
348022e0:	e3833ec1 	orr	r3, r3, #3088	; 0xc10
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
348022e4:	e2877001 	add	r7, r7, #1
		page_table[i] = i << 20 | (3 << 10) | 0x12;
348022e8:	e3833002 	orr	r3, r3, #2
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
348022ec:	e3570a01 	cmp	r7, #4096	; 0x1000
		page_table[i] = i << 20 | (3 << 10) | 0x12;
348022f0:	e4843004 	str	r3, [r4], #4
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
348022f4:	1afffff8 	bne	348022dc <cache_enable+0x28>
	asm volatile("" : : : "memory");
}

static inline void dram_bank_mmu_setup(int bank)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
348022f8:	e1a01008 	mov	r1, r8
348022fc:	e3a02000 	mov	r2, #0
34802300:	e591004c 	ldr	r0, [r1, #76]	; 0x4c
	bd_t *bd = gd->bd;
34802304:	e591e000 	ldr	lr, [r1]
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
34802308:	e2824003 	add	r4, r2, #3
3480230c:	e79ec184 	ldr	ip, [lr, r4, lsl #3]
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
34802310:	e08ee184 	add	lr, lr, r4, lsl #3
34802314:	e59ee004 	ldr	lr, [lr, #4]
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
34802318:	e1a03a2c 	lsr	r3, ip, #20
{
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
3480231c:	e2400004 	sub	r0, r0, #4
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
34802320:	e08cc00e 	add	ip, ip, lr
34802324:	e1a0ca2c 	lsr	ip, ip, #20
34802328:	e0800103 	add	r0, r0, r3, lsl #2
3480232c:	ea000004 	b	34802344 <cache_enable+0x90>
	     i++) {
		page_table[i] = i << 20 | (3 << 10) | CACHE_SETUP;
34802330:	e1a0ea03 	lsl	lr, r3, #20
34802334:	e38eeec1 	orr	lr, lr, #3088	; 0xc10
34802338:	e38ee00e 	orr	lr, lr, #14
3480233c:	e5a0e004 	str	lr, [r0, #4]!
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
	     i++) {
34802340:	e2833001 	add	r3, r3, #1
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
34802344:	e153000c 	cmp	r3, ip
34802348:	3afffff8 	bcc	34802330 <cache_enable+0x7c>
	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
		page_table[i] = i << 20 | (3 << 10) | 0x12;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
3480234c:	e2822001 	add	r2, r2, #1
34802350:	e3520003 	cmp	r2, #3
34802354:	1affffe9 	bne	34802300 <cache_enable+0x4c>
		dram_bank_mmu_setup(i);
	}

	/* Copy the page table address to cp15 */
	asm volatile("mcr p15, 0, %0, c2, c0, 0"
34802358:	ee026f10 	mcr	15, 0, r6, cr2, cr0, {0}
		     : : "r" (page_table) : "memory");
	/* Set the access control to all-supervisor */
	asm volatile("mcr p15, 0, %0, c3, c0, 0"
3480235c:	e3e03000 	mvn	r3, #0
34802360:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}
		     : : "r" (~0));
	/* and enable the mmu */
	reg = get_cr();	/* get control reg. */
	cp_delay();
34802364:	ebffffc6 	bl	34802284 <cp_delay>
34802368:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg | CR_M);
3480236c:	e3844001 	orr	r4, r4, #1
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34802370:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34802374:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
		mmu_setup();
	reg = get_cr();	/* get control reg. */
	cp_delay();
34802378:	ebffffc1 	bl	34802284 <cp_delay>
	set_cr(reg | cache_bit);
3480237c:	e1845005 	orr	r5, r4, r5
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34802380:	ee015f10 	mcr	15, 0, r5, cr1, cr0, {0}
}
34802384:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34802388 <cache_disable>:

/* cache_bit must be either CR_I or CR_C */
static void cache_disable(uint32_t cache_bit)
{
34802388:	e92d4038 	push	{r3, r4, r5, lr}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
3480238c:	ee115f10 	mrc	15, 0, r5, cr1, cr0, {0}
34802390:	e1a04000 	mov	r4, r0
	uint32_t reg;

	reg = get_cr();
	cp_delay();
34802394:	ebffffba 	bl	34802284 <cp_delay>

	if (cache_bit == CR_C) {
34802398:	e3540004 	cmp	r4, #4
3480239c:	1a000003 	bne	348023b0 <cache_disable+0x28>
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
348023a0:	e3150004 	tst	r5, #4
348023a4:	08bd8038 	popeq	{r3, r4, r5, pc}
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
		flush_dcache_all();
348023a8:	ebfffb4d 	bl	348010e4 <flush_dcache_all>
	if (cache_bit == CR_C) {
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
348023ac:	e2844001 	add	r4, r4, #1
		flush_dcache_all();
	}
	set_cr(reg & ~cache_bit);
348023b0:	e1c54004 	bic	r4, r5, r4
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
348023b4:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	  : : "r" (val) : "cc");
	isb();
348023b8:	e8bd8038 	pop	{r3, r4, r5, pc}

348023bc <__arm_init_before_mmu>:

DECLARE_GLOBAL_DATA_PTR;

void __arm_init_before_mmu(void)
{
}
348023bc:	e12fff1e 	bx	lr

348023c0 <icache_enable>:
	return 0;					/* always off */
}
#else
void icache_enable(void)
{
	cache_enable(CR_I);
348023c0:	e3a00a01 	mov	r0, #4096	; 0x1000
348023c4:	eaffffba 	b	348022b4 <cache_enable>

348023c8 <icache_disable>:
}

void icache_disable(void)
{
	cache_disable(CR_I);
348023c8:	e3a00a01 	mov	r0, #4096	; 0x1000
348023cc:	eaffffed 	b	34802388 <cache_disable>

348023d0 <icache_status>:
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
348023d0:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int icache_status(void)
{
	return (get_cr() & CR_I) != 0;
}
348023d4:	e7e00650 	ubfx	r0, r0, #12, #1
348023d8:	e12fff1e 	bx	lr

348023dc <dcache_enable>:
	return 0;					/* always off */
}
#else
void dcache_enable(void)
{
	cache_enable(CR_C);
348023dc:	e3a00004 	mov	r0, #4
348023e0:	eaffffb3 	b	348022b4 <cache_enable>

348023e4 <dcache_disable>:
}

void dcache_disable(void)
{
	cache_disable(CR_C);
348023e4:	e3a00004 	mov	r0, #4
348023e8:	eaffffe6 	b	34802388 <cache_disable>

348023ec <dcache_status>:
348023ec:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int dcache_status(void)
{
	return (get_cr() & CR_C) != 0;
}
348023f0:	e7e00150 	ubfx	r0, r0, #2, #1
348023f4:	e12fff1e 	bx	lr

348023f8 <do_bdinfo>:
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348023f8:	e92d4070 	push	{r4, r5, r6, lr}
	int i;
	bd_t *bd = gd->bd;
348023fc:	e5984000 	ldr	r4, [r8]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802400:	e59f10d4 	ldr	r1, [pc, #212]	; 348024dc <do_bdinfo+0xe4>
34802404:	e5942004 	ldr	r2, [r4, #4]
34802408:	e59f00d0 	ldr	r0, [pc, #208]	; 348024e0 <do_bdinfo+0xe8>
3480240c:	eb001de9 	bl	34809bb8 <printf>
34802410:	e59f00c8 	ldr	r0, [pc, #200]	; 348024e0 <do_bdinfo+0xe8>
34802414:	e59f10c8 	ldr	r1, [pc, #200]	; 348024e4 <do_bdinfo+0xec>
34802418:	e5942008 	ldr	r2, [r4, #8]
3480241c:	eb001de5 	bl	34809bb8 <printf>
34802420:	e1a06004 	mov	r6, r4
	bd_t *bd = gd->bd;

	print_num("arch_number",	bd->bi_arch_number);
	print_num("boot_params",	(ulong)bd->bi_boot_params);

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
34802424:	e3a05000 	mov	r5, #0
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802428:	e1a02005 	mov	r2, r5
3480242c:	e59f10b4 	ldr	r1, [pc, #180]	; 348024e8 <do_bdinfo+0xf0>
34802430:	e59f00a8 	ldr	r0, [pc, #168]	; 348024e0 <do_bdinfo+0xe8>
34802434:	eb001ddf 	bl	34809bb8 <printf>
34802438:	e5962018 	ldr	r2, [r6, #24]
3480243c:	e59f10a8 	ldr	r1, [pc, #168]	; 348024ec <do_bdinfo+0xf4>
34802440:	e59f0098 	ldr	r0, [pc, #152]	; 348024e0 <do_bdinfo+0xe8>
34802444:	eb001ddb 	bl	34809bb8 <printf>
	bd_t *bd = gd->bd;

	print_num("arch_number",	bd->bi_arch_number);
	print_num("boot_params",	(ulong)bd->bi_boot_params);

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
34802448:	e2855001 	add	r5, r5, #1
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480244c:	e596201c 	ldr	r2, [r6, #28]
34802450:	e59f0088 	ldr	r0, [pc, #136]	; 348024e0 <do_bdinfo+0xe8>
34802454:	e59f1094 	ldr	r1, [pc, #148]	; 348024f0 <do_bdinfo+0xf8>
34802458:	eb001dd6 	bl	34809bb8 <printf>
	bd_t *bd = gd->bd;

	print_num("arch_number",	bd->bi_arch_number);
	print_num("boot_params",	(ulong)bd->bi_boot_params);

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
3480245c:	e3550003 	cmp	r5, #3
34802460:	e2866008 	add	r6, r6, #8
34802464:	1affffef 	bne	34802428 <do_bdinfo+0x30>

#if defined(CONFIG_CMD_NET)
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
34802468:	e5941000 	ldr	r1, [r4]
3480246c:	e59f0080 	ldr	r0, [pc, #128]	; 348024f4 <do_bdinfo+0xfc>
34802470:	eb001dd0 	bl	34809bb8 <printf>
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802474:	e59f107c 	ldr	r1, [pc, #124]	; 348024f8 <do_bdinfo+0x100>
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
34802478:	e598204c 	ldr	r2, [r8, #76]	; 0x4c
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480247c:	e59f005c 	ldr	r0, [pc, #92]	; 348024e0 <do_bdinfo+0xe8>
34802480:	eb001dcc 	bl	34809bb8 <printf>
34802484:	e59f1070 	ldr	r1, [pc, #112]	; 348024fc <do_bdinfo+0x104>
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
34802488:	e5982034 	ldr	r2, [r8, #52]	; 0x34
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480248c:	e59f004c 	ldr	r0, [pc, #76]	; 348024e0 <do_bdinfo+0xe8>
34802490:	eb001dc8 	bl	34809bb8 <printf>
34802494:	e59f1064 	ldr	r1, [pc, #100]	; 34802500 <do_bdinfo+0x108>
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
34802498:	e5982048 	ldr	r2, [r8, #72]	; 0x48
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480249c:	e59f003c 	ldr	r0, [pc, #60]	; 348024e0 <do_bdinfo+0xe8>
348024a0:	eb001dc4 	bl	34809bb8 <printf>
348024a4:	e59f1058 	ldr	r1, [pc, #88]	; 34802504 <do_bdinfo+0x10c>
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
348024a8:	e5982040 	ldr	r2, [r8, #64]	; 0x40
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348024ac:	e59f002c 	ldr	r0, [pc, #44]	; 348024e0 <do_bdinfo+0xe8>
348024b0:	eb001dc0 	bl	34809bb8 <printf>
348024b4:	e59f104c 	ldr	r1, [pc, #76]	; 34802508 <do_bdinfo+0x110>
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
348024b8:	e5982044 	ldr	r2, [r8, #68]	; 0x44
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348024bc:	e59f001c 	ldr	r0, [pc, #28]	; 348024e0 <do_bdinfo+0xe8>
348024c0:	eb001dbc 	bl	34809bb8 <printf>
348024c4:	e59f1040 	ldr	r1, [pc, #64]	; 3480250c <do_bdinfo+0x114>
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
	print_num("FB base  ", gd->fb_base);
348024c8:	e5982018 	ldr	r2, [r8, #24]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348024cc:	e59f000c 	ldr	r0, [pc, #12]	; 348024e0 <do_bdinfo+0xe8>
348024d0:	eb001db8 	bl	34809bb8 <printf>
	printf("ARM frequency = %ld MHz\n", gd->bd->bi_arm_freq);
	printf("DSP frequency = %ld MHz\n", gd->bd->bi_dsp_freq);
	printf("DDR frequency = %ld MHz\n", gd->bd->bi_ddr_freq);
#endif
	return 0;
}
348024d4:	e3a00000 	mov	r0, #0
348024d8:	e8bd8070 	pop	{r4, r5, r6, pc}
348024dc:	34822eeb 	.word	0x34822eeb
348024e0:	34822edb 	.word	0x34822edb
348024e4:	34822ef7 	.word	0x34822ef7
348024e8:	34822f03 	.word	0x34822f03
348024ec:	34822f0d 	.word	0x34822f0d
348024f0:	34822f16 	.word	0x34822f16
348024f4:	34822f1e 	.word	0x34822f1e
348024f8:	34822f34 	.word	0x34822f34
348024fc:	34822f3d 	.word	0x34822f3d
34802500:	34822f47 	.word	0x34822f47
34802504:	34822f51 	.word	0x34822f51
34802508:	34822f58 	.word	0x34822f58
3480250c:	34822f62 	.word	0x34822f62

34802510 <do_go_exec>:
#ifdef CONFIG_CMD_GO

/* Allow ports to override the default behavior */
__attribute__((weak))
unsigned long do_go_exec (ulong (*entry)(int, char * const []), int argc, char * const argv[])
{
34802510:	e92d4008 	push	{r3, lr}
34802514:	e1a03000 	mov	r3, r0
	return entry (argc, argv);
34802518:	e1a00001 	mov	r0, r1
3480251c:	e1a01002 	mov	r1, r2
34802520:	e12fff33 	blx	r3
}
34802524:	e8bd8008 	pop	{r3, pc}

34802528 <do_go>:
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
34802528:	e3520001 	cmp	r2, #1
{
	return entry (argc, argv);
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480252c:	e92d4070 	push	{r4, r5, r6, lr}
34802530:	e1a04002 	mov	r4, r2
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
		return CMD_RET_USAGE;
34802534:	d3e04000 	mvnle	r4, #0
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
34802538:	da000011 	ble	34802584 <do_go+0x5c>
		return CMD_RET_USAGE;

	addr = simple_strtoul(argv[1], NULL, 16);
3480253c:	e5930004 	ldr	r0, [r3, #4]
34802540:	e3a02010 	mov	r2, #16
34802544:	e3a01000 	mov	r1, #0
34802548:	e2835004 	add	r5, r3, #4
3480254c:	eb006bdd 	bl	3481d4c8 <simple_strtoul>
34802550:	e1a06000 	mov	r6, r0

	printf ("## Starting application at 0x%08lX ...\n", addr);
34802554:	e1a01006 	mov	r1, r6
34802558:	e59f002c 	ldr	r0, [pc, #44]	; 3480258c <do_go+0x64>
3480255c:	eb001d95 	bl	34809bb8 <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
34802560:	e2441001 	sub	r1, r4, #1
34802564:	e1a00006 	mov	r0, r6
34802568:	e1a02005 	mov	r2, r5
3480256c:	ebffffe7 	bl	34802510 <do_go_exec>
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;
34802570:	e1a01000 	mov	r1, r0
34802574:	e2504000 	subs	r4, r0, #0
34802578:	13a04001 	movne	r4, #1
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
	if (rc != 0) rcode = 1;

	printf ("## Application terminated, rc = 0x%lX\n", rc);
3480257c:	e59f000c 	ldr	r0, [pc, #12]	; 34802590 <do_go+0x68>
34802580:	eb001d8c 	bl	34809bb8 <printf>
	return rcode;
}
34802584:	e1a00004 	mov	r0, r4
34802588:	e8bd8070 	pop	{r4, r5, r6, pc}
3480258c:	34822f8e 	.word	0x34822f8e
34802590:	34822fb6 	.word	0x34822fb6

34802594 <__fswab32>:
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
}
34802594:	e6bf0f30 	rev	r0, r0
34802598:	e12fff1e 	bx	lr

3480259c <do_bootd>:
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480259c:	e92d4010 	push	{r4, lr}
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
348025a0:	e59f0014 	ldr	r0, [pc, #20]	; 348025bc <do_bootd+0x20>
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348025a4:	e1a04001 	mov	r4, r1
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
348025a8:	eb001694 	bl	34808000 <getenv>
348025ac:	e1a01004 	mov	r1, r4
348025b0:	eb0030da 	bl	3480e920 <run_command>
		rcode = 1;
	return rcode;
}
348025b4:	e1a00fa0 	lsr	r0, r0, #31
348025b8:	e8bd8010 	pop	{r4, pc}
348025bc:	3482307d 	.word	0x3482307d

348025c0 <do_bootm_rtems>:
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
348025c0:	e3500080 	cmp	r0, #128	; 0x80
348025c4:	13500000 	cmpne	r0, #0
#endif /* CONFIG_LYNXKDI */

#ifdef CONFIG_BOOTM_RTEMS
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
348025c8:	e92d4010 	push	{r4, lr}
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
348025cc:	1a000007 	bne	348025f0 <do_bootm_rtems+0x30>
		fit_unsupported_reset("RTEMS");
		return 1;
	}
#endif

	entry_point = (void (*)(bd_t *))images->ep;
348025d0:	e5934060 	ldr	r4, [r3, #96]	; 0x60

	printf("## Transferring control to RTEMS (at address %08lx) ...\n",
348025d4:	e59f001c 	ldr	r0, [pc, #28]	; 348025f8 <do_bootm_rtems+0x38>
348025d8:	e1a01004 	mov	r1, r4
348025dc:	eb001d75 	bl	34809bb8 <printf>
348025e0:	e3a0000f 	mov	r0, #15
348025e4:	eb002e67 	bl	3480df88 <__show_boot_progress>

	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);
348025e8:	e5980000 	ldr	r0, [r8]
348025ec:	e12fff34 	blx	r4

	return 1;
}
348025f0:	e3a00001 	mov	r0, #1
348025f4:	e8bd8010 	pop	{r4, pc}
348025f8:	34823085 	.word	0x34823085

348025fc <do_bootm_netbsd>:
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
348025fc:	e3500080 	cmp	r0, #128	; 0x80
34802600:	13500000 	cmpne	r0, #0
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
			    bootm_headers_t *images)
{
34802604:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34802608:	e1a05001 	mov	r5, r1
3480260c:	e1a07002 	mov	r7, r2
34802610:	e1a04003 	mov	r4, r3
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34802614:	03a00000 	moveq	r0, #0
34802618:	13a00001 	movne	r0, #1
3480261c:	1a00003e 	bne	3480271c <do_bootm_netbsd+0x120>
	if (!images->legacy_hdr_valid) {
		fit_unsupported_reset("NetBSD");
		return 1;
	}
#endif
	hdr = images->legacy_hdr_os;
34802620:	e5936000 	ldr	r6, [r3]
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
34802624:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
34802628:	e3530004 	cmp	r3, #4
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
3480262c:	11a06000 	movne	r6, r0
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
34802630:	1a000007 	bne	34802654 <do_bootm_netbsd+0x58>
		image_multi_getimg(hdr, 1, &kernel_data, &kernel_len);
34802634:	e1a00006 	mov	r0, r6
34802638:	e28d3008 	add	r3, sp, #8
3480263c:	e3a01001 	mov	r1, #1
34802640:	e28d200c 	add	r2, sp, #12
34802644:	eb002be9 	bl	3480d5f0 <image_multi_getimg>
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
34802648:	e59d3008 	ldr	r3, [sp, #8]
3480264c:	e3530000 	cmp	r3, #0
34802650:	03a06000 	moveq	r6, #0
	consdev = "scc2";
#elif defined(CONFIG_8xx_CONS_SCC3)
	consdev = "scc3";
#endif

	if (argc > 2) {
34802654:	e3550002 	cmp	r5, #2
34802658:	da00001f 	ble	348026dc <do_bootm_netbsd+0xe0>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
3480265c:	e287b004 	add	fp, r7, #4
34802660:	e3a09002 	mov	r9, #2
34802664:	e3a0a000 	mov	sl, #0
	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
34802668:	e5bb0004 	ldr	r0, [fp, #4]!
3480266c:	eb006802 	bl	3481c67c <strlen>

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802670:	e2899001 	add	r9, r9, #1
			len += strlen(argv[i]) + 1;
34802674:	e080a00a 	add	sl, r0, sl

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802678:	e1590005 	cmp	r9, r5
			len += strlen(argv[i]) + 1;
3480267c:	e28aa001 	add	sl, sl, #1

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802680:	bafffff8 	blt	34802668 <do_bootm_netbsd+0x6c>
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
34802684:	e1a0000a 	mov	r0, sl
34802688:	eb001f11 	bl	3480a2d4 <malloc>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
3480268c:	e2877008 	add	r7, r7, #8
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
34802690:	e1a0a000 	mov	sl, r0

		for (i = 2, len = 0; i < argc; i += 1) {
34802694:	e3a0b002 	mov	fp, #2
34802698:	e3a09000 	mov	r9, #0
			if (i > 2)
				cmdline[len++] = ' ';
3480269c:	e3a03020 	mov	r3, #32
348026a0:	ea000002 	b	348026b0 <do_bootm_netbsd+0xb4>
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
348026a4:	e0809009 	add	r9, r0, r9
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
			if (i > 2)
				cmdline[len++] = ' ';
348026a8:	e7ca3009 	strb	r3, [sl, r9]
348026ac:	e2899001 	add	r9, r9, #1
			strcpy(&cmdline[len], argv[i]);
348026b0:	e5971000 	ldr	r1, [r7]
348026b4:	e08a0009 	add	r0, sl, r9
348026b8:	e58d3004 	str	r3, [sp, #4]

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
348026bc:	e28bb001 	add	fp, fp, #1
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
348026c0:	eb006788 	bl	3481c4e8 <strcpy>
			len += strlen(argv[i]);
348026c4:	e4970004 	ldr	r0, [r7], #4
348026c8:	eb0067eb 	bl	3481c67c <strlen>

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
348026cc:	e15b0005 	cmp	fp, r5
348026d0:	e59d3004 	ldr	r3, [sp, #4]
348026d4:	bafffff2 	blt	348026a4 <do_bootm_netbsd+0xa8>
348026d8:	ea000004 	b	348026f0 <do_bootm_netbsd+0xf4>
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
		}
	} else if ((cmdline = getenv("bootargs")) == NULL) {
348026dc:	e59f0044 	ldr	r0, [pc, #68]	; 34802728 <do_bootm_netbsd+0x12c>
348026e0:	eb001646 	bl	34808000 <getenv>
		cmdline = "";
348026e4:	e3500000 	cmp	r0, #0
348026e8:	e59fa03c 	ldr	sl, [pc, #60]	; 3480272c <do_bootm_netbsd+0x130>
348026ec:	11a0a000 	movne	sl, r0
	}

	loader = (void (*)(bd_t *, image_header_t *, char *, char *))images->ep;
348026f0:	e5944060 	ldr	r4, [r4, #96]	; 0x60

	printf("## Transferring control to NetBSD stage-2 loader "
348026f4:	e59f0034 	ldr	r0, [pc, #52]	; 34802730 <do_bootm_netbsd+0x134>
348026f8:	e1a01004 	mov	r1, r4
348026fc:	eb001d2d 	bl	34809bb8 <printf>
34802700:	e3a0000f 	mov	r0, #15
34802704:	eb002e1f 	bl	3480df88 <__show_boot_progress>
	 *   r3: ptr to board info data
	 *   r4: image address
	 *   r5: console device
	 *   r6: boot args string
	 */
	(*loader)(gd->bd, os_hdr, consdev, cmdline);
34802708:	e1a01006 	mov	r1, r6
3480270c:	e5980000 	ldr	r0, [r8]
34802710:	e59f2014 	ldr	r2, [pc, #20]	; 3480272c <do_bootm_netbsd+0x130>
34802714:	e1a0300a 	mov	r3, sl
34802718:	e12fff34 	blx	r4

	return 1;
}
3480271c:	e3a00001 	mov	r0, #1
34802720:	e28dd010 	add	sp, sp, #16
34802724:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34802728:	34822c03 	.word	0x34822c03
3480272c:	34824003 	.word	0x34824003
34802730:	348230be 	.word	0x348230be

34802734 <image_check_magic.clone.9>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
34802734:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34802738:	ebffff95 	bl	34802594 <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
3480273c:	e59f300c 	ldr	r3, [pc, #12]	; 34802750 <image_check_magic.clone.9+0x1c>
34802740:	e1500003 	cmp	r0, r3
34802744:	13a00000 	movne	r0, #0
34802748:	03a00001 	moveq	r0, #1
3480274c:	e8bd8008 	pop	{r3, pc}
34802750:	27051956 	.word	0x27051956

34802754 <image_info>:
	}
	return rcode;
}

static int image_info(ulong addr)
{
34802754:	e92d4038 	push	{r3, r4, r5, lr}
34802758:	e1a04000 	mov	r4, r0
	void *hdr = (void *)addr;

	printf("\n## Checking Image at %08lx ...\n", addr);
3480275c:	e1a01004 	mov	r1, r4
34802760:	e59f0094 	ldr	r0, [pc, #148]	; 348027fc <image_info+0xa8>
34802764:	eb001d13 	bl	34809bb8 <printf>

	switch (genimg_get_format(hdr)) {
34802768:	e1a00004 	mov	r0, r4
3480276c:	eb002cb4 	bl	3480da44 <genimg_get_format>
34802770:	e3500001 	cmp	r0, #1
34802774:	e1a05000 	mov	r5, r0
34802778:	1a00001a 	bne	348027e8 <image_info+0x94>
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
3480277c:	e59f007c 	ldr	r0, [pc, #124]	; 34802800 <image_info+0xac>
34802780:	eb001d02 	bl	34809b90 <puts>
		if (!image_check_magic(hdr)) {
34802784:	e5940000 	ldr	r0, [r4]
34802788:	ebffffe9 	bl	34802734 <image_check_magic.clone.9>
3480278c:	e3500000 	cmp	r0, #0
			puts("   Bad Magic Number\n");
34802790:	059f006c 	ldreq	r0, [pc, #108]	; 34802804 <image_info+0xb0>
	printf("\n## Checking Image at %08lx ...\n", addr);

	switch (genimg_get_format(hdr)) {
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
		if (!image_check_magic(hdr)) {
34802794:	0a000004 	beq	348027ac <image_info+0x58>
			puts("   Bad Magic Number\n");
			return 1;
		}

		if (!image_check_hcrc(hdr)) {
34802798:	e1a00004 	mov	r0, r4
3480279c:	eb002b67 	bl	3480d540 <image_check_hcrc>
348027a0:	e3500000 	cmp	r0, #0
348027a4:	1a000002 	bne	348027b4 <image_info+0x60>
			puts("   Bad Header Checksum\n");
348027a8:	e59f0058 	ldr	r0, [pc, #88]	; 34802808 <image_info+0xb4>
348027ac:	eb001cf7 	bl	34809b90 <puts>
			return 1;
348027b0:	ea00000f 	b	348027f4 <image_info+0xa0>
		}

		image_print_contents(hdr);
348027b4:	e1a00004 	mov	r0, r4
348027b8:	eb002c18 	bl	3480d820 <image_print_contents>

		puts("   Verifying Checksum ... ");
348027bc:	e59f0048 	ldr	r0, [pc, #72]	; 3480280c <image_info+0xb8>
348027c0:	eb001cf2 	bl	34809b90 <puts>
		if (!image_check_dcrc(hdr)) {
348027c4:	e1a00004 	mov	r0, r4
348027c8:	eb002b70 	bl	3480d590 <image_check_dcrc>
348027cc:	e3500000 	cmp	r0, #0
			puts("   Bad Data CRC\n");
348027d0:	059f0038 	ldreq	r0, [pc, #56]	; 34802810 <image_info+0xbc>
		}

		image_print_contents(hdr);

		puts("   Verifying Checksum ... ");
		if (!image_check_dcrc(hdr)) {
348027d4:	0afffff4 	beq	348027ac <image_info+0x58>
			puts("   Bad Data CRC\n");
			return 1;
		}
		puts("OK\n");
348027d8:	e59f0034 	ldr	r0, [pc, #52]	; 34802814 <image_info+0xc0>
348027dc:	eb001ceb 	bl	34809b90 <puts>
		return 0;
348027e0:	e3a05000 	mov	r5, #0
348027e4:	ea000002 	b	348027f4 <image_info+0xa0>
		}

		return 0;
#endif
	default:
		puts("Unknown image format!\n");
348027e8:	e59f0028 	ldr	r0, [pc, #40]	; 34802818 <image_info+0xc4>
348027ec:	eb001ce7 	bl	34809b90 <puts>
		break;
	}

	return 1;
348027f0:	e3a05001 	mov	r5, #1
}
348027f4:	e1a00005 	mov	r0, r5
348027f8:	e8bd8038 	pop	{r3, r4, r5, pc}
348027fc:	34823107 	.word	0x34823107
34802800:	34823128 	.word	0x34823128
34802804:	3482313f 	.word	0x3482313f
34802808:	34823154 	.word	0x34823154
3480280c:	3482316c 	.word	0x3482316c
34802810:	34823187 	.word	0x34823187
34802814:	34823198 	.word	0x34823198
34802818:	3482319c 	.word	0x3482319c

3480281c <do_iminfo>:
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
3480281c:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* iminfo - print header info for a requested image */
/*******************************************************************/
#if defined(CONFIG_CMD_IMI)
int do_iminfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802820:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
34802824:	e1a04002 	mov	r4, r2
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
34802828:	c1a07003 	movgt	r7, r3
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
3480282c:	c3a05000 	movgt	r5, #0
34802830:	c3a06001 	movgt	r6, #1
34802834:	ca000003 	bgt	34802848 <do_iminfo+0x2c>
		return image_info(load_addr);
34802838:	e59f3038 	ldr	r3, [pc, #56]	; 34802878 <do_iminfo+0x5c>
3480283c:	e5930000 	ldr	r0, [r3]
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34802840:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
34802844:	eaffffc2 	b	34802754 <image_info>
	}

	for (arg = 1; arg < argc; ++arg) {
		addr = simple_strtoul(argv[arg], NULL, 16);
34802848:	e3a01000 	mov	r1, #0
3480284c:	e3a02010 	mov	r2, #16
34802850:	e5b70004 	ldr	r0, [r7, #4]!
34802854:	eb006b1b 	bl	3481d4c8 <simple_strtoul>
		if (image_info(addr) != 0)
34802858:	ebffffbd 	bl	34802754 <image_info>

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
3480285c:	e2866001 	add	r6, r6, #1
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
34802860:	e3500000 	cmp	r0, #0
34802864:	13a05001 	movne	r5, #1

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
34802868:	e1560004 	cmp	r6, r4
3480286c:	bafffff5 	blt	34802848 <do_iminfo+0x2c>
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34802870:	e1a00005 	mov	r0, r5
34802874:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
34802878:	34828780 	.word	0x34828780

3480287c <image_get_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
3480287c:	eaffff44 	b	34802594 <__fswab32>

34802880 <bootm_load_os.clone.18>:
}

#define BOOTM_ERR_RESET		-1
#define BOOTM_ERR_OVERLAP	-2
#define BOOTM_ERR_UNIMPLEMENTED	-3
static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
34802880:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
34802884:	e1a07000 	mov	r7, r0
34802888:	e5dd0030 	ldrb	r0, [sp, #48]	; 0x30
3480288c:	e1a09001 	mov	r9, r1
34802890:	e5dd602c 	ldrb	r6, [sp, #44]	; 0x2c
34802894:	e1a0a002 	mov	sl, r2
34802898:	e59d4028 	ldr	r4, [sp, #40]	; 0x28
3480289c:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
	uint8_t comp = os.comp;
	ulong load = os.load;
	ulong blob_start = os.start;
	ulong blob_end = os.end;
	ulong image_start = os.image_start;
	ulong image_len = os.image_len;
348028a0:	e58d3004 	str	r3, [sp, #4]
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
348028a4:	eb002bd1 	bl	3480d7f0 <genimg_get_type_name>

	switch (comp) {
348028a8:	e3560000 	cmp	r6, #0
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
348028ac:	e1a01000 	mov	r1, r0

	switch (comp) {
348028b0:	0a000002 	beq	348028c0 <bootm_load_os.clone.18+0x40>
348028b4:	e3560001 	cmp	r6, #1
348028b8:	1a00002a 	bne	34802968 <bootm_load_os.clone.18+0xe8>
348028bc:	ea000015 	b	34802918 <bootm_load_os.clone.18+0x98>
	case IH_COMP_NONE:
		if (load == blob_start || load == image_start) {
348028c0:	e1540007 	cmp	r4, r7
348028c4:	1154000a 	cmpne	r4, sl
348028c8:	13a06000 	movne	r6, #0
348028cc:	03a06001 	moveq	r6, #1
348028d0:	1a000003 	bne	348028e4 <bootm_load_os.clone.18+0x64>
			printf("   XIP %s ... ", type_name);
348028d4:	e59f00f8 	ldr	r0, [pc, #248]	; 348029d4 <bootm_load_os.clone.18+0x154>
348028d8:	eb001cb6 	bl	34809bb8 <printf>
			no_overlap = 1;
348028dc:	e3a06001 	mov	r6, #1
348028e0:	ea000006 	b	34802900 <bootm_load_os.clone.18+0x80>
		} else {
			printf("   Loading %s ... ", type_name);
348028e4:	e59f00ec 	ldr	r0, [pc, #236]	; 348029d8 <bootm_load_os.clone.18+0x158>
348028e8:	eb001cb2 	bl	34809bb8 <printf>
			memmove_wd((void *)load, (void *)image_start,
348028ec:	e1a00004 	mov	r0, r4
348028f0:	e1a0100a 	mov	r1, sl
348028f4:	e59d2004 	ldr	r2, [sp, #4]
348028f8:	e3a03801 	mov	r3, #65536	; 0x10000
348028fc:	eb002b95 	bl	3480d758 <memmove_wd>
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
34802900:	e59d3004 	ldr	r3, [sp, #4]
		puts("OK\n");
34802904:	e59f00d0 	ldr	r0, [pc, #208]	; 348029dc <bootm_load_os.clone.18+0x15c>
		} else {
			printf("   Loading %s ... ", type_name);
			memmove_wd((void *)load, (void *)image_start,
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
34802908:	e0843003 	add	r3, r4, r3
3480290c:	e5853000 	str	r3, [r5]
		puts("OK\n");
34802910:	eb001c9e 	bl	34809b90 <puts>
34802914:	ea000018 	b	3480297c <bootm_load_os.clone.18+0xfc>
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
34802918:	e59f00c0 	ldr	r0, [pc, #192]	; 348029e0 <bootm_load_os.clone.18+0x160>
3480291c:	eb001ca5 	bl	34809bb8 <printf>
		if (gunzip((void *)load, unc_len,
34802920:	e28d3004 	add	r3, sp, #4
34802924:	e1a00004 	mov	r0, r4
34802928:	e3a01502 	mov	r1, #8388608	; 0x800000
3480292c:	e1a0200a 	mov	r2, sl
34802930:	eb0061d9 	bl	3481b09c <gunzip>
34802934:	e2506000 	subs	r6, r0, #0
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
		}

		*load_end = load + image_len;
34802938:	059d3004 	ldreq	r3, [sp, #4]
3480293c:	00843003 	addeq	r3, r4, r3
34802940:	05853000 	streq	r3, [r5]
		puts("OK\n");
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
		if (gunzip((void *)load, unc_len,
34802944:	0a00000c 	beq	3480297c <bootm_load_os.clone.18+0xfc>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
34802948:	e59f0094 	ldr	r0, [pc, #148]	; 348029e4 <bootm_load_os.clone.18+0x164>
3480294c:	eb001c8f 	bl	34809b90 <puts>
				"error - must RESET board to recover\n");
			if (boot_progress)
34802950:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34802954:	e3530000 	cmp	r3, #0
34802958:	0a00001b 	beq	348029cc <bootm_load_os.clone.18+0x14c>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480295c:	e3e00005 	mvn	r0, #5
34802960:	eb002d88 	bl	3480df88 <__show_boot_progress>
34802964:	ea000018 	b	348029cc <bootm_load_os.clone.18+0x14c>

		*load_end = load + unc_len;
		break;
#endif /* CONFIG_LZO */
	default:
		printf("Unimplemented compression type %d\n", comp);
34802968:	e59f0078 	ldr	r0, [pc, #120]	; 348029e8 <bootm_load_os.clone.18+0x168>
3480296c:	e1a01006 	mov	r1, r6
34802970:	eb001c90 	bl	34809bb8 <printf>
		return BOOTM_ERR_UNIMPLEMENTED;
34802974:	e3e00002 	mvn	r0, #2
34802978:	ea000014 	b	348029d0 <bootm_load_os.clone.18+0x150>
	}

	flush_cache(load, (*load_end - load) * sizeof(ulong));
3480297c:	e5951000 	ldr	r1, [r5]
34802980:	e1a00004 	mov	r0, r4
34802984:	e0641001 	rsb	r1, r4, r1
34802988:	e1a01101 	lsl	r1, r1, #2
3480298c:	ebfff9f5 	bl	34801168 <flush_cache>

	puts("OK\n");
34802990:	e59f0044 	ldr	r0, [pc, #68]	; 348029dc <bootm_load_os.clone.18+0x15c>
34802994:	eb001c7d 	bl	34809b90 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802998:	e3a00007 	mov	r0, #7
3480299c:	eb002d79 	bl	3480df88 <__show_boot_progress>
	debug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);

	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
348029a0:	e2760001 	rsbs	r0, r6, #1
348029a4:	33a00000 	movcc	r0, #0
348029a8:	e1540009 	cmp	r4, r9
348029ac:	23a00000 	movcs	r0, #0
348029b0:	e3500000 	cmp	r0, #0
348029b4:	0a000005 	beq	348029d0 <bootm_load_os.clone.18+0x150>
348029b8:	e5953000 	ldr	r3, [r5]
348029bc:	e1530007 	cmp	r3, r7
			*load_end);

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
348029c0:	83e00001 	mvnhi	r0, #1
348029c4:	93a00000 	movls	r0, #0
348029c8:	ea000000 	b	348029d0 <bootm_load_os.clone.18+0x150>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
				"error - must RESET board to recover\n");
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
348029cc:	e3e00000 	mvn	r0, #0

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
}
348029d0:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
348029d4:	348231b3 	.word	0x348231b3
348029d8:	348231c2 	.word	0x348231c2
348029dc:	34823198 	.word	0x34823198
348029e0:	348231d5 	.word	0x348231d5
348029e4:	348231ee 	.word	0x348231ee
348029e8:	3482323f 	.word	0x3482323f

348029ec <bootm_start.clone.17>:
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
348029ec:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
348029f0:	e59f4358 	ldr	r4, [pc, #856]	; 34802d50 <bootm_start.clone.17+0x364>
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
348029f4:	e1a07001 	mov	r7, r1
348029f8:	e1a0a000 	mov	sl, r0
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
348029fc:	e3a01000 	mov	r1, #0
34802a00:	e1a00004 	mov	r0, r4
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34802a04:	e1a06002 	mov	r6, r2
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
34802a08:	e3a02f4b 	mov	r2, #300	; 0x12c
34802a0c:	eb0067ba 	bl	3481c8fc <memset>
	images.verify = getenv_yesno("verify");
34802a10:	e59f033c 	ldr	r0, [pc, #828]	; 34802d54 <bootm_start.clone.17+0x368>
34802a14:	eb002b16 	bl	3480d674 <getenv_yesno>
34802a18:	e5840084 	str	r0, [r4, #132]	; 0x84
static void boot_start_lmb(bootm_headers_t *images)
{
	ulong		mem_start;
	phys_size_t	mem_size;

	lmb_init(&images->lmb);
34802a1c:	e284008c 	add	r0, r4, #140	; 0x8c
34802a20:	eb006577 	bl	3481c004 <lmb_init>

	mem_start = getenv_bootm_low();
34802a24:	eb002b1c 	bl	3480d69c <getenv_bootm_low>
34802a28:	e1a05000 	mov	r5, r0
	mem_size = getenv_bootm_size();
34802a2c:	eb002b26 	bl	3480d6cc <getenv_bootm_size>

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34802a30:	e1a01005 	mov	r1, r5
	phys_size_t	mem_size;

	lmb_init(&images->lmb);

	mem_start = getenv_bootm_low();
	mem_size = getenv_bootm_size();
34802a34:	e1a02000 	mov	r2, r0

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34802a38:	e284008c 	add	r0, r4, #140	; 0x8c
34802a3c:	eb00657a 	bl	3481c02c <lmb_add>

	arch_lmb_reserve(&images->lmb);
34802a40:	e284008c 	add	r0, r4, #140	; 0x8c
34802a44:	ebfffd40 	bl	34801f4c <arch_lmb_reserve>
	board_lmb_reserve(&images->lmb);
34802a48:	e284008c 	add	r0, r4, #140	; 0x8c
34802a4c:	eb00664b 	bl	3481c380 <__board_lmb_reserve>
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
34802a50:	e3570001 	cmp	r7, #1
		img_addr = load_addr;
34802a54:	d59f32fc 	ldrle	r3, [pc, #764]	; 34802d58 <bootm_start.clone.17+0x36c>
34802a58:	d5934000 	ldrle	r4, [r3]
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
34802a5c:	da000004 	ble	34802a74 <bootm_start.clone.17+0x88>
							&fit_uname_kernel)) {
		debug("*  kernel: subimage '%s' from image at 0x%08lx\n",
				fit_uname_kernel, img_addr);
#endif
	} else {
		img_addr = simple_strtoul(argv[1], NULL, 16);
34802a60:	e5960004 	ldr	r0, [r6, #4]
34802a64:	e3a01000 	mov	r1, #0
34802a68:	e3a02010 	mov	r2, #16
34802a6c:	eb006a95 	bl	3481d4c8 <simple_strtoul>
34802a70:	e1a04000 	mov	r4, r0
34802a74:	e3a00001 	mov	r0, #1
34802a78:	eb002d42 	bl	3480df88 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
34802a7c:	e1a00004 	mov	r0, r4
34802a80:	eb002bf5 	bl	3480da5c <genimg_get_image>

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
34802a84:	e59fb2c4 	ldr	fp, [pc, #708]	; 34802d50 <bootm_start.clone.17+0x364>
34802a88:	e3a09000 	mov	r9, #0
34802a8c:	e58b9054 	str	r9, [fp, #84]	; 0x54
34802a90:	e58b9050 	str	r9, [fp, #80]	; 0x50
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
34802a94:	e1a04000 	mov	r4, r0

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
34802a98:	e1a05000 	mov	r5, r0
34802a9c:	eb002be8 	bl	3480da44 <genimg_get_format>
34802aa0:	e3500001 	cmp	r0, #1
34802aa4:	1a00005c 	bne	34802c1c <bootm_start.clone.17+0x230>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
34802aa8:	e1a01004 	mov	r1, r4
34802aac:	e59f02a8 	ldr	r0, [pc, #680]	; 34802d5c <bootm_start.clone.17+0x370>
34802ab0:	eb001c40 	bl	34809bb8 <printf>
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
34802ab4:	e5940000 	ldr	r0, [r4]
34802ab8:	ebffff1d 	bl	34802734 <image_check_magic.clone.9>
34802abc:	e3500000 	cmp	r0, #0
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
34802ac0:	e59b9084 	ldr	r9, [fp, #132]	; 0x84
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
34802ac4:	1a000003 	bne	34802ad8 <bootm_start.clone.17+0xec>
		puts("Bad Magic Number\n");
34802ac8:	e59f0290 	ldr	r0, [pc, #656]	; 34802d60 <bootm_start.clone.17+0x374>
34802acc:	eb001c2f 	bl	34809b90 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802ad0:	e3e00000 	mvn	r0, #0
34802ad4:	ea000023 	b	34802b68 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802ad8:	e3a00002 	mov	r0, #2
34802adc:	eb002d29 	bl	3480df88 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_MAGIC);
		return NULL;
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_HEADER);

	if (!image_check_hcrc(hdr)) {
34802ae0:	e1a00004 	mov	r0, r4
34802ae4:	eb002a95 	bl	3480d540 <image_check_hcrc>
34802ae8:	e3500000 	cmp	r0, #0
34802aec:	1a000003 	bne	34802b00 <bootm_start.clone.17+0x114>
		puts("Bad Header Checksum\n");
34802af0:	e59f026c 	ldr	r0, [pc, #620]	; 34802d64 <bootm_start.clone.17+0x378>
34802af4:	eb001c25 	bl	34809b90 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802af8:	e3e00001 	mvn	r0, #1
34802afc:	ea000019 	b	34802b68 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802b00:	e3a00003 	mov	r0, #3
34802b04:	eb002d1f 	bl	3480df88 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_HEADER);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_CHECKSUM);
	image_print_contents(hdr);
34802b08:	e1a00004 	mov	r0, r4
34802b0c:	eb002b43 	bl	3480d820 <image_print_contents>

	if (verify) {
34802b10:	e3590000 	cmp	r9, #0
34802b14:	0a00000b 	beq	34802b48 <bootm_start.clone.17+0x15c>
		puts("   Verifying Checksum ... ");
34802b18:	e59f0248 	ldr	r0, [pc, #584]	; 34802d68 <bootm_start.clone.17+0x37c>
34802b1c:	eb001c1b 	bl	34809b90 <puts>
		if (!image_check_dcrc(hdr)) {
34802b20:	e1a00004 	mov	r0, r4
34802b24:	eb002a99 	bl	3480d590 <image_check_dcrc>
34802b28:	e3500000 	cmp	r0, #0
34802b2c:	1a000003 	bne	34802b40 <bootm_start.clone.17+0x154>
			printf("Bad Data CRC\n");
34802b30:	e59f0234 	ldr	r0, [pc, #564]	; 34802d6c <bootm_start.clone.17+0x380>
34802b34:	eb001c1f 	bl	34809bb8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802b38:	e3e00002 	mvn	r0, #2
34802b3c:	ea000009 	b	34802b68 <bootm_start.clone.17+0x17c>
			bootstage_error(BOOTSTAGE_ID_CHECK_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
34802b40:	e59f0228 	ldr	r0, [pc, #552]	; 34802d70 <bootm_start.clone.17+0x384>
34802b44:	eb001c11 	bl	34809b90 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802b48:	e3a00004 	mov	r0, #4
34802b4c:	eb002d0d 	bl	3480df88 <__show_boot_progress>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802b50:	e5d4101d 	ldrb	r1, [r4, #29]
		}
		puts("OK\n");
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_ARCH);

	if (!image_check_target_arch(hdr)) {
34802b54:	e3510002 	cmp	r1, #2
34802b58:	0a000005 	beq	34802b74 <bootm_start.clone.17+0x188>
		printf("Unsupported Architecture 0x%x\n", image_get_arch(hdr));
34802b5c:	e59f0210 	ldr	r0, [pc, #528]	; 34802d74 <bootm_start.clone.17+0x388>
34802b60:	eb001c14 	bl	34809bb8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802b64:	e3e00003 	mvn	r0, #3
34802b68:	eb002d06 	bl	3480df88 <__show_boot_progress>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
		if (!hdr)
			return NULL;
34802b6c:	e3a05000 	mov	r5, #0
34802b70:	ea00002f 	b	34802c34 <bootm_start.clone.17+0x248>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802b74:	e3a00005 	mov	r0, #5
34802b78:	eb002d02 	bl	3480df88 <__show_boot_progress>
		bootstage_mark(BOOTSTAGE_ID_CHECK_IMAGETYPE);

		/* get os_data and os_len */
		switch (image_get_type(hdr)) {
34802b7c:	e5d4301e 	ldrb	r3, [r4, #30]
34802b80:	e3530002 	cmp	r3, #2
34802b84:	0a00000d 	beq	34802bc0 <bootm_start.clone.17+0x1d4>
34802b88:	8a000001 	bhi	34802b94 <bootm_start.clone.17+0x1a8>
34802b8c:	e3530001 	cmp	r3, #1
34802b90:	ea000002 	b	34802ba0 <bootm_start.clone.17+0x1b4>
34802b94:	e3530004 	cmp	r3, #4
34802b98:	0a000002 	beq	34802ba8 <bootm_start.clone.17+0x1bc>
34802b9c:	e353000e 	cmp	r3, #14
34802ba0:	1a00000d 	bne	34802bdc <bootm_start.clone.17+0x1f0>
34802ba4:	ea000005 	b	34802bc0 <bootm_start.clone.17+0x1d4>
		case IH_TYPE_KERNEL_NOLOAD:
			*os_data = image_get_data(hdr);
			*os_len = image_get_data_size(hdr);
			break;
		case IH_TYPE_MULTI:
			image_multi_getimg(hdr, 0, os_data, os_len);
34802ba8:	e59f21c8 	ldr	r2, [pc, #456]	; 34802d78 <bootm_start.clone.17+0x38c>
34802bac:	e1a00004 	mov	r0, r4
34802bb0:	e3a01000 	mov	r1, #0
34802bb4:	e2823004 	add	r3, r2, #4
34802bb8:	eb002a8c 	bl	3480d5f0 <image_multi_getimg>
34802bbc:	ea00000b 	b	34802bf0 <bootm_start.clone.17+0x204>
			break;
		case IH_TYPE_STANDALONE:
			*os_data = image_get_data(hdr);
34802bc0:	e59fa188 	ldr	sl, [pc, #392]	; 34802d50 <bootm_start.clone.17+0x364>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
34802bc4:	e2843040 	add	r3, r4, #64	; 0x40
	return (char *)hdr->ih_name;
}

static inline uint32_t image_get_data_size(const image_header_t *hdr)
{
	return image_get_size(hdr);
34802bc8:	e594000c 	ldr	r0, [r4, #12]
34802bcc:	e58a3050 	str	r3, [sl, #80]	; 0x50
34802bd0:	ebffff29 	bl	3480287c <image_get_size.clone.10>
			*os_len = image_get_data_size(hdr);
34802bd4:	e58a0054 	str	r0, [sl, #84]	; 0x54
34802bd8:	ea000004 	b	34802bf0 <bootm_start.clone.17+0x204>
			break;
		default:
			printf("Wrong Image Type for %s command\n",
34802bdc:	e59f0198 	ldr	r0, [pc, #408]	; 34802d7c <bootm_start.clone.17+0x390>
34802be0:	e59a1000 	ldr	r1, [sl]
34802be4:	eb001bf3 	bl	34809bb8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802be8:	e3e00004 	mvn	r0, #4
34802bec:	eaffffdd 	b	34802b68 <bootm_start.clone.17+0x17c>

		/*
		 * copy image header to allow for image overwrites during
		 * kernel decompression.
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
34802bf0:	e59fa158 	ldr	sl, [pc, #344]	; 34802d50 <bootm_start.clone.17+0x364>
34802bf4:	e1a01004 	mov	r1, r4
34802bf8:	e28a0004 	add	r0, sl, #4
34802bfc:	e3a02040 	mov	r2, #64	; 0x40
34802c00:	eb00677e 	bl	3481ca00 <memmove>
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;

		images->legacy_hdr_valid = 1;
34802c04:	e3a03001 	mov	r3, #1
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;
34802c08:	e58a4000 	str	r4, [sl]

		images->legacy_hdr_valid = 1;
34802c0c:	e58a3044 	str	r3, [sl, #68]	; 0x44
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802c10:	e3a00006 	mov	r0, #6
34802c14:	eb002cdb 	bl	3480df88 <__show_boot_progress>
34802c18:	ea000005 	b	34802c34 <bootm_start.clone.17+0x248>
		images->fit_uname_os = fit_uname_kernel;
		images->fit_noffset_os = os_noffset;
		break;
#endif
	default:
		printf("Wrong Image Format for %s command\n", cmdtp->name);
34802c1c:	e59a1000 	ldr	r1, [sl]
34802c20:	e59f0158 	ldr	r0, [pc, #344]	; 34802d80 <bootm_start.clone.17+0x394>
34802c24:	eb001be3 	bl	34809bb8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802c28:	e3e0006b 	mvn	r0, #107	; 0x6b
34802c2c:	eb002cd5 	bl	3480df88 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
		return NULL;
34802c30:	e1a05009 	mov	r5, r9
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
34802c34:	e59f4114 	ldr	r4, [pc, #276]	; 34802d50 <bootm_start.clone.17+0x364>
34802c38:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34802c3c:	e3530000 	cmp	r3, #0
		puts("ERROR: can't get kernel image!\n");
34802c40:	059f013c 	ldreq	r0, [pc, #316]	; 34802d84 <bootm_start.clone.17+0x398>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
34802c44:	0a000017 	beq	34802ca8 <bootm_start.clone.17+0x2bc>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
34802c48:	e1a00005 	mov	r0, r5
34802c4c:	eb002b7c 	bl	3480da44 <genimg_get_format>
34802c50:	e3500001 	cmp	r0, #1
34802c54:	e1a0b000 	mov	fp, r0
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
34802c58:	159f0128 	ldrne	r0, [pc, #296]	; 34802d88 <bootm_start.clone.17+0x39c>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
34802c5c:	1a000011 	bne	34802ca8 <bootm_start.clone.17+0x2bc>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802c60:	e5d5a01e 	ldrb	sl, [r5, #30]
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
34802c64:	e5c4a05d 	strb	sl, [r4, #93]	; 0x5d
		images.os.comp = image_get_comp(os_hdr);
34802c68:	e5d5301f 	ldrb	r3, [r5, #31]
34802c6c:	e5c4305c 	strb	r3, [r4, #92]	; 0x5c
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802c70:	e5d5901c 	ldrb	r9, [r5, #28]
	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);
34802c74:	e5c4905e 	strb	r9, [r4, #94]	; 0x5e
	return ((ulong)hdr + image_get_header_size());
}

static inline uint32_t image_get_image_size(const image_header_t *hdr)
{
	return (image_get_size(hdr) + image_get_header_size());
34802c78:	e595000c 	ldr	r0, [r5, #12]
34802c7c:	ebfffefe 	bl	3480287c <image_get_size.clone.10>
34802c80:	e2853040 	add	r3, r5, #64	; 0x40
}
static inline ulong image_get_image_end(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_image_size(hdr));
34802c84:	e0833000 	add	r3, r3, r0

		images.os.end = image_get_image_end(os_hdr);
34802c88:	e584304c 	str	r3, [r4, #76]	; 0x4c
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
34802c8c:	e5950010 	ldr	r0, [r5, #16]
34802c90:	ebfffe3f 	bl	34802594 <__fswab32>
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
34802c94:	e5943044 	ldr	r3, [r4, #68]	; 0x44
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);

		images.os.end = image_get_image_end(os_hdr);
		images.os.load = image_get_load(os_hdr);
34802c98:	e5840058 	str	r0, [r4, #88]	; 0x58
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
34802c9c:	e3530000 	cmp	r3, #0
34802ca0:	1a000003 	bne	34802cb4 <bootm_start.clone.17+0x2c8>
34802ca4:	ea000008 	b	34802ccc <bootm_start.clone.17+0x2e0>
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
34802ca8:	eb001bb8 	bl	34809b90 <puts>
		return 1;
34802cac:	e3a00001 	mov	r0, #1
34802cb0:	ea000025 	b	34802d4c <bootm_start.clone.17+0x360>
image_get_hdr_l(ep)		/* image_get_ep */
34802cb4:	e5940018 	ldr	r0, [r4, #24]
34802cb8:	ebfffe35 	bl	34802594 <__fswab32>
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802cbc:	e35a000e 	cmp	sl, #14
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
		images.ep = image_get_ep(&images.legacy_hdr_os_copy);
34802cc0:	e5840060 	str	r0, [r4, #96]	; 0x60
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802cc4:	1a000008 	bne	34802cec <bootm_start.clone.17+0x300>
34802cc8:	ea000003 	b	34802cdc <bootm_start.clone.17+0x2f0>
			puts("Can't get entry point property!\n");
			return 1;
		}
#endif
	} else {
		puts("Could not find kernel entry point!\n");
34802ccc:	e59f00b8 	ldr	r0, [pc, #184]	; 34802d8c <bootm_start.clone.17+0x3a0>
34802cd0:	eb001bae 	bl	34809b90 <puts>
		return 1;
34802cd4:	e1a0000b 	mov	r0, fp
34802cd8:	ea00001b 	b	34802d4c <bootm_start.clone.17+0x360>
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
		images.os.load = images.os.image_start;
34802cdc:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34802ce0:	e5843058 	str	r3, [r4, #88]	; 0x58
		images.ep += images.os.load;
34802ce4:	e0803003 	add	r3, r0, r3
34802ce8:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	if (((images.os.type == IH_TYPE_KERNEL) ||
34802cec:	e35a0002 	cmp	sl, #2
34802cf0:	135a000e 	cmpne	sl, #14
34802cf4:	0a000001 	beq	34802d00 <bootm_start.clone.17+0x314>
	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||
34802cf8:	e35a0004 	cmp	sl, #4
34802cfc:	1a00000d 	bne	34802d38 <bootm_start.clone.17+0x34c>
	     (images.os.type == IH_TYPE_MULTI)) &&
34802d00:	e3590005 	cmp	r9, #5
34802d04:	1a00000b 	bne	34802d38 <bootm_start.clone.17+0x34c>
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
34802d08:	e59f3080 	ldr	r3, [pc, #128]	; 34802d90 <bootm_start.clone.17+0x3a4>
34802d0c:	e1a00007 	mov	r0, r7
34802d10:	e58d3000 	str	r3, [sp]
34802d14:	e2833004 	add	r3, r3, #4
34802d18:	e58d3004 	str	r3, [sp, #4]
34802d1c:	e1a01006 	mov	r1, r6
34802d20:	e59f2028 	ldr	r2, [pc, #40]	; 34802d50 <bootm_start.clone.17+0x364>
34802d24:	e3a03002 	mov	r3, #2
34802d28:	eb002b4e 	bl	3480da68 <boot_get_ramdisk>
				&images.rd_start, &images.rd_end);
		if (ret) {
34802d2c:	e3500000 	cmp	r0, #0
			puts("Ramdisk image is corrupt or invalid\n");
34802d30:	159f005c 	ldrne	r0, [pc, #92]	; 34802d94 <bootm_start.clone.17+0x3a8>
	     (images.os.type == IH_TYPE_MULTI)) &&
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
				&images.rd_start, &images.rd_end);
		if (ret) {
34802d34:	1affffdb 	bne	34802ca8 <bootm_start.clone.17+0x2bc>

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
34802d38:	e59f3010 	ldr	r3, [pc, #16]	; 34802d50 <bootm_start.clone.17+0x364>
	images.state = BOOTM_STATE_START;
34802d3c:	e3a02001 	mov	r2, #1

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
34802d40:	e5835048 	str	r5, [r3, #72]	; 0x48
	images.state = BOOTM_STATE_START;
34802d44:	e5832088 	str	r2, [r3, #136]	; 0x88

	return 0;
34802d48:	e3a00000 	mov	r0, #0
}
34802d4c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34802d50:	34829bb0 	.word	0x34829bb0
34802d54:	34823262 	.word	0x34823262
34802d58:	34828780 	.word	0x34828780
34802d5c:	34823269 	.word	0x34823269
34802d60:	34823142 	.word	0x34823142
34802d64:	34823157 	.word	0x34823157
34802d68:	3482316c 	.word	0x3482316c
34802d6c:	3482318a 	.word	0x3482318a
34802d70:	34823198 	.word	0x34823198
34802d74:	3482329b 	.word	0x3482329b
34802d78:	34829c00 	.word	0x34829c00
34802d7c:	348232ba 	.word	0x348232ba
34802d80:	348232db 	.word	0x348232db
34802d84:	348232fe 	.word	0x348232fe
34802d88:	3482331e 	.word	0x3482331e
34802d8c:	34823341 	.word	0x34823341
34802d90:	34829c14 	.word	0x34829c14
34802d94:	34823365 	.word	0x34823365

34802d98 <__arch_preboot_os>:

/* Allow for arch specific config before we boot */
void __arch_preboot_os(void)
{
	/* please define platform specific arch_preboot_os() */
}
34802d98:	e12fff1e 	bx	lr

34802d9c <do_bootm_subcommand>:
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802d9c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802da0:	e59f1218 	ldr	r1, [pc, #536]	; 34802fc0 <do_bootm_subcommand+0x224>
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802da4:	e24dd030 	sub	sp, sp, #48	; 0x30
34802da8:	e1a04000 	mov	r4, r0
34802dac:	e1a05002 	mov	r5, r2
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802db0:	e5930004 	ldr	r0, [r3, #4]
34802db4:	e3a02007 	mov	r2, #7
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802db8:	e1a07003 	mov	r7, r3
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802dbc:	e2836004 	add	r6, r3, #4
34802dc0:	eb0019f4 	bl	34809598 <find_cmd_tbl>

	if (c) {
34802dc4:	e3500000 	cmp	r0, #0
34802dc8:	0a000076 	beq	34802fa8 <do_bootm_subcommand+0x20c>
		state = (long)c->cmd;
34802dcc:	e590a00c 	ldr	sl, [r0, #12]

		/* treat start special since it resets the state machine */
		if (state == BOOTM_STATE_START) {
34802dd0:	e35a0001 	cmp	sl, #1
34802dd4:	1a000005 	bne	34802df0 <do_bootm_subcommand+0x54>
			argc--;
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
34802dd8:	e2451001 	sub	r1, r5, #1
34802ddc:	e1a00004 	mov	r0, r4
34802de0:	e1a02006 	mov	r2, r6
34802de4:	ebffff00 	bl	348029ec <bootm_start.clone.17>
34802de8:	e1a05000 	mov	r5, r0
34802dec:	ea000070 	b	34802fb4 <do_bootm_subcommand+0x218>
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
	}

	if (images.state >= state) {
34802df0:	e59f41cc 	ldr	r4, [pc, #460]	; 34802fc4 <do_bootm_subcommand+0x228>
34802df4:	e5943088 	ldr	r3, [r4, #136]	; 0x88
34802df8:	e153000a 	cmp	r3, sl
34802dfc:	ba000002 	blt	34802e0c <do_bootm_subcommand+0x70>
		printf("Trying to execute a command out of order\n");
34802e00:	e59f01c0 	ldr	r0, [pc, #448]	; 34802fc8 <do_bootm_subcommand+0x22c>
34802e04:	eb001b6b 	bl	34809bb8 <printf>
34802e08:	ea000066 	b	34802fa8 <do_bootm_subcommand+0x20c>
		return CMD_RET_USAGE;
	}

	images.state |= state;
34802e0c:	e18a3003 	orr	r3, sl, r3
34802e10:	e5843088 	str	r3, [r4, #136]	; 0x88
	boot_fn = boot_os[images.os.os];
34802e14:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34802e18:	e59f31ac 	ldr	r3, [pc, #428]	; 34802fcc <do_bootm_subcommand+0x230>

	switch (state) {
34802e1c:	e35a0010 	cmp	sl, #16
		printf("Trying to execute a command out of order\n");
		return CMD_RET_USAGE;
	}

	images.state |= state;
	boot_fn = boot_os[images.os.os];
34802e20:	e7936102 	ldr	r6, [r3, r2, lsl #2]

	switch (state) {
34802e24:	0a00003b 	beq	34802f18 <do_bootm_subcommand+0x17c>
34802e28:	ca000004 	bgt	34802e40 <do_bootm_subcommand+0xa4>
34802e2c:	e35a0002 	cmp	sl, #2
34802e30:	0a000009 	beq	34802e5c <do_bootm_subcommand+0xc0>
34802e34:	e35a0004 	cmp	sl, #4
34802e38:	1a00005c 	bne	34802fb0 <do_bootm_subcommand+0x214>
34802e3c:	ea00001b 	b	34802eb0 <do_bootm_subcommand+0x114>
34802e40:	e35a0040 	cmp	sl, #64	; 0x40
34802e44:	0a000045 	beq	34802f60 <do_bootm_subcommand+0x1c4>
34802e48:	e35a0080 	cmp	sl, #128	; 0x80
34802e4c:	0a00004d 	beq	34802f88 <do_bootm_subcommand+0x1ec>
34802e50:	e35a0020 	cmp	sl, #32
34802e54:	1a000055 	bne	34802fb0 <do_bootm_subcommand+0x214>
34802e58:	ea000037 	b	34802f3c <do_bootm_subcommand+0x1a0>
		ulong load_end;
		case BOOTM_STATE_START:
			/* should never occur */
			break;
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
34802e5c:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34802e60:	e58d3000 	str	r3, [sp]
34802e64:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802e68:	e58d3004 	str	r3, [sp, #4]
34802e6c:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802e70:	e58d3008 	str	r3, [sp, #8]
34802e74:	e28d302c 	add	r3, sp, #44	; 0x2c
34802e78:	e58d300c 	str	r3, [sp, #12]
34802e7c:	e3a03000 	mov	r3, #0
34802e80:	e58d3010 	str	r3, [sp, #16]
34802e84:	e2840048 	add	r0, r4, #72	; 0x48
34802e88:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802e8c:	ebfffe7b 	bl	34802880 <bootm_load_os.clone.18>
			if (ret)
34802e90:	e2505000 	subs	r5, r0, #0
34802e94:	1a000046 	bne	34802fb4 <do_bootm_subcommand+0x218>
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
					(load_end - images.os.load));
34802e98:	e5941058 	ldr	r1, [r4, #88]	; 0x58
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
			if (ret)
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
34802e9c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34802ea0:	e284008c 	add	r0, r4, #140	; 0x8c
34802ea4:	e0612002 	rsb	r2, r1, r2
34802ea8:	eb0064aa 	bl	3481c158 <lmb_reserve>
					(load_end - images.os.load));
			break;
34802eac:	ea000040 	b	34802fb4 <do_bootm_subcommand+0x218>
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		case BOOTM_STATE_RAMDISK:
		{
			ulong rd_len = images.rd_end - images.rd_start;
34802eb0:	e5941064 	ldr	r1, [r4, #100]	; 0x64
34802eb4:	e5942068 	ldr	r2, [r4, #104]	; 0x68
			char str[17];

			ret = boot_ramdisk_high(&images.lmb, images.rd_start,
34802eb8:	e2843074 	add	r3, r4, #116	; 0x74
34802ebc:	e58d3000 	str	r3, [sp]
34802ec0:	e284008c 	add	r0, r4, #140	; 0x8c
34802ec4:	e0612002 	rsb	r2, r1, r2
34802ec8:	e2843070 	add	r3, r4, #112	; 0x70
34802ecc:	eb002b71 	bl	3480dc98 <boot_ramdisk_high>
				rd_len, &images.initrd_start, &images.initrd_end);
			if (ret)
34802ed0:	e2505000 	subs	r5, r0, #0
34802ed4:	1a000036 	bne	34802fb4 <do_bootm_subcommand+0x218>
				return ret;

			sprintf(str, "%lx", images.initrd_start);
34802ed8:	e28d6018 	add	r6, sp, #24
34802edc:	e5942070 	ldr	r2, [r4, #112]	; 0x70
34802ee0:	e1a00006 	mov	r0, r6
34802ee4:	e59f10e4 	ldr	r1, [pc, #228]	; 34802fd0 <do_bootm_subcommand+0x234>
34802ee8:	eb006a1c 	bl	3481d760 <sprintf>
			setenv("initrd_start", str);
34802eec:	e1a01006 	mov	r1, r6
34802ef0:	e59f00dc 	ldr	r0, [pc, #220]	; 34802fd4 <do_bootm_subcommand+0x238>
34802ef4:	eb001339 	bl	34807be0 <setenv>
			sprintf(str, "%lx", images.initrd_end);
34802ef8:	e1a00006 	mov	r0, r6
34802efc:	e59f10cc 	ldr	r1, [pc, #204]	; 34802fd0 <do_bootm_subcommand+0x234>
34802f00:	e5942074 	ldr	r2, [r4, #116]	; 0x74
34802f04:	eb006a15 	bl	3481d760 <sprintf>
			setenv("initrd_end", str);
34802f08:	e1a01006 	mov	r1, r6
34802f0c:	e59f00c4 	ldr	r0, [pc, #196]	; 34802fd8 <do_bootm_subcommand+0x23c>
34802f10:	eb001332 	bl	34807be0 <setenv>
		}
			break;
34802f14:	ea000026 	b	34802fb4 <do_bootm_subcommand+0x218>
				&images.ft_addr, &images.ft_len);
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
34802f18:	e1a01005 	mov	r1, r5
34802f1c:	e1a0000a 	mov	r0, sl
34802f20:	e1a02007 	mov	r2, r7
34802f24:	e1a03004 	mov	r3, r4
34802f28:	e12fff36 	blx	r6
			if (ret)
34802f2c:	e2505000 	subs	r5, r0, #0
				printf("cmdline subcommand not supported\n");
34802f30:	159f00a4 	ldrne	r0, [pc, #164]	; 34802fdc <do_bootm_subcommand+0x240>
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
			if (ret)
34802f34:	0a00001e 	beq	34802fb4 <do_bootm_subcommand+0x218>
34802f38:	ea000010 	b	34802f80 <do_bootm_subcommand+0x1e4>
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
34802f3c:	e1a01005 	mov	r1, r5
34802f40:	e1a0000a 	mov	r0, sl
34802f44:	e1a02007 	mov	r2, r7
34802f48:	e1a03004 	mov	r3, r4
34802f4c:	e12fff36 	blx	r6
			if (ret)
34802f50:	e2505000 	subs	r5, r0, #0
				printf("bdt subcommand not supported\n");
34802f54:	159f0084 	ldrne	r0, [pc, #132]	; 34802fe0 <do_bootm_subcommand+0x244>
			if (ret)
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
			if (ret)
34802f58:	0a000015 	beq	34802fb4 <do_bootm_subcommand+0x218>
34802f5c:	ea000007 	b	34802f80 <do_bootm_subcommand+0x1e4>
				printf("bdt subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_PREP:
			ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, &images);
34802f60:	e1a01005 	mov	r1, r5
34802f64:	e1a0000a 	mov	r0, sl
34802f68:	e1a02007 	mov	r2, r7
34802f6c:	e1a03004 	mov	r3, r4
34802f70:	e12fff36 	blx	r6
			if (ret)
34802f74:	e2505000 	subs	r5, r0, #0
34802f78:	0a00000d 	beq	34802fb4 <do_bootm_subcommand+0x218>
				printf("prep subcommand not supported\n");
34802f7c:	e59f0060 	ldr	r0, [pc, #96]	; 34802fe4 <do_bootm_subcommand+0x248>
34802f80:	eb001b0c 	bl	34809bb8 <printf>
34802f84:	ea00000a 	b	34802fb4 <do_bootm_subcommand+0x218>
			break;
		case BOOTM_STATE_OS_GO:
			disable_interrupts();
34802f88:	ebfffc16 	bl	34801fe8 <disable_interrupts>
			 * Stop the ethernet stack if NetConsole could have
			 * left it up
			 */
			eth_halt();
#endif
			arch_preboot_os();
34802f8c:	ebffff81 	bl	34802d98 <__arch_preboot_os>
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
34802f90:	e1a0000a 	mov	r0, sl
34802f94:	e1a01005 	mov	r1, r5
34802f98:	e1a02007 	mov	r2, r7
34802f9c:	e1a03004 	mov	r3, r4
34802fa0:	e12fff36 	blx	r6
34802fa4:	ea000001 	b	34802fb0 <do_bootm_subcommand+0x214>
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
		}
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
34802fa8:	e3e05000 	mvn	r5, #0
34802fac:	ea000000 	b	34802fb4 <do_bootm_subcommand+0x218>
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
	int ret = 0;
34802fb0:	e3a05000 	mov	r5, #0
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
			break;
	}

	return ret;
}
34802fb4:	e1a00005 	mov	r0, r5
34802fb8:	e28dd030 	add	sp, sp, #48	; 0x30
34802fbc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34802fc0:	34828608 	.word	0x34828608
34802fc4:	34829bb0 	.word	0x34829bb0
34802fc8:	3482338a 	.word	0x3482338a
34802fcc:	348203f4 	.word	0x348203f4
34802fd0:	348233b4 	.word	0x348233b4
34802fd4:	348233b8 	.word	0x348233b8
34802fd8:	348233c5 	.word	0x348233c5
34802fdc:	348233d0 	.word	0x348233d0
34802fe0:	348233f2 	.word	0x348233f2
34802fe4:	34823410 	.word	0x34823410

34802fe8 <do_bootm>:
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802fe8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
34802fec:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802ff0:	e24dd040 	sub	sp, sp, #64	; 0x40
34802ff4:	e1a05003 	mov	r5, r3
	ulong		iflag;
	ulong		load_end = 0;
34802ff8:	e3a03000 	mov	r3, #0
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802ffc:	e1a07000 	mov	r7, r0
34803000:	e1a09001 	mov	r9, r1
34803004:	e1a06002 	mov	r6, r2
	ulong		iflag;
	ulong		load_end = 0;
34803008:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
3480300c:	da000010 	ble	34803054 <do_bootm+0x6c>
		char *endp;

		simple_strtoul(argv[1], &endp, 16);
34803010:	e5950004 	ldr	r0, [r5, #4]
34803014:	e28d1038 	add	r1, sp, #56	; 0x38
34803018:	e3a02010 	mov	r2, #16
3480301c:	eb006929 	bl	3481d4c8 <simple_strtoul>
		 * If endp is ':' or '#' assume a FIT identifier so pass
		 * along for normal processing.
		 *
		 * Right now we assume the first arg should never be '-'
		 */
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
34803020:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34803024:	e5d33000 	ldrb	r3, [r3]
34803028:	e353003a 	cmp	r3, #58	; 0x3a
3480302c:	13530000 	cmpne	r3, #0
34803030:	0a000007 	beq	34803054 <do_bootm+0x6c>
34803034:	e3530023 	cmp	r3, #35	; 0x23
34803038:	0a000005 	beq	34803054 <do_bootm+0x6c>
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
3480303c:	e1a00007 	mov	r0, r7
34803040:	e1a01009 	mov	r1, r9
34803044:	e1a02006 	mov	r2, r6
34803048:	e1a03005 	mov	r3, r5
3480304c:	ebffff52 	bl	34802d9c <do_bootm_subcommand>
34803050:	ea00007f 	b	34803254 <do_bootm+0x26c>
	}

	if (bootm_start(cmdtp, flag, argc, argv))
34803054:	e1a00007 	mov	r0, r7
34803058:	e1a01006 	mov	r1, r6
3480305c:	e1a02005 	mov	r2, r5
34803060:	ebfffe61 	bl	348029ec <bootm_start.clone.17>
34803064:	e3500000 	cmp	r0, #0
34803068:	1a000078 	bne	34803250 <do_bootm+0x268>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
3480306c:	ebfffbdd 	bl	34801fe8 <disable_interrupts>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34803070:	e59f41e4 	ldr	r4, [pc, #484]	; 3480325c <do_bootm+0x274>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
34803074:	e1a0b000 	mov	fp, r0
	 * details see the OpenHCI specification.
	 */
	usb_stop();
#endif

	ret = bootm_load_os(images.os, &load_end, 1);
34803078:	e5943058 	ldr	r3, [r4, #88]	; 0x58
3480307c:	e58d3000 	str	r3, [sp]
34803080:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34803084:	e58d3004 	str	r3, [sp, #4]
34803088:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
3480308c:	e58d3008 	str	r3, [sp, #8]
34803090:	e28d303c 	add	r3, sp, #60	; 0x3c
34803094:	e58d300c 	str	r3, [sp, #12]
34803098:	e3a03001 	mov	r3, #1
3480309c:	e58d3010 	str	r3, [sp, #16]
348030a0:	e2840048 	add	r0, r4, #72	; 0x48
348030a4:	e890000f 	ldm	r0, {r0, r1, r2, r3}
348030a8:	ebfffdf4 	bl	34802880 <bootm_load_os.clone.18>

	if (ret < 0) {
348030ac:	e3500000 	cmp	r0, #0
348030b0:	aa00001d 	bge	3480312c <do_bootm+0x144>
		if (ret == BOOTM_ERR_RESET)
348030b4:	e3700001 	cmn	r0, #1
348030b8:	0a00000e 	beq	348030f8 <do_bootm+0x110>
			do_reset(cmdtp, flag, argc, argv);
		if (ret == BOOTM_ERR_OVERLAP) {
348030bc:	e3700002 	cmn	r0, #2
348030c0:	1a000012 	bne	34803110 <do_bootm+0x128>
			if (images.legacy_hdr_valid) {
348030c4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
348030c8:	e3530000 	cmp	r3, #0
348030cc:	0a000005 	beq	348030e8 <do_bootm+0x100>
				image_header_t *hdr;
				hdr = &images.legacy_hdr_os_copy;
				if (image_get_type(hdr) == IH_TYPE_MULTI)
348030d0:	e5d43022 	ldrb	r3, [r4, #34]	; 0x22
348030d4:	e3530004 	cmp	r3, #4
348030d8:	1a000013 	bne	3480312c <do_bootm+0x144>
					puts("WARNING: legacy format multi "
348030dc:	e59f017c 	ldr	r0, [pc, #380]	; 34803260 <do_bootm+0x278>
348030e0:	eb001aaa 	bl	34809b90 <puts>
348030e4:	ea000010 	b	3480312c <do_bootm+0x144>
						"component image "
						"overwritten\n");
			} else {
				puts("ERROR: new format image overwritten - "
348030e8:	e59f0174 	ldr	r0, [pc, #372]	; 34803264 <do_bootm+0x27c>
348030ec:	eb001aa7 	bl	34809b90 <puts>
348030f0:	e3e00070 	mvn	r0, #112	; 0x70
348030f4:	eb002ba3 	bl	3480df88 <__show_boot_progress>
					"must RESET the board to recover\n");
				bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);
				do_reset(cmdtp, flag, argc, argv);
348030f8:	e1a00007 	mov	r0, r7
348030fc:	e1a01009 	mov	r1, r9
34803100:	e1a02006 	mov	r2, r6
34803104:	e1a03005 	mov	r3, r5
34803108:	ebfffc4b 	bl	3480223c <do_reset>
3480310c:	ea000006 	b	3480312c <do_bootm+0x144>
			}
		}
		if (ret == BOOTM_ERR_UNIMPLEMENTED) {
34803110:	e3700003 	cmn	r0, #3
34803114:	1a000004 	bne	3480312c <do_bootm+0x144>
			if (iflag)
34803118:	e35b0000 	cmp	fp, #0
3480311c:	0a000000 	beq	34803124 <do_bootm+0x13c>
				enable_interrupts();
34803120:	ebfffbaf 	bl	34801fe4 <enable_interrupts>
34803124:	e3e00006 	mvn	r0, #6
34803128:	ea000039 	b	34803214 <do_bootm+0x22c>
			bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
			return 1;
		}
	}

	lmb_reserve(&images.lmb, images.os.load, (load_end - images.os.load));
3480312c:	e59fa128 	ldr	sl, [pc, #296]	; 3480325c <do_bootm+0x274>
34803130:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
34803134:	e59a1058 	ldr	r1, [sl, #88]	; 0x58
34803138:	e28a008c 	add	r0, sl, #140	; 0x8c
3480313c:	e0612002 	rsb	r2, r1, r2
34803140:	eb006404 	bl	3481c158 <lmb_reserve>

	if (images.os.type == IH_TYPE_STANDALONE) {
34803144:	e5da305d 	ldrb	r3, [sl, #93]	; 0x5d
34803148:	e3530001 	cmp	r3, #1
3480314c:	1a00001e 	bne	348031cc <do_bootm+0x1e4>
		if (iflag)
34803150:	e35b0000 	cmp	fp, #0
34803154:	0a000000 	beq	3480315c <do_bootm+0x174>
			enable_interrupts();
34803158:	ebfffba1 	bl	34801fe4 <enable_interrupts>
{
	char  *s;
	int   (*appl)(int, char * const []);

	/* Don't start if "autostart" is set to "no" */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s, "no") == 0)) {
3480315c:	e59f0104 	ldr	r0, [pc, #260]	; 34803268 <do_bootm+0x280>
34803160:	eb0013a6 	bl	34808000 <getenv>
34803164:	e3500000 	cmp	r0, #0
34803168:	0a00000e 	beq	348031a8 <do_bootm+0x1c0>
3480316c:	e59f10f8 	ldr	r1, [pc, #248]	; 3480326c <do_bootm+0x284>
34803170:	eb00650d 	bl	3481c5ac <strcmp>
34803174:	e2507000 	subs	r7, r0, #0
34803178:	1a00000a 	bne	348031a8 <do_bootm+0x1c0>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
3480317c:	e59f30d8 	ldr	r3, [pc, #216]	; 3480325c <do_bootm+0x274>
34803180:	e28d4018 	add	r4, sp, #24
34803184:	e59f10e4 	ldr	r1, [pc, #228]	; 34803270 <do_bootm+0x288>
34803188:	e5932054 	ldr	r2, [r3, #84]	; 0x54
3480318c:	e1a00004 	mov	r0, r4
34803190:	eb006972 	bl	3481d760 <sprintf>
		setenv("filesize", buf);
34803194:	e59f00d8 	ldr	r0, [pc, #216]	; 34803274 <do_bootm+0x28c>
34803198:	e1a01004 	mov	r1, r4
3480319c:	eb00128f 	bl	34807be0 <setenv>
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
348031a0:	e1a00007 	mov	r0, r7
348031a4:	ea00002a 	b	34803254 <do_bootm+0x26c>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
348031a8:	e59f30ac 	ldr	r3, [pc, #172]	; 3480325c <do_bootm+0x274>
348031ac:	e5930060 	ldr	r0, [r3, #96]	; 0x60
348031b0:	ebfffcf7 	bl	34802594 <__fswab32>
	(*appl)(argc-1, &argv[1]);
348031b4:	e2851004 	add	r1, r5, #4
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
348031b8:	e1a03000 	mov	r3, r0
	(*appl)(argc-1, &argv[1]);
348031bc:	e2460001 	sub	r0, r6, #1
348031c0:	e12fff33 	blx	r3
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
348031c4:	e3a00000 	mov	r0, #0
348031c8:	ea000021 	b	34803254 <do_bootm+0x26c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348031cc:	e3a00008 	mov	r0, #8
348031d0:	eb002b6c 	bl	3480df88 <__show_boot_progress>
#ifdef CONFIG_SILENT_CONSOLE
	if (images.os.os == IH_OS_LINUX)
		fixup_silent_linux();
#endif

	boot_fn = boot_os[images.os.os];
348031d4:	e5da205e 	ldrb	r2, [sl, #94]	; 0x5e
348031d8:	e59f3098 	ldr	r3, [pc, #152]	; 34803278 <do_bootm+0x290>
348031dc:	e7934102 	ldr	r4, [r3, r2, lsl #2]

	if (boot_fn == NULL) {
348031e0:	e3540000 	cmp	r4, #0
348031e4:	1a00000c 	bne	3480321c <do_bootm+0x234>
		if (iflag)
348031e8:	e35b0000 	cmp	fp, #0
348031ec:	0a000000 	beq	348031f4 <do_bootm+0x20c>
			enable_interrupts();
348031f0:	ebfffb7b 	bl	34801fe4 <enable_interrupts>
		printf("ERROR: booting os '%s' (%d) is not supported\n",
348031f4:	e59f4060 	ldr	r4, [pc, #96]	; 3480325c <do_bootm+0x274>
348031f8:	e5d4005e 	ldrb	r0, [r4, #94]	; 0x5e
348031fc:	eb00296f 	bl	3480d7c0 <genimg_get_os_name>
34803200:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34803204:	e1a01000 	mov	r1, r0
34803208:	e59f006c 	ldr	r0, [pc, #108]	; 3480327c <do_bootm+0x294>
3480320c:	eb001a69 	bl	34809bb8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34803210:	e3e00007 	mvn	r0, #7
34803214:	eb002b5b 	bl	3480df88 <__show_boot_progress>
34803218:	ea00000c 	b	34803250 <do_bootm+0x268>
			genimg_get_os_name(images.os.os), images.os.os);
		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
		return 1;
	}

	arch_preboot_os();
3480321c:	ebfffedd 	bl	34802d98 <__arch_preboot_os>

	boot_fn(0, argc, argv, &images);
34803220:	e1a01006 	mov	r1, r6
34803224:	e1a02005 	mov	r2, r5
34803228:	e1a0300a 	mov	r3, sl
3480322c:	e3a00000 	mov	r0, #0
34803230:	e12fff34 	blx	r4
34803234:	e3e00008 	mvn	r0, #8
34803238:	eb002b52 	bl	3480df88 <__show_boot_progress>

	bootstage_error(BOOTSTAGE_ID_BOOT_OS_RETURNED);
#ifdef DEBUG
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);
3480323c:	e1a00007 	mov	r0, r7
34803240:	e1a01009 	mov	r1, r9
34803244:	e1a02006 	mov	r2, r6
34803248:	e1a03005 	mov	r3, r5
3480324c:	ebfffbfa 	bl	3480223c <do_reset>
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
	}

	if (bootm_start(cmdtp, flag, argc, argv))
		return 1;
34803250:	e3a00001 	mov	r0, #1
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);

	return 1;
}
34803254:	e28dd040 	add	sp, sp, #64	; 0x40
34803258:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480325c:	34829bb0 	.word	0x34829bb0
34803260:	3482342f 	.word	0x3482342f
34803264:	34823469 	.word	0x34823469
34803268:	348234b0 	.word	0x348234b0
3480326c:	348234ba 	.word	0x348234ba
34803270:	348234bd 	.word	0x348234bd
34803274:	348234c1 	.word	0x348234c1
34803278:	348203f4 	.word	0x348203f4
3480327c:	348234ca 	.word	0x348234ca

34803280 <bootm_maybe_autostart>:

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
34803280:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
34803284:	e1a05000 	mov	r5, r0
	const char *ep = getenv("autostart");
34803288:	e59f0054 	ldr	r0, [pc, #84]	; 348032e4 <bootm_maybe_autostart+0x64>

	return 1;
}

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
3480328c:	e1a06001 	mov	r6, r1
	const char *ep = getenv("autostart");
34803290:	eb00135a 	bl	34808000 <getenv>

	if (ep && !strcmp(ep, "yes")) {
34803294:	e2503000 	subs	r3, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
34803298:	01a00003 	moveq	r0, r3

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
3480329c:	0a00000f 	beq	348032e0 <bootm_maybe_autostart+0x60>
348032a0:	e59f1040 	ldr	r1, [pc, #64]	; 348032e8 <bootm_maybe_autostart+0x68>
348032a4:	eb0064c0 	bl	3481c5ac <strcmp>
348032a8:	e2504000 	subs	r4, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
348032ac:	13a00000 	movne	r0, #0

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
348032b0:	1a00000a 	bne	348032e0 <bootm_maybe_autostart+0x60>
		char *local_args[2];
		local_args[0] = (char *)cmd;
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
348032b4:	e59f3030 	ldr	r3, [pc, #48]	; 348032ec <bootm_maybe_autostart+0x6c>
348032b8:	e59f0030 	ldr	r0, [pc, #48]	; 348032f0 <bootm_maybe_autostart+0x70>
348032bc:	e5931000 	ldr	r1, [r3]
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
		char *local_args[2];
		local_args[0] = (char *)cmd;
348032c0:	e58d6000 	str	r6, [sp]
		local_args[1] = NULL;
348032c4:	e58d4004 	str	r4, [sp, #4]
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
348032c8:	eb001a3a 	bl	34809bb8 <printf>
		return do_bootm(cmdtp, 0, 1, local_args);
348032cc:	e1a00005 	mov	r0, r5
348032d0:	e1a01004 	mov	r1, r4
348032d4:	e3a02001 	mov	r2, #1
348032d8:	e1a0300d 	mov	r3, sp
348032dc:	ebffff41 	bl	34802fe8 <do_bootm>
	}

	return 0;
}
348032e0:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
348032e4:	348234b0 	.word	0x348234b0
348032e8:	348234f8 	.word	0x348234f8
348032ec:	34828780 	.word	0x34828780
348032f0:	348234fc 	.word	0x348234fc

348032f4 <parse_argv>:
	}
	return 0;
}

static int parse_argv(const char *s)
{
348032f4:	e92d4010 	push	{r4, lr}
	if (strcmp(s, "flush") == 0)
348032f8:	e59f1044 	ldr	r1, [pc, #68]	; 34803344 <parse_argv+0x50>
	}
	return 0;
}

static int parse_argv(const char *s)
{
348032fc:	e1a04000 	mov	r4, r0
	if (strcmp(s, "flush") == 0)
34803300:	eb0064a9 	bl	3481c5ac <strcmp>
34803304:	e3500000 	cmp	r0, #0
		return 2;
34803308:	03a00002 	moveq	r0, #2
	return 0;
}

static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
3480330c:	08bd8010 	popeq	{r4, pc}
		return 2;
	else if (strcmp(s, "on") == 0)
34803310:	e1a00004 	mov	r0, r4
34803314:	e59f102c 	ldr	r1, [pc, #44]	; 34803348 <parse_argv+0x54>
34803318:	eb0064a3 	bl	3481c5ac <strcmp>
3480331c:	e3500000 	cmp	r0, #0
34803320:	0a000005 	beq	3480333c <parse_argv+0x48>
		return 1;
	else if (strcmp(s, "off") == 0)
34803324:	e1a00004 	mov	r0, r4
34803328:	e59f101c 	ldr	r1, [pc, #28]	; 3480334c <parse_argv+0x58>
3480332c:	eb00649e 	bl	3481c5ac <strcmp>
34803330:	e3500000 	cmp	r0, #0
		return 0;
34803334:	13e00000 	mvnne	r0, #0
34803338:	e8bd8010 	pop	{r4, pc}
static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
		return 2;
	else if (strcmp(s, "on") == 0)
		return 1;
3480333c:	e3a00001 	mov	r0, #1
	else if (strcmp(s, "off") == 0)
		return 0;

	return -1;
}
34803340:	e8bd8010 	pop	{r4, pc}
34803344:	348238ae 	.word	0x348238ae
34803348:	34828554 	.word	0x34828554
3480334c:	34822f4d 	.word	0x34822f4d
static int parse_argv(const char *);

void __weak invalidate_icache_all(void)
{
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
34803350:	e59f0000 	ldr	r0, [pc, #0]	; 34803358 <parse_argv+0x64>
34803354:	ea001a0d 	b	34809b90 <puts>
34803358:	348238b4 	.word	0x348238b4

3480335c <do_icache>:
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
3480335c:	e3520001 	cmp	r2, #1
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803360:	e92d4010 	push	{r4, lr}
	switch (argc) {
34803364:	0a000012 	beq	348033b4 <do_icache+0x58>
34803368:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
3480336c:	13e00000 	mvnne	r0, #0
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
34803370:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
34803374:	e5930004 	ldr	r0, [r3, #4]
34803378:	ebffffdd 	bl	348032f4 <parse_argv>
3480337c:	e3500001 	cmp	r0, #1
34803380:	e1a04000 	mov	r4, r0
34803384:	0a000006 	beq	348033a4 <do_icache+0x48>
34803388:	e3500002 	cmp	r0, #2
3480338c:	0a000006 	beq	348033ac <do_icache+0x50>
34803390:	e3500000 	cmp	r0, #0
34803394:	1a00000f 	bne	348033d8 <do_icache+0x7c>
		case 0:
			icache_disable();
34803398:	ebfffc0a 	bl	348023c8 <icache_disable>
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
3480339c:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
		case 0:
			icache_disable();
			break;
348033a0:	e8bd8010 	pop	{r4, pc}
		case 1:
			icache_enable();
348033a4:	ebfffc05 	bl	348023c0 <icache_enable>
348033a8:	ea000008 	b	348033d0 <do_icache+0x74>
			break;
		case 2:
			invalidate_icache_all();
348033ac:	ebfff76f 	bl	34801170 <invalidate_icache_all>
348033b0:	ea000006 	b	348033d0 <do_icache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
348033b4:	ebfffc05 	bl	348023d0 <icache_status>
			invalidate_icache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
348033b8:	e59f3020 	ldr	r3, [pc, #32]	; 348033e0 <do_icache+0x84>
348033bc:	e3500000 	cmp	r0, #0
348033c0:	e59f101c 	ldr	r1, [pc, #28]	; 348033e4 <do_icache+0x88>
348033c4:	e59f001c 	ldr	r0, [pc, #28]	; 348033e8 <do_icache+0x8c>
348033c8:	11a01003 	movne	r1, r3
348033cc:	eb0019f9 	bl	34809bb8 <printf>
			icache_status() ? "ON" : "OFF");
		return 0;
348033d0:	e3a00000 	mov	r0, #0
348033d4:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
348033d8:	e3a00000 	mov	r0, #0
}
348033dc:	e8bd8010 	pop	{r4, pc}
348033e0:	34826573 	.word	0x34826573
348033e4:	348238e7 	.word	0x348238e7
348033e8:	348238eb 	.word	0x348238eb

void __weak flush_dcache_all(void)
{
	puts("No arch specific flush_dcache_all available!\n");
348033ec:	e59f0000 	ldr	r0, [pc, #0]	; 348033f4 <do_icache+0x98>
348033f0:	ea0019e6 	b	34809b90 <puts>
348033f4:	34823904 	.word	0x34823904

348033f8 <do_dcache>:
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
348033f8:	e3520001 	cmp	r2, #1
	puts("No arch specific flush_dcache_all available!\n");
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348033fc:	e92d4010 	push	{r4, lr}
	switch (argc) {
34803400:	0a000012 	beq	34803450 <do_dcache+0x58>
34803404:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
34803408:	13e00000 	mvnne	r0, #0
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
3480340c:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
34803410:	e5930004 	ldr	r0, [r3, #4]
34803414:	ebffffb6 	bl	348032f4 <parse_argv>
34803418:	e3500001 	cmp	r0, #1
3480341c:	e1a04000 	mov	r4, r0
34803420:	0a000006 	beq	34803440 <do_dcache+0x48>
34803424:	e3500002 	cmp	r0, #2
34803428:	0a000006 	beq	34803448 <do_dcache+0x50>
3480342c:	e3500000 	cmp	r0, #0
34803430:	1a00000f 	bne	34803474 <do_dcache+0x7c>
		case 0:
			dcache_disable();
34803434:	ebfffbea 	bl	348023e4 <dcache_disable>
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
34803438:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
		case 0:
			dcache_disable();
			break;
3480343c:	e8bd8010 	pop	{r4, pc}
		case 1:
			dcache_enable();
34803440:	ebfffbe5 	bl	348023dc <dcache_enable>
34803444:	ea000008 	b	3480346c <do_dcache+0x74>
			break;
		case 2:
			flush_dcache_all();
34803448:	ebfff725 	bl	348010e4 <flush_dcache_all>
3480344c:	ea000006 	b	3480346c <do_dcache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
34803450:	ebfffbe5 	bl	348023ec <dcache_status>
			flush_dcache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
34803454:	e59f3020 	ldr	r3, [pc, #32]	; 3480347c <do_dcache+0x84>
34803458:	e3500000 	cmp	r0, #0
3480345c:	e59f101c 	ldr	r1, [pc, #28]	; 34803480 <do_dcache+0x88>
34803460:	e59f001c 	ldr	r0, [pc, #28]	; 34803484 <do_dcache+0x8c>
34803464:	11a01003 	movne	r1, r3
34803468:	eb0019d2 	bl	34809bb8 <printf>
			dcache_status() ? "ON" : "OFF");
		return 0;
3480346c:	e3a00000 	mov	r0, #0
34803470:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
34803474:	e3a00000 	mov	r0, #0
}
34803478:	e8bd8010 	pop	{r4, pc}
3480347c:	34826573 	.word	0x34826573
34803480:	348238e7 	.word	0x348238e7
34803484:	34823932 	.word	0x34823932

34803488 <do_coninfo>:
#include <command.h>
#include <stdio_dev.h>

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char * const argv[])
{
34803488:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	int l;
	struct list_head *list = stdio_get_list();
3480348c:	eb002f24 	bl	3480f124 <stdio_get_list>
34803490:	e1a05000 	mov	r5, r0
	struct list_head *pos;
	struct stdio_dev *dev;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
34803494:	e59f0090 	ldr	r0, [pc, #144]	; 3480352c <do_coninfo+0xa4>
34803498:	eb0019bc 	bl	34809b90 <puts>
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
3480349c:	e59f708c 	ldr	r7, [pc, #140]	; 34803530 <do_coninfo+0xa8>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
348034a0:	e5954000 	ldr	r4, [r5]
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
348034a4:	e59fa088 	ldr	sl, [pc, #136]	; 34803534 <do_coninfo+0xac>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
348034a8:	ea00001b 	b	3480351c <do_coninfo+0x94>
		dev = list_entry(pos, struct stdio_dev, list);

		printf ("%-8s %08x %c%c%c ",
			dev->name,
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
348034ac:	e5142034 	ldr	r2, [r4, #-52]	; 0x34
	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
		dev = list_entry(pos, struct stdio_dev, list);
348034b0:	e2446034 	sub	r6, r4, #52	; 0x34

		printf ("%-8s %08x %c%c%c ",
348034b4:	e3120001 	tst	r2, #1
348034b8:	03a0102e 	moveq	r1, #46	; 0x2e
348034bc:	13a01049 	movne	r1, #73	; 0x49
348034c0:	e3120002 	tst	r2, #2
348034c4:	03a0302e 	moveq	r3, #46	; 0x2e
348034c8:	13a0304f 	movne	r3, #79	; 0x4f
348034cc:	e3520000 	cmp	r2, #0
348034d0:	e88d000a 	stm	sp, {r1, r3}
348034d4:	e59f005c 	ldr	r0, [pc, #92]	; 34803538 <do_coninfo+0xb0>
348034d8:	e2861008 	add	r1, r6, #8
348034dc:	a3a0302e 	movge	r3, #46	; 0x2e
348034e0:	b3a03053 	movlt	r3, #83	; 0x53
348034e4:	eb0019b3 	bl	34809bb8 <printf>
348034e8:	e3a09000 	mov	r9, #0
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
348034ec:	e7993007 	ldr	r3, [r9, r7]
348034f0:	e1530006 	cmp	r3, r6
348034f4:	1a000002 	bne	34803504 <do_coninfo+0x7c>
				printf ("%s ", stdio_names[l]);
348034f8:	e59f003c 	ldr	r0, [pc, #60]	; 3480353c <do_coninfo+0xb4>
348034fc:	e799100a 	ldr	r1, [r9, sl]
34803500:	eb0019ac 	bl	34809bb8 <printf>
34803504:	e2899004 	add	r9, r9, #4
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
34803508:	e359000c 	cmp	r9, #12
3480350c:	1afffff6 	bne	348034ec <do_coninfo+0x64>
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
			}
		}
		putc ('\n');
34803510:	e3a0000a 	mov	r0, #10
34803514:	eb001993 	bl	34809b68 <putc>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
34803518:	e5944000 	ldr	r4, [r4]
3480351c:	e1540005 	cmp	r4, r5
34803520:	1affffe1 	bne	348034ac <do_coninfo+0x24>
			}
		}
		putc ('\n');
	}
	return 0;
}
34803524:	e3a00000 	mov	r0, #0
34803528:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
3480352c:	34823a30 	.word	0x34823a30
34803530:	3482b868 	.word	0x3482b868
34803534:	34828d0c 	.word	0x34828d0c
34803538:	34823a4c 	.word	0x34823a4c
3480353c:	348261f0 	.word	0x348261f0

34803540 <do_echo>:

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803540:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	int putnl = 1;
34803544:	e3a07001 	mov	r7, #1

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803548:	e1a04002 	mov	r4, r2
3480354c:	e1a0a003 	mov	sl, r3
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
34803550:	e1a06007 	mov	r6, r7
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34803554:	e3a0b000 	mov	fp, #0
				puts(prenls);
				*nls = '\\';
34803558:	e3a0905c 	mov	r9, #92	; 0x5c
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
3480355c:	ea00001e 	b	348035dc <do_echo+0x9c>
		char *p = argv[i];
		char *nls; /* new-line suppression */

		if (i > 1)
34803560:	e3560001 	cmp	r6, #1
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
		char *p = argv[i];
34803564:	e5ba5004 	ldr	r5, [sl, #4]!
		char *nls; /* new-line suppression */

		if (i > 1)
34803568:	da000001 	ble	34803574 <do_echo+0x34>
			putc(' ');
3480356c:	e3a00020 	mov	r0, #32
34803570:	eb00197c 	bl	34809b68 <putc>

		nls = strstr(p, "\\c");
34803574:	e1a00005 	mov	r0, r5
34803578:	e59f107c 	ldr	r1, [pc, #124]	; 348035fc <do_echo+0xbc>
3480357c:	eb00654d 	bl	3481cab8 <strstr>
		if (nls) {
34803580:	e2503000 	subs	r3, r0, #0
34803584:	0a000011 	beq	348035d0 <do_echo+0x90>
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34803588:	e5c3b000 	strb	fp, [r3]
				puts(prenls);
3480358c:	e1a00005 	mov	r0, r5
34803590:	e58d3004 	str	r3, [sp, #4]
34803594:	eb00197d 	bl	34809b90 <puts>
				*nls = '\\';
34803598:	e59d3004 	ldr	r3, [sp, #4]
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
3480359c:	e59f1058 	ldr	r1, [pc, #88]	; 348035fc <do_echo+0xbc>
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
				puts(prenls);
				*nls = '\\';
348035a0:	e1a05003 	mov	r5, r3
348035a4:	e4c59002 	strb	r9, [r5], #2
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
348035a8:	e1a00005 	mov	r0, r5
348035ac:	eb006541 	bl	3481cab8 <strstr>
			putnl = 0;
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
348035b0:	e2503000 	subs	r3, r0, #0
348035b4:	1afffff3 	bne	34803588 <do_echo+0x48>
				puts(prenls);
				*nls = '\\';
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
348035b8:	e1a00005 	mov	r0, r5
348035bc:	e58d3004 	str	r3, [sp, #4]
348035c0:	eb001972 	bl	34809b90 <puts>

		nls = strstr(p, "\\c");
		if (nls) {
			char *prenls = p;

			putnl = 0;
348035c4:	e59d3004 	ldr	r3, [sp, #4]
348035c8:	e1a07003 	mov	r7, r3
348035cc:	ea000001 	b	348035d8 <do_echo+0x98>
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
		} else {
			puts(p);
348035d0:	e1a00005 	mov	r0, r5
348035d4:	eb00196d 	bl	34809b90 <puts>
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
348035d8:	e2866001 	add	r6, r6, #1
348035dc:	e1560004 	cmp	r6, r4
348035e0:	baffffde 	blt	34803560 <do_echo+0x20>
		} else {
			puts(p);
		}
	}

	if (putnl)
348035e4:	e3570000 	cmp	r7, #0
348035e8:	0a000001 	beq	348035f4 <do_echo+0xb4>
		putc('\n');
348035ec:	e3a0000a 	mov	r0, #10
348035f0:	eb00195c 	bl	34809b68 <putc>

	return 0;
}
348035f4:	e3a00000 	mov	r0, #0
348035f8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348035fc:	34823a8c 	.word	0x34823a8c

34803600 <do_exit>:
int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int r;

	r = 0;
	if (argc > 1)
34803600:	e3520001 	cmp	r2, #1

#include <common.h>
#include <command.h>

int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803604:	e92d4008 	push	{r3, lr}
	int r;

	r = 0;
34803608:	d3a03000 	movle	r3, #0
	if (argc > 1)
3480360c:	da000004 	ble	34803624 <do_exit+0x24>
		r = simple_strtoul(argv[1], NULL, 10);
34803610:	e5930004 	ldr	r0, [r3, #4]
34803614:	e3a01000 	mov	r1, #0
34803618:	e3a0200a 	mov	r2, #10
3480361c:	eb0067a9 	bl	3481d4c8 <simple_strtoul>
34803620:	e1a03000 	mov	r3, r0

	return -r - 2;
}
34803624:	e3e00001 	mvn	r0, #1
34803628:	e0630000 	rsb	r0, r3, r0
3480362c:	e8bd8008 	pop	{r3, pc}

34803630 <do_help>:

#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34803630:	e92d4007 	push	{r0, r1, r2, lr}
34803634:	e1a0c001 	mov	ip, r1
34803638:	e1a0e000 	mov	lr, r0
	return _do_help(&__u_boot_cmd_start,
			&__u_boot_cmd_end - &__u_boot_cmd_start,
3480363c:	e59f1028 	ldr	r1, [pc, #40]	; 3480366c <do_help+0x3c>
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
34803640:	e59f0028 	ldr	r0, [pc, #40]	; 34803670 <do_help+0x40>
34803644:	e58d3004 	str	r3, [sp, #4]
			&__u_boot_cmd_end - &__u_boot_cmd_start,
34803648:	e0601001 	rsb	r1, r0, r1
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
3480364c:	e59f3020 	ldr	r3, [pc, #32]	; 34803674 <do_help+0x44>
34803650:	e1a011c1 	asr	r1, r1, #3
34803654:	e58d2000 	str	r2, [sp]
34803658:	e0010193 	mul	r1, r3, r1
3480365c:	e1a0200e 	mov	r2, lr
34803660:	e1a0300c 	mov	r3, ip
34803664:	eb001813 	bl	348096b8 <_do_help>
			&__u_boot_cmd_end - &__u_boot_cmd_start,
			cmdtp, flag, argc, argv);
}
34803668:	e8bd800e 	pop	{r1, r2, r3, pc}
	...
34803674:	aaaaaaab 	.word	0xaaaaaaab

34803678 <evalstr>:
}

static char * evalstr(char *s)
{
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
34803678:	e5d02000 	ldrb	r2, [r0]
3480367c:	e352002a 	cmp	r2, #42	; 0x2a
34803680:	112fff1e 	bxne	lr
		return (char *)simple_strtoul(&s[1], NULL, 16);
34803684:	e2800001 	add	r0, r0, #1
34803688:	e3a01000 	mov	r1, #0
3480368c:	e3a02010 	mov	r2, #16
34803690:	ea00678c 	b	3481d4c8 <simple_strtoul>

34803694 <evalexp>:
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
34803694:	e92d4010 	push	{r4, lr}
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
34803698:	e5d02000 	ldrb	r2, [r0]
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
3480369c:	e1a04001 	mov	r4, r1
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
348036a0:	e352002a 	cmp	r2, #42	; 0x2a
348036a4:	1a00000d 	bne	348036e0 <evalexp+0x4c>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
348036a8:	e2800001 	add	r0, r0, #1
348036ac:	e3a01000 	mov	r1, #0
348036b0:	e3a02010 	mov	r2, #16
348036b4:	eb006783 	bl	3481d4c8 <simple_strtoul>
		switch (w) {
348036b8:	e3540002 	cmp	r4, #2
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
348036bc:	01d000b0 	ldrheq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
348036c0:	08bd8010 	popeq	{r4, pc}
348036c4:	e3540004 	cmp	r4, #4
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
348036c8:	05900000 	ldreq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
348036cc:	08bd8010 	popeq	{r4, pc}
348036d0:	e3540001 	cmp	r4, #1
		case 1: return((long)(*(unsigned char *)p));
348036d4:	05d00000 	ldrbeq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
348036d8:	1a000004 	bne	348036f0 <evalexp+0x5c>
348036dc:	e8bd8010 	pop	{r4, pc}
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
348036e0:	e3a01000 	mov	r1, #0
348036e4:	e3a02010 	mov	r2, #16
348036e8:	eb006776 	bl	3481d4c8 <simple_strtoul>
348036ec:	ea000000 	b	348036f4 <evalexp+0x60>
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
	long l = 0;
348036f0:	e3a00000 	mov	r0, #0
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
	}

	return (l & ((1 << (w * 8)) - 1));
348036f4:	e1a04184 	lsl	r4, r4, #3
348036f8:	e3e03000 	mvn	r3, #0
348036fc:	e1c00413 	bic	r0, r0, r3, lsl r4
}
34803700:	e8bd8010 	pop	{r4, pc}

34803704 <binary_test>:
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
{
34803704:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34803708:	e1a09000 	mov	r9, r0
3480370c:	e1a05001 	mov	r5, r1
34803710:	e1a04002 	mov	r4, r2
34803714:	e1a07003 	mov	r7, r3
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
34803718:	eb0063d7 	bl	3481c67c <strlen>
	case GE: return (l >= r);
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
3480371c:	e59fb190 	ldr	fp, [pc, #400]	; 348038b4 <binary_test+0x1b0>
{
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
34803720:	e1a0a000 	mov	sl, r0

	for (optp = (op_tbl_t *)&op_table, i = 0;
34803724:	e59f618c 	ldr	r6, [pc, #396]	; 348038b8 <binary_test+0x1b4>
34803728:	ea000058 	b	34803890 <binary_test+0x18c>
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
3480372c:	e1a00009 	mov	r0, r9
34803730:	e5961000 	ldr	r1, [r6]
34803734:	e1a0200a 	mov	r2, sl
34803738:	eb0063a7 	bl	3481c5dc <strncmp>
3480373c:	e3500000 	cmp	r0, #0
34803740:	1a000051 	bne	3480388c <binary_test+0x188>
34803744:	e5960000 	ldr	r0, [r6]
34803748:	eb0063cb 	bl	3481c67c <strlen>
3480374c:	e15a0000 	cmp	sl, r0
34803750:	1a00004d 	bne	3480388c <binary_test+0x188>
			if (w == 0) {
34803754:	e3570000 	cmp	r7, #0
34803758:	e5966004 	ldr	r6, [r6, #4]
3480375c:	1a000023 	bne	348037f0 <binary_test+0xec>
static int stringcomp(char *s, char *t, int op)
{
	int p;
	char *l, *r;

	l = evalstr(s);
34803760:	e1a00005 	mov	r0, r5
34803764:	ebffffc3 	bl	34803678 <evalstr>
34803768:	e1a05000 	mov	r5, r0
	r = evalstr(t);
3480376c:	e1a00004 	mov	r0, r4
34803770:	ebffffc0 	bl	34803678 <evalstr>
34803774:	e1a01000 	mov	r1, r0

	p = strcmp(l, r);
34803778:	e1a00005 	mov	r0, r5
3480377c:	eb00638a 	bl	3481c5ac <strcmp>
	switch (op) {
34803780:	e3560005 	cmp	r6, #5
34803784:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
34803788:	ea000045 	b	348038a4 <binary_test+0x1a0>
3480378c:	348037a4 	.word	0x348037a4
34803790:	348037b0 	.word	0x348037b0
34803794:	348037bc 	.word	0x348037bc
34803798:	348037c4 	.word	0x348037c4
3480379c:	348037d4 	.word	0x348037d4
348037a0:	348037e4 	.word	0x348037e4
	case EQ: return (p == 0);
348037a4:	e2700001 	rsbs	r0, r0, #1
348037a8:	33a00000 	movcc	r0, #0
348037ac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (p != 0);
348037b0:	e2500000 	subs	r0, r0, #0
348037b4:	13a00001 	movne	r0, #1
348037b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (p < 0);
348037bc:	e1a00fa0 	lsr	r0, r0, #31
348037c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (p > 0);
348037c4:	e3500000 	cmp	r0, #0
348037c8:	d3a00000 	movle	r0, #0
348037cc:	c3a00001 	movgt	r0, #1
348037d0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (p <= 0);
348037d4:	e3500000 	cmp	r0, #0
348037d8:	c3a00000 	movgt	r0, #0
348037dc:	d3a00001 	movle	r0, #1
348037e0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (p >= 0);
348037e4:	e1e00000 	mvn	r0, r0
348037e8:	e1a00fa0 	lsr	r0, r0, #31
348037ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
348037f0:	e1a00005 	mov	r0, r5
348037f4:	e1a01007 	mov	r1, r7
348037f8:	ebffffa5 	bl	34803694 <evalexp>
	r = evalexp (t, w);
348037fc:	e1a01007 	mov	r1, r7

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
34803800:	e1a05000 	mov	r5, r0
	r = evalexp (t, w);
34803804:	e1a00004 	mov	r0, r4
34803808:	ebffffa1 	bl	34803694 <evalexp>

	switch (op) {
3480380c:	e3560005 	cmp	r6, #5
34803810:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
34803814:	ea000024 	b	348038ac <binary_test+0x1a8>
34803818:	34803830 	.word	0x34803830
3480381c:	34803840 	.word	0x34803840
34803820:	3480384c 	.word	0x3480384c
34803824:	3480385c 	.word	0x3480385c
34803828:	3480386c 	.word	0x3480386c
3480382c:	3480387c 	.word	0x3480387c
	case EQ: return (l == r);
34803830:	e1550000 	cmp	r5, r0
34803834:	13a00000 	movne	r0, #0
34803838:	03a00001 	moveq	r0, #1
3480383c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (l != r);
34803840:	e0550000 	subs	r0, r5, r0
34803844:	13a00001 	movne	r0, #1
34803848:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
3480384c:	e1550000 	cmp	r5, r0
34803850:	a3a00000 	movge	r0, #0
34803854:	b3a00001 	movlt	r0, #1
34803858:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (l > r);
3480385c:	e1550000 	cmp	r5, r0
34803860:	d3a00000 	movle	r0, #0
34803864:	c3a00001 	movgt	r0, #1
34803868:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (l <= r);
3480386c:	e1550000 	cmp	r5, r0
34803870:	c3a00000 	movgt	r0, #0
34803874:	d3a00001 	movle	r0, #1
34803878:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (l >= r);
3480387c:	e1550000 	cmp	r5, r0
34803880:	b3a00000 	movlt	r0, #0
34803884:	a3a00001 	movge	r0, #1
34803888:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {
3480388c:	e2866008 	add	r6, r6, #8
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
34803890:	e156000b 	cmp	r6, fp
34803894:	1affffa4 	bne	3480372c <binary_test+0x28>
				return (arithcomp (arg1, arg2, optp->opcode, w));
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
34803898:	e59f001c 	ldr	r0, [pc, #28]	; 348038bc <binary_test+0x1b8>
3480389c:	e1a01009 	mov	r1, r9
348038a0:	eb0018c4 	bl	34809bb8 <printf>
	case LT: return (p < 0);
	case GT: return (p > 0);
	case LE: return (p <= 0);
	case GE: return (p >= 0);
	}
	return (0);
348038a4:	e3a00000 	mov	r0, #0
348038a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
	case GT: return (l > r);
	case LE: return (l <= r);
	case GE: return (l >= r);
	}
	return (0);
348038ac:	e3a00000 	mov	r0, #0
		}
	}

	printf("Unknown operator '%s'\n", op);
	return 0;	/* op code not found */
}
348038b0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348038b4:	348204a8 	.word	0x348204a8
348038b8:	34820440 	.word	0x34820440
348038bc:	34823b8a 	.word	0x34823b8a

348038c0 <do_itest>:
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
348038c0:	e3520004 	cmp	r2, #4
	return 0;	/* op code not found */
}

/* command line interface to the shell test */
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
348038c4:	e92d4010 	push	{r4, lr}
348038c8:	e1a04003 	mov	r4, r3
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
348038cc:	1a00001e 	bne	3480394c <do_itest+0x8c>

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
348038d0:	e5930000 	ldr	r0, [r3]
348038d4:	e1a01002 	mov	r1, r2
348038d8:	eb0017d8 	bl	34809840 <cmd_get_data_size>
348038dc:	e2802002 	add	r2, r0, #2
348038e0:	e1a03000 	mov	r3, r0
348038e4:	e3520006 	cmp	r2, #6
348038e8:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
348038ec:	ea000010 	b	34803934 <do_itest+0x74>
348038f0:	3480391c 	.word	0x3480391c
348038f4:	34803934 	.word	0x34803934
348038f8:	34803934 	.word	0x34803934
348038fc:	3480390c 	.word	0x3480390c
34803900:	3480390c 	.word	0x3480390c
34803904:	34803934 	.word	0x34803934
34803908:	3480390c 	.word	0x3480390c
	case 1:
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
3480390c:	e5940008 	ldr	r0, [r4, #8]
34803910:	e5941004 	ldr	r1, [r4, #4]
34803914:	e594200c 	ldr	r2, [r4, #12]
34803918:	ea000003 	b	3480392c <do_itest+0x6c>
		break;
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
3480391c:	e5940008 	ldr	r0, [r4, #8]
34803920:	e5941004 	ldr	r1, [r4, #4]
34803924:	e594200c 	ldr	r2, [r4, #12]
34803928:	e3a03000 	mov	r3, #0
3480392c:	ebffff74 	bl	34803704 <binary_test>
		break;
34803930:	ea000002 	b	34803940 <do_itest+0x80>
	case -1:
	default:
		puts("Invalid data width specifier\n");
34803934:	e59f0018 	ldr	r0, [pc, #24]	; 34803954 <do_itest+0x94>
34803938:	eb001894 	bl	34809b90 <puts>
		value = 0;
3480393c:	e3a00000 	mov	r0, #0
		break;
	}

	return !value;
34803940:	e2700001 	rsbs	r0, r0, #1
34803944:	33a00000 	movcc	r0, #0
34803948:	e8bd8010 	pop	{r4, pc}
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
		return CMD_RET_USAGE;
3480394c:	e3e00000 	mvn	r0, #0
		value = 0;
		break;
	}

	return !value;
}
34803950:	e8bd8010 	pop	{r4, pc}
34803954:	34823ba1 	.word	0x34823ba1

34803958 <bin_data_init>:
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;

static void bin_data_init (void)
{
	os_data_state = 0;
34803958:	e59f3010 	ldr	r3, [pc, #16]	; 34803970 <bin_data_init+0x18>
3480395c:	e3a02000 	mov	r2, #0
34803960:	e5832000 	str	r2, [r3]
	os_data_addr = bin_start_address;
34803964:	e5932008 	ldr	r2, [r3, #8]
34803968:	e5832004 	str	r2, [r3, #4]
}
3480396c:	e12fff1e 	bx	lr
34803970:	34829cdc 	.word	0x34829cdc

34803974 <bin_data_char>:
	os_data_addr = os_data_addr_saved;
}

static void bin_data_char (char new_char)
{
	switch (os_data_state) {
34803974:	e59f3014 	ldr	r3, [pc, #20]	; 34803990 <bin_data_char+0x1c>
34803978:	e5932000 	ldr	r2, [r3]
3480397c:	e3520000 	cmp	r2, #0
	case 0:					/* data */
		*os_data_addr++ = new_char;
34803980:	05932004 	ldreq	r2, [r3, #4]
34803984:	04c20001 	strbeq	r0, [r2], #1
34803988:	05832004 	streq	r2, [r3, #4]
3480398c:	e12fff1e 	bx	lr
34803990:	34829cdc 	.word	0x34829cdc

34803994 <load_serial_ymodem>:
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
34803994:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34803998:	e24dde43 	sub	sp, sp, #1072	; 0x430
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
3480399c:	e28dae42 	add	sl, sp, #1056	; 0x420
348039a0:	e28aa00c 	add	sl, sl, #12
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
348039a4:	e3a03002 	mov	r3, #2
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
348039a8:	e1a06000 	mov	r6, r0
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
348039ac:	e1a0100a 	mov	r1, sl
348039b0:	e28d0e42 	add	r0, sp, #1056	; 0x420
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
348039b4:	e58d3424 	str	r3, [sp, #1060]	; 0x424
	res = xyzModem_stream_open (&info, &err);
348039b8:	eb002f45 	bl	3480f6d4 <xyzModem_stream_open>
	if (!res) {
348039bc:	e2505000 	subs	r5, r0, #0
348039c0:	01a04005 	moveq	r4, r5

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
348039c4:	01a0700d 	moveq	r7, sp
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {
348039c8:	0a000005 	beq	348039e4 <load_serial_ymodem+0x50>
348039cc:	ea00000b 	b	34803a00 <load_serial_ymodem+0x6c>

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
348039d0:	e0850006 	add	r0, r5, r6
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
348039d4:	e1a0100d 	mov	r1, sp
	if (!res) {

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
			size += res;
348039d8:	e0844002 	add	r4, r4, r2
			addr += res;
348039dc:	e0855002 	add	r5, r5, r2
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
348039e0:	eb0063e9 	bl	3481c98c <memcpy>
	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {

		while ((res =
348039e4:	e1a0200a 	mov	r2, sl
348039e8:	e1a0000d 	mov	r0, sp
348039ec:	e3a01b01 	mov	r1, #1024	; 0x400
348039f0:	eb002f89 	bl	3480f81c <xyzModem_stream_read>
348039f4:	e2502000 	subs	r2, r0, #0
348039f8:	cafffff4 	bgt	348039d0 <load_serial_ymodem+0x3c>
348039fc:	ea000005 	b	34803a18 <load_serial_ymodem+0x84>
					res);
			}

		}
	} else {
		printf ("%s\n", xyzModem_error (err));
34803a00:	e59d042c 	ldr	r0, [sp, #1068]	; 0x42c
34803a04:	eb003051 	bl	3480fb50 <xyzModem_error>
34803a08:	e1a01000 	mov	r1, r0
34803a0c:	e59f0064 	ldr	r0, [pc, #100]	; 34803a78 <load_serial_ymodem+0xe4>
34803a10:	eb001868 	bl	34809bb8 <printf>
	connection_info_t info;
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
34803a14:	e3a04000 	mov	r4, #0
		}
	} else {
		printf ("%s\n", xyzModem_error (err));
	}

	xyzModem_stream_close (&err);
34803a18:	e28d0e42 	add	r0, sp, #1056	; 0x420
34803a1c:	e280000c 	add	r0, r0, #12
34803a20:	eb003011 	bl	3480fa6c <xyzModem_stream_close>
	xyzModem_stream_terminate (false, &getcxmodem);
34803a24:	e3a00000 	mov	r0, #0
34803a28:	e59f104c 	ldr	r1, [pc, #76]	; 34803a7c <load_serial_ymodem+0xe8>
34803a2c:	eb003022 	bl	3480fabc <xyzModem_stream_terminate>


	flush_cache (offset, size);
34803a30:	e1a00006 	mov	r0, r6
34803a34:	e1a01004 	mov	r1, r4
34803a38:	ebfff5ca 	bl	34801168 <flush_cache>

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf (buf, "%X", size);
34803a3c:	e28d5b01 	add	r5, sp, #1024	; 0x400
	xyzModem_stream_terminate (false, &getcxmodem);


	flush_cache (offset, size);

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
34803a40:	e1a01004 	mov	r1, r4
34803a44:	e1a02004 	mov	r2, r4
34803a48:	e59f0030 	ldr	r0, [pc, #48]	; 34803a80 <load_serial_ymodem+0xec>
34803a4c:	eb001859 	bl	34809bb8 <printf>
	sprintf (buf, "%X", size);
34803a50:	e1a02004 	mov	r2, r4
34803a54:	e1a00005 	mov	r0, r5
34803a58:	e59f1024 	ldr	r1, [pc, #36]	; 34803a84 <load_serial_ymodem+0xf0>
34803a5c:	eb00673f 	bl	3481d760 <sprintf>
	setenv ("filesize", buf);
34803a60:	e1a01005 	mov	r1, r5
34803a64:	e59f001c 	ldr	r0, [pc, #28]	; 34803a88 <load_serial_ymodem+0xf4>
34803a68:	eb00105c 	bl	34807be0 <setenv>

	return offset;
}
34803a6c:	e1a00006 	mov	r0, r6
34803a70:	e28dde43 	add	sp, sp, #1072	; 0x430
34803a74:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34803a78:	34826164 	.word	0x34826164
34803a7c:	34803a8c 	.word	0x34803a8c
34803a80:	34823c3d 	.word	0x34823c3d
34803a84:	34823c65 	.word	0x34823c65
34803a88:	348234c1 	.word	0x348234c1

34803a8c <getcxmodem>:
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
34803a8c:	e92d4010 	push	{r4, lr}
	if (tstc())
34803a90:	eb00182b 	bl	34809b44 <tstc>
34803a94:	e3500000 	cmp	r0, #0
34803a98:	0a000001 	beq	34803aa4 <getcxmodem+0x18>
		return (getc());
	return -1;
}
34803a9c:	e8bd4010 	pop	{r4, lr}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
	if (tstc())
		return (getc());
34803aa0:	ea00181e 	b	34809b20 <getc>
	return -1;
}
34803aa4:	e3e00000 	mvn	r0, #0
34803aa8:	e8bd8010 	pop	{r4, pc}

34803aac <load_serial>:
	return rcode;
}

static ulong
load_serial (long offset)
{
34803aac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;
34803ab0:	e3a05000 	mov	r5, #0
	return rcode;
}

static ulong
load_serial (long offset)
{
34803ab4:	e24ddd0d 	sub	sp, sp, #832	; 0x340
34803ab8:	e58d000c 	str	r0, [sp, #12]
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
34803abc:	e1a07005 	mov	r7, r5
	int	type;				/* return code for record type	*/
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
34803ac0:	e3e04000 	mvn	r4, #0
#endif
	return rcode;
}

static ulong
load_serial (long offset)
34803ac4:	e28d9f85 	add	r9, sp, #532	; 0x214

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
		if (do_echo)
34803ac8:	e59f61dc 	ldr	r6, [pc, #476]	; 34803cac <load_serial+0x200>
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
34803acc:	e1a0b005 	mov	fp, r5
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803ad0:	ea000044 	b	34803be8 <load_serial+0x13c>
		type = srec_decode (record, &binlen, &addr, binbuf);
34803ad4:	e28d0010 	add	r0, sp, #16
34803ad8:	e28d1fcf 	add	r1, sp, #828	; 0x33c
34803adc:	e28d2fce 	add	r2, sp, #824	; 0x338
34803ae0:	e28d3f86 	add	r3, sp, #536	; 0x218
34803ae4:	eb002c65 	bl	3480ec80 <srec_decode>

		if (type < 0) {
34803ae8:	e3500000 	cmp	r0, #0
34803aec:	ba00006b 	blt	34803ca0 <load_serial+0x1f4>
			return (~0);		/* Invalid S-Record		*/
		}

		switch (type) {
34803af0:	e2400001 	sub	r0, r0, #1
34803af4:	e3500008 	cmp	r0, #8
34803af8:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
34803afc:	ea00002e 	b	34803bbc <load_serial+0x110>
34803b00:	34803b24 	.word	0x34803b24
34803b04:	34803b24 	.word	0x34803b24
34803b08:	34803b24 	.word	0x34803b24
34803b0c:	34803bbc 	.word	0x34803bbc
34803b10:	34803bbc 	.word	0x34803bbc
34803b14:	34803bbc 	.word	0x34803bbc
34803b18:	34803b60 	.word	0x34803b60
34803b1c:	34803b60 	.word	0x34803b60
34803b20:	34803b60 	.word	0x34803b60
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
34803b24:	e59d200c 	ldr	r2, [sp, #12]
34803b28:	e59da338 	ldr	sl, [sp, #824]	; 0x338
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
34803b2c:	e28d1f86 	add	r1, sp, #536	; 0x218

		switch (type) {
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
34803b30:	e082a00a 	add	sl, r2, sl
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
34803b34:	e1a0000a 	mov	r0, sl
34803b38:	e59d233c 	ldr	r2, [sp, #828]	; 0x33c
34803b3c:	eb006392 	bl	3481c98c <memcpy>
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
34803b40:	e59d333c 	ldr	r3, [sp, #828]	; 0x33c
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
34803b44:	e154000a 	cmp	r4, sl
34803b48:	21a0400a 	movcs	r4, sl
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
34803b4c:	e2433001 	sub	r3, r3, #1
34803b50:	e083a00a 	add	sl, r3, sl
34803b54:	e157000a 	cmp	r7, sl
34803b58:	31a0700a 	movcc	r7, sl
34803b5c:	ea000016 	b	34803bbc <load_serial+0x110>
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
		    size = end_addr - start_addr + 1;
34803b60:	e2875001 	add	r5, r7, #1
34803b64:	e0645005 	rsb	r5, r4, r5
			end_addr = store_addr + binlen - 1;
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
34803b68:	e3020710 	movw	r0, #10000	; 0x2710
34803b6c:	eb006411 	bl	3481cbb8 <udelay>
		    size = end_addr - start_addr + 1;
		    printf ("\n"
34803b70:	e1a03005 	mov	r3, r5
34803b74:	e1a01004 	mov	r1, r4
34803b78:	e1a02007 	mov	r2, r7
34803b7c:	e59f012c 	ldr	r0, [pc, #300]	; 34803cb0 <load_serial+0x204>
34803b80:	e58d5000 	str	r5, [sp]
34803b84:	eb00180b 	bl	34809bb8 <printf>
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803b88:	e1a00004 	mov	r0, r4
34803b8c:	e1a01005 	mov	r1, r5
		    sprintf(buf, "%lX", size);
34803b90:	e28d4fc6 	add	r4, sp, #792	; 0x318
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803b94:	ebfff573 	bl	34801168 <flush_cache>
		    sprintf(buf, "%lX", size);
34803b98:	e59f1114 	ldr	r1, [pc, #276]	; 34803cb4 <load_serial+0x208>
34803b9c:	e1a02005 	mov	r2, r5
34803ba0:	e1a00004 	mov	r0, r4
34803ba4:	eb0066ed 	bl	3481d760 <sprintf>
		    setenv("filesize", buf);
34803ba8:	e59f0108 	ldr	r0, [pc, #264]	; 34803cb8 <load_serial+0x20c>
34803bac:	e1a01004 	mov	r1, r4
34803bb0:	eb00100a 	bl	34807be0 <setenv>
		    return (addr);
34803bb4:	e59d0338 	ldr	r0, [sp, #824]	; 0x338
34803bb8:	ea000039 	b	34803ca4 <load_serial+0x1f8>
		case SREC_START:
		    break;
		default:
		    break;
		}
		if (!do_echo) {	/* print a '.' every 100 lines */
34803bbc:	e5963000 	ldr	r3, [r6]
34803bc0:	e3530000 	cmp	r3, #0
34803bc4:	1a000007 	bne	34803be8 <load_serial+0x13c>
			if ((++line_count % 100) == 0)
34803bc8:	e2855001 	add	r5, r5, #1
34803bcc:	e1a00005 	mov	r0, r5
34803bd0:	e3a01064 	mov	r1, #100	; 0x64
34803bd4:	eb0071bf 	bl	348202d8 <__aeabi_idivmod>
34803bd8:	e3510000 	cmp	r1, #0
34803bdc:	1a000001 	bne	34803be8 <load_serial+0x13c>
				putc ('.');
34803be0:	e3a0002e 	mov	r0, #46	; 0x2e
34803be4:	eb0017df 	bl	34809b68 <putc>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803be8:	e28d3010 	add	r3, sp, #16
34803bec:	e58d5008 	str	r5, [sp, #8]
34803bf0:	e1a05004 	mov	r5, r4
34803bf4:	e1a04003 	mov	r4, r3
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803bf8:	eb0017c8 	bl	34809b20 <getc>
		if (do_echo)
34803bfc:	e5963000 	ldr	r3, [r6]
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803c00:	e6efa070 	uxtb	sl, r0
		if (do_echo)
34803c04:	e3530000 	cmp	r3, #0
34803c08:	0a000001 	beq	34803c14 <load_serial+0x168>
			putc (c);	/* ... and echo it		*/
34803c0c:	e1a0000a 	mov	r0, sl
34803c10:	eb0017d4 	bl	34809b68 <putc>

		switch (c) {
34803c14:	e35a0003 	cmp	sl, #3
34803c18:	0a000020 	beq	34803ca0 <load_serial+0x1f4>
34803c1c:	8a000002 	bhi	34803c2c <load_serial+0x180>
34803c20:	e35a0000 	cmp	sl, #0
34803c24:	0a00001d 	beq	34803ca0 <load_serial+0x1f4>
34803c28:	ea00000a 	b	34803c58 <load_serial+0x1ac>
34803c2c:	e35a000a 	cmp	sl, #10
34803c30:	0a000001 	beq	34803c3c <load_serial+0x190>
34803c34:	e35a000d 	cmp	sl, #13
34803c38:	1a000006 	bne	34803c58 <load_serial+0x1ac>
34803c3c:	e1a03004 	mov	r3, r4
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803c40:	e28d2010 	add	r2, sp, #16
34803c44:	e1a04005 	mov	r4, r5
34803c48:	e59d5008 	ldr	r5, [sp, #8]
			putc (c);	/* ... and echo it		*/

		switch (c) {
		case '\r':
		case '\n':
			*p = '\0';
34803c4c:	e5c3b000 	strb	fp, [r3]
			return (p - buf);
34803c50:	e0623003 	rsb	r3, r2, r3
34803c54:	ea00000f 	b	34803c98 <load_serial+0x1ec>
		case '\0':
		case 0x03:			/* ^C - Control C		*/
			return (-1);
		default:
			*p = c;
34803c58:	e4c4a001 	strb	sl, [r4], #1
		}

	    /* Check for the console hangup (if any different from serial) */
	    if (gd->jt[XF_getc] != getc) {
34803c5c:	e5983054 	ldr	r3, [r8, #84]	; 0x54
34803c60:	e59f2054 	ldr	r2, [pc, #84]	; 34803cbc <load_serial+0x210>
34803c64:	e5933004 	ldr	r3, [r3, #4]
34803c68:	e1530002 	cmp	r3, r2
34803c6c:	0a000002 	beq	34803c7c <load_serial+0x1d0>
		if (ctrlc()) {
34803c70:	eb0017f5 	bl	34809c4c <ctrlc>
34803c74:	e3500000 	cmp	r0, #0
34803c78:	1a000008 	bne	34803ca0 <load_serial+0x1f4>
	char *p;
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
34803c7c:	e1540009 	cmp	r4, r9
34803c80:	1affffdc 	bne	34803bf8 <load_serial+0x14c>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803c84:	e28d3010 	add	r3, sp, #16
34803c88:	e1a04005 	mov	r4, r5
	    }
	}

	/* line too long - truncate */
	*p = '\0';
	return (p - buf);
34803c8c:	e0633009 	rsb	r3, r3, r9
34803c90:	e59d5008 	ldr	r5, [sp, #8]
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
34803c94:	e5c9b000 	strb	fp, [r9]
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803c98:	e3530000 	cmp	r3, #0
34803c9c:	aaffff8c 	bge	34803ad4 <load_serial+0x28>
			if ((++line_count % 100) == 0)
				putc ('.');
		}
	}

	return (~0);			/* Download aborted		*/
34803ca0:	e3e00000 	mvn	r0, #0
}
34803ca4:	e28ddd0d 	add	sp, sp, #832	; 0x340
34803ca8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34803cac:	348286b0 	.word	0x348286b0
34803cb0:	34823c68 	.word	0x34823c68
34803cb4:	348234bd 	.word	0x348234bd
34803cb8:	348234c1 	.word	0x348234c1
34803cbc:	34809b20 	.word	0x34809b20

34803cc0 <do_load_serial>:

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803cc0:	e92d4038 	push	{r3, r4, r5, lr}
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803cc4:	e59f00b8 	ldr	r0, [pc, #184]	; 34803d84 <do_load_serial+0xc4>

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803cc8:	e1a04002 	mov	r4, r2
34803ccc:	e1a05003 	mov	r5, r3
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803cd0:	eb0010ca 	bl	34808000 <getenv>
34803cd4:	e3500000 	cmp	r0, #0
34803cd8:	0a000003 	beq	34803cec <do_load_serial+0x2c>
34803cdc:	e5d03000 	ldrb	r3, [r0]
34803ce0:	e3530031 	cmp	r3, #49	; 0x31
		do_echo = 1;
34803ce4:	03a02001 	moveq	r2, #1
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803ce8:	0a000000 	beq	34803cf0 <do_load_serial+0x30>
		do_echo = 1;
	} else {
		do_echo = 0;
34803cec:	e3a02000 	mov	r2, #0
34803cf0:	e59f3090 	ldr	r3, [pc, #144]	; 34803d88 <do_load_serial+0xc8>
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803cf4:	e3540002 	cmp	r4, #2
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
		do_echo = 1;
	} else {
		do_echo = 0;
34803cf8:	e5832000 	str	r2, [r3]
/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	long offset = 0;
34803cfc:	13a04000 	movne	r4, #0
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803d00:	1a000004 	bne	34803d18 <do_load_serial+0x58>
		offset = simple_strtol(argv[1], NULL, 16);
34803d04:	e5950004 	ldr	r0, [r5, #4]
34803d08:	e3a01000 	mov	r1, #0
34803d0c:	e3a02010 	mov	r2, #16
34803d10:	eb006635 	bl	3481d5ec <simple_strtol>
34803d14:	e1a04000 	mov	r4, r0
	}
#endif	/* CONFIG_SYS_LOADS_BAUD_CHANGE */

	printf ("## Ready for S-Record download ...\n");
34803d18:	e59f006c 	ldr	r0, [pc, #108]	; 34803d8c <do_load_serial+0xcc>
34803d1c:	eb0017a5 	bl	34809bb8 <printf>

	addr = load_serial (offset);
34803d20:	e1a00004 	mov	r0, r4
34803d24:	ebffff60 	bl	34803aac <load_serial>
34803d28:	e3a04064 	mov	r4, #100	; 0x64
34803d2c:	e1a05000 	mov	r5, r0
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
34803d30:	eb001783 	bl	34809b44 <tstc>
34803d34:	e3500000 	cmp	r0, #0
34803d38:	0a000000 	beq	34803d40 <do_load_serial+0x80>
			(void) getc();
34803d3c:	eb001777 	bl	34809b20 <getc>
		}
		udelay(1000);
34803d40:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34803d44:	eb00639b 	bl	3481cbb8 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
34803d48:	e2544001 	subs	r4, r4, #1
34803d4c:	1afffff7 	bne	34803d30 <do_load_serial+0x70>
			(void) getc();
		}
		udelay(1000);
	}

	if (addr == ~0) {
34803d50:	e3750001 	cmn	r5, #1
34803d54:	1a000003 	bne	34803d68 <do_load_serial+0xa8>
		printf ("## S-Record download aborted\n");
34803d58:	e59f0030 	ldr	r0, [pc, #48]	; 34803d90 <do_load_serial+0xd0>
34803d5c:	eb001795 	bl	34809bb8 <printf>
		rcode = 1;
34803d60:	e3a00001 	mov	r0, #1
34803d64:	e8bd8038 	pop	{r3, r4, r5, pc}
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
34803d68:	e1a01005 	mov	r1, r5
34803d6c:	e59f0020 	ldr	r0, [pc, #32]	; 34803d94 <do_load_serial+0xd4>
34803d70:	eb001790 	bl	34809bb8 <printf>
		load_addr = addr;
34803d74:	e59f301c 	ldr	r3, [pc, #28]	; 34803d98 <do_load_serial+0xd8>
{
	long offset = 0;
	ulong addr;
	int i;
	char *env_echo;
	int rcode = 0;
34803d78:	e1a00004 	mov	r0, r4
	if (addr == ~0) {
		printf ("## S-Record download aborted\n");
		rcode = 1;
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
		load_addr = addr;
34803d7c:	e5835000 	str	r5, [r3]
				break;
		}
	}
#endif
	return rcode;
}
34803d80:	e8bd8038 	pop	{r3, r4, r5, pc}
34803d84:	34823ccd 	.word	0x34823ccd
34803d88:	348286b0 	.word	0x348286b0
34803d8c:	34823cd8 	.word	0x34823cd8
34803d90:	34823cfc 	.word	0x34823cfc
34803d94:	34823d1a 	.word	0x34823d1a
34803d98:	34828780 	.word	0x34828780

34803d9c <send_pad>:

	return offset;
}

void send_pad (void)
{
34803d9c:	e92d4038 	push	{r3, r4, r5, lr}
34803da0:	e59f501c 	ldr	r5, [pc, #28]	; 34803dc4 <send_pad+0x28>
34803da4:	e595400c 	ldr	r4, [r5, #12]
	int count = his_pad_count;

	while (count-- > 0)
34803da8:	ea000002 	b	34803db8 <send_pad+0x1c>
		putc (his_pad_char);
34803dac:	e5d50010 	ldrb	r0, [r5, #16]
34803db0:	eb00176c 	bl	34809b68 <putc>
34803db4:	e2444001 	sub	r4, r4, #1

void send_pad (void)
{
	int count = his_pad_count;

	while (count-- > 0)
34803db8:	e3540000 	cmp	r4, #0
34803dbc:	cafffffa 	bgt	34803dac <send_pad+0x10>
		putc (his_pad_char);
}
34803dc0:	e8bd8038 	pop	{r3, r4, r5, pc}
34803dc4:	34829cdc 	.word	0x34829cdc

34803dc8 <ktrans>:

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803dc8:	e2003060 	and	r3, r0, #96	; 0x60
34803dcc:	e3530040 	cmp	r3, #64	; 0x40
		return (char) (in & ~0x40);
34803dd0:	020000bf 	andeq	r0, r0, #191	; 0xbf
}

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803dd4:	012fff1e 	bxeq	lr
		return (char) (in & ~0x40);
	} else if ((in & 0x7f) == 0x3f) {
34803dd8:	e200307f 	and	r3, r0, #127	; 0x7f
34803ddc:	e353003f 	cmp	r3, #63	; 0x3f
		return (char) (in | 0x40);
34803de0:	03800040 	orreq	r0, r0, #64	; 0x40
	} else
		return in;
}
34803de4:	e12fff1e 	bx	lr

34803de8 <chk1>:

int chk1 (char *buffer)
{
	int total = 0;
34803de8:	e3a03000 	mov	r3, #0

	while (*buffer) {
34803dec:	ea000000 	b	34803df4 <chk1+0xc>
		total += *buffer++;
34803df0:	e0833002 	add	r3, r3, r2

int chk1 (char *buffer)
{
	int total = 0;

	while (*buffer) {
34803df4:	e4d02001 	ldrb	r2, [r0], #1
34803df8:	e3520000 	cmp	r2, #0
34803dfc:	1afffffb 	bne	34803df0 <chk1+0x8>
		total += *buffer++;
	}
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
34803e00:	e7e12353 	ubfx	r2, r3, #6, #2
34803e04:	e0823003 	add	r3, r2, r3
}
34803e08:	e203003f 	and	r0, r3, #63	; 0x3f
34803e0c:	e12fff1e 	bx	lr

34803e10 <s1_sendpacket>:

void s1_sendpacket (char *packet)
{
34803e10:	e92d4010 	push	{r4, lr}
34803e14:	e1a04000 	mov	r4, r0
	send_pad ();
34803e18:	ebffffdf 	bl	34803d9c <send_pad>
	while (*packet) {
34803e1c:	ea000000 	b	34803e24 <s1_sendpacket+0x14>
		putc (*packet++);
34803e20:	eb001750 	bl	34809b68 <putc>
}

void s1_sendpacket (char *packet)
{
	send_pad ();
	while (*packet) {
34803e24:	e4d40001 	ldrb	r0, [r4], #1
34803e28:	e3500000 	cmp	r0, #0
34803e2c:	1afffffb 	bne	34803e20 <s1_sendpacket+0x10>
		putc (*packet++);
	}
}
34803e30:	e8bd8010 	pop	{r4, pc}

34803e34 <send_ack>:

static char a_b[24];
void send_ack (int n)
{
34803e34:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803e38:	e59f404c 	ldr	r4, [pc, #76]	; 34803e8c <send_ack+0x58>
34803e3c:	e3a03001 	mov	r3, #1
34803e40:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
34803e44:	e2800020 	add	r0, r0, #32

static char a_b[24];
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
34803e48:	e2833022 	add	r3, r3, #34	; 0x22
34803e4c:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803e50:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = ACK_TYPE;
34803e54:	e2833036 	add	r3, r3, #54	; 0x36
	a_b[4] = '\0';
34803e58:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
34803e5c:	e2840015 	add	r0, r4, #21
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
34803e60:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
34803e64:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803e68:	ebffffde 	bl	34803de8 <chk1>
34803e6c:	e2800020 	add	r0, r0, #32
34803e70:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
34803e74:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803e78:	e59f0010 	ldr	r0, [pc, #16]	; 34803e90 <send_ack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
34803e7c:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803e80:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803e84:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803e88:	eaffffe0 	b	34803e10 <s1_sendpacket>
34803e8c:	34829cdc 	.word	0x34829cdc
34803e90:	34829cf0 	.word	0x34829cf0

34803e94 <send_nack>:
}

void send_nack (int n)
{
34803e94:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803e98:	e59f404c 	ldr	r4, [pc, #76]	; 34803eec <send_nack+0x58>
34803e9c:	e3a03001 	mov	r3, #1
34803ea0:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
34803ea4:	e2800020 	add	r0, r0, #32
}

void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
34803ea8:	e2833022 	add	r3, r3, #34	; 0x22
34803eac:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803eb0:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = NACK_TYPE;
34803eb4:	e283302b 	add	r3, r3, #43	; 0x2b
	a_b[4] = '\0';
34803eb8:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
34803ebc:	e2840015 	add	r0, r4, #21
void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
34803ec0:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
34803ec4:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803ec8:	ebffffc6 	bl	34803de8 <chk1>
34803ecc:	e2800020 	add	r0, r0, #32
34803ed0:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
34803ed4:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803ed8:	e59f0010 	ldr	r0, [pc, #16]	; 34803ef0 <send_nack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
34803edc:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803ee0:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803ee4:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803ee8:	eaffffc8 	b	34803e10 <s1_sendpacket>
34803eec:	34829cdc 	.word	0x34829cdc
34803ef0:	34829cf0 	.word	0x34829cf0

34803ef4 <k_data_init>:


/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
void k_data_init (void)
{
34803ef4:	e92d4008 	push	{r3, lr}
	k_data_escape = 0;
34803ef8:	e59f3010 	ldr	r3, [pc, #16]	; 34803f10 <k_data_init+0x1c>
34803efc:	e3a02000 	mov	r2, #0
34803f00:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_init ();
34803f04:	e5933034 	ldr	r3, [r3, #52]	; 0x34
34803f08:	e12fff33 	blx	r3
}
34803f0c:	e8bd8008 	pop	{r3, pc}
34803f10:	34829cdc 	.word	0x34829cdc

34803f14 <k_data_save>:

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
34803f14:	e59f3018 	ldr	r3, [pc, #24]	; 34803f34 <k_data_save+0x20>
34803f18:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34803f1c:	e5832038 	str	r2, [r3, #56]	; 0x38
	os_data_addr = bin_start_address;
}

static void os_data_save (void)
{
	os_data_state_saved = os_data_state;
34803f20:	e5932000 	ldr	r2, [r3]
34803f24:	e583203c 	str	r2, [r3, #60]	; 0x3c
	os_data_addr_saved = os_data_addr;
34803f28:	e5932004 	ldr	r2, [r3, #4]
34803f2c:	e5832040 	str	r2, [r3, #64]	; 0x40

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
	os_data_save ();
}
34803f30:	e12fff1e 	bx	lr
34803f34:	34829cdc 	.word	0x34829cdc

34803f38 <k_data_restore>:

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
34803f38:	e59f3018 	ldr	r3, [pc, #24]	; 34803f58 <k_data_restore+0x20>
34803f3c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
34803f40:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_addr_saved = os_data_addr;
}

static void os_data_restore (void)
{
	os_data_state = os_data_state_saved;
34803f44:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
34803f48:	e5832000 	str	r2, [r3]
	os_data_addr = os_data_addr_saved;
34803f4c:	e5932040 	ldr	r2, [r3, #64]	; 0x40
34803f50:	e5832004 	str	r2, [r3, #4]

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
	os_data_restore ();
}
34803f54:	e12fff1e 	bx	lr
34803f58:	34829cdc 	.word	0x34829cdc

34803f5c <k_data_char>:

void k_data_char (char new_char)
{
34803f5c:	e92d4010 	push	{r4, lr}
	if (k_data_escape) {
34803f60:	e59f4040 	ldr	r4, [pc, #64]	; 34803fa8 <k_data_char+0x4c>
34803f64:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34803f68:	e3520000 	cmp	r2, #0
34803f6c:	0a000004 	beq	34803f84 <k_data_char+0x28>
		/* last char was escape - translate this character */
		os_data_char (ktrans (new_char));
34803f70:	ebffff94 	bl	34803dc8 <ktrans>
34803f74:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34803f78:	e12fff33 	blx	r3
		k_data_escape = 0;
34803f7c:	e3a03000 	mov	r3, #0
34803f80:	ea000003 	b	34803f94 <k_data_char+0x38>
	} else {
		if (new_char == his_quote) {
34803f84:	e5d42048 	ldrb	r2, [r4, #72]	; 0x48
34803f88:	e1520000 	cmp	r2, r0
34803f8c:	1a000002 	bne	34803f9c <k_data_char+0x40>
			/* this char is escape - remember */
			k_data_escape = 1;
34803f90:	e3a03001 	mov	r3, #1
34803f94:	e5843030 	str	r3, [r4, #48]	; 0x30
34803f98:	e8bd8010 	pop	{r4, pc}
		} else {
			/* otherwise send this char as-is */
			os_data_char (new_char);
34803f9c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34803fa0:	e12fff33 	blx	r3
34803fa4:	e8bd8010 	pop	{r4, pc}
34803fa8:	34829cdc 	.word	0x34829cdc

34803fac <handle_send_packet>:
{
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34803fac:	e59f31b8 	ldr	r3, [pc, #440]	; 3480416c <handle_send_packet+0x1c0>
34803fb0:	e3a0200d 	mov	r2, #13
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803fb4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34803fb8:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
	his_pad_count = 0;
34803fbc:	e3a02000 	mov	r2, #0
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803fc0:	e593104c 	ldr	r1, [r3, #76]	; 0x4c
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34803fc4:	e583200c 	str	r2, [r3, #12]
	his_pad_char = '\0';
34803fc8:	e5c32010 	strb	r2, [r3, #16]
	his_quote = K_ESCAPE;
34803fcc:	e2822023 	add	r2, r2, #35	; 0x23
34803fd0:	e5c32048 	strb	r2, [r3, #72]	; 0x48

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803fd4:	e2832063 	add	r2, r3, #99	; 0x63
34803fd8:	e1510002 	cmp	r1, r2
		--send_ptr;
34803fdc:	02832062 	addeq	r2, r3, #98	; 0x62
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803fe0:	e59f4184 	ldr	r4, [pc, #388]	; 3480416c <handle_send_packet+0x1c0>
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
34803fe4:	0583204c 	streq	r2, [r3, #76]	; 0x4c
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803fe8:	e594504c 	ldr	r5, [r4, #76]	; 0x4c
34803fec:	e2843050 	add	r3, r4, #80	; 0x50
34803ff0:	e0635005 	rsb	r5, r3, r5
	do {
		if (bytes-- <= 0)
34803ff4:	e3550000 	cmp	r5, #0
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803ff8:	e1a07000 	mov	r7, r0
	int length = 3;
34803ffc:	d3a06003 	movle	r6, #3
	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
	do {
		if (bytes-- <= 0)
34804000:	da000040 	ble	34804108 <handle_send_packet+0x15c>
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
34804004:	e3a0307e 	mov	r3, #126	; 0x7e
		if (bytes-- <= 0)
34804008:	e2555001 	subs	r5, r5, #1
	do {
		if (bytes-- <= 0)
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
3480400c:	e5c43018 	strb	r3, [r4, #24]
34804010:	03a06004 	moveq	r6, #4
		if (bytes-- <= 0)
34804014:	0a00003b 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
34804018:	e3a03021 	mov	r3, #33	; 0x21
		if (bytes-- <= 0)
3480401c:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (94);
		if (bytes-- <= 0)
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
34804020:	e5c43019 	strb	r3, [r4, #25]
34804024:	03a06005 	moveq	r6, #5
		if (bytes-- <= 0)
34804028:	0a000036 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
3480402c:	e5d43052 	ldrb	r3, [r4, #82]	; 0x52
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
34804030:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (1);
		if (bytes-- <= 0)
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
34804034:	e2433020 	sub	r3, r3, #32
34804038:	e20330ff 	and	r3, r3, #255	; 0xff
3480403c:	e584300c 	str	r3, [r4, #12]
		a_b[++length] = tochar (0);
34804040:	e3a03020 	mov	r3, #32
34804044:	e5c4301a 	strb	r3, [r4, #26]
34804048:	03a06006 	moveq	r6, #6
		if (bytes-- <= 0)
3480404c:	0a00002d 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
34804050:	e5d40053 	ldrb	r0, [r4, #83]	; 0x53
34804054:	ebffff5b 	bl	34803dc8 <ktrans>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
34804058:	e2455001 	sub	r5, r5, #1
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
		a_b[++length] = 0x40;	/* He should ignore this */
3480405c:	e3a03040 	mov	r3, #64	; 0x40
		if (bytes-- <= 0)
34804060:	e3550000 	cmp	r5, #0
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
34804064:	e5c40010 	strb	r0, [r4, #16]
		a_b[++length] = 0x40;	/* He should ignore this */
34804068:	e5c4301b 	strb	r3, [r4, #27]
3480406c:	03a06007 	moveq	r6, #7
		if (bytes-- <= 0)
34804070:	0a000024 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
34804074:	e5d43054 	ldrb	r3, [r4, #84]	; 0x54
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
34804078:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 0x40;	/* He should ignore this */
		if (bytes-- <= 0)
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
3480407c:	e2433020 	sub	r3, r3, #32
34804080:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
		a_b[++length] = tochar (END_CHAR);
34804084:	e3a0302d 	mov	r3, #45	; 0x2d
34804088:	e5c4301c 	strb	r3, [r4, #28]
3480408c:	03a06008 	moveq	r6, #8
		if (bytes-- <= 0)
34804090:	0a00001c 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
34804094:	e5d43055 	ldrb	r3, [r4, #85]	; 0x55
		a_b[++length] = '#';
		if (bytes-- <= 0)
34804098:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
3480409c:	e5c43048 	strb	r3, [r4, #72]	; 0x48
		a_b[++length] = '#';
348040a0:	e3a03023 	mov	r3, #35	; 0x23
348040a4:	e5c4301d 	strb	r3, [r4, #29]
348040a8:	03a06009 	moveq	r6, #9
		if (bytes-- <= 0)
348040ac:	0a000015 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
348040b0:	e283302b 	add	r3, r3, #43	; 0x2b
		if (bytes-- <= 0)
348040b4:	e2555001 	subs	r5, r5, #1
		a_b[++length] = '#';
		if (bytes-- <= 0)
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
348040b8:	e5c4301e 	strb	r3, [r4, #30]
348040bc:	03a0600a 	moveq	r6, #10
		if (bytes-- <= 0)
348040c0:	0a000010 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
348040c4:	e3a02031 	mov	r2, #49	; 0x31
		if (bytes-- <= 0)
348040c8:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 'N';
		if (bytes-- <= 0)
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
348040cc:	e5c4201f 	strb	r2, [r4, #31]
348040d0:	03a0600b 	moveq	r6, #11
		if (bytes-- <= 0)
348040d4:	0a00000b 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
		if (bytes-- <= 0)
348040d8:	e3550001 	cmp	r5, #1
		a_b[++length] = '1';
		if (bytes-- <= 0)
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
348040dc:	e5c43020 	strb	r3, [r4, #32]
348040e0:	03a0600c 	moveq	r6, #12
		if (bytes-- <= 0)
348040e4:	0a000007 	beq	34804108 <handle_send_packet+0x15c>
			break;
		/* handle CAPAS - the capabilities mask */
		/* ignore what he says - I only do long packets - I don't do windows */
		a_b[++length] = tochar (2);	/* only long packets */
348040e8:	e3a02022 	mov	r2, #34	; 0x22
348040ec:	e5c42021 	strb	r2, [r4, #33]	; 0x21
		a_b[++length] = tochar (0);	/* no windows */
348040f0:	e3a02020 	mov	r2, #32
348040f4:	e5c42022 	strb	r2, [r4, #34]	; 0x22
		a_b[++length] = tochar (94);	/* large packet msb */
348040f8:	e282205e 	add	r2, r2, #94	; 0x5e
348040fc:	e5c42023 	strb	r2, [r4, #35]	; 0x23
		a_b[++length] = tochar (94);	/* large packet lsb */
34804100:	e5c42024 	strb	r2, [r4, #36]	; 0x24
34804104:	e3a06010 	mov	r6, #16
	} while (0);

	a_b[0] = START_CHAR;
34804108:	e59f405c 	ldr	r4, [pc, #92]	; 3480416c <handle_send_packet+0x1c0>
3480410c:	e3a03001 	mov	r3, #1
34804110:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
34804114:	e2877020 	add	r7, r7, #32
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
34804118:	e2863020 	add	r3, r6, #32
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
3480411c:	e2866001 	add	r6, r6, #1
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
34804120:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34804124:	e5c47016 	strb	r7, [r4, #22]
	a_b[3] = ACK_TYPE;
34804128:	e3a03059 	mov	r3, #89	; 0x59
	a_b[++length] = '\0';
3480412c:	e0847006 	add	r7, r4, r6
34804130:	e3a05000 	mov	r5, #0
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
34804134:	e5c43017 	strb	r3, [r4, #23]
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804138:	e2840015 	add	r0, r4, #21

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
3480413c:	e5c75014 	strb	r5, [r7, #20]
	a_b[length] = tochar (chk1 (&a_b[1]));
34804140:	ebffff28 	bl	34803de8 <chk1>
	a_b[++length] = his_eol;
34804144:	e2866001 	add	r6, r6, #1
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804148:	e2800020 	add	r0, r0, #32
	a_b[++length] = his_eol;
3480414c:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804150:	e5c70014 	strb	r0, [r7, #20]
	a_b[++length] = his_eol;
34804154:	e0846006 	add	r6, r4, r6
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
34804158:	e2840014 	add	r0, r4, #20
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
3480415c:	e5c63014 	strb	r3, [r6, #20]
	a_b[++length] = '\0';
34804160:	e5c65015 	strb	r5, [r6, #21]
	s1_sendpacket (a_b);
}
34804164:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
34804168:	eaffff28 	b	34803e10 <s1_sendpacket>
3480416c:	34829cdc 	.word	0x34829cdc

34804170 <do_load_serial_bin>:
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804170:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34804174:	e59f0404 	ldr	r0, [pc, #1028]	; 34804580 <do_load_serial_bin+0x410>
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804178:	e24dd028 	sub	sp, sp, #40	; 0x28
3480417c:	e1a05002 	mov	r5, r2
34804180:	e1a06003 	mov	r6, r3

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34804184:	eb000f9d 	bl	34808000 <getenv>
34804188:	e3500000 	cmp	r0, #0
	int load_baudrate, current_baudrate;
	int rcode = 0;
	char *s;

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;
3480418c:	03a04309 	moveq	r4, #603979776	; 0x24000000

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34804190:	0a000003 	beq	348041a4 <do_load_serial_bin+0x34>
		offset = simple_strtoul(s, NULL, 16);
34804194:	e3a01000 	mov	r1, #0
34804198:	e3a02010 	mov	r2, #16
3480419c:	eb0064c9 	bl	3481d4c8 <simple_strtoul>
348041a0:	e1a04000 	mov	r4, r0
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
348041a4:	e3550001 	cmp	r5, #1
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
348041a8:	e5987008 	ldr	r7, [r8, #8]

	if (argc >= 2) {
348041ac:	da0000eb 	ble	34804560 <do_load_serial_bin+0x3f0>
		offset = simple_strtoul(argv[1], NULL, 16);
348041b0:	e5960004 	ldr	r0, [r6, #4]
348041b4:	e3a01000 	mov	r1, #0
348041b8:	e3a02010 	mov	r2, #16
348041bc:	eb0064c1 	bl	3481d4c8 <simple_strtoul>
	}
	if (argc == 3) {
348041c0:	e3550003 	cmp	r5, #3
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
		offset = simple_strtoul(argv[1], NULL, 16);
348041c4:	e1a04000 	mov	r4, r0
	}
	if (argc == 3) {
348041c8:	1a0000e4 	bne	34804560 <do_load_serial_bin+0x3f0>
		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
348041cc:	e5960008 	ldr	r0, [r6, #8]
348041d0:	e3a01000 	mov	r1, #0
348041d4:	e3a0200a 	mov	r2, #10
348041d8:	eb0064ba 	bl	3481d4c8 <simple_strtoul>

		/* default to current baudrate */
		if (load_baudrate == 0)
348041dc:	e2505000 	subs	r5, r0, #0
348041e0:	0a0000de 	beq	34804560 <do_load_serial_bin+0x3f0>
			load_baudrate = current_baudrate;
	}

	if (load_baudrate != current_baudrate) {
348041e4:	e1550007 	cmp	r5, r7
348041e8:	0a00000b 	beq	3480421c <do_load_serial_bin+0xac>
		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
348041ec:	e1a01005 	mov	r1, r5
348041f0:	e59f038c 	ldr	r0, [pc, #908]	; 34804584 <do_load_serial_bin+0x414>
348041f4:	eb00166f 	bl	34809bb8 <printf>
			load_baudrate);
		udelay(50000);
348041f8:	e30c0350 	movw	r0, #50000	; 0xc350
348041fc:	eb00626d 	bl	3481cbb8 <udelay>
		gd->baudrate = load_baudrate;
34804200:	e5885008 	str	r5, [r8, #8]
		serial_setbrg ();
34804204:	eb002ba9 	bl	3480f0b0 <serial_setbrg>
		udelay(50000);
34804208:	e30c0350 	movw	r0, #50000	; 0xc350
3480420c:	eb006269 	bl	3481cbb8 <udelay>
		for (;;) {
			if (getc() == '\r')
34804210:	eb001642 	bl	34809b20 <getc>
34804214:	e350000d 	cmp	r0, #13
34804218:	1afffffc 	bne	34804210 <do_load_serial_bin+0xa0>
				break;
		}
	}

	if (strcmp(argv[0],"loady")==0) {
3480421c:	e5960000 	ldr	r0, [r6]
34804220:	e59f1360 	ldr	r1, [pc, #864]	; 34804588 <do_load_serial_bin+0x418>
34804224:	eb0060e0 	bl	3481c5ac <strcmp>
34804228:	e2509000 	subs	r9, r0, #0
3480422c:	1a000006 	bne	3480424c <do_load_serial_bin+0xdc>
		printf ("## Ready for binary (ymodem) download "
34804230:	e1a01004 	mov	r1, r4
34804234:	e1a02005 	mov	r2, r5
34804238:	e59f034c 	ldr	r0, [pc, #844]	; 3480458c <do_load_serial_bin+0x41c>
3480423c:	eb00165d 	bl	34809bb8 <printf>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);

		addr = load_serial_ymodem (offset);
34804240:	e1a00004 	mov	r0, r4
34804244:	ebfffdd2 	bl	34803994 <load_serial_ymodem>
34804248:	ea0000b3 	b	3480451c <do_load_serial_bin+0x3ac>

	} else {

		printf ("## Ready for binary (kermit) download "
3480424c:	e1a02005 	mov	r2, r5
34804250:	e1a01004 	mov	r1, r4
34804254:	e59f0334 	ldr	r0, [pc, #820]	; 34804590 <do_load_serial_bin+0x420>
34804258:	eb001656 	bl	34809bb8 <printf>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
3480425c:	e59fa330 	ldr	sl, [pc, #816]	; 34804594 <do_load_serial_bin+0x424>
	os_data_init = bin_data_init;
34804260:	e59f3330 	ldr	r3, [pc, #816]	; 34804598 <do_load_serial_bin+0x428>
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34804264:	e3a06000 	mov	r6, #0
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
	os_data_init = bin_data_init;
34804268:	e58a3034 	str	r3, [sl, #52]	; 0x34
	os_data_char = bin_data_char;
3480426c:	e59f3328 	ldr	r3, [pc, #808]	; 3480459c <do_load_serial_bin+0x42c>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
34804270:	e58a4008 	str	r4, [sl, #8]
	os_data_init = bin_data_init;
	os_data_char = bin_data_char;
34804274:	e58a3044 	str	r3, [sl, #68]	; 0x44
	int length;
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34804278:	e3a0300d 	mov	r3, #13
3480427c:	e5ca302c 	strb	r3, [sl, #44]	; 0x2c
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;
34804280:	e2833016 	add	r3, r3, #22
34804284:	e5ca3048 	strb	r3, [sl, #72]	; 0x48
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34804288:	e58a600c 	str	r6, [sl, #12]
	his_pad_char = '\0';
3480428c:	e5ca6010 	strb	r6, [sl, #16]
	his_quote = K_ESCAPE;

	/* initialize the k_recv and k_data state machine */
	done = 0;
	k_state = 0;
	k_data_init ();
34804290:	ebffff17 	bl	34803ef4 <k_data_init>
	k_state_saved = k_state;
	k_data_save ();
34804294:	ebffff1e 	bl	34803f14 <k_data_save>
	n = 0;				/* just to get rid of a warning */
	last_n = -1;
34804298:	e3e09000 	mvn	r9, #0
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
3480429c:	e58d5004 	str	r5, [sp, #4]
348042a0:	e1a05004 	mov	r5, r4
	 */

	/* enter main loop */
	while (!done) {
		/* set the send packet pointer to begining of send packet parms */
		send_ptr = send_parms;
348042a4:	e59f12f4 	ldr	r1, [pc, #756]	; 348045a0 <do_load_serial_bin+0x430>
348042a8:	e58a104c 	str	r1, [sl, #76]	; 0x4c
#endif

		/* get a packet */
		/* wait for the starting character or ^C */
		for (;;) {
			switch (getc ()) {
348042ac:	eb00161b 	bl	34809b20 <getc>
348042b0:	e3500001 	cmp	r0, #1
348042b4:	0a000002 	beq	348042c4 <do_load_serial_bin+0x154>
348042b8:	e3500003 	cmp	r0, #3
348042bc:	1afffffa 	bne	348042ac <do_load_serial_bin+0x13c>
348042c0:	ea00006e 	b	34804480 <do_load_serial_bin+0x310>
			}
		}
START:
		/* get length of packet */
		sum = 0;
		new_char = getc ();
348042c4:	eb001615 	bl	34809b20 <getc>
		if ((new_char & 0xE0) == 0)
348042c8:	e6ef4070 	uxtb	r4, r0
348042cc:	e31400e0 	tst	r4, #224	; 0xe0
348042d0:	0a000057 	beq	34804434 <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
348042d4:	eb001611 	bl	34809b20 <getc>
		if ((new_char & 0xE0) == 0)
348042d8:	e6efb070 	uxtb	fp, r0
348042dc:	e31b00e0 	tst	fp, #224	; 0xe0
348042e0:	0a000053 	beq	34804434 <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
348042e4:	e24b6020 	sub	r6, fp, #32
348042e8:	e20660ff 	and	r6, r6, #255	; 0xff
		 * received.  Handling an invalid sequence number adds another layer
		 * of complexity that may not be needed - yet!  At this time, I'm hoping
		 * that I don't need to buffer the incoming data packets and can write
		 * the data into memory in real time.
		 */
		if (n == last_n) {
348042ec:	e1560009 	cmp	r6, r9
348042f0:	1a000001 	bne	348042fc <do_load_serial_bin+0x18c>
			/* same sequence number, restore the previous state */
			k_state = k_state_saved;
			k_data_restore ();
348042f4:	ebffff0f 	bl	34803f38 <k_data_restore>
348042f8:	ea000000 	b	34804300 <do_load_serial_bin+0x190>
		} else {
			/* new sequence number, checkpoint the download */
			last_n = n;
			k_state_saved = k_state;
			k_data_save ();
348042fc:	ebffff04 	bl	34803f14 <k_data_save>
		}
		/* END NEW CODE */

		/* get packet type */
		new_char = getc ();
34804300:	eb001606 	bl	34809b20 <getc>
34804304:	e6ef9070 	uxtb	r9, r0
		if ((new_char & 0xE0) == 0)
34804308:	e31900e0 	tst	r9, #224	; 0xe0
3480430c:	0a000047 	beq	34804430 <do_load_serial_bin+0x2c0>
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
34804310:	e08bb004 	add	fp, fp, r4
		sum = 0;
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
34804314:	e2444020 	sub	r4, r4, #32
34804318:	e20440ff 	and	r4, r4, #255	; 0xff
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		k_state = new_char;
		--length;
3480431c:	e2444002 	sub	r4, r4, #2
		/* check for extended length */
		if (length == -2) {
34804320:	e3740002 	cmn	r4, #2

		/* get packet type */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
34804324:	e08bb009 	add	fp, fp, r9
		k_state = new_char;
		--length;
		/* check for extended length */
		if (length == -2) {
34804328:	1a000030 	bne	348043f0 <do_load_serial_bin+0x280>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
3480432c:	eb0015fb 	bl	34809b20 <getc>
			if ((new_char & 0xE0) == 0)
34804330:	e6ef4070 	uxtb	r4, r0
34804334:	e31400e0 	tst	r4, #224	; 0xe0
34804338:	0a00003c 	beq	34804430 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
			new_char = getc ();
3480433c:	eb0015f7 	bl	34809b20 <getc>
			if ((new_char & 0xE0) == 0)
34804340:	e6ef3070 	uxtb	r3, r0
34804344:	e31300e0 	tst	r3, #224	; 0xe0
34804348:	0a000038 	beq	34804430 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
3480434c:	e58d3000 	str	r3, [sp]
34804350:	eb0015f2 	bl	34809b20 <getc>
34804354:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
34804358:	e31000e0 	tst	r0, #224	; 0xe0
3480435c:	e59d3000 	ldr	r3, [sp]
34804360:	0a000032 	beq	34804430 <do_load_serial_bin+0x2c0>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
34804364:	e084b00b 	add	fp, r4, fp
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
34804368:	e08bb003 	add	fp, fp, r3
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
3480436c:	e7e1235b 	ubfx	r2, fp, #6, #2
34804370:	e082200b 	add	r2, r2, fp
34804374:	e202203f 	and	r2, r2, #63	; 0x3f
34804378:	e2822020 	add	r2, r2, #32
3480437c:	e1500002 	cmp	r0, r2
34804380:	1a00002a 	bne	34804430 <do_load_serial_bin+0x2c0>
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
34804384:	e2444020 	sub	r4, r4, #32
34804388:	e20440ff 	and	r4, r4, #255	; 0xff
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
3480438c:	e3a0205f 	mov	r2, #95	; 0x5f
34804390:	e0040492 	mul	r4, r2, r4
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
34804394:	e2433020 	sub	r3, r3, #32
			length = len_hi * 95 + len_lo;
34804398:	e6e44073 	uxtab	r4, r4, r3
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
				goto packet_error;
			sum += new_char & 0xff;
3480439c:	e080b00b 	add	fp, r0, fp
348043a0:	ea000012 	b	348043f0 <do_load_serial_bin+0x280>
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
348043a4:	eb0015dd 	bl	34809b20 <getc>
348043a8:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
348043ac:	e31000e0 	tst	r0, #224	; 0xe0
348043b0:	0a00001e 	beq	34804430 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			--length;
			if (k_state == DATA_TYPE) {
348043b4:	e3590044 	cmp	r9, #68	; 0x44
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
348043b8:	e08bb000 	add	fp, fp, r0
			--length;
348043bc:	e2444001 	sub	r4, r4, #1
			if (k_state == DATA_TYPE) {
348043c0:	1a000001 	bne	348043cc <do_load_serial_bin+0x25c>
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
348043c4:	ebfffee4 	bl	34803f5c <k_data_char>
348043c8:	ea000008 	b	348043f0 <do_load_serial_bin+0x280>
			} else if (k_state == SEND_TYPE) {
348043cc:	e3590053 	cmp	r9, #83	; 0x53
348043d0:	1a000006 	bne	348043f0 <do_load_serial_bin+0x280>
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
348043d4:	e59a204c 	ldr	r2, [sl, #76]	; 0x4c
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
348043d8:	e59f11c4 	ldr	r1, [pc, #452]	; 348045a4 <do_load_serial_bin+0x434>
			if (k_state == DATA_TYPE) {
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
			} else if (k_state == SEND_TYPE) {
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
348043dc:	e1a03002 	mov	r3, r2
348043e0:	e4c30001 	strb	r0, [r3], #1
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
348043e4:	e1530001 	cmp	r3, r1
					--send_ptr;
348043e8:	21a03002 	movcs	r3, r2
348043ec:	e58a304c 	str	r3, [sl, #76]	; 0x4c
				goto packet_error;
			sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
348043f0:	e3540001 	cmp	r4, #1
348043f4:	caffffea 	bgt	348043a4 <do_load_serial_bin+0x234>
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
					--send_ptr;
			}
		}
		/* get and validate checksum character */
		new_char = getc ();
348043f8:	eb0015c8 	bl	34809b20 <getc>
348043fc:	e6ef0070 	uxtb	r0, r0
		if ((new_char & 0xE0) == 0)
34804400:	e31000e0 	tst	r0, #224	; 0xe0
34804404:	0a000009 	beq	34804430 <do_load_serial_bin+0x2c0>
			goto packet_error;
		if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
34804408:	e7e1335b 	ubfx	r3, fp, #6, #2
3480440c:	e083b00b 	add	fp, r3, fp
34804410:	e20bb03f 	and	fp, fp, #63	; 0x3f
34804414:	e28bb020 	add	fp, fp, #32
34804418:	e150000b 	cmp	r0, fp
3480441c:	1a000003 	bne	34804430 <do_load_serial_bin+0x2c0>
			goto packet_error;
		/* get END_CHAR */
		new_char = getc ();
34804420:	eb0015be 	bl	34809b20 <getc>
		if (new_char != END_CHAR) {
34804424:	e6ef0070 	uxtb	r0, r0
34804428:	e350000d 	cmp	r0, #13
3480442c:	0a000006 	beq	3480444c <do_load_serial_bin+0x2dc>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
34804430:	e1a09006 	mov	r9, r6
		new_char = getc ();
		if (new_char != END_CHAR) {
		  packet_error:
			/* restore state machines */
			k_state = k_state_saved;
			k_data_restore ();
34804434:	ebfffebf 	bl	34803f38 <k_data_restore>
			/* send a negative acknowledge packet in */
			send_nack (n);
34804438:	e1a00006 	mov	r0, r6
3480443c:	ebfffe94 	bl	34803e94 <send_nack>
34804440:	e1a03006 	mov	r3, r6
34804444:	e1a06009 	mov	r6, r9
34804448:	ea000009 	b	34804474 <do_load_serial_bin+0x304>
		} else if (k_state == SEND_TYPE) {
3480444c:	e3590053 	cmp	r9, #83	; 0x53
34804450:	1a000002 	bne	34804460 <do_load_serial_bin+0x2f0>
			/* crack the protocol parms, build an appropriate ack packet */
			handle_send_packet (n);
34804454:	e1a00006 	mov	r0, r6
34804458:	ebfffed3 	bl	34803fac <handle_send_packet>
3480445c:	ea000003 	b	34804470 <do_load_serial_bin+0x300>
		} else {
			/* send simple acknowledge packet in */
			send_ack (n);
34804460:	e1a00006 	mov	r0, r6
34804464:	ebfffe72 	bl	34803e34 <send_ack>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
34804468:	e3590042 	cmp	r9, #66	; 0x42
3480446c:	0a00003d 	beq	34804568 <do_load_serial_bin+0x3f8>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
34804470:	e1a03006 	mov	r3, r6
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34804474:	e1a09006 	mov	r9, r6
34804478:	e1a06003 	mov	r6, r3
3480447c:	eaffff88 	b	348042a4 <do_load_serial_bin+0x134>
34804480:	e1a04005 	mov	r4, r5
34804484:	e59d5004 	ldr	r5, [sp, #4]
		for (;;) {
			switch (getc ()) {
			case START_CHAR:	/* start packet */
				goto START;
			case ETX_CHAR:		/* ^C waiting for packet */
				return (0);
34804488:	e3a06000 	mov	r6, #0
3480448c:	e3a09064 	mov	r9, #100	; 0x64
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
34804490:	eb0015ab 	bl	34809b44 <tstc>
34804494:	e3500000 	cmp	r0, #0
34804498:	0a000000 	beq	348044a0 <do_load_serial_bin+0x330>
			(void) getc();
3480449c:	eb00159f 	bl	34809b20 <getc>
		}
		udelay(1000);
348044a0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348044a4:	eb0061c3 	bl	3481cbb8 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
348044a8:	e2599001 	subs	r9, r9, #1
348044ac:	1afffff7 	bne	34804490 <do_load_serial_bin+0x320>
			(void) getc();
		}
		udelay(1000);
	}

	flush_cache (offset, size);
348044b0:	e1a01006 	mov	r1, r6
348044b4:	e1a00004 	mov	r0, r4
348044b8:	ebfff32a 	bl	34801168 <flush_cache>

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf(buf, "%X", size);
348044bc:	e28da008 	add	sl, sp, #8
		udelay(1000);
	}

	flush_cache (offset, size);

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
348044c0:	e1a01006 	mov	r1, r6
348044c4:	e1a02006 	mov	r2, r6
348044c8:	e59f00d8 	ldr	r0, [pc, #216]	; 348045a8 <do_load_serial_bin+0x438>
348044cc:	eb0015b9 	bl	34809bb8 <printf>
	sprintf(buf, "%X", size);
348044d0:	e1a02006 	mov	r2, r6
348044d4:	e59f10d0 	ldr	r1, [pc, #208]	; 348045ac <do_load_serial_bin+0x43c>
348044d8:	e1a0000a 	mov	r0, sl
348044dc:	eb00649f 	bl	3481d760 <sprintf>
	setenv("filesize", buf);
348044e0:	e59f00c8 	ldr	r0, [pc, #200]	; 348045b0 <do_load_serial_bin+0x440>
348044e4:	e1a0100a 	mov	r1, sl
348044e8:	eb000dbc 	bl	34807be0 <setenv>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);
		addr = load_serial_bin (offset);

		if (addr == ~0) {
348044ec:	e3740001 	cmn	r4, #1
348044f0:	e59f60bc 	ldr	r6, [pc, #188]	; 348045b4 <do_load_serial_bin+0x444>
348044f4:	1a000004 	bne	3480450c <do_load_serial_bin+0x39c>
			load_addr = 0;
348044f8:	e5869000 	str	r9, [r6]
			printf ("## Binary (kermit) download aborted\n");
348044fc:	e59f00b4 	ldr	r0, [pc, #180]	; 348045b8 <do_load_serial_bin+0x448>
34804500:	eb0015ac 	bl	34809bb8 <printf>
			rcode = 1;
34804504:	e3a09001 	mov	r9, #1
34804508:	ea000003 	b	3480451c <do_load_serial_bin+0x3ac>
		} else {
			printf ("## Start Addr      = 0x%08lX\n", addr);
3480450c:	e59f00a8 	ldr	r0, [pc, #168]	; 348045bc <do_load_serial_bin+0x44c>
34804510:	e1a01004 	mov	r1, r4
34804514:	eb0015a7 	bl	34809bb8 <printf>
			load_addr = addr;
34804518:	e5864000 	str	r4, [r6]
		}
	}
	if (load_baudrate != current_baudrate) {
3480451c:	e1550007 	cmp	r5, r7
34804520:	0a00000b 	beq	34804554 <do_load_serial_bin+0x3e4>
		printf ("## Switch baudrate to %d bps and press ESC ...\n",
34804524:	e1a01007 	mov	r1, r7
34804528:	e59f0090 	ldr	r0, [pc, #144]	; 348045c0 <do_load_serial_bin+0x450>
3480452c:	eb0015a1 	bl	34809bb8 <printf>
			current_baudrate);
		udelay (50000);
34804530:	e30c0350 	movw	r0, #50000	; 0xc350
34804534:	eb00619f 	bl	3481cbb8 <udelay>
		gd->baudrate = current_baudrate;
34804538:	e5887008 	str	r7, [r8, #8]
		serial_setbrg ();
3480453c:	eb002adb 	bl	3480f0b0 <serial_setbrg>
		udelay (50000);
34804540:	e30c0350 	movw	r0, #50000	; 0xc350
34804544:	eb00619b 	bl	3481cbb8 <udelay>
		for (;;) {
			if (getc() == 0x1B) /* ESC */
34804548:	eb001574 	bl	34809b20 <getc>
3480454c:	e350001b 	cmp	r0, #27
34804550:	1afffffc 	bne	34804548 <do_load_serial_bin+0x3d8>
				break;
		}
	}

	return rcode;
}
34804554:	e1a00009 	mov	r0, r9
34804558:	e28dd028 	add	sp, sp, #40	; 0x28
3480455c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34804560:	e1a05007 	mov	r5, r7
34804564:	eaffff2c 	b	3480421c <do_load_serial_bin+0xac>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
				done = 1;
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
34804568:	e59f3024 	ldr	r3, [pc, #36]	; 34804594 <do_load_serial_bin+0x424>
3480456c:	e1a04005 	mov	r4, r5
34804570:	e9930044 	ldmib	r3, {r2, r6}
34804574:	e0426006 	sub	r6, r2, r6
34804578:	e59d5004 	ldr	r5, [sp, #4]
3480457c:	eaffffc2 	b	3480448c <do_load_serial_bin+0x31c>
34804580:	34822bb9 	.word	0x34822bb9
34804584:	34823d38 	.word	0x34823d38
34804588:	34823d6a 	.word	0x34823d6a
3480458c:	34823d70 	.word	0x34823d70
34804590:	34823daf 	.word	0x34823daf
34804594:	34829cdc 	.word	0x34829cdc
34804598:	34803958 	.word	0x34803958
3480459c:	34803974 	.word	0x34803974
348045a0:	34829d2c 	.word	0x34829d2c
348045a4:	34829d40 	.word	0x34829d40
348045a8:	34823c3d 	.word	0x34823c3d
348045ac:	34823c65 	.word	0x34823c65
348045b0:	348234c1 	.word	0x348234c1
348045b4:	34828780 	.word	0x34828780
348045b8:	34823dee 	.word	0x34823dee
348045bc:	34823d1a 	.word	0x34823d1a
348045c0:	34823e13 	.word	0x34823e13

348045c4 <do_mem_crc>:
{
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
348045c4:	e3520002 	cmp	r2, #2
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348045c8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
		return CMD_RET_USAGE;
348045cc:	d3e00000 	mvnle	r0, #0
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348045d0:	e1a07002 	mov	r7, r2
348045d4:	e1a04003 	mov	r4, r3
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
348045d8:	d8bd84f0 	pople	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
348045dc:	e5930004 	ldr	r0, [r3, #4]
348045e0:	e3a01000 	mov	r1, #0
348045e4:	e3a02010 	mov	r2, #16
348045e8:	eb0063b6 	bl	3481d4c8 <simple_strtoul>
	addr += base_address;
348045ec:	e59f3074 	ldr	r3, [pc, #116]	; 34804668 <do_mem_crc+0xa4>

	length = simple_strtoul (argv[2], NULL, 16);
348045f0:	e3a01000 	mov	r1, #0

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
348045f4:	e5935000 	ldr	r5, [r3]

	length = simple_strtoul (argv[2], NULL, 16);
348045f8:	e3a02010 	mov	r2, #16

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
348045fc:	e0805005 	add	r5, r0, r5

	length = simple_strtoul (argv[2], NULL, 16);
34804600:	e5940008 	ldr	r0, [r4, #8]
34804604:	eb0063af 	bl	3481d4c8 <simple_strtoul>
34804608:	e1a06000 	mov	r6, r0

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
3480460c:	e1a01005 	mov	r1, r5
34804610:	e1a02006 	mov	r2, r6
34804614:	e3a03801 	mov	r3, #65536	; 0x10000
34804618:	e3a00000 	mov	r0, #0
3480461c:	eb00595d 	bl	3481ab98 <crc32_wd>

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
			addr, addr + length - 1, crc);
34804620:	e2462001 	sub	r2, r6, #1
	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;

	length = simple_strtoul (argv[2], NULL, 16);

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
34804624:	e1a0a000 	mov	sl, r0

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
34804628:	e1a01005 	mov	r1, r5
3480462c:	e59f0038 	ldr	r0, [pc, #56]	; 3480466c <do_mem_crc+0xa8>
34804630:	e0822005 	add	r2, r2, r5
34804634:	e1a0300a 	mov	r3, sl
34804638:	eb00155e 	bl	34809bb8 <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
3480463c:	e3570003 	cmp	r7, #3
34804640:	0a000006 	beq	34804660 <do_mem_crc+0x9c>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
34804644:	e594000c 	ldr	r0, [r4, #12]
34804648:	e3a01000 	mov	r1, #0
3480464c:	e3a02010 	mov	r2, #16
34804650:	eb00639c 	bl	3481d4c8 <simple_strtoul>
		*ptr = crc;
34804654:	e580a000 	str	sl, [r0]
	}

	return 0;
34804658:	e3a00000 	mov	r0, #0
3480465c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804660:	e3a00000 	mov	r0, #0
}
34804664:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804668:	34829d40 	.word	0x34829d40
3480466c:	34823f76 	.word	0x34823f76

34804670 <do_mem_base>:
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc > 1) {
34804670:	e3520001 	cmp	r2, #1
	}
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804674:	e92d4008 	push	{r3, lr}
	if (argc > 1) {
34804678:	da000005 	ble	34804694 <do_mem_base+0x24>
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
3480467c:	e5930004 	ldr	r0, [r3, #4]
34804680:	e3a01000 	mov	r1, #0
34804684:	e3a02010 	mov	r2, #16
34804688:	eb00638e 	bl	3481d4c8 <simple_strtoul>
3480468c:	e59f3018 	ldr	r3, [pc, #24]	; 348046ac <do_mem_base+0x3c>
34804690:	e5830000 	str	r0, [r3]
	}
	/* Print the current base address.
	*/
	printf("Base Address: 0x%08lx\n", base_address);
34804694:	e59f3010 	ldr	r3, [pc, #16]	; 348046ac <do_mem_base+0x3c>
34804698:	e59f0010 	ldr	r0, [pc, #16]	; 348046b0 <do_mem_base+0x40>
3480469c:	e5931000 	ldr	r1, [r3]
348046a0:	eb001544 	bl	34809bb8 <printf>
	return 0;
}
348046a4:	e3a00000 	mov	r0, #0
348046a8:	e8bd8008 	pop	{r3, pc}
348046ac:	34829d40 	.word	0x34829d40
348046b0:	34823f9b 	.word	0x34823f9b

348046b4 <do_mem_mtest>:
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
348046b4:	e3520001 	cmp	r2, #1
 * Perform a memory test. A more complete alternative test can be
 * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 */
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348046b8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348046bc:	e1a05002 	mov	r5, r2
348046c0:	e1a06003 	mov	r6, r3
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
348046c4:	da000056 	ble	34804824 <do_mem_mtest+0x170>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
348046c8:	e5930004 	ldr	r0, [r3, #4]
348046cc:	e3a01000 	mov	r1, #0
348046d0:	e3a02010 	mov	r2, #16
348046d4:	eb00637b 	bl	3481d4c8 <simple_strtoul>
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
348046d8:	e3550002 	cmp	r5, #2
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
348046dc:	e58d0000 	str	r0, [sp]
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
348046e0:	0a000051 	beq	3480482c <do_mem_mtest+0x178>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
348046e4:	e5960008 	ldr	r0, [r6, #8]
348046e8:	e3a01000 	mov	r1, #0
348046ec:	e3a02010 	mov	r2, #16
348046f0:	eb006374 	bl	3481d4c8 <simple_strtoul>
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
348046f4:	e3550003 	cmp	r5, #3
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
348046f8:	e58d0004 	str	r0, [sp, #4]
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
348046fc:	0a00004c 	beq	34804834 <do_mem_mtest+0x180>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34804700:	e596000c 	ldr	r0, [r6, #12]
34804704:	e3a01000 	mov	r1, #0
34804708:	e3a02010 	mov	r2, #16
3480470c:	eb00636d 	bl	3481d4c8 <simple_strtoul>
	else
		pattern = 0;

	if (argc > 4)
34804710:	e3550004 	cmp	r5, #4
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34804714:	e1a04000 	mov	r4, r0
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
34804718:	03a0b000 	moveq	fp, #0
	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
	else
		pattern = 0;

	if (argc > 4)
3480471c:	0a000004 	beq	34804734 <do_mem_mtest+0x80>
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
34804720:	e5960010 	ldr	r0, [r6, #16]
34804724:	e3a01000 	mov	r1, #0
34804728:	e3a02010 	mov	r2, #16
3480472c:	eb006365 	bl	3481d4c8 <simple_strtoul>
34804730:	e1a0b000 	mov	fp, r0
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
34804734:	e3a05001 	mov	r5, #1
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
	int iterations = 1;
34804738:	e1a0a005 	mov	sl, r5
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
3480473c:	e3a09000 	mov	r9, #0
	}

#else /* The original, quickie test */
	incr = 1;
	for (;;) {
		if (ctrlc()) {
34804740:	eb001541 	bl	34809c4c <ctrlc>
34804744:	e3500000 	cmp	r0, #0
34804748:	1a000025 	bne	348047e4 <do_mem_mtest+0x130>
			putc ('\n');
			return 1;
		}

		if (iteration_limit && iterations > iteration_limit) {
3480474c:	e35b0000 	cmp	fp, #0
34804750:	115a000b 	cmpne	sl, fp
34804754:	da000006 	ble	34804774 <do_mem_mtest+0xc0>
			printf("Tested %d iteration(s) with %lu errors.\n",
34804758:	e59f00e0 	ldr	r0, [pc, #224]	; 34804840 <do_mem_mtest+0x18c>
3480475c:	e24a1001 	sub	r1, sl, #1
34804760:	e1a02009 	mov	r2, r9
34804764:	eb001513 	bl	34809bb8 <printf>
				iterations-1, errs);
			return errs != 0;
34804768:	e2590000 	subs	r0, r9, #0
3480476c:	13a00001 	movne	r0, #1
34804770:	ea00002a 	b	34804820 <do_mem_mtest+0x16c>
		}
		++iterations;

		printf ("\rPattern %08lX  Writing..."
34804774:	e59f20c8 	ldr	r2, [pc, #200]	; 34804844 <do_mem_mtest+0x190>
34804778:	e59f00c8 	ldr	r0, [pc, #200]	; 34804848 <do_mem_mtest+0x194>
3480477c:	e1a01004 	mov	r1, r4
34804780:	eb00150c 	bl	34809bb8 <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
34804784:	e1a02004 	mov	r2, r4
34804788:	e59d3000 	ldr	r3, [sp]
3480478c:	ea000001 	b	34804798 <do_mem_mtest+0xe4>
			WATCHDOG_RESET();
			*addr = val;
34804790:	e4832004 	str	r2, [r3], #4
			val  += incr;
34804794:	e0822005 	add	r2, r2, r5
		printf ("\rPattern %08lX  Writing..."
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
34804798:	e59d1004 	ldr	r1, [sp, #4]
3480479c:	e1530001 	cmp	r3, r1
348047a0:	3afffffa 	bcc	34804790 <do_mem_mtest+0xdc>
			WATCHDOG_RESET();
			*addr = val;
			val  += incr;
		}

		puts ("Reading...");
348047a4:	e59f00a0 	ldr	r0, [pc, #160]	; 3480484c <do_mem_mtest+0x198>
348047a8:	eb0014f8 	bl	34809b90 <puts>

		for (addr=start,val=pattern; addr<end; addr++) {
348047ac:	e1a07004 	mov	r7, r4
348047b0:	e59d6000 	ldr	r6, [sp]
348047b4:	ea000010 	b	348047fc <do_mem_mtest+0x148>
			WATCHDOG_RESET();
			readback = *addr;
348047b8:	e5962000 	ldr	r2, [r6]
			if (readback != val) {
348047bc:	e1520007 	cmp	r2, r7
348047c0:	0a00000b 	beq	348047f4 <do_mem_mtest+0x140>
				printf ("\nMem error @ 0x%08X: "
348047c4:	e1a01006 	mov	r1, r6
348047c8:	e1a03007 	mov	r3, r7
348047cc:	e59f007c 	ldr	r0, [pc, #124]	; 34804850 <do_mem_mtest+0x19c>
348047d0:	eb0014f8 	bl	34809bb8 <printf>
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
				if (ctrlc()) {
348047d4:	eb00151c 	bl	34809c4c <ctrlc>
348047d8:	e3500000 	cmp	r0, #0
			readback = *addr;
			if (readback != val) {
				printf ("\nMem error @ 0x%08X: "
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
348047dc:	02899001 	addeq	r9, r9, #1
348047e0:	0a000003 	beq	348047f4 <do_mem_mtest+0x140>
				if (ctrlc()) {
					putc ('\n');
348047e4:	e3a0000a 	mov	r0, #10
348047e8:	eb0014de 	bl	34809b68 <putc>
					return 1;
348047ec:	e3a00001 	mov	r0, #1
348047f0:	ea00000a 	b	34804820 <do_mem_mtest+0x16c>
				}
			}
			val += incr;
348047f4:	e0877005 	add	r7, r7, r5
			val  += incr;
		}

		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
348047f8:	e2866004 	add	r6, r6, #4
348047fc:	e59d3004 	ldr	r3, [sp, #4]
34804800:	e1560003 	cmp	r6, r3
34804804:	3affffeb 	bcc	348047b8 <do_mem_mtest+0x104>
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
34804808:	e3540000 	cmp	r4, #0
			pattern = -pattern;	/* complement & increment */
3480480c:	b2644000 	rsblt	r4, r4, #0
		}
		else {
			pattern = ~pattern;
34804810:	a1e04004 	mvnge	r4, r4
		if (iteration_limit && iterations > iteration_limit) {
			printf("Tested %d iteration(s) with %lu errors.\n",
				iterations-1, errs);
			return errs != 0;
		}
		++iterations;
34804814:	e28aa001 	add	sl, sl, #1
			pattern = -pattern;	/* complement & increment */
		}
		else {
			pattern = ~pattern;
		}
		incr = -incr;
34804818:	e2655000 	rsb	r5, r5, #0
	}
3480481c:	eaffffc7 	b	34804740 <do_mem_mtest+0x8c>
#endif
	return 0;	/* not reached */
}
34804820:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;
34804824:	e3a01202 	mov	r1, #536870912	; 0x20000000
34804828:	e58d1000 	str	r1, [sp]
3480482c:	e3a03425 	mov	r3, #620756992	; 0x25000000
34804830:	e58d3004 	str	r3, [sp, #4]
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
34804834:	e3a04000 	mov	r4, #0
34804838:	e1a0b004 	mov	fp, r4
3480483c:	eaffffbc 	b	34804734 <do_mem_mtest+0x80>
34804840:	34823fb2 	.word	0x34823fb2
34804844:	34824003 	.word	0x34824003
34804848:	34823fdb 	.word	0x34823fdb
3480484c:	34824004 	.word	0x34824004
34804850:	3482400f 	.word	0x3482400f

34804854 <do_mem_loop>:
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
34804854:	e3520002 	cmp	r2, #2
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804858:	e92d4070 	push	{r4, r5, r6, lr}
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
		return CMD_RET_USAGE;
3480485c:	d3e00000 	mvnle	r0, #0
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804860:	e1a06003 	mov	r6, r3
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
34804864:	d8bd8070 	pople	{r4, r5, r6, pc}
		return CMD_RET_USAGE;

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804868:	e5930000 	ldr	r0, [r3]
3480486c:	e3a01004 	mov	r1, #4
34804870:	eb0013f2 	bl	34809840 <cmd_get_data_size>
34804874:	e2505000 	subs	r5, r0, #0
34804878:	ba000030 	blt	34804940 <do_mem_loop+0xec>
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
3480487c:	e3a01000 	mov	r1, #0
34804880:	e3a02010 	mov	r2, #16
34804884:	e5960004 	ldr	r0, [r6, #4]
34804888:	eb00630e 	bl	3481d4c8 <simple_strtoul>

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
3480488c:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804890:	e1a04000 	mov	r4, r0

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
34804894:	e3a02010 	mov	r2, #16
34804898:	e5960008 	ldr	r0, [r6, #8]
3480489c:	eb006309 	bl	3481d4c8 <simple_strtoul>

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
348048a0:	e3500001 	cmp	r0, #1
348048a4:	1a000009 	bne	348048d0 <do_mem_loop+0x7c>
		if (size == 4) {
348048a8:	e3550004 	cmp	r5, #4
348048ac:	1a000001 	bne	348048b8 <do_mem_loop+0x64>
			longp = (uint *)addr;
			for (;;)
				i = *longp;
348048b0:	e5943000 	ldr	r3, [r4]
348048b4:	eafffffd 	b	348048b0 <do_mem_loop+0x5c>
		}
		if (size == 2) {
348048b8:	e3550002 	cmp	r5, #2
348048bc:	1a000001 	bne	348048c8 <do_mem_loop+0x74>
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
348048c0:	e1d430b0 	ldrh	r3, [r4]
348048c4:	eafffffd 	b	348048c0 <do_mem_loop+0x6c>
		}
		cp = (u_char *)addr;
		for (;;)
			i = *cp;
348048c8:	e5d43000 	ldrb	r3, [r4]
348048cc:	eafffffd 	b	348048c8 <do_mem_loop+0x74>
	}

	if (size == 4) {
348048d0:	e3550004 	cmp	r5, #4
348048d4:	1a000007 	bne	348048f8 <do_mem_loop+0xa4>
		for (;;) {
			longp = (uint *)addr;
348048d8:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
348048dc:	e1a03000 	mov	r3, r0
348048e0:	ea000001 	b	348048ec <do_mem_loop+0x98>
				*longp++;
348048e4:	e4921004 	ldr	r1, [r2], #4
348048e8:	e2433001 	sub	r3, r3, #1

	if (size == 4) {
		for (;;) {
			longp = (uint *)addr;
			i = length;
			while (i-- > 0)
348048ec:	e3530000 	cmp	r3, #0
348048f0:	0afffff8 	beq	348048d8 <do_mem_loop+0x84>
348048f4:	eafffffa 	b	348048e4 <do_mem_loop+0x90>
				*longp++;
		}
	}
	if (size == 2) {
348048f8:	e3550002 	cmp	r5, #2
348048fc:	1a000007 	bne	34804920 <do_mem_loop+0xcc>
		for (;;) {
			shortp = (ushort *)addr;
34804900:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
34804904:	e1a03000 	mov	r3, r0
34804908:	ea000001 	b	34804914 <do_mem_loop+0xc0>
				*shortp++;
3480490c:	e0d210b2 	ldrh	r1, [r2], #2
34804910:	e2433001 	sub	r3, r3, #1
	}
	if (size == 2) {
		for (;;) {
			shortp = (ushort *)addr;
			i = length;
			while (i-- > 0)
34804914:	e3530000 	cmp	r3, #0
34804918:	0afffff8 	beq	34804900 <do_mem_loop+0xac>
3480491c:	eafffffa 	b	3480490c <do_mem_loop+0xb8>
				*shortp++;
		}
	}
	for (;;) {
		cp = (u_char *)addr;
34804920:	e1a02004 	mov	r2, r4
		i = length;
		while (i-- > 0)
34804924:	e1a03000 	mov	r3, r0
34804928:	ea000001 	b	34804934 <do_mem_loop+0xe0>
			*cp++;
3480492c:	e4d21001 	ldrb	r1, [r2], #1
34804930:	e2433001 	sub	r3, r3, #1
		}
	}
	for (;;) {
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
34804934:	e3530000 	cmp	r3, #0
34804938:	0afffff8 	beq	34804920 <do_mem_loop+0xcc>
3480493c:	eafffffa 	b	3480492c <do_mem_loop+0xd8>

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
34804940:	e3a00001 	mov	r0, #1
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
			*cp++;
	}
}
34804944:	e8bd8070 	pop	{r4, r5, r6, pc}

34804948 <do_mem_cp>:
int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34804948:	e3520004 	cmp	r2, #4
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480494c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
		return CMD_RET_USAGE;
34804950:	13e00000 	mvnne	r0, #0
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804954:	e1a05003 	mov	r5, r3
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34804958:	18bd86f8 	popne	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
3480495c:	e5930000 	ldr	r0, [r3]
34804960:	e1a01002 	mov	r1, r2
34804964:	eb0013b5 	bl	34809840 <cmd_get_data_size>
34804968:	e2504000 	subs	r4, r0, #0
3480496c:	ba000026 	blt	34804a0c <do_mem_cp+0xc4>
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
34804970:	e3a01000 	mov	r1, #0
34804974:	e3a02010 	mov	r2, #16
34804978:	e5950004 	ldr	r0, [r5, #4]
3480497c:	eb0062d1 	bl	3481d4c8 <simple_strtoul>
	addr += base_address;
34804980:	e59f608c 	ldr	r6, [pc, #140]	; 34804a14 <do_mem_cp+0xcc>
	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
34804984:	e1a0a000 	mov	sl, r0
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
34804988:	e3a01000 	mov	r1, #0
3480498c:	e3a02010 	mov	r2, #16
34804990:	e5950008 	ldr	r0, [r5, #8]
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804994:	e5967000 	ldr	r7, [r6]

	dest = simple_strtoul(argv[2], NULL, 16);
34804998:	eb0062ca 	bl	3481d4c8 <simple_strtoul>
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
3480499c:	e3a01000 	mov	r1, #0
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
348049a0:	e1a09000 	mov	r9, r0
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
348049a4:	e3a02010 	mov	r2, #16
348049a8:	e595000c 	ldr	r0, [r5, #12]

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
348049ac:	e5966000 	ldr	r6, [r6]

	count = simple_strtoul(argv[3], NULL, 16);
348049b0:	eb0062c4 	bl	3481d4c8 <simple_strtoul>

	if (count == 0) {
348049b4:	e3500000 	cmp	r0, #0
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
348049b8:	108a7007 	addne	r7, sl, r7

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
348049bc:	10896006 	addne	r6, r9, r6

	count = simple_strtoul(argv[3], NULL, 16);

	if (count == 0) {
348049c0:	1a000003 	bne	348049d4 <do_mem_cp+0x8c>
		puts ("Zero length ???\n");
348049c4:	e59f004c 	ldr	r0, [pc, #76]	; 34804a18 <do_mem_cp+0xd0>
348049c8:	eb001470 	bl	34809b90 <puts>
		return 1;
348049cc:	e3a00001 	mov	r0, #1
348049d0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
348049d4:	e3540004 	cmp	r4, #4
			*((ulong  *)dest) = *((ulong  *)addr);
348049d8:	05973000 	ldreq	r3, [r7]
348049dc:	05863000 	streq	r3, [r6]
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
348049e0:	0a000004 	beq	348049f8 <do_mem_cp+0xb0>
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
348049e4:	e3540002 	cmp	r4, #2
			*((ushort *)dest) = *((ushort *)addr);
348049e8:	01d730b0 	ldrheq	r3, [r7]
		else
			*((u_char *)dest) = *((u_char *)addr);
348049ec:	15d73000 	ldrbne	r3, [r7]

	while (count-- > 0) {
		if (size == 4)
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
348049f0:	01c630b0 	strheq	r3, [r6]
		else
			*((u_char *)dest) = *((u_char *)addr);
348049f4:	15c63000 	strbne	r3, [r6]
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
348049f8:	e2500001 	subs	r0, r0, #1
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
348049fc:	e0877004 	add	r7, r7, r4
34804a00:	e0866004 	add	r6, r6, r4
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
34804a04:	1afffff2 	bne	348049d4 <do_mem_cp+0x8c>
34804a08:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
34804a0c:	e3a00001 	mov	r0, #1
		/* reset watchdog from time to time */
		if ((count % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}
	return 0;
}
34804a10:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
34804a14:	34829d40 	.word	0x34829d40
34804a18:	34824041 	.word	0x34824041

34804a1c <do_mem_cmp>:
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804a1c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
34804a20:	e3520004 	cmp	r2, #4
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804a24:	e24dd018 	sub	sp, sp, #24
34804a28:	e1a05003 	mov	r5, r3
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
		return CMD_RET_USAGE;
34804a2c:	13e06000 	mvnne	r6, #0
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
34804a30:	1a00003f 	bne	34804b34 <do_mem_cmp+0x118>
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804a34:	e5930000 	ldr	r0, [r3]
34804a38:	e1a01002 	mov	r1, r2
34804a3c:	eb00137f 	bl	34809840 <cmd_get_data_size>
34804a40:	e2506000 	subs	r6, r0, #0
		return 1;
34804a44:	b3a06001 	movlt	r6, #1
	if (argc != 4)
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804a48:	ba000039 	blt	34804b34 <do_mem_cmp+0x118>
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";
34804a4c:	e3560004 	cmp	r6, #4
34804a50:	059f40e8 	ldreq	r4, [pc, #232]	; 34804b40 <do_mem_cmp+0x124>
34804a54:	0a000003 	beq	34804a68 <do_mem_cmp+0x4c>
34804a58:	e59f30e4 	ldr	r3, [pc, #228]	; 34804b44 <do_mem_cmp+0x128>
34804a5c:	e3560002 	cmp	r6, #2
34804a60:	e59f40e0 	ldr	r4, [pc, #224]	; 34804b48 <do_mem_cmp+0x12c>
34804a64:	01a04003 	moveq	r4, r3

	addr1 = simple_strtoul(argv[1], NULL, 16);
34804a68:	e5950004 	ldr	r0, [r5, #4]
34804a6c:	e3a01000 	mov	r1, #0
34804a70:	e3a02010 	mov	r2, #16
34804a74:	eb006293 	bl	3481d4c8 <simple_strtoul>
	addr1 += base_address;
34804a78:	e59fa0cc 	ldr	sl, [pc, #204]	; 34804b4c <do_mem_cmp+0x130>

	addr2 = simple_strtoul(argv[2], NULL, 16);
34804a7c:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804a80:	e59a7000 	ldr	r7, [sl]

	addr2 = simple_strtoul(argv[2], NULL, 16);
34804a84:	e3a02010 	mov	r2, #16
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804a88:	e0807007 	add	r7, r0, r7

	addr2 = simple_strtoul(argv[2], NULL, 16);
34804a8c:	e5950008 	ldr	r0, [r5, #8]
34804a90:	eb00628c 	bl	3481d4c8 <simple_strtoul>
	addr2 += base_address;
34804a94:	e59aa000 	ldr	sl, [sl]

	count = simple_strtoul(argv[3], NULL, 16);
34804a98:	e3a01000 	mov	r1, #0

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;

	addr2 = simple_strtoul(argv[2], NULL, 16);
	addr2 += base_address;
34804a9c:	e080a00a 	add	sl, r0, sl

	count = simple_strtoul(argv[3], NULL, 16);
34804aa0:	e3a02010 	mov	r2, #16
34804aa4:	e595000c 	ldr	r0, [r5, #12]
34804aa8:	eb006286 	bl	3481d4c8 <simple_strtoul>
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
34804aac:	e3a05000 	mov	r5, #0
34804ab0:	ea000018 	b	34804b18 <do_mem_cmp+0xfc>
		ulong word1, word2;
		if (size == 4) {
34804ab4:	e3560004 	cmp	r6, #4
			word1 = *(ulong *)addr1;
34804ab8:	05972000 	ldreq	r2, [r7]
			word2 = *(ulong *)addr2;
34804abc:	059a3000 	ldreq	r3, [sl]
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
		ulong word1, word2;
		if (size == 4) {
34804ac0:	0a000004 	beq	34804ad8 <do_mem_cmp+0xbc>
			word1 = *(ulong *)addr1;
			word2 = *(ulong *)addr2;
		} else if (size == 2) {
34804ac4:	e3560002 	cmp	r6, #2
			word1 = *(ushort *)addr1;
34804ac8:	01d720b0 	ldrheq	r2, [r7]
			word2 = *(ushort *)addr2;
34804acc:	01da30b0 	ldrheq	r3, [sl]
		} else {
			word1 = *(u_char *)addr1;
34804ad0:	15d72000 	ldrbne	r2, [r7]
			word2 = *(u_char *)addr2;
34804ad4:	15da3000 	ldrbne	r3, [sl]
		}
		if (word1 != word2) {
34804ad8:	e1520003 	cmp	r2, r3
34804adc:	0a00000a 	beq	34804b0c <do_mem_cmp+0xf0>
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
34804ae0:	e58d2000 	str	r2, [sp]
34804ae4:	e58d3010 	str	r3, [sp, #16]
34804ae8:	e59f0060 	ldr	r0, [pc, #96]	; 34804b50 <do_mem_cmp+0x134>
34804aec:	e1a03006 	mov	r3, r6
34804af0:	e1a01004 	mov	r1, r4
34804af4:	e1a02007 	mov	r2, r7
34804af8:	e58d600c 	str	r6, [sp, #12]
34804afc:	e98d0410 	stmib	sp, {r4, sl}
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
34804b00:	e3a06001 	mov	r6, #1
		} else {
			word1 = *(u_char *)addr1;
			word2 = *(u_char *)addr2;
		}
		if (word1 != word2) {
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
34804b04:	eb00142b 	bl	34809bb8 <printf>
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
			break;
34804b08:	ea000005 	b	34804b24 <do_mem_cmp+0x108>
		}

		addr1 += size;
34804b0c:	e0877006 	add	r7, r7, r6
34804b10:	e08aa006 	add	sl, sl, r6
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
34804b14:	e2855001 	add	r5, r5, #1
34804b18:	e1550000 	cmp	r5, r0
34804b1c:	3affffe4 	bcc	34804ab4 <do_mem_cmp+0x98>

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
34804b20:	e3a06000 	mov	r6, #0
		/* reset watchdog from time to time */
		if ((ngood % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}

	printf("Total of %ld %s(s) were the same\n", ngood, type);
34804b24:	e59f0028 	ldr	r0, [pc, #40]	; 34804b54 <do_mem_cmp+0x138>
34804b28:	e1a01005 	mov	r1, r5
34804b2c:	e1a02004 	mov	r2, r4
34804b30:	eb001420 	bl	34809bb8 <printf>
	return rcode;
}
34804b34:	e1a00006 	mov	r0, r6
34804b38:	e28dd018 	add	sp, sp, #24
34804b3c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804b40:	3482405b 	.word	0x3482405b
34804b44:	34824057 	.word	0x34824057
34804b48:	34824052 	.word	0x34824052
34804b4c:	34829d40 	.word	0x34829d40
34804b50:	34824060 	.word	0x34824060
34804b54:	34824092 	.word	0x34824092

34804b58 <do_mem_mw>:
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804b58:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34804b5c:	e1a06003 	mov	r6, r3
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
34804b60:	e2423003 	sub	r3, r2, #3
34804b64:	e3530001 	cmp	r3, #1
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804b68:	e1a04002 	mov	r4, r2
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
		return CMD_RET_USAGE;
34804b6c:	83e00000 	mvnhi	r0, #0
int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
34804b70:	88bd84f0 	pophi	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
34804b74:	e5960000 	ldr	r0, [r6]
34804b78:	e3a01004 	mov	r1, #4
34804b7c:	eb00132f 	bl	34809840 <cmd_get_data_size>
34804b80:	e2507000 	subs	r7, r0, #0
34804b84:	da00001e 	ble	34804c04 <do_mem_mw+0xac>
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804b88:	e3a01000 	mov	r1, #0
34804b8c:	e3a02010 	mov	r2, #16
34804b90:	e5960004 	ldr	r0, [r6, #4]
34804b94:	eb00624b 	bl	3481d4c8 <simple_strtoul>
	addr += base_address;
34804b98:	e59f306c 	ldr	r3, [pc, #108]	; 34804c0c <do_mem_mw+0xb4>

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804b9c:	e3a01000 	mov	r1, #0
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804ba0:	e5935000 	ldr	r5, [r3]

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804ba4:	e3a02010 	mov	r2, #16
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804ba8:	e0805005 	add	r5, r0, r5

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804bac:	e5960008 	ldr	r0, [r6, #8]
34804bb0:	eb006244 	bl	3481d4c8 <simple_strtoul>

	/* Count ? */
	if (argc == 4) {
34804bb4:	e3540004 	cmp	r4, #4
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804bb8:	e1a0a000 	mov	sl, r0

	/* Count ? */
	if (argc == 4) {
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
34804bbc:	13a00001 	movne	r0, #1
	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);

	/* Count ? */
	if (argc == 4) {
34804bc0:	1a00000c 	bne	34804bf8 <do_mem_mw+0xa0>
		count = simple_strtoul(argv[3], NULL, 16);
34804bc4:	e596000c 	ldr	r0, [r6, #12]
34804bc8:	e3a01000 	mov	r1, #0
34804bcc:	e3a02010 	mov	r2, #16
34804bd0:	eb00623c 	bl	3481d4c8 <simple_strtoul>
34804bd4:	ea000007 	b	34804bf8 <do_mem_mw+0xa0>
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804bd8:	e3570004 	cmp	r7, #4
			*((ulong  *)addr) = (ulong )writeval;
34804bdc:	0585a000 	streq	sl, [r5]
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804be0:	0a000002 	beq	34804bf0 <do_mem_mw+0x98>
			*((ulong  *)addr) = (ulong )writeval;
		else if (size == 2)
34804be4:	e3570002 	cmp	r7, #2
			*((ushort *)addr) = (ushort)writeval;
34804be8:	01c5a0b0 	strheq	sl, [r5]
		else
			*((u_char *)addr) = (u_char)writeval;
34804bec:	15c5a000 	strbne	sl, [r5]
34804bf0:	e0855007 	add	r5, r5, r7
34804bf4:	e2400001 	sub	r0, r0, #1
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
	}

	while (count-- > 0) {
34804bf8:	e3500000 	cmp	r0, #0
34804bfc:	1afffff5 	bne	34804bd8 <do_mem_mw+0x80>
34804c00:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
		return 1;
34804c04:	e3a00001 	mov	r0, #1
		else
			*((u_char *)addr) = (u_char)writeval;
		addr += size;
	}
	return 0;
}
34804c08:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804c0c:	34829d40 	.word	0x34829d40

34804c10 <do_mem_md>:
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804c10:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
34804c14:	e59fa0b8 	ldr	sl, [pc, #184]	; 34804cd4 <do_mem_md+0xc4>
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804c18:	e1a07003 	mov	r7, r3
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;
34804c1c:	e59f30b4 	ldr	r3, [pc, #180]	; 34804cd8 <do_mem_md+0xc8>

	if (argc < 2)
34804c20:	e3520001 	cmp	r2, #1
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804c24:	e1a0b002 	mov	fp, r2
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
34804c28:	e59a6004 	ldr	r6, [sl, #4]
	size = dp_last_size;
34804c2c:	e59a4008 	ldr	r4, [sl, #8]
	length = dp_last_length;
34804c30:	e5935000 	ldr	r5, [r3]

	if (argc < 2)
		return CMD_RET_USAGE;
34804c34:	d3e00000 	mvnle	r0, #0
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;

	if (argc < 2)
34804c38:	da000024 	ble	34804cd0 <do_mem_md+0xc0>
		return CMD_RET_USAGE;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804c3c:	e2119001 	ands	r9, r1, #1
34804c40:	1a000012 	bne	34804c90 <do_mem_md+0x80>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804c44:	e5970000 	ldr	r0, [r7]
34804c48:	e3a01004 	mov	r1, #4
34804c4c:	eb0012fb 	bl	34809840 <cmd_get_data_size>
34804c50:	e2504000 	subs	r4, r0, #0
			return 1;
34804c54:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804c58:	ba00001c 	blt	34804cd0 <do_mem_md+0xc0>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
34804c5c:	e5970004 	ldr	r0, [r7, #4]
34804c60:	e1a01009 	mov	r1, r9
34804c64:	e3a02010 	mov	r2, #16
34804c68:	eb006216 	bl	3481d4c8 <simple_strtoul>
		addr += base_address;
34804c6c:	e59a6000 	ldr	r6, [sl]

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
34804c70:	e35b0002 	cmp	fp, #2
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
		addr += base_address;
34804c74:	e0806006 	add	r6, r0, r6

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
34804c78:	0a000004 	beq	34804c90 <do_mem_md+0x80>
			length = simple_strtoul(argv[2], NULL, 16);
34804c7c:	e5970008 	ldr	r0, [r7, #8]
34804c80:	e1a01009 	mov	r1, r9
34804c84:	e3a02010 	mov	r2, #16
34804c88:	eb00620e 	bl	3481d4c8 <simple_strtoul>
34804c8c:	e1a05000 	mov	r5, r0
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804c90:	e1a01004 	mov	r1, r4
34804c94:	e3a00010 	mov	r0, #16
34804c98:	eb006d06 	bl	348200b8 <__divsi3>
34804c9c:	e1a01006 	mov	r1, r6
34804ca0:	e58d0000 	str	r0, [sp]
34804ca4:	e1a00006 	mov	r0, r6
		addr += size*length;
34804ca8:	e0266495 	mla	r6, r5, r4, r6
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804cac:	e1a02004 	mov	r2, r4
34804cb0:	e1a03005 	mov	r3, r5
34804cb4:	eb005815 	bl	3481ad10 <print_buffer>
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804cb8:	e59f3014 	ldr	r3, [pc, #20]	; 34804cd4 <do_mem_md+0xc4>
	dp_last_length = length;
34804cbc:	e59f2014 	ldr	r2, [pc, #20]	; 34804cd8 <do_mem_md+0xc8>
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804cc0:	e5836004 	str	r6, [r3, #4]
	dp_last_length = length;
34804cc4:	e5825000 	str	r5, [r2]
	dp_last_size = size;
34804cc8:	e5834008 	str	r4, [r3, #8]
	return (rc);
34804ccc:	e3a00000 	mov	r0, #0
}
34804cd0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34804cd4:	34829d40 	.word	0x34829d40
34804cd8:	348286b4 	.word	0x348286b4

34804cdc <mod_mem.clone.0>:
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
34804cdc:	e3520002 	cmp	r2, #2
 * Syntax:
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
34804ce0:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
34804ce4:	e1a04000 	mov	r4, r0
34804ce8:	e1a0a003 	mov	sl, r3
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
		return CMD_RET_USAGE;
34804cec:	13e00000 	mvnne	r0, #0
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
34804cf0:	1a000040 	bne	34804df8 <mod_mem.clone.0+0x11c>
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
34804cf4:	e59f7114 	ldr	r7, [pc, #276]	; 34804e10 <mod_mem.clone.0+0x134>
	size = mm_last_size;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804cf8:	e2119001 	ands	r9, r1, #1
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
34804cfc:	e597500c 	ldr	r5, [r7, #12]
	size = mm_last_size;
34804d00:	e5976010 	ldr	r6, [r7, #16]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804d04:	1a00000b 	bne	34804d38 <mod_mem.clone.0+0x5c>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804d08:	e5930000 	ldr	r0, [r3]
34804d0c:	e3a01004 	mov	r1, #4
34804d10:	eb0012ca 	bl	34809840 <cmd_get_data_size>
34804d14:	e2506000 	subs	r6, r0, #0
			return 1;
34804d18:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804d1c:	ba000035 	blt	34804df8 <mod_mem.clone.0+0x11c>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
34804d20:	e59a0004 	ldr	r0, [sl, #4]
34804d24:	e1a01009 	mov	r1, r9
34804d28:	e3a02010 	mov	r2, #16
34804d2c:	eb0061e5 	bl	3481d4c8 <simple_strtoul>
		addr += base_address;
34804d30:	e5975000 	ldr	r5, [r7]
34804d34:	e0805005 	add	r5, r0, r5
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804d38:	e59f70d4 	ldr	r7, [pc, #212]	; 34804e14 <mod_mem.clone.0+0x138>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
				addr += nbytes ? -size : size;
34804d3c:	e266a000 	rsb	sl, r6, #0
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804d40:	e28d9004 	add	r9, sp, #4

	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
34804d44:	e1a01005 	mov	r1, r5
34804d48:	e59f00c8 	ldr	r0, [pc, #200]	; 34804e18 <mod_mem.clone.0+0x13c>
34804d4c:	eb001399 	bl	34809bb8 <printf>
		if (size == 4)
34804d50:	e3560004 	cmp	r6, #4
			printf(" %08x", *((uint   *)addr));
34804d54:	059f00c0 	ldreq	r0, [pc, #192]	; 34804e1c <mod_mem.clone.0+0x140>
34804d58:	05951000 	ldreq	r1, [r5]
	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
		if (size == 4)
34804d5c:	0a000004 	beq	34804d74 <mod_mem.clone.0+0x98>
			printf(" %08x", *((uint   *)addr));
		else if (size == 2)
34804d60:	e3560002 	cmp	r6, #2
			printf(" %04x", *((ushort *)addr));
34804d64:	059f00b4 	ldreq	r0, [pc, #180]	; 34804e20 <mod_mem.clone.0+0x144>
34804d68:	01d510b0 	ldrheq	r1, [r5]
		else
			printf(" %02x", *((u_char *)addr));
34804d6c:	159f00b0 	ldrne	r0, [pc, #176]	; 34804e24 <mod_mem.clone.0+0x148>
34804d70:	15d51000 	ldrbne	r1, [r5]
34804d74:	eb00138f 	bl	34809bb8 <printf>

		nbytes = readline (" ? ");
34804d78:	e59f00a8 	ldr	r0, [pc, #168]	; 34804e28 <mod_mem.clone.0+0x14c>
34804d7c:	eb0026bf 	bl	3480e880 <readline>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
34804d80:	e3500000 	cmp	r0, #0
34804d84:	0a000004 	beq	34804d9c <mod_mem.clone.0+0xc0>
34804d88:	e3500001 	cmp	r0, #1
34804d8c:	1a000009 	bne	34804db8 <mod_mem.clone.0+0xdc>
34804d90:	e5d73000 	ldrb	r3, [r7]
34804d94:	e353002d 	cmp	r3, #45	; 0x2d
34804d98:	1a000006 	bne	34804db8 <mod_mem.clone.0+0xdc>
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
34804d9c:	e3540000 	cmp	r4, #0
34804da0:	0affffe7 	beq	34804d44 <mod_mem.clone.0+0x68>
				addr += nbytes ? -size : size;
34804da4:	e3500000 	cmp	r0, #0
34804da8:	01a03006 	moveq	r3, r6
34804dac:	11a0300a 	movne	r3, sl
34804db0:	e0855003 	add	r5, r5, r3
34804db4:	eaffffe2 	b	34804d44 <mod_mem.clone.0+0x68>
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804db8:	e59f0054 	ldr	r0, [pc, #84]	; 34804e14 <mod_mem.clone.0+0x138>
34804dbc:	e1a01009 	mov	r1, r9
34804dc0:	e3a02010 	mov	r2, #16
34804dc4:	eb0061bf 	bl	3481d4c8 <simple_strtoul>
			nbytes = endp - console_buffer;
			if (nbytes) {
34804dc8:	e59d3004 	ldr	r3, [sp, #4]
34804dcc:	e1530007 	cmp	r3, r7
34804dd0:	0a000009 	beq	34804dfc <mod_mem.clone.0+0x120>
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
34804dd4:	e3560004 	cmp	r6, #4
					*((uint   *)addr) = i;
34804dd8:	05850000 	streq	r0, [r5]
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
34804ddc:	0a000002 	beq	34804dec <mod_mem.clone.0+0x110>
					*((uint   *)addr) = i;
				else if (size == 2)
34804de0:	e3560002 	cmp	r6, #2
					*((ushort *)addr) = i;
34804de4:	01c500b0 	strheq	r0, [r5]
				else
					*((u_char *)addr) = i;
34804de8:	15c50000 	strbne	r0, [r5]
				if (incrflag)
34804dec:	e3540000 	cmp	r4, #0
					addr += size;
34804df0:	10855006 	addne	r5, r5, r6
34804df4:	eaffffd2 	b	34804d44 <mod_mem.clone.0+0x68>
	} while (nbytes);

	mm_last_addr = addr;
	mm_last_size = size;
	return 0;
}
34804df8:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
34804dfc:	e59f300c 	ldr	r3, [pc, #12]	; 34804e10 <mod_mem.clone.0+0x134>
	mm_last_size = size;
	return 0;
34804e00:	e3a00000 	mov	r0, #0
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
34804e04:	e583500c 	str	r5, [r3, #12]
	mm_last_size = size;
34804e08:	e5836010 	str	r6, [r3, #16]
34804e0c:	eafffff9 	b	34804df8 <mod_mem.clone.0+0x11c>
34804e10:	34829d40 	.word	0x34829d40
34804e14:	3482b720 	.word	0x3482b720
34804e18:	348240b4 	.word	0x348240b4
34804e1c:	3482735f 	.word	0x3482735f
34804e20:	348240bb 	.word	0x348240bb
34804e24:	348240c1 	.word	0x348240c1
34804e28:	348240c7 	.word	0x348240c7

34804e2c <do_mem_nm>:
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
}
int do_mem_nm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
34804e2c:	e3a00000 	mov	r0, #0
34804e30:	eaffffa9 	b	34804cdc <mod_mem.clone.0>

34804e34 <do_mem_mm>:
	return (rc);
}

int do_mem_mm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
34804e34:	e3a00001 	mov	r0, #1
34804e38:	eaffffa7 	b	34804cdc <mod_mem.clone.0>

34804e3c <do_mmcops>:

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
34804e3c:	e3520001 	cmp	r2, #1
	"display MMC info",
	"- dislay info of the current MMC device"
);

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804e40:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34804e44:	e1a07002 	mov	r7, r2
34804e48:	e1a04003 	mov	r4, r3
	enum mmc_state state;

	if (argc < 2)
34804e4c:	da0000eb 	ble	34805200 <do_mmcops+0x3c4>
		return CMD_RET_USAGE;

	if (curr_device < 0) {
34804e50:	e59f53b4 	ldr	r5, [pc, #948]	; 3480520c <do_mmcops+0x3d0>
34804e54:	e5953000 	ldr	r3, [r5]
34804e58:	e3530000 	cmp	r3, #0
34804e5c:	aa000005 	bge	34804e78 <do_mmcops+0x3c>
		if (get_mmc_num() > 0)
34804e60:	eb0037f6 	bl	34812e40 <get_mmc_num>
34804e64:	e3500000 	cmp	r0, #0
			curr_device = 0;
34804e68:	c3a03000 	movgt	r3, #0
34804e6c:	c5853000 	strgt	r3, [r5]
		else {
			puts("No MMC device available\n");
34804e70:	d59f0398 	ldrle	r0, [pc, #920]	; 34805210 <do_mmcops+0x3d4>

	if (argc < 2)
		return CMD_RET_USAGE;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
34804e74:	da000027 	ble	34804f18 <do_mmcops+0xdc>
			puts("No MMC device available\n");
			return 1;
		}
	}

	if (strcmp(argv[1], "rescan") == 0) {
34804e78:	e5940004 	ldr	r0, [r4, #4]
34804e7c:	e59f1390 	ldr	r1, [pc, #912]	; 34805214 <do_mmcops+0x3d8>
34804e80:	eb005dc9 	bl	3481c5ac <strcmp>
34804e84:	e2505000 	subs	r5, r0, #0
34804e88:	1a000009 	bne	34804eb4 <do_mmcops+0x78>
		struct mmc *mmc = find_mmc_device(curr_device);
34804e8c:	e59f4378 	ldr	r4, [pc, #888]	; 3480520c <do_mmcops+0x3d0>
34804e90:	e5940000 	ldr	r0, [r4]
34804e94:	eb0032ad 	bl	34811950 <find_mmc_device>

		if (!mmc) {
34804e98:	e2503000 	subs	r3, r0, #0
34804e9c:	0a00000f 	beq	34804ee0 <do_mmcops+0xa4>
			printf("no mmc device at slot %x\n", curr_device);
			return 1;
		}

		mmc->has_init = 0;
34804ea0:	e5835034 	str	r5, [r3, #52]	; 0x34

		if (mmc_init(mmc))
34804ea4:	eb003788 	bl	34812ccc <mmc_init>
int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
		return CMD_RET_USAGE;
34804ea8:	e2505000 	subs	r5, r0, #0
34804eac:	13a05001 	movne	r5, #1
34804eb0:	ea0000d3 	b	34805204 <do_mmcops+0x3c8>

		if (mmc_init(mmc))
			return 1;
		else
			return 0;
	} else if (strncmp(argv[1], "part", 4) == 0) {
34804eb4:	e5940004 	ldr	r0, [r4, #4]
34804eb8:	e59f1358 	ldr	r1, [pc, #856]	; 34805218 <do_mmcops+0x3dc>
34804ebc:	e3a02004 	mov	r2, #4
34804ec0:	eb005dc5 	bl	3481c5dc <strncmp>
34804ec4:	e2505000 	subs	r5, r0, #0
34804ec8:	1a000014 	bne	34804f20 <do_mmcops+0xe4>
		block_dev_desc_t *mmc_dev;
		struct mmc *mmc = find_mmc_device(curr_device);
34804ecc:	e59f4338 	ldr	r4, [pc, #824]	; 3480520c <do_mmcops+0x3d0>
34804ed0:	e5940000 	ldr	r0, [r4]
34804ed4:	eb00329d 	bl	34811950 <find_mmc_device>

		if (!mmc) {
34804ed8:	e3500000 	cmp	r0, #0
34804edc:	1a000002 	bne	34804eec <do_mmcops+0xb0>
			printf("no mmc device at slot %x\n", curr_device);
34804ee0:	e59f0334 	ldr	r0, [pc, #820]	; 3480521c <do_mmcops+0x3e0>
34804ee4:	e5941000 	ldr	r1, [r4]
34804ee8:	ea000092 	b	34805138 <do_mmcops+0x2fc>
			return 1;
		}
		mmc_init(mmc);
34804eec:	eb003776 	bl	34812ccc <mmc_init>
		mmc_dev = mmc_get_dev(curr_device);
34804ef0:	e5940000 	ldr	r0, [r4]
34804ef4:	eb0037ac 	bl	34812dac <mmc_get_dev>
		if (mmc_dev != NULL &&
34804ef8:	e2503000 	subs	r3, r0, #0
34804efc:	0a000004 	beq	34804f14 <do_mmcops+0xd8>
34804f00:	e5d3300b 	ldrb	r3, [r3, #11]
34804f04:	e35300ff 	cmp	r3, #255	; 0xff
34804f08:	0a000001 	beq	34804f14 <do_mmcops+0xd8>
				mmc_dev->type != DEV_TYPE_UNKNOWN) {
			print_part(mmc_dev);
34804f0c:	eb002bbe 	bl	3480fe0c <print_part>
			return 0;
34804f10:	ea0000bb 	b	34805204 <do_mmcops+0x3c8>
		}

		puts("get mmc type error!\n");
34804f14:	e59f0304 	ldr	r0, [pc, #772]	; 34805220 <do_mmcops+0x3e4>
34804f18:	eb00131c 	bl	34809b90 <puts>
34804f1c:	ea000086 	b	3480513c <do_mmcops+0x300>
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
34804f20:	e5940004 	ldr	r0, [r4, #4]
34804f24:	e59f12f8 	ldr	r1, [pc, #760]	; 34805224 <do_mmcops+0x3e8>
34804f28:	eb005d9f 	bl	3481c5ac <strcmp>
34804f2c:	e2505000 	subs	r5, r0, #0
34804f30:	1a000002 	bne	34804f40 <do_mmcops+0x104>
		print_mmc_devices('\n');
34804f34:	e280000a 	add	r0, r0, #10
34804f38:	eb0037a7 	bl	34812ddc <print_mmc_devices>
		return 0;
34804f3c:	ea0000b0 	b	34805204 <do_mmcops+0x3c8>
	} else if (strcmp(argv[1], "dev") == 0) {
34804f40:	e5940004 	ldr	r0, [r4, #4]
34804f44:	e59f12dc 	ldr	r1, [pc, #732]	; 34805228 <do_mmcops+0x3ec>
34804f48:	eb005d97 	bl	3481c5ac <strcmp>
34804f4c:	e2505000 	subs	r5, r0, #0
34804f50:	1a000048 	bne	34805078 <do_mmcops+0x23c>
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
34804f54:	e3570002 	cmp	r7, #2
			dev = curr_device;
34804f58:	059f32ac 	ldreq	r3, [pc, #684]	; 3480520c <do_mmcops+0x3d0>
34804f5c:	05934000 	ldreq	r4, [r3]
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
34804f60:	0a000006 	beq	34804f80 <do_mmcops+0x144>
			dev = curr_device;
		else if (argc == 3)
34804f64:	e3570003 	cmp	r7, #3
34804f68:	1a000006 	bne	34804f88 <do_mmcops+0x14c>
			dev = simple_strtoul(argv[2], NULL, 10);
34804f6c:	e5940008 	ldr	r0, [r4, #8]
34804f70:	e1a01005 	mov	r1, r5
34804f74:	e3a0200a 	mov	r2, #10
34804f78:	eb006152 	bl	3481d4c8 <simple_strtoul>
34804f7c:	e1a04000 	mov	r4, r0
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
		print_mmc_devices('\n');
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
34804f80:	e3e07000 	mvn	r7, #0
34804f84:	ea000010 	b	34804fcc <do_mmcops+0x190>

		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
34804f88:	e3570004 	cmp	r7, #4
34804f8c:	1a00009b 	bne	34805200 <do_mmcops+0x3c4>
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804f90:	e1a01005 	mov	r1, r5
34804f94:	e3a0200a 	mov	r2, #10
34804f98:	e5940008 	ldr	r0, [r4, #8]
34804f9c:	eb006149 	bl	3481d4c8 <simple_strtoul>
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804fa0:	e1a01005 	mov	r1, r5
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804fa4:	e1a06000 	mov	r6, r0
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804fa8:	e3a0200a 	mov	r2, #10
34804fac:	e594000c 	ldr	r0, [r4, #12]
34804fb0:	eb006144 	bl	3481d4c8 <simple_strtoul>
			if (part > PART_ACCESS_MASK) {
34804fb4:	e3500007 	cmp	r0, #7
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804fb8:	e1a07000 	mov	r7, r0
			if (part > PART_ACCESS_MASK) {
				printf("#part_num shouldn't be larger"
34804fbc:	c3a01007 	movgt	r1, #7
34804fc0:	c59f0264 	ldrgt	r0, [pc, #612]	; 3480522c <do_mmcops+0x3f0>
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
			if (part > PART_ACCESS_MASK) {
34804fc4:	ca00005b 	bgt	34805138 <do_mmcops+0x2fc>
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804fc8:	e1a04006 	mov	r4, r6
				return 1;
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
34804fcc:	e1a00004 	mov	r0, r4
34804fd0:	eb00325e 	bl	34811950 <find_mmc_device>
		if (!mmc) {
34804fd4:	e2505000 	subs	r5, r0, #0
			printf("no mmc device at slot %x\n", dev);
34804fd8:	059f023c 	ldreq	r0, [pc, #572]	; 3480521c <do_mmcops+0x3e0>
34804fdc:	01a01004 	moveq	r1, r4
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
		if (!mmc) {
34804fe0:	0a000054 	beq	34805138 <do_mmcops+0x2fc>
			printf("no mmc device at slot %x\n", dev);
			return 1;
		}

		mmc_init(mmc);
34804fe4:	eb003738 	bl	34812ccc <mmc_init>
		if (part != -1) {
34804fe8:	e3770001 	cmn	r7, #1
34804fec:	0a000012 	beq	3480503c <do_mmcops+0x200>
			int ret;
			if (mmc->part_config == MMCPART_NOAVAILABLE) {
34804ff0:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
34804ff4:	e35300ff 	cmp	r3, #255	; 0xff
34804ff8:	1a000002 	bne	34805008 <do_mmcops+0x1cc>
				printf("Card doesn't support part_switch\n");
34804ffc:	e59f022c 	ldr	r0, [pc, #556]	; 34805230 <do_mmcops+0x3f4>
34805000:	eb0012ec 	bl	34809bb8 <printf>
34805004:	ea00004c 	b	3480513c <do_mmcops+0x300>
				return 1;
			}

			if (part != mmc->part_num) {
34805008:	e5d53083 	ldrb	r3, [r5, #131]	; 0x83
3480500c:	e1570003 	cmp	r7, r3
34805010:	0a000009 	beq	3480503c <do_mmcops+0x200>
				ret = mmc_switch_part(dev, part);
34805014:	e1a01007 	mov	r1, r7
34805018:	e1a00004 	mov	r0, r4
3480501c:	eb003487 	bl	34812240 <mmc_switch_part>
				if (!ret)
34805020:	e3500000 	cmp	r0, #0
					mmc->part_num = part;
34805024:	05c57083 	strbeq	r7, [r5, #131]	; 0x83

				printf("switch to partions #%d, %s\n",
34805028:	059f2204 	ldreq	r2, [pc, #516]	; 34805234 <do_mmcops+0x3f8>
3480502c:	159f2204 	ldrne	r2, [pc, #516]	; 34805238 <do_mmcops+0x3fc>
34805030:	e59f0204 	ldr	r0, [pc, #516]	; 3480523c <do_mmcops+0x400>
34805034:	e1a01007 	mov	r1, r7
34805038:	eb0012de 	bl	34809bb8 <printf>
						part, (!ret) ? "OK" : "ERROR");
			}
		}
		curr_device = dev;
3480503c:	e59f31c8 	ldr	r3, [pc, #456]	; 3480520c <do_mmcops+0x3d0>
34805040:	e5834000 	str	r4, [r3]
		if (mmc->part_config == MMCPART_NOAVAILABLE)
34805044:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
34805048:	e35300ff 	cmp	r3, #255	; 0xff
3480504c:	1a000003 	bne	34805060 <do_mmcops+0x224>
			printf("mmc%d is current device\n", curr_device);
34805050:	e1a01004 	mov	r1, r4
34805054:	e59f01e4 	ldr	r0, [pc, #484]	; 34805240 <do_mmcops+0x404>
34805058:	eb0012d6 	bl	34809bb8 <printf>
3480505c:	ea000003 	b	34805070 <do_mmcops+0x234>
		else
			printf("mmc%d(part %d) is current device\n",
34805060:	e59f01dc 	ldr	r0, [pc, #476]	; 34805244 <do_mmcops+0x408>
34805064:	e1a01004 	mov	r1, r4
34805068:	e5d52083 	ldrb	r2, [r5, #131]	; 0x83
3480506c:	eb0012d1 	bl	34809bb8 <printf>
				curr_device, mmc->part_num);

		return 0;
34805070:	e3a05000 	mov	r5, #0
34805074:	ea000062 	b	34805204 <do_mmcops+0x3c8>
	}

	if (strcmp(argv[1], "read") == 0)
34805078:	e5940004 	ldr	r0, [r4, #4]
3480507c:	e59f11c4 	ldr	r1, [pc, #452]	; 34805248 <do_mmcops+0x40c>
34805080:	eb005d49 	bl	3481c5ac <strcmp>
34805084:	e3500000 	cmp	r0, #0
		state = MMC_READ;
34805088:	03a06001 	moveq	r6, #1
				curr_device, mmc->part_num);

		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
3480508c:	0a00000b 	beq	348050c0 <do_mmcops+0x284>
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
34805090:	e5940004 	ldr	r0, [r4, #4]
34805094:	e59f11b0 	ldr	r1, [pc, #432]	; 3480524c <do_mmcops+0x410>
34805098:	eb005d43 	bl	3481c5ac <strcmp>
3480509c:	e3500000 	cmp	r0, #0
		state = MMC_WRITE;
348050a0:	03a06002 	moveq	r6, #2
		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
348050a4:	0a000005 	beq	348050c0 <do_mmcops+0x284>
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
348050a8:	e5940004 	ldr	r0, [r4, #4]
348050ac:	e59f119c 	ldr	r1, [pc, #412]	; 34805250 <do_mmcops+0x414>
348050b0:	eb005d3d 	bl	3481c5ac <strcmp>
348050b4:	e3500000 	cmp	r0, #0
		state = MMC_ERASE;
348050b8:	03a06003 	moveq	r6, #3

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
348050bc:	1a00004f 	bne	34805200 <do_mmcops+0x3c4>
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
348050c0:	e59f3144 	ldr	r3, [pc, #324]	; 3480520c <do_mmcops+0x3d0>
348050c4:	e5930000 	ldr	r0, [r3]
348050c8:	eb003220 	bl	34811950 <find_mmc_device>
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
348050cc:	e3560003 	cmp	r6, #3
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
348050d0:	e1a07000 	mov	r7, r0

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
348050d4:	03a0b000 	moveq	fp, #0
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
		int idx = 2;
348050d8:	03a05002 	moveq	r5, #2
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
348050dc:	0a000005 	beq	348050f8 <do_mmcops+0x2bc>
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
348050e0:	e5940008 	ldr	r0, [r4, #8]
348050e4:	e3a01000 	mov	r1, #0
348050e8:	e3a02010 	mov	r2, #16
348050ec:	eb0060f5 	bl	3481d4c8 <simple_strtoul>
			++idx;
348050f0:	e3a05003 	mov	r5, #3
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
348050f4:	e1a0b000 	mov	fp, r0
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
348050f8:	e7940105 	ldr	r0, [r4, r5, lsl #2]
348050fc:	e3a01000 	mov	r1, #0
34805100:	e3a02010 	mov	r2, #16
34805104:	eb0060ef 	bl	3481d4c8 <simple_strtoul>
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34805108:	e2855001 	add	r5, r5, #1
		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
3480510c:	e1a09000 	mov	r9, r0
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34805110:	e3a01000 	mov	r1, #0
34805114:	e7940105 	ldr	r0, [r4, r5, lsl #2]
34805118:	e3a02010 	mov	r2, #16
3480511c:	eb0060e9 	bl	3481d4c8 <simple_strtoul>

		if (!mmc) {
34805120:	e3570000 	cmp	r7, #0
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34805124:	e1a05000 	mov	r5, r0
34805128:	e59fa0dc 	ldr	sl, [pc, #220]	; 3480520c <do_mmcops+0x3d0>

		if (!mmc) {
3480512c:	1a000004 	bne	34805144 <do_mmcops+0x308>
			printf("no mmc device at slot %x\n", curr_device);
34805130:	e59f00e4 	ldr	r0, [pc, #228]	; 3480521c <do_mmcops+0x3e0>
34805134:	e59a1000 	ldr	r1, [sl]
34805138:	eb00129e 	bl	34809bb8 <printf>
			return 1;
3480513c:	e3a05001 	mov	r5, #1
34805140:	ea00002f 	b	34805204 <do_mmcops+0x3c8>
		}

		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
34805144:	e58d0000 	str	r0, [sp]
34805148:	e5941004 	ldr	r1, [r4, #4]
3480514c:	e59a2000 	ldr	r2, [sl]
34805150:	e1a03009 	mov	r3, r9
34805154:	e59f00f8 	ldr	r0, [pc, #248]	; 34805254 <do_mmcops+0x418>
34805158:	eb001296 	bl	34809bb8 <printf>
				argv[1], curr_device, blk, cnt);

		mmc_init(mmc);
3480515c:	e1a00007 	mov	r0, r7
34805160:	eb0036d9 	bl	34812ccc <mmc_init>

		switch (state) {
34805164:	e3560002 	cmp	r6, #2
34805168:	0a00000c 	beq	348051a0 <do_mmcops+0x364>
3480516c:	e3560003 	cmp	r6, #3
34805170:	0a000011 	beq	348051bc <do_mmcops+0x380>
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
34805174:	e1a01009 	mov	r1, r9
34805178:	e597c100 	ldr	ip, [r7, #256]	; 0x100
3480517c:	e59a0000 	ldr	r0, [sl]
34805180:	e1a02005 	mov	r2, r5
34805184:	e1a0300b 	mov	r3, fp
34805188:	e12fff3c 	blx	ip
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
3480518c:	e1a01485 	lsl	r1, r5, #9

		mmc_init(mmc);

		switch (state) {
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
34805190:	e1a06000 	mov	r6, r0
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
34805194:	e1a0000b 	mov	r0, fp
34805198:	ebffeff2 	bl	34801168 <flush_cache>
			break;
3480519c:	ea00000c 	b	348051d4 <do_mmcops+0x398>
		case MMC_WRITE:
			n = mmc->block_dev.block_write(curr_device, blk,
348051a0:	e597c104 	ldr	ip, [r7, #260]	; 0x104
348051a4:	e59a0000 	ldr	r0, [sl]
348051a8:	e1a01009 	mov	r1, r9
348051ac:	e1a02005 	mov	r2, r5
348051b0:	e1a0300b 	mov	r3, fp
348051b4:	e12fff3c 	blx	ip
348051b8:	ea000004 	b	348051d0 <do_mmcops+0x394>
						      cnt, addr);
			break;
		case MMC_ERASE:
			n = mmc->block_dev.block_erase(curr_device, blk, cnt);
348051bc:	e5973108 	ldr	r3, [r7, #264]	; 0x108
348051c0:	e59a0000 	ldr	r0, [sl]
348051c4:	e1a01009 	mov	r1, r9
348051c8:	e1a02005 	mov	r2, r5
348051cc:	e12fff33 	blx	r3
348051d0:	e1a06000 	mov	r6, r0
			break;
		default:
			BUG();
		}

		printf("%d blocks %s: %s\n",
348051d4:	e59fc05c 	ldr	ip, [pc, #92]	; 34805238 <do_mmcops+0x3fc>
348051d8:	e1560005 	cmp	r6, r5
348051dc:	e59f3050 	ldr	r3, [pc, #80]	; 34805234 <do_mmcops+0x3f8>
348051e0:	e59f0070 	ldr	r0, [pc, #112]	; 34805258 <do_mmcops+0x41c>
348051e4:	11a0300c 	movne	r3, ip
348051e8:	e1a01006 	mov	r1, r6
348051ec:	e5942004 	ldr	r2, [r4, #4]
348051f0:	eb001270 	bl	34809bb8 <printf>
				n, argv[1], (n == cnt) ? "OK" : "ERROR");
		return (n == cnt) ? 0 : 1;
348051f4:	e0565005 	subs	r5, r6, r5
348051f8:	13a05001 	movne	r5, #1
348051fc:	ea000000 	b	34805204 <do_mmcops+0x3c8>
	}

	return CMD_RET_USAGE;
34805200:	e3e05000 	mvn	r5, #0
}
34805204:	e1a00005 	mov	r0, r5
34805208:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480520c:	348286b8 	.word	0x348286b8
34805210:	34824386 	.word	0x34824386
34805214:	3482439f 	.word	0x3482439f
34805218:	34824e3c 	.word	0x34824e3c
3480521c:	348243a6 	.word	0x348243a6
34805220:	348243c0 	.word	0x348243c0
34805224:	348243d5 	.word	0x348243d5
34805228:	348243da 	.word	0x348243da
3480522c:	348243de 	.word	0x348243de
34805230:	34824405 	.word	0x34824405
34805234:	3482437d 	.word	0x3482437d
34805238:	34824380 	.word	0x34824380
3480523c:	34824427 	.word	0x34824427
34805240:	34824443 	.word	0x34824443
34805244:	3482445c 	.word	0x3482445c
34805248:	3482447e 	.word	0x3482447e
3480524c:	34824483 	.word	0x34824483
34805250:	34824489 	.word	0x34824489
34805254:	3482448f 	.word	0x3482448f
34805258:	348244bc 	.word	0x348244bc

3480525c <do_mmcinfo>:

	printf("Bus Width: %d-bit\n", mmc->bus_width);
}

int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480525c:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	struct mmc *mmc;

	if (curr_device < 0) {
34805260:	e59f4128 	ldr	r4, [pc, #296]	; 34805390 <do_mmcinfo+0x134>
34805264:	e5943000 	ldr	r3, [r4]
34805268:	e3530000 	cmp	r3, #0
3480526c:	aa000007 	bge	34805290 <do_mmcinfo+0x34>
		if (get_mmc_num() > 0)
34805270:	eb0036f2 	bl	34812e40 <get_mmc_num>
34805274:	e3500000 	cmp	r0, #0
			curr_device = 0;
34805278:	c3a03000 	movgt	r3, #0
3480527c:	c5843000 	strgt	r3, [r4]
int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	struct mmc *mmc;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
34805280:	ca000002 	bgt	34805290 <do_mmcinfo+0x34>
			curr_device = 0;
		else {
			puts("No MMC device available\n");
34805284:	e59f0108 	ldr	r0, [pc, #264]	; 34805394 <do_mmcinfo+0x138>
34805288:	eb001240 	bl	34809b90 <puts>
3480528c:	ea00003d 	b	34805388 <do_mmcinfo+0x12c>
			return 1;
		}
	}

	mmc = find_mmc_device(curr_device);
34805290:	e59f50f8 	ldr	r5, [pc, #248]	; 34805390 <do_mmcinfo+0x134>
34805294:	e5950000 	ldr	r0, [r5]
34805298:	eb0031ac 	bl	34811950 <find_mmc_device>

	if (mmc) {
3480529c:	e2504000 	subs	r4, r0, #0
348052a0:	0a000035 	beq	3480537c <do_mmcinfo+0x120>
		mmc_init(mmc);
348052a4:	eb003688 	bl	34812ccc <mmc_init>
	MMC_WRITE,
	MMC_ERASE,
};
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
348052a8:	e2841008 	add	r1, r4, #8
348052ac:	e59f00e4 	ldr	r0, [pc, #228]	; 34805398 <do_mmcinfo+0x13c>
348052b0:	eb001240 	bl	34809bb8 <printf>
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
348052b4:	e5d41073 	ldrb	r1, [r4, #115]	; 0x73
348052b8:	e59f00dc 	ldr	r0, [pc, #220]	; 3480539c <do_mmcinfo+0x140>
348052bc:	eb00123d 	bl	34809bb8 <printf>
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
348052c0:	e5941070 	ldr	r1, [r4, #112]	; 0x70
348052c4:	e59f00d4 	ldr	r0, [pc, #212]	; 348053a0 <do_mmcinfo+0x144>
348052c8:	e7ef1451 	ubfx	r1, r1, #8, #16
348052cc:	eb001239 	bl	34809bb8 <printf>
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
348052d0:	e5943074 	ldr	r3, [r4, #116]	; 0x74
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
348052d4:	e5d41070 	ldrb	r1, [r4, #112]	; 0x70
348052d8:	e7e72453 	ubfx	r2, r3, #8, #8
348052dc:	e58d2000 	str	r2, [sp]
348052e0:	e20320ff 	and	r2, r3, #255	; 0xff
348052e4:	e58d2004 	str	r2, [sp, #4]
348052e8:	e59f00b4 	ldr	r0, [pc, #180]	; 348053a4 <do_mmcinfo+0x148>
348052ec:	e1a02c23 	lsr	r2, r3, #24
348052f0:	e7e73853 	ubfx	r3, r3, #16, #8
348052f4:	eb00122f 	bl	34809bb8 <printf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);

	printf("Tran Speed: %d\n", mmc->tran_speed);
348052f8:	e5941084 	ldr	r1, [r4, #132]	; 0x84
348052fc:	e59f00a4 	ldr	r0, [pc, #164]	; 348053a8 <do_mmcinfo+0x14c>
34805300:	eb00122c 	bl	34809bb8 <printf>
	printf("Rd Block Len: %d\n", mmc->read_bl_len);
34805304:	e5941088 	ldr	r1, [r4, #136]	; 0x88
34805308:	e59f009c 	ldr	r0, [pc, #156]	; 348053ac <do_mmcinfo+0x150>
3480530c:	eb001229 	bl	34809bb8 <printf>

	printf("%s version %d.%d\n", IS_SD(mmc) ? "SD" : "MMC",
34805310:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34805314:	e59f2094 	ldr	r2, [pc, #148]	; 348053b0 <do_mmcinfo+0x154>
34805318:	e59f1094 	ldr	r1, [pc, #148]	; 348053b4 <do_mmcinfo+0x158>
3480531c:	e3130802 	tst	r3, #131072	; 0x20000
34805320:	11a01002 	movne	r1, r2
34805324:	e59f008c 	ldr	r0, [pc, #140]	; 348053b8 <do_mmcinfo+0x15c>
34805328:	e7e32253 	ubfx	r2, r3, #4, #4
3480532c:	e203300f 	and	r3, r3, #15
34805330:	eb001220 	bl	34809bb8 <printf>
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);

	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
34805334:	e5941040 	ldr	r1, [r4, #64]	; 0x40
34805338:	e59f307c 	ldr	r3, [pc, #124]	; 348053bc <do_mmcinfo+0x160>
3480533c:	e59f207c 	ldr	r2, [pc, #124]	; 348053c0 <do_mmcinfo+0x164>
34805340:	e3510000 	cmp	r1, #0
34805344:	01a01002 	moveq	r1, r2
34805348:	11a01003 	movne	r1, r3
3480534c:	e59f0070 	ldr	r0, [pc, #112]	; 348053c4 <do_mmcinfo+0x168>
34805350:	eb001218 	bl	34809bb8 <printf>
	puts("Capacity: ");
34805354:	e59f006c 	ldr	r0, [pc, #108]	; 348053c8 <do_mmcinfo+0x16c>
34805358:	eb00120c 	bl	34809b90 <puts>
	print_size(mmc->capacity, "\n");
3480535c:	e1c409d8 	ldrd	r0, [r4, #152]	; 0x98
34805360:	e59f2064 	ldr	r2, [pc, #100]	; 348053cc <do_mmcinfo+0x170>
34805364:	eb00561e 	bl	3481abe4 <print_size>

	printf("Bus Width: %d-bit\n", mmc->bus_width);
34805368:	e59f0060 	ldr	r0, [pc, #96]	; 348053d0 <do_mmcinfo+0x174>
3480536c:	e5941044 	ldr	r1, [r4, #68]	; 0x44
34805370:	eb001210 	bl	34809bb8 <printf>

	if (mmc) {
		mmc_init(mmc);

		print_mmcinfo(mmc);
		return 0;
34805374:	e3a00000 	mov	r0, #0
34805378:	ea000003 	b	3480538c <do_mmcinfo+0x130>
	} else {
		printf("no mmc device at slot %x\n", curr_device);
3480537c:	e59f0050 	ldr	r0, [pc, #80]	; 348053d4 <do_mmcinfo+0x178>
34805380:	e5951000 	ldr	r1, [r5]
34805384:	eb00120b 	bl	34809bb8 <printf>
		return 1;
34805388:	e3a00001 	mov	r0, #1
	}
}
3480538c:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
34805390:	348286b8 	.word	0x348286b8
34805394:	34824386 	.word	0x34824386
34805398:	348244d9 	.word	0x348244d9
3480539c:	348244e5 	.word	0x348244e5
348053a0:	348244fa 	.word	0x348244fa
348053a4:	34824503 	.word	0x34824503
348053a8:	34824516 	.word	0x34824516
348053ac:	34824526 	.word	0x34824526
348053b0:	34826b88 	.word	0x34826b88
348053b4:	348244ce 	.word	0x348244ce
348053b8:	34824538 	.word	0x34824538
348053bc:	348244d2 	.word	0x348244d2
348053c0:	348244d6 	.word	0x348244d6
348053c4:	3482454a 	.word	0x3482454a
348053c8:	3482455d 	.word	0x3482455d
348053cc:	348264dd 	.word	0x348264dd
348053d0:	34824568 	.word	0x34824568
348053d4:	348243a6 	.word	0x348243a6

348053d8 <mtd_part_info>:
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 */
static struct part_info* mtd_part_info(struct mtd_device *dev, unsigned int part_num)
{
348053d8:	e92d4007 	push	{r0, r1, r2, lr}
	struct list_head *entry;
	struct part_info *part;
	int num;

	if (!dev)
348053dc:	e3500000 	cmp	r0, #0
348053e0:	0a00001c 	beq	34805458 <mtd_part_info+0x80>

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
348053e4:	e1d030bc 	ldrh	r3, [r0, #12]
348053e8:	e1510003 	cmp	r1, r3
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
348053ec:	31a0c000 	movcc	ip, r0
348053f0:	35bc3010 	ldrcc	r3, [ip, #16]!
				dev->id->num, dev->id->mtd_id);
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
348053f4:	33a02000 	movcc	r2, #0

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
348053f8:	3a000013 	bcc	3480544c <mtd_part_info+0x74>
		printf("invalid partition number %d for device %s%d (%s)\n",
				part_num, MTD_DEV_TYPE(dev->id->type),
348053fc:	e5900008 	ldr	r0, [r0, #8]
34805400:	e5d03008 	ldrb	r3, [r0, #8]
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
34805404:	e3530002 	cmp	r3, #2
34805408:	059f204c 	ldreq	r2, [pc, #76]	; 3480545c <mtd_part_info+0x84>
3480540c:	0a000003 	beq	34805420 <mtd_part_info+0x48>
				part_num, MTD_DEV_TYPE(dev->id->type),
34805410:	e59fc048 	ldr	ip, [pc, #72]	; 34805460 <mtd_part_info+0x88>
34805414:	e3530004 	cmp	r3, #4
34805418:	e59f2044 	ldr	r2, [pc, #68]	; 34805464 <mtd_part_info+0x8c>
3480541c:	11a0200c 	movne	r2, ip
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
34805420:	e5d03009 	ldrb	r3, [r0, #9]
34805424:	e5900010 	ldr	r0, [r0, #16]
34805428:	e58d0000 	str	r0, [sp]
3480542c:	e59f0034 	ldr	r0, [pc, #52]	; 34805468 <mtd_part_info+0x90>
34805430:	eb0011e0 	bl	34809bb8 <printf>
34805434:	ea000006 	b	34805454 <mtd_part_info+0x7c>
	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
34805438:	e1510002 	cmp	r1, r2
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);
3480543c:	e1a00003 	mov	r0, r3

		if (part_num == num++) {
34805440:	0a000004 	beq	34805458 <mtd_part_info+0x80>
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
34805444:	e5933000 	ldr	r3, [r3]
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
34805448:	e2822001 	add	r2, r2, #1
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
3480544c:	e153000c 	cmp	r3, ip
34805450:	1afffff8 	bne	34805438 <mtd_part_info+0x60>
		if (part_num == num++) {
			return part;
		}
	}

	return NULL;
34805454:	e3a00000 	mov	r0, #0
}
34805458:	e8bd800e 	pop	{r1, r2, r3, pc}
3480545c:	34824a89 	.word	0x34824a89
34805460:	348246b8 	.word	0x348246b8
34805464:	34824a86 	.word	0x34824a86
34805468:	348246bc 	.word	0x348246bc

3480546c <index_partitions>:
 * This routine does global indexing of all partitions. Resulting index for
 * current partition is saved in 'mtddevnum'. Current partition name in
 * 'mtddevname'.
 */
static void index_partitions(void)
{
3480546c:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
34805470:	e59f10a0 	ldr	r1, [pc, #160]	; 34805518 <index_partitions+0xac>
34805474:	e5914000 	ldr	r4, [r1]
34805478:	e3540000 	cmp	r4, #0
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
3480547c:	15b13004 	ldrne	r3, [r1, #4]!
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
34805480:	13a02000 	movne	r2, #0
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
34805484:	1a000012 	bne	348054d4 <index_partitions+0x68>
34805488:	ea00001b 	b	348054fc <index_partitions+0x90>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
3480548c:	e1530004 	cmp	r3, r4
34805490:	1a00000b 	bne	348054c4 <index_partitions+0x58>
				mtddevnum += current_mtd_partnum;
34805494:	e59f307c 	ldr	r3, [pc, #124]	; 34805518 <index_partitions+0xac>
				sprintf(buf, "%d", mtddevnum);
34805498:	e1a0000d 	mov	r0, sp
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
3480549c:	e5d3300c 	ldrb	r3, [r3, #12]
				sprintf(buf, "%d", mtddevnum);
348054a0:	e59f1074 	ldr	r1, [pc, #116]	; 3480551c <index_partitions+0xb0>
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
348054a4:	e0822003 	add	r2, r2, r3
				sprintf(buf, "%d", mtddevnum);
348054a8:	e6ff2072 	uxth	r2, r2
348054ac:	eb0060ab 	bl	3481d760 <sprintf>
				setenv("mtddevnum", buf);
348054b0:	e1a0100d 	mov	r1, sp
348054b4:	e59f0064 	ldr	r0, [pc, #100]	; 34805520 <index_partitions+0xb4>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
348054b8:	e1a0400d 	mov	r4, sp
				setenv("mtddevnum", buf);
348054bc:	eb0009c7 	bl	34807be0 <setenv>
				break;
348054c0:	ea000005 	b	348054dc <index_partitions+0x70>
			}
			mtddevnum += dev->num_parts;
348054c4:	e1d300bc 	ldrh	r0, [r3, #12]

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
348054c8:	e5933000 	ldr	r3, [r3]
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
				setenv("mtddevnum", buf);
				break;
			}
			mtddevnum += dev->num_parts;
348054cc:	e0822000 	add	r2, r2, r0
348054d0:	e6ff2072 	uxth	r2, r2

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
348054d4:	e1530001 	cmp	r3, r1
348054d8:	1affffeb 	bne	3480548c <index_partitions+0x20>
				break;
			}
			mtddevnum += dev->num_parts;
		}

		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
348054dc:	e59f3034 	ldr	r3, [pc, #52]	; 34805518 <index_partitions+0xac>
348054e0:	e5d3100c 	ldrb	r1, [r3, #12]
348054e4:	e5930000 	ldr	r0, [r3]
348054e8:	ebffffba 	bl	348053d8 <mtd_part_info>
348054ec:	e1a03000 	mov	r3, r0
		setenv("mtddevname", part->name);
348054f0:	e5931008 	ldr	r1, [r3, #8]
348054f4:	e59f0028 	ldr	r0, [pc, #40]	; 34805524 <index_partitions+0xb8>
348054f8:	ea000004 	b	34805510 <index_partitions+0xa4>

		debug("=> mtddevnum %d,\n=> mtddevname %s\n", mtddevnum, part->name);
	} else {
		setenv("mtddevnum", NULL);
348054fc:	e1a01004 	mov	r1, r4
34805500:	e59f0018 	ldr	r0, [pc, #24]	; 34805520 <index_partitions+0xb4>
34805504:	eb0009b5 	bl	34807be0 <setenv>
		setenv("mtddevname", NULL);
34805508:	e59f0014 	ldr	r0, [pc, #20]	; 34805524 <index_partitions+0xb8>
3480550c:	e1a01004 	mov	r1, r4
34805510:	eb0009b2 	bl	34807be0 <setenv>

		debug("=> mtddevnum NULL\n=> mtddevname NULL\n");
	}
}
34805514:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
34805518:	34829d54 	.word	0x34829d54
3480551c:	34825d5d 	.word	0x34825d5d
34805520:	348246ee 	.word	0x348246ee
34805524:	348246f8 	.word	0x348246f8

34805528 <memsize_format>:
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34805528:	e3c13103 	bic	r3, r1, #-1073741824	; 0xc0000000
 *
 * @param buf output buffer
 * @param size size to be converted to string
 */
static void memsize_format(char *buf, u32 size)
{
3480552c:	e1a02001 	mov	r2, r1
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34805530:	e3530000 	cmp	r3, #0
		sprintf(buf, "%ug", size/SIZE_GB);
34805534:	059f1030 	ldreq	r1, [pc, #48]	; 3480556c <memsize_format+0x44>
34805538:	01a02f22 	lsreq	r2, r2, #30
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
3480553c:	0a000009 	beq	34805568 <memsize_format+0x40>
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
34805540:	e3c234ff 	bic	r3, r2, #-16777216	; 0xff000000
34805544:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
34805548:	e3530000 	cmp	r3, #0
		sprintf(buf, "%um", size/SIZE_MB);
3480554c:	059f101c 	ldreq	r1, [pc, #28]	; 34805570 <memsize_format+0x48>
34805550:	01a02a22 	lsreq	r2, r2, #20
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
34805554:	0a000003 	beq	34805568 <memsize_format+0x40>
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
34805558:	e1b03b02 	lsls	r3, r2, #22
		sprintf(buf, "%uk", size/SIZE_KB);
3480555c:	059f1010 	ldreq	r1, [pc, #16]	; 34805574 <memsize_format+0x4c>
	else
		sprintf(buf, "%u", size);
34805560:	159f1010 	ldrne	r1, [pc, #16]	; 34805578 <memsize_format+0x50>
	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
		sprintf(buf, "%uk", size/SIZE_KB);
34805564:	01a02522 	lsreq	r2, r2, #10
	else
		sprintf(buf, "%u", size);
34805568:	ea00607c 	b	3481d760 <sprintf>
3480556c:	34824703 	.word	0x34824703
34805570:	34824707 	.word	0x34824707
34805574:	3482470b 	.word	0x3482470b
34805578:	3482470f 	.word	0x3482470f

3480557c <current_save>:

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
3480557c:	e92d4030 	push	{r4, r5, lr}
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34805580:	e59f508c 	ldr	r5, [pc, #140]	; 34805614 <current_save+0x98>

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
34805584:	e24dd01c 	sub	sp, sp, #28
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34805588:	e5954000 	ldr	r4, [r5]
3480558c:	e3540000 	cmp	r4, #0
34805590:	0a000018 	beq	348055f8 <current_save+0x7c>
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_mtd_dev->id->type),
34805594:	e5943008 	ldr	r3, [r4, #8]
34805598:	e5d31008 	ldrb	r1, [r3, #8]
3480559c:	e3510002 	cmp	r1, #2
348055a0:	059f2070 	ldreq	r2, [pc, #112]	; 34805618 <current_save+0x9c>
348055a4:	0a000003 	beq	348055b8 <current_save+0x3c>
348055a8:	e59f006c 	ldr	r0, [pc, #108]	; 3480561c <current_save+0xa0>
348055ac:	e3510004 	cmp	r1, #4
348055b0:	e59f2068 	ldr	r2, [pc, #104]	; 34805620 <current_save+0xa4>
348055b4:	11a02000 	movne	r2, r0
348055b8:	e59f5054 	ldr	r5, [pc, #84]	; 34805614 <current_save+0x98>
348055bc:	e28d4008 	add	r4, sp, #8
348055c0:	e5d5100c 	ldrb	r1, [r5, #12]
348055c4:	e5d33009 	ldrb	r3, [r3, #9]
348055c8:	e1a00004 	mov	r0, r4
348055cc:	e58d1000 	str	r1, [sp]
348055d0:	e59f104c 	ldr	r1, [pc, #76]	; 34805624 <current_save+0xa8>
348055d4:	eb006061 	bl	3481d760 <sprintf>
					current_mtd_dev->id->num, current_mtd_partnum);

		setenv("partition", buf);
348055d8:	e1a01004 	mov	r1, r4
348055dc:	e59f0044 	ldr	r0, [pc, #68]	; 34805628 <current_save+0xac>
348055e0:	eb00097e 	bl	34807be0 <setenv>
		strncpy(last_partition, buf, 16);
348055e4:	e2850010 	add	r0, r5, #16
348055e8:	e1a01004 	mov	r1, r4
348055ec:	e3a02010 	mov	r2, #16
348055f0:	eb005bc3 	bl	3481c504 <strncpy>
348055f4:	ea000003 	b	34805608 <current_save+0x8c>

		debug("=> partition %s\n", buf);
	} else {
		setenv("partition", NULL);
348055f8:	e59f0028 	ldr	r0, [pc, #40]	; 34805628 <current_save+0xac>
348055fc:	e1a01004 	mov	r1, r4
34805600:	eb000976 	bl	34807be0 <setenv>
		last_partition[0] = '\0';
34805604:	e5c54010 	strb	r4, [r5, #16]

		debug("=> partition NULL\n");
	}
	index_partitions();
34805608:	ebffff97 	bl	3480546c <index_partitions>
}
3480560c:	e28dd01c 	add	sp, sp, #28
34805610:	e8bd8030 	pop	{r4, r5, pc}
34805614:	34829d54 	.word	0x34829d54
34805618:	34824a89 	.word	0x34824a89
3480561c:	348246b8 	.word	0x348246b8
34805620:	34824a86 	.word	0x34824a86
34805624:	34824712 	.word	0x34824712
34805628:	34824e4f 	.word	0x34824e4f

3480562c <part_sort_add>:
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
3480562c:	e5903010 	ldr	r3, [r0, #16]
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805630:	e92d4070 	push	{r4, r5, r6, lr}
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
34805634:	e2806010 	add	r6, r0, #16
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805638:	e1a05001 	mov	r5, r1
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
3480563c:	e1530006 	cmp	r3, r6
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805640:	e1a04000 	mov	r4, r0
	struct list_head *entry;
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;
34805644:	e5850024 	str	r0, [r5, #36]	; 0x24

	if (list_empty(&dev->parts)) {
34805648:	1a000007 	bne	3480566c <part_sort_add+0x40>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3480564c:	e5831004 	str	r1, [r3, #4]
	new->next = next;
34805650:	e5813000 	str	r3, [r1]
	new->prev = prev;
34805654:	e5813004 	str	r3, [r1, #4]
		debug("part_sort_add: list empty\n");
		list_add(&part->link, &dev->parts);
		dev->num_parts++;
34805658:	e1d030bc 	ldrh	r3, [r0, #12]
	prev->next = new;
3480565c:	e5841010 	str	r1, [r4, #16]
34805660:	e2833001 	add	r3, r3, #1
34805664:	e1c030bc 	strh	r3, [r0, #12]
34805668:	ea000027 	b	3480570c <part_sort_add+0xe0>

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
3480566c:	e59f30dc 	ldr	r3, [pc, #220]	; 34805750 <part_sort_add+0x124>
34805670:	e5932000 	ldr	r2, [r3]
34805674:	e1500002 	cmp	r0, r2
	}

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
34805678:	13a00000 	movne	r0, #0
	if (dev == current_mtd_dev)
3480567c:	1a000001 	bne	34805688 <part_sort_add+0x5c>
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34805680:	e5d3100c 	ldrb	r1, [r3, #12]
34805684:	ebffff53 	bl	348053d8 <mtd_part_info>

	list_for_each(entry, &dev->parts) {
34805688:	e5943010 	ldr	r3, [r4, #16]
3480568c:	ea000022 	b	3480571c <part_sort_add+0xf0>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
34805690:	e5952014 	ldr	r2, [r5, #20]
34805694:	e5931014 	ldr	r1, [r3, #20]
34805698:	e1520001 	cmp	r2, r1
3480569c:	1a000005 	bne	348056b8 <part_sort_add+0x8c>
348056a0:	e3520000 	cmp	r2, #0
348056a4:	1a000005 	bne	348056c0 <part_sort_add+0x94>
			printf("cannot add second partition at offset 0\n");
348056a8:	e59f00a4 	ldr	r0, [pc, #164]	; 34805754 <part_sort_add+0x128>
348056ac:	eb001141 	bl	34809bb8 <printf>
			return 1;
348056b0:	e3a00001 	mov	r0, #1
348056b4:	e8bd8070 	pop	{r4, r5, r6, pc}
		}

		if (new_pi->offset <= pi->offset) {
348056b8:	8a000016 	bhi	34805718 <part_sort_add+0xec>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
348056bc:	e1a02001 	mov	r2, r1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348056c0:	e5931004 	ldr	r1, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348056c4:	e5853000 	str	r3, [r5]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348056c8:	e5835004 	str	r5, [r3, #4]
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
348056cc:	e1d430bc 	ldrh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
348056d0:	e3500000 	cmp	r0, #0
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
348056d4:	e2833001 	add	r3, r3, #1
	new->next = next;
	new->prev = prev;
348056d8:	e5851004 	str	r1, [r5, #4]
	prev->next = new;
348056dc:	e5815000 	str	r5, [r1]
348056e0:	e1c430bc 	strh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
348056e4:	0a000008 	beq	3480570c <part_sort_add+0xe0>
348056e8:	e5903014 	ldr	r3, [r0, #20]
348056ec:	e1520003 	cmp	r2, r3
348056f0:	8a000005 	bhi	3480570c <part_sort_add+0xe0>
				/* we are modyfing partitions for the current
				 * device, update current */
				current_mtd_partnum++;
348056f4:	e59f3054 	ldr	r3, [pc, #84]	; 34805750 <part_sort_add+0x124>
348056f8:	e5d3200c 	ldrb	r2, [r3, #12]
348056fc:	e2822001 	add	r2, r2, #1
34805700:	e5c3200c 	strb	r2, [r3, #12]
				current_save();
34805704:	ebffff9c 	bl	3480557c <current_save>
34805708:	ea000000 	b	34805710 <part_sort_add+0xe4>
			} else {
				index_partitions();
3480570c:	ebffff56 	bl	3480546c <index_partitions>
			}
			return 0;
34805710:	e3a00000 	mov	r0, #0
34805714:	e8bd8070 	pop	{r4, r5, r6, pc}
	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);

	list_for_each(entry, &dev->parts) {
34805718:	e5933000 	ldr	r3, [r3]
3480571c:	e1530006 	cmp	r3, r6
34805720:	1affffda 	bne	34805690 <part_sort_add+0x64>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34805724:	e5853000 	str	r3, [r5]
			return 0;
		}
	}

	list_add_tail(&part->link, &dev->parts);
	dev->num_parts++;
34805728:	e1d430bc 	ldrh	r3, [r4, #12]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480572c:	e5942014 	ldr	r2, [r4, #20]
34805730:	e2833001 	add	r3, r3, #1
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34805734:	e5845014 	str	r5, [r4, #20]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34805738:	e5825000 	str	r5, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
3480573c:	e5852004 	str	r2, [r5, #4]
34805740:	e1c430bc 	strh	r3, [r4, #12]
	index_partitions();
34805744:	ebffff48 	bl	3480546c <index_partitions>
	return 0;
34805748:	e3a00000 	mov	r0, #0
}
3480574c:	e8bd8070 	pop	{r4, r5, r6, pc}
34805750:	34829d54 	.word	0x34829d54
34805754:	3482471a 	.word	0x3482471a

34805758 <part_delall>:
 * Delete all partitions from parts head list, free memory.
 *
 * @param head list of partitions to delete
 */
static void part_delall(struct list_head *head)
{
34805758:	e92d4070 	push	{r4, r5, r6, lr}
3480575c:	e1a06000 	mov	r6, r0
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34805760:	e5900000 	ldr	r0, [r0]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805764:	e3a05000 	mov	r5, #0
34805768:	e5904000 	ldr	r4, [r0]
3480576c:	ea000007 	b	34805790 <part_delall+0x38>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805770:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34805774:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805778:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
3480577c:	e5805004 	str	r5, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805780:	e5805000 	str	r5, [r0]
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
34805784:	eb001249 	bl	3480a0b0 <free>
{
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34805788:	e1a00004 	mov	r0, r4
3480578c:	e5944000 	ldr	r4, [r4]
34805790:	e1500006 	cmp	r0, r6
34805794:	1afffff5 	bne	34805770 <part_delall+0x18>
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
	}
}
34805798:	e8bd8070 	pop	{r4, r5, r6, pc}

3480579c <device_del>:
 *
 * @param dev device to be deleted
 * @return 0 on success, 1 otherwise
 */
static int device_del(struct mtd_device *dev)
{
3480579c:	e92d4038 	push	{r3, r4, r5, lr}
348057a0:	e1a04000 	mov	r4, r0
	part_delall(&dev->parts);
348057a4:	e2800010 	add	r0, r0, #16
348057a8:	ebffffea 	bl	34805758 <part_delall>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348057ac:	e894000c 	ldm	r4, {r2, r3}
	entry->next = LIST_POISON1;
348057b0:	e3a05000 	mov	r5, #0
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348057b4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348057b8:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348057bc:	e5845004 	str	r5, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348057c0:	e5845000 	str	r5, [r4]
	list_del(&dev->link);
	free(dev);
348057c4:	e1a00004 	mov	r0, r4
348057c8:	eb001238 	bl	3480a0b0 <free>

	if (dev == current_mtd_dev) {
348057cc:	e59f3034 	ldr	r3, [pc, #52]	; 34805808 <device_del+0x6c>
348057d0:	e5932000 	ldr	r2, [r3]
348057d4:	e1540002 	cmp	r4, r2
348057d8:	1a000007 	bne	348057fc <device_del+0x60>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
348057dc:	e1a02003 	mov	r2, r3
348057e0:	e5b21004 	ldr	r1, [r2, #4]!
		/* we just deleted current device */
		if (list_empty(&devices)) {
348057e4:	e1510002 	cmp	r1, r2
			current_mtd_dev = NULL;
348057e8:	05835000 	streq	r5, [r3]
		} else {
			/* reset first partition from first dev from the
			 * devices list as current */
			current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
348057ec:	15831000 	strne	r1, [r3]
			current_mtd_partnum = 0;
348057f0:	15c3500c 	strbne	r5, [r3, #12]
		}
		current_save();
348057f4:	ebffff60 	bl	3480557c <current_save>
		return 0;
348057f8:	ea000000 	b	34805800 <device_del+0x64>
	}

	index_partitions();
348057fc:	ebffff1a 	bl	3480546c <index_partitions>
	return 0;
}
34805800:	e3a00000 	mov	r0, #0
34805804:	e8bd8038 	pop	{r3, r4, r5, pc}
34805808:	34829d54 	.word	0x34829d54

3480580c <memsize_parse>:
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
3480580c:	e92d4010 	push	{r4, lr}
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34805810:	e3a02000 	mov	r2, #0
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
34805814:	e1a04001 	mov	r4, r1
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34805818:	eb005f2a 	bl	3481d4c8 <simple_strtoul>

	switch (**retptr) {
3480581c:	e5942000 	ldr	r2, [r4]
34805820:	e5d23000 	ldrb	r3, [r2]
34805824:	e353004d 	cmp	r3, #77	; 0x4d
34805828:	0a00000c 	beq	34805860 <memsize_parse+0x54>
3480582c:	8a000004 	bhi	34805844 <memsize_parse+0x38>
34805830:	e3530047 	cmp	r3, #71	; 0x47
34805834:	0a000008 	beq	3480585c <memsize_parse+0x50>
34805838:	e353004b 	cmp	r3, #75	; 0x4b
3480583c:	18bd8010 	popne	{r4, pc}
34805840:	ea000007 	b	34805864 <memsize_parse+0x58>
34805844:	e353006b 	cmp	r3, #107	; 0x6b
34805848:	0a000005 	beq	34805864 <memsize_parse+0x58>
3480584c:	e353006d 	cmp	r3, #109	; 0x6d
34805850:	0a000002 	beq	34805860 <memsize_parse+0x54>
34805854:	e3530067 	cmp	r3, #103	; 0x67
34805858:	18bd8010 	popne	{r4, pc}
		case 'G':
		case 'g':
			ret <<= 10;
3480585c:	e1a00500 	lsl	r0, r0, #10
		case 'M':
		case 'm':
			ret <<= 10;
34805860:	e1a00500 	lsl	r0, r0, #10
		case 'K':
		case 'k':
			ret <<= 10;
			(*retptr)++;
34805864:	e2822001 	add	r2, r2, #1
		case 'M':
		case 'm':
			ret <<= 10;
		case 'K':
		case 'k':
			ret <<= 10;
34805868:	e1a00500 	lsl	r0, r0, #10
			(*retptr)++;
3480586c:	e5842000 	str	r2, [r4]
		default:
			break;
	}

	return ret;
}
34805870:	e8bd8010 	pop	{r4, pc}

34805874 <get_mtd_info>:
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
34805874:	e92d4030 	push	{r4, r5, lr}
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805878:	e3500002 	cmp	r0, #2
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
3480587c:	e1a05002 	mov	r5, r2
34805880:	e24dd014 	sub	sp, sp, #20
34805884:	e1a03001 	mov	r3, r1
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805888:	059f2050 	ldreq	r2, [pc, #80]	; 348058e0 <get_mtd_info+0x6c>
3480588c:	0a000003 	beq	348058a0 <get_mtd_info+0x2c>
34805890:	e59f104c 	ldr	r1, [pc, #76]	; 348058e4 <get_mtd_info+0x70>
34805894:	e3500004 	cmp	r0, #4
34805898:	e59f2048 	ldr	r2, [pc, #72]	; 348058e8 <get_mtd_info+0x74>
3480589c:	11a02001 	movne	r2, r1
348058a0:	e59f1044 	ldr	r1, [pc, #68]	; 348058ec <get_mtd_info+0x78>
348058a4:	e1a0000d 	mov	r0, sp
348058a8:	eb005fac 	bl	3481d760 <sprintf>
	*mtd = get_mtd_device_nm(mtd_dev);
348058ac:	e1a0000d 	mov	r0, sp
348058b0:	eb003816 	bl	34813910 <get_mtd_device_nm>
	if (IS_ERR(*mtd)) {
348058b4:	e3700a01 	cmn	r0, #4096	; 0x1000
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
348058b8:	e5850000 	str	r0, [r5]
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
348058bc:	e1a0400d 	mov	r4, sp
	if (IS_ERR(*mtd)) {
		printf("Device %s not found!\n", mtd_dev);
		return 1;
	}

	return 0;
348058c0:	93a00000 	movls	r0, #0
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
	if (IS_ERR(*mtd)) {
348058c4:	9a000003 	bls	348058d8 <get_mtd_info+0x64>
		printf("Device %s not found!\n", mtd_dev);
348058c8:	e59f0020 	ldr	r0, [pc, #32]	; 348058f0 <get_mtd_info+0x7c>
348058cc:	e1a0100d 	mov	r1, sp
348058d0:	eb0010b8 	bl	34809bb8 <printf>
		return 1;
348058d4:	e3a00001 	mov	r0, #1
	}

	return 0;
}
348058d8:	e28dd014 	add	sp, sp, #20
348058dc:	e8bd8030 	pop	{r4, r5, pc}
348058e0:	34824a89 	.word	0x34824a89
348058e4:	348246b8 	.word	0x348246b8
348058e8:	34824a86 	.word	0x34824a86
348058ec:	34824743 	.word	0x34824743
348058f0:	34824748 	.word	0x34824748

348058f4 <part_validate_eraseblock>:
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
348058f4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct mtd_info *mtd = NULL;
348058f8:	e3a03000 	mov	r3, #0
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
348058fc:	e1a05000 	mov	r5, r0
	struct mtd_info *mtd = NULL;
34805900:	e28d2008 	add	r2, sp, #8
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
34805904:	e1a04001 	mov	r4, r1
	struct mtd_info *mtd = NULL;
34805908:	e5223004 	str	r3, [r2, #-4]!
	int i, j;
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
3480590c:	e5d00008 	ldrb	r0, [r0, #8]
34805910:	e5d51009 	ldrb	r1, [r5, #9]
34805914:	ebffffd6 	bl	34805874 <get_mtd_info>
34805918:	e3500000 	cmp	r0, #0
3480591c:	1a00001f 	bne	348059a0 <part_validate_eraseblock+0xac>
		return 1;

	part->sector_size = mtd->erasesize;
34805920:	e59d7004 	ldr	r7, [sp, #4]

	if (!mtd->numeraseregions) {
34805924:	e597c02c 	ldr	ip, [r7, #44]	; 0x2c
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
34805928:	e5976010 	ldr	r6, [r7, #16]

	if (!mtd->numeraseregions) {
3480592c:	e35c0000 	cmp	ip, #0
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
34805930:	e5846020 	str	r6, [r4, #32]

	if (!mtd->numeraseregions) {
34805934:	11a06000 	movne	r6, r0
34805938:	1a00002b 	bne	348059ec <part_validate_eraseblock+0xf8>
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
3480593c:	e5940014 	ldr	r0, [r4, #20]
34805940:	e1a01006 	mov	r1, r6
34805944:	eb0069d3 	bl	34820098 <__aeabi_uidivmod>
34805948:	e3510000 	cmp	r1, #0
3480594c:	0a000009 	beq	34805978 <part_validate_eraseblock+0x84>
			printf("%s%d: partition (%s) start offset"
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805950:	e5d53008 	ldrb	r3, [r5, #8]
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
34805954:	e3530002 	cmp	r3, #2
34805958:	059f113c 	ldreq	r1, [pc, #316]	; 34805a9c <part_validate_eraseblock+0x1a8>
3480595c:	0a000003 	beq	34805970 <part_validate_eraseblock+0x7c>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805960:	e59f2138 	ldr	r2, [pc, #312]	; 34805aa0 <part_validate_eraseblock+0x1ac>
34805964:	e3530004 	cmp	r3, #4
34805968:	e59f1134 	ldr	r1, [pc, #308]	; 34805aa4 <part_validate_eraseblock+0x1b0>
3480596c:	01a01002 	moveq	r1, r2
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
34805970:	e59f0130 	ldr	r0, [pc, #304]	; 34805aa8 <part_validate_eraseblock+0x1b4>
34805974:	ea000006 	b	34805994 <part_validate_eraseblock+0xa0>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
34805978:	e5940010 	ldr	r0, [r4, #16]
3480597c:	e1a01006 	mov	r1, r6
34805980:	eb0069c4 	bl	34820098 <__aeabi_uidivmod>
34805984:	e2510000 	subs	r0, r1, #0
34805988:	1a000038 	bne	34805a70 <part_validate_eraseblock+0x17c>
3480598c:	ea000041 	b	34805a98 <part_validate_eraseblock+0x1a4>
			printf("%s%d: partition (%s) size alignment incorrect\n",
34805990:	e59f0114 	ldr	r0, [pc, #276]	; 34805aac <part_validate_eraseblock+0x1b8>
34805994:	e5d52009 	ldrb	r2, [r5, #9]
34805998:	e5943008 	ldr	r3, [r4, #8]
3480599c:	eb001085 	bl	34809bb8 <printf>
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
348059a0:	e3a00001 	mov	r0, #1
348059a4:	ea00003b 	b	34805a98 <part_validate_eraseblock+0x1a4>
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
348059a8:	e5971030 	ldr	r1, [r7, #48]	; 0x30
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348059ac:	e3a0a000 	mov	sl, #0
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
348059b0:	e0819000 	add	r9, r1, r0
348059b4:	e7913000 	ldr	r3, [r1, r0]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348059b8:	e599b00c 	ldr	fp, [r9, #12]
348059bc:	ea000006 	b	348059dc <part_validate_eraseblock+0xe8>
				if (part->offset == start)
348059c0:	e5942014 	ldr	r2, [r4, #20]
348059c4:	e1520003 	cmp	r2, r3
348059c8:	03a00000 	moveq	r0, #0
348059cc:	0a000021 	beq	34805a58 <part_validate_eraseblock+0x164>
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
348059d0:	e5992008 	ldr	r2, [r9, #8]
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348059d4:	e28aa001 	add	sl, sl, #1
				if (part->offset == start)
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
348059d8:	e0833002 	add	r3, r3, r2
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348059dc:	e15a000b 	cmp	sl, fp
348059e0:	3afffff6 	bcc	348059c0 <part_validate_eraseblock+0xcc>
		 * Multiple eraseregions (non-uniform NOR),
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
348059e4:	e2866001 	add	r6, r6, #1
348059e8:	e2800018 	add	r0, r0, #24
348059ec:	e156000c 	cmp	r6, ip
348059f0:	baffffec 	blt	348059a8 <part_validate_eraseblock+0xb4>
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
348059f4:	e5d53008 	ldrb	r3, [r5, #8]
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
348059f8:	e3530002 	cmp	r3, #2
348059fc:	059f1098 	ldreq	r1, [pc, #152]	; 34805a9c <part_validate_eraseblock+0x1a8>
34805a00:	0a000003 	beq	34805a14 <part_validate_eraseblock+0x120>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805a04:	e59f2094 	ldr	r2, [pc, #148]	; 34805aa0 <part_validate_eraseblock+0x1ac>
34805a08:	e3530004 	cmp	r3, #4
34805a0c:	e59f1090 	ldr	r1, [pc, #144]	; 34805aa4 <part_validate_eraseblock+0x1b0>
34805a10:	01a01002 	moveq	r1, r2
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
34805a14:	e59f0094 	ldr	r0, [pc, #148]	; 34805ab0 <part_validate_eraseblock+0x1bc>
34805a18:	eaffffdd 	b	34805994 <part_validate_eraseblock+0xa0>

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
34805a1c:	e5913000 	ldr	r3, [r1]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805a20:	e591700c 	ldr	r7, [r1, #12]
34805a24:	e3a06000 	mov	r6, #0
34805a28:	ea000006 	b	34805a48 <part_validate_eraseblock+0x154>
				if ((part->offset + part->size) == start)
34805a2c:	e594a010 	ldr	sl, [r4, #16]
34805a30:	e082a00a 	add	sl, r2, sl
34805a34:	e15a0003 	cmp	sl, r3
34805a38:	0a000015 	beq	34805a94 <part_validate_eraseblock+0x1a0>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
34805a3c:	e591a008 	ldr	sl, [r1, #8]
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805a40:	e2866001 	add	r6, r6, #1
				if ((part->offset + part->size) == start)
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
34805a44:	e083300a 	add	r3, r3, sl
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805a48:	e1560007 	cmp	r6, r7
34805a4c:	3afffff6 	bcc	34805a2c <part_validate_eraseblock+0x138>
		return 1;

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
34805a50:	e2800001 	add	r0, r0, #1
34805a54:	e2811018 	add	r1, r1, #24
34805a58:	e150000c 	cmp	r0, ip
34805a5c:	baffffee 	blt	34805a1c <part_validate_eraseblock+0x128>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
34805a60:	e5941010 	ldr	r1, [r4, #16]
34805a64:	e0822001 	add	r2, r2, r1
34805a68:	e1520003 	cmp	r2, r3
34805a6c:	0a000008 	beq	34805a94 <part_validate_eraseblock+0x1a0>
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805a70:	e5d53008 	ldrb	r3, [r5, #8]
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
34805a74:	e3530002 	cmp	r3, #2
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
			printf("%s%d: partition (%s) size alignment incorrect\n",
34805a78:	059f101c 	ldreq	r1, [pc, #28]	; 34805a9c <part_validate_eraseblock+0x1a8>
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
34805a7c:	0affffc3 	beq	34805990 <part_validate_eraseblock+0x9c>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805a80:	e59f2018 	ldr	r2, [pc, #24]	; 34805aa0 <part_validate_eraseblock+0x1ac>
34805a84:	e3530004 	cmp	r3, #4
34805a88:	e59f1014 	ldr	r1, [pc, #20]	; 34805aa4 <part_validate_eraseblock+0x1b0>
34805a8c:	01a01002 	moveq	r1, r2
34805a90:	eaffffbe 	b	34805990 <part_validate_eraseblock+0x9c>
		return 1;

	end_ok:
		return 0;
34805a94:	e3a00000 	mov	r0, #0
	}

	return 0;
}
34805a98:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34805a9c:	34824a89 	.word	0x34824a89
34805aa0:	34824a86 	.word	0x34824a86
34805aa4:	348246b8 	.word	0x348246b8
34805aa8:	3482475e 	.word	0x3482475e
34805aac:	34824794 	.word	0x34824794
34805ab0:	348247c3 	.word	0x348247c3

34805ab4 <device_delall.clone.2>:
 * Delete all mtd devices from a supplied devices list, free memory allocated for
 * each device and delete all device partitions.
 *
 * @return 0 on success, 1 otherwise
 */
static int device_delall(struct list_head *head)
34805ab4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805ab8:	e59f6054 	ldr	r6, [pc, #84]	; 34805b14 <device_delall.clone.2+0x60>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805abc:	e3a07000 	mov	r7, #0
34805ac0:	e5b64004 	ldr	r4, [r6, #4]!
34805ac4:	e5945000 	ldr	r5, [r4]
34805ac8:	ea00000a 	b	34805af8 <device_delall.clone.2+0x44>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805acc:	e894000c 	ldm	r4, {r2, r3}
		dev_tmp = list_entry(entry, struct mtd_device, link);
		list_del(entry);
		part_delall(&dev_tmp->parts);
34805ad0:	e2840010 	add	r0, r4, #16
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34805ad4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805ad8:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34805adc:	e5847004 	str	r7, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805ae0:	e5847000 	str	r7, [r4]
34805ae4:	ebffff1b 	bl	34805758 <part_delall>
		free(dev_tmp);
34805ae8:	e1a00004 	mov	r0, r4
34805aec:	eb00116f 	bl	3480a0b0 <free>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805af0:	e1a04005 	mov	r4, r5
34805af4:	e5955000 	ldr	r5, [r5]
34805af8:	e1540006 	cmp	r4, r6
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
34805afc:	e59f3010 	ldr	r3, [pc, #16]	; 34805b14 <device_delall.clone.2+0x60>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805b00:	1afffff1 	bne	34805acc <device_delall.clone.2+0x18>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805b04:	e5834004 	str	r4, [r3, #4]
	list->prev = list;
34805b08:	e5834008 	str	r4, [r3, #8]
		free(dev_tmp);
	}
	INIT_LIST_HEAD(&devices);

	return 0;
}
34805b0c:	e3a00000 	mov	r0, #0
34805b10:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34805b14:	34829d54 	.word	0x34829d54

34805b18 <mtd_devices_init>:
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
	last_parts[0] = '\0';
34805b18:	e59f3018 	ldr	r3, [pc, #24]	; 34805b38 <mtd_devices_init+0x20>
34805b1c:	e3a02000 	mov	r2, #0
 * Initialize global device list.
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
34805b20:	e92d4010 	push	{r4, lr}
	last_parts[0] = '\0';
34805b24:	e5c32020 	strb	r2, [r3, #32]
	current_mtd_dev = NULL;
34805b28:	e5832000 	str	r2, [r3]
	current_save();
34805b2c:	ebfffe92 	bl	3480557c <current_save>

	return device_delall(&devices);
}
34805b30:	e8bd4010 	pop	{r4, lr}
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
34805b34:	eaffffde 	b	34805ab4 <device_delall.clone.2>
34805b38:	34829d54 	.word	0x34829d54

34805b3c <generate_mtdparts_save.clone.1>:
 *
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 */
static int generate_mtdparts_save(char *buf, u32 buflen)
34805b3c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34805b40:	e59f52a8 	ldr	r5, [pc, #680]	; 34805df0 <generate_mtdparts_save.clone.1+0x2b4>
34805b44:	e24dd030 	sub	sp, sp, #48	; 0x30
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
34805b48:	e5952004 	ldr	r2, [r5, #4]
34805b4c:	e2853004 	add	r3, r5, #4
34805b50:	e1520003 	cmp	r2, r3
		buf[0] = '\0';
34805b54:	03a04000 	moveq	r4, #0
34805b58:	05c54020 	strbeq	r4, [r5, #32]
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
34805b5c:	0a000095 	beq	34805db8 <generate_mtdparts_save.clone.1+0x27c>
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
34805b60:	e2850020 	add	r0, r5, #32
34805b64:	e59f1288 	ldr	r1, [pc, #648]	; 34805df4 <generate_mtdparts_save.clone.1+0x2b8>
34805b68:	eb005efc 	bl	3481d760 <sprintf>
	struct mtd_device *dev;
	struct part_info *part, *prev_part;
	char *p = buf;
	char tmpbuf[32];
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;
34805b6c:	e30041ff 	movw	r4, #511	; 0x1ff
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
34805b70:	e5957004 	ldr	r7, [r5, #4]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805b74:	e28d9010 	add	r9, sp, #16
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
	p += 9;
34805b78:	e2855029 	add	r5, r5, #41	; 0x29
34805b7c:	ea000083 	b	34805d90 <generate_mtdparts_save.clone.1+0x254>

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805b80:	e5973008 	ldr	r3, [r7, #8]
34805b84:	e5930010 	ldr	r0, [r3, #16]
34805b88:	eb005abb 	bl	3481c67c <strlen>
34805b8c:	e280a001 	add	sl, r0, #1
		if (len > maxlen)
34805b90:	e15a0004 	cmp	sl, r4

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805b94:	e1a06000 	mov	r6, r0
		if (len > maxlen)
34805b98:	8a000082 	bhi	34805da8 <generate_mtdparts_save.clone.1+0x26c>
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
34805b9c:	e5973008 	ldr	r3, [r7, #8]
34805ba0:	e1a00005 	mov	r0, r5
34805ba4:	e5931010 	ldr	r1, [r3, #16]
34805ba8:	e1a02006 	mov	r2, r6
34805bac:	eb005b76 	bl	3481c98c <memcpy>
		p += len - 1;
		*(p++) = ':';
34805bb0:	e3a0203a 	mov	r2, #58	; 0x3a
34805bb4:	e7c52006 	strb	r2, [r5, r6]
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805bb8:	e1a02007 	mov	r2, r7
		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
34805bbc:	e0853006 	add	r3, r5, r6
		*(p++) = ':';
		maxlen -= len;
34805bc0:	e06a4004 	rsb	r4, sl, r4

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805bc4:	e5b2a010 	ldr	sl, [r2, #16]!
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
		*(p++) = ':';
34805bc8:	e2835001 	add	r5, r3, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
34805bcc:	e3a03000 	mov	r3, #0
		list_for_each(pentry, &dev->parts) {
34805bd0:	e88d0088 	stm	sp, {r3, r7}
34805bd4:	e58d2004 	str	r2, [sp, #4]
		p += len - 1;
		*(p++) = ':';
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
34805bd8:	e1a0b003 	mov	fp, r3
34805bdc:	ea00005e 	b	34805d5c <generate_mtdparts_save.clone.1+0x220>
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
34805be0:	e59a2014 	ldr	r2, [sl, #20]
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805be4:	e1a00009 	mov	r0, r9
34805be8:	e59a1010 	ldr	r1, [sl, #16]
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
34805bec:	e58d2008 	str	r2, [sp, #8]

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
34805bf0:	e58da00c 	str	sl, [sp, #12]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805bf4:	ebfffe4b 	bl	34805528 <memsize_format>
			len = strlen(tmpbuf);
34805bf8:	e1a00009 	mov	r0, r9
34805bfc:	eb005a9e 	bl	3481c67c <strlen>
			if (len > maxlen)
34805c00:	e1500004 	cmp	r0, r4
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
34805c04:	e1a06000 	mov	r6, r0
			if (len > maxlen)
34805c08:	8a000066 	bhi	34805da8 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			memcpy(p, tmpbuf, len);
34805c0c:	e1a00005 	mov	r0, r5
34805c10:	e1a02006 	mov	r2, r6
34805c14:	e1a01009 	mov	r1, r9
34805c18:	eb005b5b 	bl	3481c98c <memcpy>
			maxlen -= len;


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
34805c1c:	e59d2008 	ldr	r2, [sp, #8]
34805c20:	e27b3001 	rsbs	r3, fp, #1
34805c24:	33a03000 	movcc	r3, #0
34805c28:	e3520000 	cmp	r2, #0
34805c2c:	03a03000 	moveq	r3, #0
34805c30:	e3530000 	cmp	r3, #0
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
			if (len > maxlen)
				goto cleanup;
			memcpy(p, tmpbuf, len);
			p += len;
34805c34:	e0855006 	add	r5, r5, r6
			maxlen -= len;
34805c38:	e0664004 	rsb	r4, r6, r4


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
34805c3c:	1a000007 	bne	34805c60 <generate_mtdparts_save.clone.1+0x124>
34805c40:	e35b0000 	cmp	fp, #0
34805c44:	0a000016 	beq	34805ca4 <generate_mtdparts_save.clone.1+0x168>
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {
34805c48:	e59b3014 	ldr	r3, [fp, #20]
34805c4c:	e59b2010 	ldr	r2, [fp, #16]
34805c50:	e0822003 	add	r2, r2, r3
34805c54:	e59a3014 	ldr	r3, [sl, #20]
34805c58:	e1520003 	cmp	r2, r3
34805c5c:	0a000010 	beq	34805ca4 <generate_mtdparts_save.clone.1+0x168>

				memsize_format(tmpbuf, offset);
34805c60:	e1a00009 	mov	r0, r9
34805c64:	e59d1008 	ldr	r1, [sp, #8]
34805c68:	ebfffe2e 	bl	34805528 <memsize_format>
				len = strlen(tmpbuf) + 1;
34805c6c:	e1a00009 	mov	r0, r9
34805c70:	eb005a81 	bl	3481c67c <strlen>
34805c74:	e280b001 	add	fp, r0, #1
				if (len > maxlen)
34805c78:	e15b0004 	cmp	fp, r4
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {

				memsize_format(tmpbuf, offset);
				len = strlen(tmpbuf) + 1;
34805c7c:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805c80:	8a000048 	bhi	34805da8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = '@';
34805c84:	e3a03040 	mov	r3, #64	; 0x40
34805c88:	e4c53001 	strb	r3, [r5], #1
				memcpy(p, tmpbuf, len - 1);
34805c8c:	e1a00005 	mov	r0, r5
34805c90:	e1a01009 	mov	r1, r9
34805c94:	e1a02006 	mov	r2, r6
34805c98:	eb005b3b 	bl	3481c98c <memcpy>
				p += len - 1;
34805c9c:	e0855006 	add	r5, r5, r6
				maxlen -= len;
34805ca0:	e06b4004 	rsb	r4, fp, r4
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
34805ca4:	e5da300c 	ldrb	r3, [sl, #12]
34805ca8:	e3530000 	cmp	r3, #0
34805cac:	1a000010 	bne	34805cf4 <generate_mtdparts_save.clone.1+0x1b8>
				len = strlen(part->name) + 2;
34805cb0:	e59a0008 	ldr	r0, [sl, #8]
34805cb4:	eb005a70 	bl	3481c67c <strlen>
34805cb8:	e280b002 	add	fp, r0, #2
				if (len > maxlen)
34805cbc:	e15b0004 	cmp	fp, r4
				maxlen -= len;
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
				len = strlen(part->name) + 2;
34805cc0:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805cc4:	8a000037 	bhi	34805da8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;

				*(p++) = '(';
34805cc8:	e3a02028 	mov	r2, #40	; 0x28
34805ccc:	e4c52001 	strb	r2, [r5], #1
				memcpy(p, part->name, len - 2);
34805cd0:	e1a00005 	mov	r0, r5
34805cd4:	e1a02006 	mov	r2, r6
34805cd8:	e59a1008 	ldr	r1, [sl, #8]
34805cdc:	eb005b2a 	bl	3481c98c <memcpy>
				p += len - 2;
34805ce0:	e0853006 	add	r3, r5, r6
				*(p++) = ')';
34805ce4:	e3a02029 	mov	r2, #41	; 0x29
34805ce8:	e7c52006 	strb	r2, [r5, r6]
				maxlen -= len;
34805cec:	e06b4004 	rsb	r4, fp, r4
					goto cleanup;

				*(p++) = '(';
				memcpy(p, part->name, len - 2);
				p += len - 2;
				*(p++) = ')';
34805cf0:	e2835001 	add	r5, r3, #1
				maxlen -= len;
			}

			/* ro mask flag */
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
34805cf4:	e59a301c 	ldr	r3, [sl, #28]
34805cf8:	e3530000 	cmp	r3, #0
34805cfc:	0a000008 	beq	34805d24 <generate_mtdparts_save.clone.1+0x1e8>
				len = 2;
				if (len > maxlen)
34805d00:	e3540001 	cmp	r4, #1
34805d04:	9a000027 	bls	34805da8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = 'r';
34805d08:	e1a03005 	mov	r3, r5
34805d0c:	e3a02072 	mov	r2, #114	; 0x72
34805d10:	e4c32001 	strb	r2, [r3], #1
				*(p++) = 'o';
34805d14:	e3a0206f 	mov	r2, #111	; 0x6f
34805d18:	e5c52001 	strb	r2, [r5, #1]
				maxlen -= 2;
34805d1c:	e2444002 	sub	r4, r4, #2
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
				len = 2;
				if (len > maxlen)
					goto cleanup;
				*(p++) = 'r';
				*(p++) = 'o';
34805d20:	e2835001 	add	r5, r3, #1
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
			part_cnt++;
34805d24:	e59d3000 	ldr	r3, [sp]
34805d28:	e2833001 	add	r3, r3, #1
34805d2c:	e58d3000 	str	r3, [sp]
				maxlen -= 2;
			}

			/* print ',' separator if there are other partitions
			 * following */
			if (dev->num_parts > part_cnt) {
34805d30:	e59d2000 	ldr	r2, [sp]
34805d34:	e1d730bc 	ldrh	r3, [r7, #12]
34805d38:	e1530002 	cmp	r3, r2
34805d3c:	9a000004 	bls	34805d54 <generate_mtdparts_save.clone.1+0x218>
				if (1 > maxlen)
34805d40:	e3540000 	cmp	r4, #0
34805d44:	0a000017 	beq	34805da8 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = ',';
34805d48:	e3a0302c 	mov	r3, #44	; 0x2c
34805d4c:	e4c53001 	strb	r3, [r5], #1
				maxlen--;
34805d50:	e2444001 	sub	r4, r4, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805d54:	e59aa000 	ldr	sl, [sl]
34805d58:	e59db00c 	ldr	fp, [sp, #12]
34805d5c:	e59d2004 	ldr	r2, [sp, #4]
34805d60:	e15a0002 	cmp	sl, r2
34805d64:	1affff9d 	bne	34805be0 <generate_mtdparts_save.clone.1+0xa4>
				maxlen--;
			}
			prev_part = part;
		}
		/* print ';' separator if there are other devices following */
		if (dentry->next != &devices) {
34805d68:	e5972000 	ldr	r2, [r7]
34805d6c:	e59f3084 	ldr	r3, [pc, #132]	; 34805df8 <generate_mtdparts_save.clone.1+0x2bc>
34805d70:	e1520003 	cmp	r2, r3
34805d74:	0a000004 	beq	34805d8c <generate_mtdparts_save.clone.1+0x250>
			if (1 > maxlen)
34805d78:	e3540000 	cmp	r4, #0
34805d7c:	0a000009 	beq	34805da8 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			*(p++) = ';';
34805d80:	e3a0303b 	mov	r3, #59	; 0x3b
34805d84:	e4c53001 	strb	r3, [r5], #1
			maxlen--;
34805d88:	e2444001 	sub	r4, r4, #1
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
34805d8c:	e5977000 	ldr	r7, [r7]
34805d90:	e59f3060 	ldr	r3, [pc, #96]	; 34805df8 <generate_mtdparts_save.clone.1+0x2bc>
34805d94:	e1570003 	cmp	r7, r3
34805d98:	1affff78 	bne	34805b80 <generate_mtdparts_save.clone.1+0x44>
		}
	}

	/* we still have at least one char left, as we decremented maxlen at
	 * the begining */
	*p = '\0';
34805d9c:	e3a04000 	mov	r4, #0
34805da0:	e5c54000 	strb	r4, [r5]
34805da4:	ea000003 	b	34805db8 <generate_mtdparts_save.clone.1+0x27c>

	return 0;

cleanup:
	last_parts[0] = '\0';
34805da8:	e59f3040 	ldr	r3, [pc, #64]	; 34805df0 <generate_mtdparts_save.clone.1+0x2b4>
34805dac:	e3a02000 	mov	r2, #0
34805db0:	e5c32020 	strb	r2, [r3, #32]
	return 1;
34805db4:	e3a04001 	mov	r4, #1
{
	int ret;

	ret = generate_mtdparts(buf, buflen);

	if ((buf[0] != '\0') && (ret == 0))
34805db8:	e59f3030 	ldr	r3, [pc, #48]	; 34805df0 <generate_mtdparts_save.clone.1+0x2b4>
34805dbc:	e2242001 	eor	r2, r4, #1
34805dc0:	e5d31020 	ldrb	r1, [r3, #32]
34805dc4:	e3510000 	cmp	r1, #0
34805dc8:	03a01000 	moveq	r1, #0
34805dcc:	12021001 	andne	r1, r2, #1
34805dd0:	e3510000 	cmp	r1, #0
		setenv("mtdparts", buf);
34805dd4:	159f0020 	ldrne	r0, [pc, #32]	; 34805dfc <generate_mtdparts_save.clone.1+0x2c0>
34805dd8:	12831020 	addne	r1, r3, #32
	else
		setenv("mtdparts", NULL);
34805ddc:	059f0018 	ldreq	r0, [pc, #24]	; 34805dfc <generate_mtdparts_save.clone.1+0x2c0>
34805de0:	eb00077e 	bl	34807be0 <setenv>

	return ret;
}
34805de4:	e1a00004 	mov	r0, r4
34805de8:	e28dd030 	add	sp, sp, #48	; 0x30
34805dec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805df0:	34829d54 	.word	0x34829d54
34805df4:	348247fa 	.word	0x348247fa
34805df8:	34829d58 	.word	0x34829d58
34805dfc:	34824804 	.word	0x34824804

34805e00 <mtd_device_validate>:
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805e00:	e92d4013 	push	{r0, r1, r4, lr}
	struct mtd_info *mtd = NULL;
34805e04:	e3a03000 	mov	r3, #0
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805e08:	e1a04002 	mov	r4, r2
	struct mtd_info *mtd = NULL;
34805e0c:	e28d2008 	add	r2, sp, #8
34805e10:	e5223004 	str	r3, [r2, #-4]!

	if (get_mtd_info(type, num, &mtd))
34805e14:	ebfffe96 	bl	34805874 <get_mtd_info>
34805e18:	e3500000 	cmp	r0, #0
		return 1;

	*size = mtd->size;
34805e1c:	059d3004 	ldreq	r3, [sp, #4]
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
	struct mtd_info *mtd = NULL;

	if (get_mtd_info(type, num, &mtd))
		return 1;
34805e20:	13a00001 	movne	r0, #1

	*size = mtd->size;
34805e24:	05933008 	ldreq	r3, [r3, #8]
34805e28:	05843000 	streq	r3, [r4]

	return 0;
}
34805e2c:	e8bd801c 	pop	{r2, r3, r4, pc}

34805e30 <device_find>:
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805e30:	e59fc040 	ldr	ip, [pc, #64]	; 34805e78 <device_find+0x48>
 * @param type device type
 * @param num device number
 * @return NULL if requested device does not exist
 */
struct mtd_device *device_find(u8 type, u8 num)
{
34805e34:	e92d4030 	push	{r4, r5, lr}
34805e38:	e1a03000 	mov	r3, r0
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805e3c:	e5bc2004 	ldr	r2, [ip, #4]!
34805e40:	ea000008 	b	34805e68 <device_find+0x38>
		dev_tmp = list_entry(entry, struct mtd_device, link);

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
34805e44:	e5924008 	ldr	r4, [r2, #8]
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
		dev_tmp = list_entry(entry, struct mtd_device, link);
34805e48:	e1a00002 	mov	r0, r2

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
34805e4c:	e5d45008 	ldrb	r5, [r4, #8]
34805e50:	e1550003 	cmp	r5, r3
34805e54:	1a000002 	bne	34805e64 <device_find+0x34>
34805e58:	e5d44009 	ldrb	r4, [r4, #9]
34805e5c:	e1540001 	cmp	r4, r1
34805e60:	08bd8030 	popeq	{r4, r5, pc}
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805e64:	e5922000 	ldr	r2, [r2]
34805e68:	e152000c 	cmp	r2, ip
34805e6c:	1afffff4 	bne	34805e44 <device_find+0x14>

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
			return dev_tmp;
	}

	return NULL;
34805e70:	e3a00000 	mov	r0, #0
}
34805e74:	e8bd8030 	pop	{r4, r5, pc}
34805e78:	34829d54 	.word	0x34829d54

34805e7c <device_parse>:
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805e7c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34805e80:	e24dd028 	sub	sp, sp, #40	; 0x28
	struct mtdids *id;
	const char *mtd_id;
	unsigned int mtd_id_len;
	const char *p;
	const char *pend;
	LIST_HEAD(tmp_list);
34805e84:	e28d301c 	add	r3, sp, #28
34805e88:	e58d301c 	str	r3, [sp, #28]
34805e8c:	e58d3020 	str	r3, [sp, #32]
	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;

	if (ret)
34805e90:	e2517000 	subs	r7, r1, #0
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805e94:	e3a03000 	mov	r3, #0
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805e98:	e58d2010 	str	r2, [sp, #16]
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805e9c:	e3a0103a 	mov	r1, #58	; 0x3a
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805ea0:	e5823000 	str	r3, [r2]

	if (ret)
		*ret = NULL;
34805ea4:	15873000 	strne	r3, [r7]
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805ea8:	e1a04000 	mov	r4, r0
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805eac:	eb0059dc 	bl	3481c624 <strchr>
34805eb0:	e2509000 	subs	r9, r0, #0
		printf("no <mtd-id> identifier\n");
34805eb4:	059f04cc 	ldreq	r0, [pc, #1228]	; 34806388 <device_parse+0x50c>
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805eb8:	0a000109 	beq	348062e4 <device_parse+0x468>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805ebc:	e59fa4c8 	ldr	sl, [pc, #1224]	; 3480638c <device_parse+0x510>
	}
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
34805ec0:	e0646009 	rsb	r6, r4, r9
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805ec4:	e5ba5220 	ldr	r5, [sl, #544]!	; 0x220
34805ec8:	ea00000a 	b	34805ef8 <device_parse+0x7c>
		id = list_entry(entry, struct mtdids, link);

		debug("entry: '%s' (len = %d)\n",
				id->mtd_id, strlen(id->mtd_id));

		if (mtd_id_len != strlen(id->mtd_id))
34805ecc:	e5950010 	ldr	r0, [r5, #16]
34805ed0:	eb0059e9 	bl	3481c67c <strlen>
34805ed4:	e1560000 	cmp	r6, r0
34805ed8:	1a000005 	bne	34805ef4 <device_parse+0x78>
			continue;
		if (strncmp(id->mtd_id, mtd_id, mtd_id_len) == 0)
34805edc:	e5950010 	ldr	r0, [r5, #16]
34805ee0:	e1a01004 	mov	r1, r4
34805ee4:	e1a02006 	mov	r2, r6
34805ee8:	eb0059bb 	bl	3481c5dc <strncmp>
34805eec:	e3500000 	cmp	r0, #0
34805ef0:	0a000003 	beq	34805f04 <device_parse+0x88>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805ef4:	e5955000 	ldr	r5, [r5]
34805ef8:	e155000a 	cmp	r5, sl
34805efc:	1afffff2 	bne	34805ecc <device_parse+0x50>
34805f00:	ea000006 	b	34805f20 <device_parse+0xa4>

	/* parse partitions */
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805f04:	e5d50008 	ldrb	r0, [r5, #8]
34805f08:	e5d51009 	ldrb	r1, [r5, #9]
34805f0c:	ebffffc7 	bl	34805e30 <device_find>
34805f10:	e3500000 	cmp	r0, #0


	/* parse partitions */
	num_parts = 0;

	offset = 0;
34805f14:	058d0008 	streq	r0, [sp, #8]
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805f18:	1a000005 	bne	34805f34 <device_parse+0xb8>
34805f1c:	ea000009 	b	34805f48 <device_parse+0xcc>
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
		printf("invalid mtd device '%.*s'\n", mtd_id_len - 1, mtd_id);
34805f20:	e1a01006 	mov	r1, r6
34805f24:	e1a02004 	mov	r2, r4
34805f28:	e59f0460 	ldr	r0, [pc, #1120]	; 34806390 <device_parse+0x514>
34805f2c:	eb000f21 	bl	34809bb8 <printf>
34805f30:	ea000111 	b	3480637c <device_parse+0x500>
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
34805f34:	e5903014 	ldr	r3, [r0, #20]
		offset = part->offset + part->size;
34805f38:	e5932010 	ldr	r2, [r3, #16]
34805f3c:	e5933014 	ldr	r3, [r3, #20]
34805f40:	e0823003 	add	r3, r2, r3
34805f44:	e58d3008 	str	r3, [sp, #8]
	if (!(p = strchr(mtd_id, ':'))) {
		printf("no <mtd-id> identifier\n");
		return 1;
	}
	mtd_id_len = p - mtd_id + 1;
	p++;
34805f48:	e3a02000 	mov	r2, #0
34805f4c:	e2896001 	add	r6, r9, #1
34805f50:	e3a00001 	mov	r0, #1
34805f54:	e58d2004 	str	r2, [sp, #4]
34805f58:	e58d7014 	str	r7, [sp, #20]
34805f5c:	ea0000a9 	b	34806208 <device_parse+0x38c>
	const char *name;
	int name_len;
	unsigned int mask_flags;
	const char *p;

	p = partdef;
34805f60:	e58d6024 	str	r6, [sp, #36]	; 0x24
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
34805f64:	e5d63000 	ldrb	r3, [r6]
34805f68:	e353002d 	cmp	r3, #45	; 0x2d
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
34805f6c:	02866001 	addeq	r6, r6, #1
34805f70:	058d6024 	streq	r6, [sp, #36]	; 0x24

	/* fetch the partition size */
	if (*p == '-') {
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
34805f74:	03e09000 	mvneq	r9, #0
	p = partdef;
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
34805f78:	0a000008 	beq	34805fa0 <device_parse+0x124>
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
34805f7c:	e1a00006 	mov	r0, r6
34805f80:	e28d1024 	add	r1, sp, #36	; 0x24
34805f84:	ebfffe20 	bl	3480580c <memsize_parse>
		if (size < MIN_PART_SIZE) {
34805f88:	e3003fff 	movw	r3, #4095	; 0xfff
34805f8c:	e1500003 	cmp	r0, r3
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
34805f90:	e1a09000 	mov	r9, r0
		if (size < MIN_PART_SIZE) {
			printf("partition size too small (%lx)\n", size);
34805f94:	959f03f8 	ldrls	r0, [pc, #1016]	; 34806394 <device_parse+0x518>
34805f98:	91a01009 	movls	r1, r9
34805f9c:	9a000039 	bls	34806088 <device_parse+0x20c>
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
34805fa0:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805fa4:	e5d03000 	ldrb	r3, [r0]
34805fa8:	e3530040 	cmp	r3, #64	; 0x40
			return 1;
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
34805fac:	13e0b000 	mvnne	fp, #0
	if (*p == '@') {
34805fb0:	1a000004 	bne	34805fc8 <device_parse+0x14c>
		p++;
34805fb4:	e2800001 	add	r0, r0, #1
		offset = memsize_parse(p, &p);
34805fb8:	e28d1024 	add	r1, sp, #36	; 0x24
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
		p++;
34805fbc:	e58d0024 	str	r0, [sp, #36]	; 0x24
		offset = memsize_parse(p, &p);
34805fc0:	ebfffe11 	bl	3480580c <memsize_parse>
34805fc4:	e1a0b000 	mov	fp, r0
	}

	/* now look for the name */
	if (*p == '(') {
34805fc8:	e59d7024 	ldr	r7, [sp, #36]	; 0x24
34805fcc:	e5d73000 	ldrb	r3, [r7]
34805fd0:	e3530028 	cmp	r3, #40	; 0x28
			return 1;
		}
		p++;
	} else {
		/* 0x00000000@0x00000000 */
		name_len = 22;
34805fd4:	13a0a016 	movne	sl, #22
		name = NULL;
34805fd8:	13a07000 	movne	r7, #0
		p++;
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
34805fdc:	1a00000f 	bne	34806020 <device_parse+0x1a4>
		name = ++p;
34805fe0:	e2877001 	add	r7, r7, #1
		if ((p = strchr(name, ')')) == NULL) {
34805fe4:	e1a00007 	mov	r0, r7
34805fe8:	e3a01029 	mov	r1, #41	; 0x29
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
		name = ++p;
34805fec:	e58d7024 	str	r7, [sp, #36]	; 0x24
		if ((p = strchr(name, ')')) == NULL) {
34805ff0:	eb00598b 	bl	3481c624 <strchr>
34805ff4:	e3500000 	cmp	r0, #0
34805ff8:	e58d0024 	str	r0, [sp, #36]	; 0x24
			printf("no closing ) found in partition name\n");
34805ffc:	059f0394 	ldreq	r0, [pc, #916]	; 34806398 <device_parse+0x51c>
34806000:	0a00002a 	beq	348060b0 <device_parse+0x234>
			return 1;
		}
		name_len = p - name + 1;
34806004:	e267a001 	rsb	sl, r7, #1
34806008:	e080a00a 	add	sl, r0, sl
		if ((name_len - 1) == 0) {
3480600c:	e35a0001 	cmp	sl, #1
			printf("empty partition name\n");
34806010:	059f0384 	ldreq	r0, [pc, #900]	; 3480639c <device_parse+0x520>
34806014:	0a000025 	beq	348060b0 <device_parse+0x234>
			return 1;
		}
		p++;
34806018:	e2800001 	add	r0, r0, #1
3480601c:	e58d0024 	str	r0, [sp, #36]	; 0x24
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
34806020:	e3a02002 	mov	r2, #2
34806024:	e59f1374 	ldr	r1, [pc, #884]	; 348063a0 <device_parse+0x524>
34806028:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480602c:	eb00596a 	bl	3481c5dc <strncmp>
34806030:	e3500000 	cmp	r0, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
34806034:	059d3024 	ldreq	r3, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
34806038:	03a02001 	moveq	r2, #1
		p += 2;
3480603c:	02833002 	addeq	r3, r3, #2
34806040:	058d3024 	streq	r3, [sp, #36]	; 0x24
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
34806044:	13a03000 	movne	r3, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
34806048:	e59d6024 	ldr	r6, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
3480604c:	058d200c 	streq	r2, [sp, #12]
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
34806050:	158d300c 	strne	r3, [sp, #12]
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
34806054:	e5d61000 	ldrb	r1, [r6]
34806058:	e351002c 	cmp	r1, #44	; 0x2c
3480605c:	1a000005 	bne	34806078 <device_parse+0x1fc>
		if (size == SIZE_REMAINING) {
34806060:	e3790001 	cmn	r9, #1
			*ret = NULL;
			printf("no partitions allowed after a fill-up partition\n");
34806064:	059f0338 	ldreq	r0, [pc, #824]	; 348063a4 <device_parse+0x528>
34806068:	0a000010 	beq	348060b0 <device_parse+0x234>
			return 1;
		}
		*ret = ++p;
3480606c:	e2866001 	add	r6, r6, #1
34806070:	e58d6024 	str	r6, [sp, #36]	; 0x24
34806074:	ea000005 	b	34806090 <device_parse+0x214>
	} else if ((*p == ';') || (*p == '\0')) {
34806078:	e351003b 	cmp	r1, #59	; 0x3b
3480607c:	13510000 	cmpne	r1, #0
34806080:	0a000002 	beq	34806090 <device_parse+0x214>
		*ret = p;
	} else {
		printf("unexpected character '%c' at the end of partition\n", *p);
34806084:	e59f031c 	ldr	r0, [pc, #796]	; 348063a8 <device_parse+0x52c>
34806088:	eb000eca 	bl	34809bb8 <printf>
3480608c:	ea000067 	b	34806230 <device_parse+0x3b4>
		*ret = NULL;
		return 1;
	}

	/*  allocate memory */
	part = (struct part_info *)malloc(sizeof(struct part_info) + name_len);
34806090:	e28a2028 	add	r2, sl, #40	; 0x28
34806094:	e1a00002 	mov	r0, r2
34806098:	e58d2000 	str	r2, [sp]
3480609c:	eb00108c 	bl	3480a2d4 <malloc>
	if (!part) {
348060a0:	e2504000 	subs	r4, r0, #0
348060a4:	e59d2000 	ldr	r2, [sp]
348060a8:	1a000002 	bne	348060b8 <device_parse+0x23c>
		printf("out of memory\n");
348060ac:	e59f02f8 	ldr	r0, [pc, #760]	; 348063ac <device_parse+0x530>
348060b0:	eb000ec0 	bl	34809bb8 <printf>
348060b4:	ea00005d 	b	34806230 <device_parse+0x3b4>
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
348060b8:	e3a01000 	mov	r1, #0
348060bc:	eb005a0e 	bl	3481c8fc <memset>
	part->size = size;
	part->offset = offset;
	part->mask_flags = mask_flags;
348060c0:	e59d200c 	ldr	r2, [sp, #12]
	part->name = (char *)(part + 1);
348060c4:	e2840028 	add	r0, r4, #40	; 0x28

	if (name) {
348060c8:	e3570000 	cmp	r7, #0
	if (!part) {
		printf("out of memory\n");
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
	part->size = size;
348060cc:	e5849010 	str	r9, [r4, #16]
	part->offset = offset;
348060d0:	e584b014 	str	fp, [r4, #20]
	part->mask_flags = mask_flags;
348060d4:	e584201c 	str	r2, [r4, #28]
	part->name = (char *)(part + 1);
348060d8:	e5840008 	str	r0, [r4, #8]

	if (name) {
348060dc:	0a000005 	beq	348060f8 <device_parse+0x27c>
		/* copy user provided name */
		strncpy(part->name, name, name_len - 1);
348060e0:	e1a01007 	mov	r1, r7
348060e4:	e24a2001 	sub	r2, sl, #1
348060e8:	eb005905 	bl	3481c504 <strncpy>
		part->auto_name = 0;
348060ec:	e3a03000 	mov	r3, #0
348060f0:	e5c4300c 	strb	r3, [r4, #12]
348060f4:	ea000005 	b	34806110 <device_parse+0x294>
	} else {
		/* auto generated name in form of size@offset */
		sprintf(part->name, "0x%08lx@0x%08lx", size, offset);
348060f8:	e1a02009 	mov	r2, r9
348060fc:	e59f12ac 	ldr	r1, [pc, #684]	; 348063b0 <device_parse+0x534>
34806100:	e1a0300b 	mov	r3, fp
34806104:	eb005d95 	bl	3481d760 <sprintf>
		part->auto_name = 1;
34806108:	e3a02001 	mov	r2, #1
3480610c:	e5c4200c 	strb	r2, [r4, #12]
	}

	part->name[name_len - 1] = '\0';
34806110:	e5943008 	ldr	r3, [r4, #8]
34806114:	e083a00a 	add	sl, r3, sl
34806118:	e3a03000 	mov	r3, #0
3480611c:	e54a3001 	strb	r3, [sl, #-1]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
34806120:	e5947014 	ldr	r7, [r4, #20]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34806124:	e5943010 	ldr	r3, [r4, #16]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
34806128:	e3770001 	cmn	r7, #1
			part->offset = offset;
3480612c:	059d2008 	ldreq	r2, [sp, #8]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34806130:	e5844000 	str	r4, [r4]
34806134:	05842014 	streq	r2, [r4, #20]
34806138:	01a07002 	moveq	r7, r2
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
3480613c:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
34806140:	0595200c 	ldreq	r2, [r5, #12]
34806144:	05943014 	ldreq	r3, [r4, #20]
	list->prev = list;
34806148:	e5844004 	str	r4, [r4, #4]
3480614c:	00633002 	rsbeq	r3, r3, r2
34806150:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
34806154:	e5942014 	ldr	r2, [r4, #20]
34806158:	e595300c 	ldr	r3, [r5, #12]
3480615c:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
34806160:	859f024c 	ldrhi	r0, [pc, #588]	; 348063b4 <device_parse+0x538>
34806164:	85951010 	ldrhi	r1, [r5, #16]
34806168:	8a00000e 	bhi	348061a8 <device_parse+0x32c>
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
3480616c:	e5941010 	ldr	r1, [r4, #16]
34806170:	e0821001 	add	r1, r2, r1
34806174:	e1510002 	cmp	r1, r2
34806178:	8a00000c 	bhi	348061b0 <device_parse+0x334>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
3480617c:	e5d53008 	ldrb	r3, [r5, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806180:	e3530002 	cmp	r3, #2
34806184:	059f122c 	ldreq	r1, [pc, #556]	; 348063b8 <device_parse+0x53c>
34806188:	0a000003 	beq	3480619c <device_parse+0x320>
				MTD_DEV_TYPE(id->type), id->num, part->name);
3480618c:	e59f2228 	ldr	r2, [pc, #552]	; 348063bc <device_parse+0x540>
34806190:	e3530004 	cmp	r3, #4
34806194:	e59f1224 	ldr	r1, [pc, #548]	; 348063c0 <device_parse+0x544>
34806198:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
3480619c:	e59f0220 	ldr	r0, [pc, #544]	; 348063c4 <device_parse+0x548>
348061a0:	e5d52009 	ldrb	r2, [r5, #9]
348061a4:	e5943008 	ldr	r3, [r4, #8]
348061a8:	eb000e82 	bl	34809bb8 <printf>
348061ac:	ea00001f 	b	34806230 <device_parse+0x3b4>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
348061b0:	e1510003 	cmp	r1, r3
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
348061b4:	859f020c 	ldrhi	r0, [pc, #524]	; 348063c8 <device_parse+0x54c>
348061b8:	85951010 	ldrhi	r1, [r5, #16]
348061bc:	8affffb1 	bhi	34806088 <device_parse+0x20c>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
348061c0:	e1a00005 	mov	r0, r5
348061c4:	e1a01004 	mov	r1, r4
348061c8:	ebfffdc9 	bl	348058f4 <part_validate_eraseblock>
			part->offset = offset;
		else
			offset = part->offset;

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
348061cc:	e3500000 	cmp	r0, #0
348061d0:	1a000016 	bne	34806230 <device_parse+0x3b4>
			break;

		offset += part->size;
348061d4:	e5943010 	ldr	r3, [r4, #16]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348061d8:	e28d201c 	add	r2, sp, #28
348061dc:	e0873003 	add	r3, r7, r3
348061e0:	e5842000 	str	r2, [r4]
348061e4:	e58d3008 	str	r3, [sp, #8]

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
348061e8:	e59d2004 	ldr	r2, [sp, #4]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348061ec:	e59d3020 	ldr	r3, [sp, #32]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348061f0:	e58d4020 	str	r4, [sp, #32]
	new->next = next;
	new->prev = prev;
	prev->next = new;
348061f4:	e5834000 	str	r4, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
348061f8:	e5843004 	str	r3, [r4, #4]
348061fc:	e2823001 	add	r3, r2, #1
34806200:	e6ff3073 	uxth	r3, r3
34806204:	e58d3004 	str	r3, [sp, #4]
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
		offset = part->offset + part->size;
	}

	while (p && (*p != '\0') && (*p != ';')) {
34806208:	e3560000 	cmp	r6, #0
3480620c:	0a000004 	beq	34806224 <device_parse+0x3a8>
34806210:	e5d63000 	ldrb	r3, [r6]
34806214:	e3530000 	cmp	r3, #0
34806218:	0a000001 	beq	34806224 <device_parse+0x3a8>
3480621c:	e353003b 	cmp	r3, #59	; 0x3b
34806220:	1affff4e 	bne	34805f60 <device_parse+0xe4>
		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
		err = 0;
	}
	if (err == 1) {
34806224:	e3500001 	cmp	r0, #1
34806228:	e59d7014 	ldr	r7, [sp, #20]
3480622c:	1a000002 	bne	3480623c <device_parse+0x3c0>
		part_delall(&tmp_list);
34806230:	e28d001c 	add	r0, sp, #28
34806234:	ebfffd47 	bl	34805758 <part_delall>
34806238:	ea00004f 	b	3480637c <device_parse+0x500>
		return 1;
	}

	if (num_parts == 0) {
3480623c:	e59d3004 	ldr	r3, [sp, #4]
34806240:	e3530000 	cmp	r3, #0
34806244:	1a00000c 	bne	3480627c <device_parse+0x400>
		printf("no partitions for device %s%d (%s)\n",
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34806248:	e5d53008 	ldrb	r3, [r5, #8]
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
3480624c:	e3530002 	cmp	r3, #2
34806250:	059f1160 	ldreq	r1, [pc, #352]	; 348063b8 <device_parse+0x53c>
34806254:	0a000003 	beq	34806268 <device_parse+0x3ec>
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34806258:	e59f215c 	ldr	r2, [pc, #348]	; 348063bc <device_parse+0x540>
3480625c:	e3530004 	cmp	r3, #4
34806260:	e59f1158 	ldr	r1, [pc, #344]	; 348063c0 <device_parse+0x544>
34806264:	01a01002 	moveq	r1, r2
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
34806268:	e5d52009 	ldrb	r2, [r5, #9]
3480626c:	e5953010 	ldr	r3, [r5, #16]
34806270:	e59f0154 	ldr	r0, [pc, #340]	; 348063cc <device_parse+0x550>
34806274:	eb000e4f 	bl	34809bb8 <printf>
34806278:	ea00003f 	b	3480637c <device_parse+0x500>
	}

	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
3480627c:	e3560000 	cmp	r6, #0
34806280:	0a000012 	beq	348062d0 <device_parse+0x454>
		if (*p == ';') {
34806284:	e5d61000 	ldrb	r1, [r6]
34806288:	e351003b 	cmp	r1, #59	; 0x3b
3480628c:	1a000003 	bne	348062a0 <device_parse+0x424>
			if (ret)
34806290:	e3570000 	cmp	r7, #0
				*ret = ++p;
34806294:	12866001 	addne	r6, r6, #1
	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
		if (*p == ';') {
			if (ret)
34806298:	1a000004 	bne	348062b0 <device_parse+0x434>
3480629c:	ea00000b 	b	348062d0 <device_parse+0x454>
				*ret = ++p;
		} else if (*p == '\0') {
348062a0:	e3510000 	cmp	r1, #0
348062a4:	1a000003 	bne	348062b8 <device_parse+0x43c>
			if (ret)
348062a8:	e3570000 	cmp	r7, #0
348062ac:	0a000007 	beq	348062d0 <device_parse+0x454>
				*ret = p;
348062b0:	e5876000 	str	r6, [r7]
348062b4:	ea000005 	b	348062d0 <device_parse+0x454>
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
348062b8:	e59f0110 	ldr	r0, [pc, #272]	; 348063d0 <device_parse+0x554>
348062bc:	eb000e3d 	bl	34809bb8 <printf>
			if (ret)
348062c0:	e3570000 	cmp	r7, #0
				*ret = NULL;
348062c4:	13a03000 	movne	r3, #0
348062c8:	15873000 	strne	r3, [r7]
348062cc:	ea00002a 	b	3480637c <device_parse+0x500>
			return 1;
		}
	}

	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
348062d0:	e3a00018 	mov	r0, #24
348062d4:	eb000ffe 	bl	3480a2d4 <malloc>
348062d8:	e2504000 	subs	r4, r0, #0
348062dc:	1a000002 	bne	348062ec <device_parse+0x470>
		printf("out of memory\n");
348062e0:	e59f00c4 	ldr	r0, [pc, #196]	; 348063ac <device_parse+0x530>
348062e4:	eb000e33 	bl	34809bb8 <printf>
348062e8:	ea000023 	b	3480637c <device_parse+0x500>
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
348062ec:	e3a01000 	mov	r1, #0
348062f0:	e3a02018 	mov	r2, #24
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
348062f4:	e28d6028 	add	r6, sp, #40	; 0x28
	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
348062f8:	eb00597f 	bl	3481c8fc <memset>
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
348062fc:	e2843010 	add	r3, r4, #16
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34806300:	e536100c 	ldr	r1, [r6, #-12]!
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34806304:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34806308:	e5843010 	str	r3, [r4, #16]
3480630c:	e5844000 	str	r4, [r4]
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
34806310:	e5845008 	str	r5, [r4, #8]
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34806314:	e1c420bc 	strh	r2, [r4, #12]
	list->prev = list;
34806318:	e5843014 	str	r3, [r4, #20]
3480631c:	e5844004 	str	r4, [r4, #4]
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34806320:	e5915000 	ldr	r5, [r1]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34806324:	e3a07000 	mov	r7, #0
34806328:	ea00000d 	b	34806364 <device_parse+0x4e8>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
3480632c:	e891000c 	ldm	r1, {r2, r3}
		part = list_entry(entry, struct part_info, link);
		list_del(entry);
		if (part_sort_add(dev, part) != 0) {
34806330:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34806334:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34806338:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
3480633c:	e5817004 	str	r7, [r1, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34806340:	e5817000 	str	r7, [r1]
34806344:	ebfffcb8 	bl	3480562c <part_sort_add>
34806348:	e3500000 	cmp	r0, #0
3480634c:	0a000002 	beq	3480635c <device_parse+0x4e0>
			device_del(dev);
34806350:	e1a00004 	mov	r0, r4
34806354:	ebfffd10 	bl	3480579c <device_del>
34806358:	ea000007 	b	3480637c <device_parse+0x500>
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
3480635c:	e1a01005 	mov	r1, r5
34806360:	e5955000 	ldr	r5, [r5]
34806364:	e1510006 	cmp	r1, r6
34806368:	1affffef 	bne	3480632c <device_parse+0x4b0>
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
3480636c:	e59d3010 	ldr	r3, [sp, #16]

	debug("===\n\n");
	return 0;
34806370:	e3a00000 	mov	r0, #0
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
34806374:	e5834000 	str	r4, [r3]

	debug("===\n\n");
	return 0;
34806378:	ea000000 	b	34806380 <device_parse+0x504>
				*ret = p;
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
			if (ret)
				*ret = NULL;
			return 1;
3480637c:	e3a00001 	mov	r0, #1

	*retdev = dev;

	debug("===\n\n");
	return 0;
}
34806380:	e28dd028 	add	sp, sp, #40	; 0x28
34806384:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34806388:	34824b1c 	.word	0x34824b1c
3480638c:	34829d54 	.word	0x34829d54
34806390:	3482480d 	.word	0x3482480d
34806394:	34824828 	.word	0x34824828
34806398:	34824848 	.word	0x34824848
3480639c:	3482486e 	.word	0x3482486e
348063a0:	34824884 	.word	0x34824884
348063a4:	34824887 	.word	0x34824887
348063a8:	348248b8 	.word	0x348248b8
348063ac:	348248eb 	.word	0x348248eb
348063b0:	348248fa 	.word	0x348248fa
348063b4:	3482490a 	.word	0x3482490a
348063b8:	34824a89 	.word	0x34824a89
348063bc:	34824a86 	.word	0x34824a86
348063c0:	348246b8 	.word	0x348246b8
348063c4:	34824932 	.word	0x34824932
348063c8:	34824955 	.word	0x34824955
348063cc:	3482497a 	.word	0x3482497a
348063d0:	3482499e 	.word	0x3482499e

348063d4 <mtd_id_parse>:
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348063d4:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
348063d8:	e1a07003 	mov	r7, r3
	const char *p = id;

	*dev_type = 0;
348063dc:	e3a03000 	mov	r3, #0
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
	const char *p = id;
348063e0:	e58d0004 	str	r0, [sp, #4]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348063e4:	e1a05001 	mov	r5, r1
	const char *p = id;

	*dev_type = 0;
348063e8:	e5c23000 	strb	r3, [r2]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348063ec:	e1a04002 	mov	r4, r2
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
348063f0:	e59f10d4 	ldr	r1, [pc, #212]	; 348064cc <mtd_id_parse+0xf8>
348063f4:	e3a02004 	mov	r2, #4
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348063f8:	e1a06000 	mov	r6, r0
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
348063fc:	eb005876 	bl	3481c5dc <strncmp>
34806400:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NAND;
34806404:	03a03002 	moveq	r3, #2
34806408:	05c43000 	strbeq	r3, [r4]
		p += 4;
3480640c:	059d3004 	ldreq	r3, [sp, #4]
34806410:	02833004 	addeq	r3, r3, #4
34806414:	0a000013 	beq	34806468 <mtd_id_parse+0x94>
	} else if (strncmp(p, "nor", 3) == 0) {
34806418:	e59d0004 	ldr	r0, [sp, #4]
3480641c:	e59f10ac 	ldr	r1, [pc, #172]	; 348064d0 <mtd_id_parse+0xfc>
34806420:	e3a02003 	mov	r2, #3
34806424:	eb00586c 	bl	3481c5dc <strncmp>
34806428:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NOR;
3480642c:	03a03001 	moveq	r3, #1
34806430:	05c43000 	strbeq	r3, [r4]
		p += 3;
34806434:	059d3004 	ldreq	r3, [sp, #4]
34806438:	02833003 	addeq	r3, r3, #3
3480643c:	0a000009 	beq	34806468 <mtd_id_parse+0x94>
	} else if (strncmp(p, "onenand", 7) == 0) {
34806440:	e59d0004 	ldr	r0, [sp, #4]
34806444:	e59f1088 	ldr	r1, [pc, #136]	; 348064d4 <mtd_id_parse+0x100>
34806448:	e3a02007 	mov	r2, #7
3480644c:	eb005862 	bl	3481c5dc <strncmp>
34806450:	e3500000 	cmp	r0, #0
34806454:	1a00000b 	bne	34806488 <mtd_id_parse+0xb4>
		*dev_type = MTD_DEV_TYPE_ONENAND;
34806458:	e3a03004 	mov	r3, #4
3480645c:	e5c43000 	strb	r3, [r4]
		p += 7;
34806460:	e59d3004 	ldr	r3, [sp, #4]
34806464:	e2833007 	add	r3, r3, #7
34806468:	e58d3004 	str	r3, [sp, #4]
	} else {
		printf("incorrect device type in %s\n", id);
		return 1;
	}

	if (!isdigit(*p)) {
3480646c:	e59d0004 	ldr	r0, [sp, #4]
34806470:	e59f2060 	ldr	r2, [pc, #96]	; 348064d8 <mtd_id_parse+0x104>
34806474:	e5d03000 	ldrb	r3, [r0]
34806478:	e7d23003 	ldrb	r3, [r2, r3]
3480647c:	e3130004 	tst	r3, #4
34806480:	1a000007 	bne	348064a4 <mtd_id_parse+0xd0>
34806484:	ea000001 	b	34806490 <mtd_id_parse+0xbc>
		p += 3;
	} else if (strncmp(p, "onenand", 7) == 0) {
		*dev_type = MTD_DEV_TYPE_ONENAND;
		p += 7;
	} else {
		printf("incorrect device type in %s\n", id);
34806488:	e59f004c 	ldr	r0, [pc, #76]	; 348064dc <mtd_id_parse+0x108>
3480648c:	ea000000 	b	34806494 <mtd_id_parse+0xc0>
		return 1;
	}

	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
34806490:	e59f0048 	ldr	r0, [pc, #72]	; 348064e0 <mtd_id_parse+0x10c>
34806494:	e1a01006 	mov	r1, r6
34806498:	eb000dc6 	bl	34809bb8 <printf>
		return 1;
3480649c:	e3a00001 	mov	r0, #1
348064a0:	ea000008 	b	348064c8 <mtd_id_parse+0xf4>
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
348064a4:	e28d1004 	add	r1, sp, #4
348064a8:	e3a02000 	mov	r2, #0
348064ac:	eb005c05 	bl	3481d4c8 <simple_strtoul>
	if (ret_id)
348064b0:	e3550000 	cmp	r5, #0
		*ret_id = p;
348064b4:	159d3004 	ldrne	r3, [sp, #4]
	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
		return 1;
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
348064b8:	e5c70000 	strb	r0, [r7]
	if (ret_id)
		*ret_id = p;
348064bc:	15853000 	strne	r3, [r5]
	return 0;
348064c0:	13a00000 	movne	r0, #0
348064c4:	01a00005 	moveq	r0, r5
}
348064c8:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
348064cc:	34824a89 	.word	0x34824a89
348064d0:	348246b8 	.word	0x348246b8
348064d4:	34824a86 	.word	0x34824a86
348064d8:	34821fe0 	.word	0x34821fe0
348064dc:	348249ce 	.word	0x348249ce
348064e0:	348249eb 	.word	0x348249eb

348064e4 <find_dev_and_part>:
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
348064e4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
348064e8:	e59fb18c 	ldr	fp, [pc, #396]	; 3480667c <find_dev_and_part+0x198>
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
348064ec:	e1a0a003 	mov	sl, r3
348064f0:	e1a07000 	mov	r7, r0
348064f4:	e1a05001 	mov	r5, r1
348064f8:	e1a04002 	mov	r4, r2
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
348064fc:	e5bb6004 	ldr	r6, [fp, #4]!
		*part_num = 0;
34806500:	e3a03000 	mov	r3, #0
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34806504:	ea000014 	b	3480655c <find_dev_and_part+0x78>
		*part_num = 0;
34806508:	e5c43000 	strb	r3, [r4]
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
3480650c:	e5969010 	ldr	r9, [r6, #16]

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
34806510:	e5856000 	str	r6, [r5]
		list_for_each(pentry, &(*dev)->parts) {
34806514:	ea00000b 	b	34806548 <find_dev_and_part+0x64>
			*part = list_entry(pentry, struct part_info, link);
			if (strcmp((*part)->name, id) == 0)
34806518:	e5990008 	ldr	r0, [r9, #8]

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
			*part = list_entry(pentry, struct part_info, link);
3480651c:	e58a9000 	str	r9, [sl]
			if (strcmp((*part)->name, id) == 0)
34806520:	e1a01007 	mov	r1, r7
34806524:	e58d3004 	str	r3, [sp, #4]
34806528:	eb00581f 	bl	3481c5ac <strcmp>
3480652c:	e3500000 	cmp	r0, #0
34806530:	e59d3004 	ldr	r3, [sp, #4]
34806534:	0a00004e 	beq	34806674 <find_dev_and_part+0x190>
				return 0;
			(*part_num)++;
34806538:	e5d42000 	ldrb	r2, [r4]
3480653c:	e2822001 	add	r2, r2, #1
34806540:	e5c42000 	strb	r2, [r4]
	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
34806544:	e5999000 	ldr	r9, [r9]
34806548:	e5952000 	ldr	r2, [r5]
3480654c:	e2822010 	add	r2, r2, #16
34806550:	e1590002 	cmp	r9, r2
34806554:	1affffef 	bne	34806518 <find_dev_and_part+0x34>
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34806558:	e5966000 	ldr	r6, [r6]
3480655c:	e156000b 	cmp	r6, fp
34806560:	1affffe8 	bne	34806508 <find_dev_and_part+0x24>
				return 0;
			(*part_num)++;
		}
	}

	p = id;
34806564:	e28d6010 	add	r6, sp, #16
34806568:	e5267008 	str	r7, [r6, #-8]!
	*dev = NULL;
3480656c:	e3a03000 	mov	r3, #0
34806570:	e5853000 	str	r3, [r5]
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34806574:	e28d200f 	add	r2, sp, #15
		}
	}

	p = id;
	*dev = NULL;
	*part = NULL;
34806578:	e58a3000 	str	r3, [sl]
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
3480657c:	e1a00007 	mov	r0, r7
	}

	p = id;
	*dev = NULL;
	*part = NULL;
	*part_num = 0;
34806580:	e5c43000 	strb	r3, [r4]

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34806584:	e1a01006 	mov	r1, r6
34806588:	e28d300e 	add	r3, sp, #14
3480658c:	ebffff90 	bl	348063d4 <mtd_id_parse>
34806590:	e2502000 	subs	r2, r0, #0
34806594:	1a000035 	bne	34806670 <find_dev_and_part+0x18c>
		return 1;

	if ((*p++ != ',') || (*p == '\0')) {
34806598:	e59d3008 	ldr	r3, [sp, #8]
3480659c:	e1a00003 	mov	r0, r3
348065a0:	e4d01001 	ldrb	r1, [r0], #1
348065a4:	e351002c 	cmp	r1, #44	; 0x2c
348065a8:	e58d0008 	str	r0, [sp, #8]
348065ac:	1a000002 	bne	348065bc <find_dev_and_part+0xd8>
348065b0:	e5d33001 	ldrb	r3, [r3, #1]
348065b4:	e3530000 	cmp	r3, #0
348065b8:	1a000002 	bne	348065c8 <find_dev_and_part+0xe4>
		printf("no partition number specified\n");
348065bc:	e59f00bc 	ldr	r0, [pc, #188]	; 34806680 <find_dev_and_part+0x19c>
348065c0:	eb000d7c 	bl	34809bb8 <printf>
348065c4:	ea000029 	b	34806670 <find_dev_and_part+0x18c>
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
348065c8:	e1a01006 	mov	r1, r6
348065cc:	eb005bbd 	bl	3481d4c8 <simple_strtoul>
	if (*p != '\0') {
348065d0:	e59d3008 	ldr	r3, [sp, #8]

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
348065d4:	e1a0b000 	mov	fp, r0
	if (*p != '\0') {
348065d8:	e5d36000 	ldrb	r6, [r3]
348065dc:	e3560000 	cmp	r6, #0
348065e0:	0a000003 	beq	348065f4 <find_dev_and_part+0x110>
		printf("unexpected trailing character '%c'\n", *p);
348065e4:	e1a01006 	mov	r1, r6
348065e8:	e59f0094 	ldr	r0, [pc, #148]	; 34806684 <find_dev_and_part+0x1a0>
348065ec:	eb000d71 	bl	34809bb8 <printf>
348065f0:	ea00001e 	b	34806670 <find_dev_and_part+0x18c>
		return 1;
	}

	if ((*dev = device_find(type, dnum)) == NULL) {
348065f4:	e5dd700f 	ldrb	r7, [sp, #15]
348065f8:	e5dd900e 	ldrb	r9, [sp, #14]
348065fc:	e1a00007 	mov	r0, r7
34806600:	e1a01009 	mov	r1, r9
34806604:	ebfffe09 	bl	34805e30 <device_find>
34806608:	e3500000 	cmp	r0, #0
3480660c:	e5850000 	str	r0, [r5]
34806610:	1a00000a 	bne	34806640 <find_dev_and_part+0x15c>
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
34806614:	e3570002 	cmp	r7, #2
34806618:	059f1068 	ldreq	r1, [pc, #104]	; 34806688 <find_dev_and_part+0x1a4>
3480661c:	0a000003 	beq	34806630 <find_dev_and_part+0x14c>
34806620:	e59f3064 	ldr	r3, [pc, #100]	; 3480668c <find_dev_and_part+0x1a8>
34806624:	e3570004 	cmp	r7, #4
34806628:	e59f1060 	ldr	r1, [pc, #96]	; 34806690 <find_dev_and_part+0x1ac>
3480662c:	01a01003 	moveq	r1, r3
34806630:	e1a02009 	mov	r2, r9
34806634:	e59f0058 	ldr	r0, [pc, #88]	; 34806694 <find_dev_and_part+0x1b0>
34806638:	eb000d5e 	bl	34809bb8 <printf>
3480663c:	ea00000b 	b	34806670 <find_dev_and_part+0x18c>

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
34806640:	e6ef707b 	uxtb	r7, fp
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
34806644:	e1a01007 	mov	r1, r7
34806648:	ebfffb62 	bl	348053d8 <mtd_part_info>
3480664c:	e3500000 	cmp	r0, #0
34806650:	e58a0000 	str	r0, [sl]
34806654:	e1a09000 	mov	r9, r0
		printf("no such partition\n");
		*dev = NULL;
		return 1;
	}

	*part_num = pnum;
34806658:	15c47000 	strbne	r7, [r4]

	return 0;
3480665c:	11a00006 	movne	r0, r6
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
34806660:	1a000003 	bne	34806674 <find_dev_and_part+0x190>
		printf("no such partition\n");
34806664:	e59f002c 	ldr	r0, [pc, #44]	; 34806698 <find_dev_and_part+0x1b4>
34806668:	eb000d52 	bl	34809bb8 <printf>
		*dev = NULL;
3480666c:	e5859000 	str	r9, [r5]
	*dev = NULL;
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
		return 1;
34806670:	e3a00001 	mov	r0, #1
	}

	*part_num = pnum;

	return 0;
}
34806674:	e28dd010 	add	sp, sp, #16
34806678:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480667c:	34829d54 	.word	0x34829d54
34806680:	34824a0a 	.word	0x34824a0a
34806684:	34824a29 	.word	0x34824a29
34806688:	34824a89 	.word	0x34824a89
3480668c:	34824a86 	.word	0x34824a86
34806690:	348246b8 	.word	0x348246b8
34806694:	34824a4d 	.word	0x34824a4d
34806698:	34824a62 	.word	0x34824a62

3480669c <mtdparts_init>:
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
3480669c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
348066a0:	e59f4594 	ldr	r4, [pc, #1428]	; 34806c3c <mtdparts_init+0x5a0>
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
348066a4:	e24dd028 	sub	sp, sp, #40	; 0x28
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
348066a8:	e5945228 	ldr	r5, [r4, #552]	; 0x228
348066ac:	e3550000 	cmp	r5, #0
348066b0:	1a000013 	bne	34806704 <mtdparts_init+0x68>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348066b4:	e2843e22 	add	r3, r4, #544	; 0x220
348066b8:	e5843220 	str	r3, [r4, #544]	; 0x220
	list->prev = list;
348066bc:	e5843224 	str	r3, [r4, #548]	; 0x224
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348066c0:	e2843004 	add	r3, r4, #4
348066c4:	e5843004 	str	r3, [r4, #4]
	list->prev = list;
348066c8:	e5843008 	str	r3, [r4, #8]
		INIT_LIST_HEAD(&mtdids);
		INIT_LIST_HEAD(&devices);
		memset(last_ids, 0, MTDIDS_MAXLEN);
348066cc:	e1a01005 	mov	r1, r5
348066d0:	e3a02080 	mov	r2, #128	; 0x80
348066d4:	e2840f8b 	add	r0, r4, #556	; 0x22c
348066d8:	eb005887 	bl	3481c8fc <memset>
		memset(last_parts, 0, MTDPARTS_MAXLEN);
348066dc:	e1a01005 	mov	r1, r5
348066e0:	e3a02c02 	mov	r2, #512	; 0x200
348066e4:	e2840020 	add	r0, r4, #32
348066e8:	eb005883 	bl	3481c8fc <memset>
		memset(last_partition, 0, PARTITION_MAXLEN);
348066ec:	e2840010 	add	r0, r4, #16
348066f0:	e1a01005 	mov	r1, r5
348066f4:	e3a02010 	mov	r2, #16
348066f8:	eb00587f 	bl	3481c8fc <memset>
		initialized = 1;
348066fc:	e3a03001 	mov	r3, #1
34806700:	e5843228 	str	r3, [r4, #552]	; 0x228
	}

	/* get variables */
	ids = getenv("mtdids");
34806704:	e59f0534 	ldr	r0, [pc, #1332]	; 34806c40 <mtdparts_init+0x5a4>
34806708:	eb00063c 	bl	34808000 <getenv>
3480670c:	e1a05000 	mov	r5, r0
	parts = getenv("mtdparts");
34806710:	e59f052c 	ldr	r0, [pc, #1324]	; 34806c44 <mtdparts_init+0x5a8>
34806714:	eb000639 	bl	34808000 <getenv>
34806718:	e1a04000 	mov	r4, r0
	current_partition = getenv("partition");
3480671c:	e59f0524 	ldr	r0, [pc, #1316]	; 34806c48 <mtdparts_init+0x5ac>
34806720:	eb000636 	bl	34808000 <getenv>

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
34806724:	e3a03000 	mov	r3, #0
	if (current_partition)
34806728:	e2501000 	subs	r1, r0, #0
	parts = getenv("mtdparts");
	current_partition = getenv("partition");

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
3480672c:	e5cd3004 	strb	r3, [sp, #4]
	if (current_partition)
34806730:	0a000002 	beq	34806740 <mtdparts_init+0xa4>
		strncpy(tmp_ep, current_partition, PARTITION_MAXLEN);
34806734:	e28d0004 	add	r0, sp, #4
34806738:	e3a02010 	mov	r2, #16
3480673c:	eb005770 	bl	3481c504 <strncpy>

	debug("last_partition : %s\n", last_partition);
	debug("env_partition  : %s\n", current_partition);

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
34806740:	e3550000 	cmp	r5, #0
34806744:	1a000003 	bne	34806758 <mtdparts_init+0xbc>
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
			setenv("mtdids", (char *)ids);
34806748:	e59f04f0 	ldr	r0, [pc, #1264]	; 34806c40 <mtdparts_init+0x5a4>
3480674c:	e59f14f8 	ldr	r1, [pc, #1272]	; 34806c4c <mtdparts_init+0x5b0>
34806750:	eb000522 	bl	34807be0 <setenv>

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
34806754:	e59f54f0 	ldr	r5, [pc, #1264]	; 34806c4c <mtdparts_init+0x5b0>
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
34806758:	e1a00005 	mov	r0, r5
3480675c:	eb0057c6 	bl	3481c67c <strlen>
34806760:	e350007f 	cmp	r0, #127	; 0x7f
		printf("mtdids too long (> %d)\n", MTDIDS_MAXLEN);
34806764:	859f04e4 	ldrhi	r0, [pc, #1252]	; 34806c50 <mtdparts_init+0x5b4>
34806768:	83a01080 	movhi	r1, #128	; 0x80
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
3480676c:	8a00000a 	bhi	3480679c <mtdparts_init+0x100>
		return 1;
	}

	/* do no try to use defaults when mtdparts variable is not defined,
	 * just check the length */
	if (!parts)
34806770:	e3540000 	cmp	r4, #0
34806774:	1a000002 	bne	34806784 <mtdparts_init+0xe8>
		printf("mtdparts variable not set, see 'help mtdparts'\n");
34806778:	e59f04d4 	ldr	r0, [pc, #1236]	; 34806c54 <mtdparts_init+0x5b8>
3480677c:	eb000d0d 	bl	34809bb8 <printf>
34806780:	ea000008 	b	348067a8 <mtdparts_init+0x10c>

	if (parts && (strlen(parts) > MTDPARTS_MAXLEN - 1)) {
34806784:	e1a00004 	mov	r0, r4
34806788:	eb0057bb 	bl	3481c67c <strlen>
3480678c:	e3500c02 	cmp	r0, #512	; 0x200
34806790:	3a000004 	bcc	348067a8 <mtdparts_init+0x10c>
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
34806794:	e59f04bc 	ldr	r0, [pc, #1212]	; 34806c58 <mtdparts_init+0x5bc>
34806798:	e3a01c02 	mov	r1, #512	; 0x200
3480679c:	eb000d05 	bl	34809bb8 <printf>
		return 1;
348067a0:	e3a00001 	mov	r0, #1
348067a4:	ea00010c 	b	34806bdc <mtdparts_init+0x540>
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
348067a8:	e59f048c 	ldr	r0, [pc, #1164]	; 34806c3c <mtdparts_init+0x5a0>
348067ac:	e5d0322c 	ldrb	r3, [r0, #556]	; 0x22c
348067b0:	e3530000 	cmp	r3, #0
348067b4:	0a000005 	beq	348067d0 <mtdparts_init+0x134>
348067b8:	e1a01005 	mov	r1, r5
348067bc:	e2800f8b 	add	r0, r0, #556	; 0x22c
348067c0:	eb005779 	bl	3481c5ac <strcmp>
348067c4:	e3500000 	cmp	r0, #0
		ids_changed = 0;
348067c8:	01a05000 	moveq	r5, r0
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
		return 1;
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
348067cc:	0a000088 	beq	348069f4 <mtdparts_init+0x358>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
348067d0:	e59f7464 	ldr	r7, [pc, #1124]	; 34806c3c <mtdparts_init+0x5a0>
 * @param ids mapping string
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdids(const char *const ids)
{
	const char *p = ids;
348067d4:	e58d5018 	str	r5, [sp, #24]
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
348067d8:	e5b70220 	ldr	r0, [r7, #544]!	; 0x220
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348067dc:	e3a0a000 	mov	sl, #0
348067e0:	e5906000 	ldr	r6, [r0]
348067e4:	ea000007 	b	34806808 <mtdparts_init+0x16c>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348067e8:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348067ec:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348067f0:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348067f4:	e580a004 	str	sl, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348067f8:	e580a000 	str	sl, [r0]
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
348067fc:	eb000e2b 	bl	3480a0b0 <free>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
34806800:	e1a00006 	mov	r0, r6
34806804:	e5966000 	ldr	r6, [r6]
34806808:	e1500007 	cmp	r0, r7
3480680c:	e59f9428 	ldr	r9, [pc, #1064]	; 34806c3c <mtdparts_init+0x5a0>
34806810:	1afffff4 	bne	348067e8 <mtdparts_init+0x14c>
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
	}
	last_ids[0] = '\0';
34806814:	e3a03000 	mov	r3, #0
34806818:	e5c9322c 	strb	r3, [r9, #556]	; 0x22c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3480681c:	e5890220 	str	r0, [r9, #544]	; 0x220
	list->prev = list;
34806820:	e5890224 	str	r0, [r9, #548]	; 0x224
	struct mtdids *id;
	struct list_head *entry, *n;
	struct mtdids *id_tmp;
	u8 type, num;
	u32 size;
	int ret = 1;
34806824:	e2833001 	add	r3, r3, #1
34806828:	e1a0a005 	mov	sl, r5
3480682c:	ea000057 	b	34806990 <mtdparts_init+0x2f4>

	while(p && (*p != '\0')) {

		ret = 1;
		/* parse 'nor'|'nand'|'onenand'<dev-num> */
		if (mtd_id_parse(p, &p, &type, &num) != 0)
34806830:	e28d1018 	add	r1, sp, #24
34806834:	e28d2027 	add	r2, sp, #39	; 0x27
34806838:	e28d3020 	add	r3, sp, #32
3480683c:	ebfffee4 	bl	348063d4 <mtd_id_parse>
34806840:	e3500000 	cmp	r0, #0
34806844:	1a000059 	bne	348069b0 <mtdparts_init+0x314>
			break;

		if (*p != '=') {
34806848:	e59d3018 	ldr	r3, [sp, #24]
3480684c:	e5d32000 	ldrb	r2, [r3]
34806850:	e352003d 	cmp	r2, #61	; 0x3d
			printf("mtdids: incorrect <dev-num>\n");
34806854:	159f0400 	ldrne	r0, [pc, #1024]	; 34806c5c <mtdparts_init+0x5c0>
34806858:	1a000032 	bne	34806928 <mtdparts_init+0x28c>
			break;
		}
		p++;
3480685c:	e2833001 	add	r3, r3, #1

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34806860:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
34806864:	e5dd1020 	ldrb	r1, [sp, #32]
34806868:	e28d201c 	add	r2, sp, #28

		if (*p != '=') {
			printf("mtdids: incorrect <dev-num>\n");
			break;
		}
		p++;
3480686c:	e58d3018 	str	r3, [sp, #24]

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34806870:	ebfffd62 	bl	34805e00 <mtd_device_validate>
34806874:	e3500000 	cmp	r0, #0
34806878:	1a00005b 	bne	348069ec <mtdparts_init+0x350>
			return 1;

		/* locate <mtd-id> */
		mtd_id = p;
3480687c:	e59d7018 	ldr	r7, [sp, #24]
		if ((p = strchr(mtd_id, ',')) != NULL) {
34806880:	e3a0102c 	mov	r1, #44	; 0x2c
34806884:	e1a00007 	mov	r0, r7
34806888:	eb005765 	bl	3481c624 <strchr>
3480688c:	e3500000 	cmp	r0, #0
34806890:	e58d0018 	str	r0, [sp, #24]
			mtd_id_len = p - mtd_id + 1;
34806894:	12676001 	rsbne	r6, r7, #1
34806898:	10806006 	addne	r6, r0, r6
			p++;
3480689c:	12800001 	addne	r0, r0, #1
348068a0:	158d0018 	strne	r0, [sp, #24]
348068a4:	1a000002 	bne	348068b4 <mtdparts_init+0x218>
		} else {
			mtd_id_len = strlen(mtd_id) + 1;
348068a8:	e1a00007 	mov	r0, r7
348068ac:	eb005772 	bl	3481c67c <strlen>
348068b0:	e2806001 	add	r6, r0, #1
		}
		if (mtd_id_len == 0) {
348068b4:	e3560000 	cmp	r6, #0
			printf("mtdids: no <mtd-id> identifier\n");
348068b8:	059f03a0 	ldreq	r0, [pc, #928]	; 34806c60 <mtdparts_init+0x5c4>
348068bc:	0a000019 	beq	34806928 <mtdparts_init+0x28c>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
348068c0:	e5993220 	ldr	r3, [r9, #544]	; 0x220
			id_tmp = list_entry(entry, struct mtdids, link);
			if ((id_tmp->type == type) && (id_tmp->num == num)) {
348068c4:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
348068c8:	e5dd1020 	ldrb	r1, [sp, #32]
348068cc:	ea000006 	b	348068ec <mtdparts_init+0x250>
348068d0:	e5d32008 	ldrb	r2, [r3, #8]
348068d4:	e1520000 	cmp	r2, r0
348068d8:	1a000002 	bne	348068e8 <mtdparts_init+0x24c>
348068dc:	e5d32009 	ldrb	r2, [r3, #9]
348068e0:	e1520001 	cmp	r2, r1
348068e4:	0a000004 	beq	348068fc <mtdparts_init+0x260>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
348068e8:	e5933000 	ldr	r3, [r3]
348068ec:	e59f2370 	ldr	r2, [pc, #880]	; 34806c64 <mtdparts_init+0x5c8>
348068f0:	e1530002 	cmp	r3, r2
348068f4:	1afffff5 	bne	348068d0 <mtdparts_init+0x234>
348068f8:	ea0000b9 	b	34806be4 <mtdparts_init+0x548>
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
348068fc:	e3500002 	cmp	r0, #2
34806900:	059f1360 	ldreq	r1, [pc, #864]	; 34806c68 <mtdparts_init+0x5cc>
34806904:	0a000003 	beq	34806918 <mtdparts_init+0x27c>
					MTD_DEV_TYPE(type), num);
34806908:	e59f335c 	ldr	r3, [pc, #860]	; 34806c6c <mtdparts_init+0x5d0>
3480690c:	e3500004 	cmp	r0, #4
34806910:	e59f1358 	ldr	r1, [pc, #856]	; 34806c70 <mtdparts_init+0x5d4>
34806914:	01a01003 	moveq	r1, r3
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
34806918:	e59f0354 	ldr	r0, [pc, #852]	; 34806c74 <mtdparts_init+0x5d8>
3480691c:	eb000ca5 	bl	34809bb8 <printf>
34806920:	ea000022 	b	348069b0 <mtdparts_init+0x314>
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
34806924:	e59f034c 	ldr	r0, [pc, #844]	; 34806c78 <mtdparts_init+0x5dc>
34806928:	eb000ca2 	bl	34809bb8 <printf>
3480692c:	ea00001f 	b	348069b0 <mtdparts_init+0x314>
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
34806930:	e3a01000 	mov	r1, #0
34806934:	e1a0200b 	mov	r2, fp
34806938:	eb0057ef 	bl	3481c8fc <memset>
		id->num = num;
3480693c:	e5dd3020 	ldrb	r3, [sp, #32]
		id->type = type;
		id->size = size;
		id->mtd_id = (char *)(id + 1);
34806940:	e2850014 	add	r0, r5, #20
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
34806944:	e5c53009 	strb	r3, [r5, #9]
		id->type = type;
34806948:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
		id->size = size;
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
3480694c:	e2462001 	sub	r2, r6, #1
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
34806950:	e5c53008 	strb	r3, [r5, #8]
		id->size = size;
34806954:	e59d301c 	ldr	r3, [sp, #28]
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34806958:	e1a01007 	mov	r1, r7
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
		id->size = size;
3480695c:	e585300c 	str	r3, [r5, #12]
		id->mtd_id = (char *)(id + 1);
34806960:	e5850010 	str	r0, [r5, #16]
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34806964:	eb0056e6 	bl	3481c504 <strncpy>
		id->mtd_id[mtd_id_len - 1] = '\0';
34806968:	e5953010 	ldr	r3, [r5, #16]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480696c:	e59f12c8 	ldr	r1, [pc, #712]	; 34806c3c <mtdparts_init+0x5a0>
34806970:	e0836006 	add	r6, r3, r6
34806974:	e3a03000 	mov	r3, #0
34806978:	e5463001 	strb	r3, [r6, #-1]
3480697c:	e5912224 	ldr	r2, [r1, #548]	; 0x224
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806980:	e5815224 	str	r5, [r1, #548]	; 0x224
	new->next = next;
34806984:	e59f12d8 	ldr	r1, [pc, #728]	; 34806c64 <mtdparts_init+0x5c8>
	new->prev = prev;
34806988:	e8850006 	stm	r5, {r1, r2}
	prev->next = new;
3480698c:	e5825000 	str	r5, [r2]
		free(id_tmp);
	}
	last_ids[0] = '\0';
	INIT_LIST_HEAD(&mtdids);

	while(p && (*p != '\0')) {
34806990:	e59d0018 	ldr	r0, [sp, #24]
34806994:	e3500000 	cmp	r0, #0
34806998:	0a000002 	beq	348069a8 <mtdparts_init+0x30c>
3480699c:	e5d02000 	ldrb	r2, [r0]
348069a0:	e3520000 	cmp	r2, #0
348069a4:	1affffa1 	bne	34806830 <mtdparts_init+0x194>
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
348069a8:	e3530001 	cmp	r3, #1
348069ac:	1a000092 	bne	34806bfc <mtdparts_init+0x560>
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
348069b0:	e59f5284 	ldr	r5, [pc, #644]	; 34806c3c <mtdparts_init+0x5a0>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348069b4:	e3a06000 	mov	r6, #0
348069b8:	e5b50220 	ldr	r0, [r5, #544]!	; 0x220
348069bc:	e5904000 	ldr	r4, [r0]
348069c0:	ea000007 	b	348069e4 <mtdparts_init+0x348>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348069c4:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348069c8:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348069cc:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348069d0:	e5806004 	str	r6, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348069d4:	e5806000 	str	r6, [r0]
			id_tmp = list_entry(entry, struct mtdids, link);
			list_del(entry);
			free(id_tmp);
348069d8:	eb000db4 	bl	3480a0b0 <free>
		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
348069dc:	e1a00004 	mov	r0, r4
348069e0:	e5944000 	ldr	r4, [r4]
348069e4:	e1500005 	cmp	r0, r5
348069e8:	1afffff5 	bne	348069c4 <mtdparts_init+0x328>
		ids_changed = 0;
	} else {
		ids_changed = 1;

		if (parse_mtdids(ids) != 0) {
			mtd_devices_init();
348069ec:	ebfffc49 	bl	34805b18 <mtd_devices_init>
348069f0:	eaffff6a 	b	348067a0 <mtdparts_init+0x104>
		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
	}

	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
348069f4:	e3540000 	cmp	r4, #0
348069f8:	e59f023c 	ldr	r0, [pc, #572]	; 34806c3c <mtdparts_init+0x5a0>
348069fc:	0a000056 	beq	34806b5c <mtdparts_init+0x4c0>
34806a00:	e5d03020 	ldrb	r3, [r0, #32]
34806a04:	e3530000 	cmp	r3, #0
34806a08:	0a000006 	beq	34806a28 <mtdparts_init+0x38c>
34806a0c:	e2800020 	add	r0, r0, #32
34806a10:	e1a01004 	mov	r1, r4
34806a14:	eb0056e4 	bl	3481c5ac <strcmp>
34806a18:	e3500000 	cmp	r0, #0
34806a1c:	1a000001 	bne	34806a28 <mtdparts_init+0x38c>
34806a20:	e3550000 	cmp	r5, #0
34806a24:	0a000080 	beq	34806c2c <mtdparts_init+0x590>
 * @param mtdparts string specifing mtd partitions
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
34806a28:	e58d4018 	str	r4, [sp, #24]
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
34806a2c:	ebfffc39 	bl	34805b18 <mtd_devices_init>
34806a30:	e3500000 	cmp	r0, #0
		printf("could not initialise device list\n");
34806a34:	159f0240 	ldrne	r0, [pc, #576]	; 34806c7c <mtdparts_init+0x5e0>
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
34806a38:	1a00003b 	bne	34806b2c <mtdparts_init+0x490>
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
34806a3c:	e59f0200 	ldr	r0, [pc, #512]	; 34806c44 <mtdparts_init+0x5a8>
34806a40:	eb00056e 	bl	34808000 <getenv>

	if (strncmp(p, "mtdparts=", 9) != 0) {
34806a44:	e59f1234 	ldr	r1, [pc, #564]	; 34806c80 <mtdparts_init+0x5e4>
34806a48:	e3a02009 	mov	r2, #9
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
34806a4c:	e58d0018 	str	r0, [sp, #24]

	if (strncmp(p, "mtdparts=", 9) != 0) {
34806a50:	eb0056e1 	bl	3481c5dc <strncmp>
34806a54:	e3500000 	cmp	r0, #0
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
34806a58:	159f0224 	ldrne	r0, [pc, #548]	; 34806c84 <mtdparts_init+0x5e8>
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");

	if (strncmp(p, "mtdparts=", 9) != 0) {
34806a5c:	1a000032 	bne	34806b2c <mtdparts_init+0x490>
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;
34806a60:	e59d3018 	ldr	r3, [sp, #24]
34806a64:	e28d6028 	add	r6, sp, #40	; 0x28
34806a68:	e2833009 	add	r3, r3, #9
34806a6c:	e5263010 	str	r3, [r6, #-16]!

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34806a70:	e28d7014 	add	r7, sp, #20
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
	struct mtd_device *dev;
	int err = 1;
34806a74:	e3a03001 	mov	r3, #1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34806a78:	e59f51bc 	ldr	r5, [pc, #444]	; 34806c3c <mtdparts_init+0x5a0>
34806a7c:	ea00001f 	b	34806b00 <mtdparts_init+0x464>
	}
	p += 9;

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34806a80:	e1a01006 	mov	r1, r6
34806a84:	e1a02007 	mov	r2, r7
34806a88:	ebfffcfb 	bl	34805e7c <device_parse>
34806a8c:	e3500000 	cmp	r0, #0
34806a90:	1a000022 	bne	34806b20 <mtdparts_init+0x484>
34806a94:	e59da014 	ldr	sl, [sp, #20]
34806a98:	e35a0000 	cmp	sl, #0
34806a9c:	0a00001f 	beq	34806b20 <mtdparts_init+0x484>

		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
34806aa0:	e59a3008 	ldr	r3, [sl, #8]
34806aa4:	e5d39008 	ldrb	r9, [r3, #8]
34806aa8:	e5d3b009 	ldrb	fp, [r3, #9]
34806aac:	e1a00009 	mov	r0, r9
34806ab0:	e1a0100b 	mov	r1, fp
34806ab4:	ebfffcdd 	bl	34805e30 <device_find>
34806ab8:	e2503000 	subs	r3, r0, #0
34806abc:	0a00000a 	beq	34806aec <mtdparts_init+0x450>
			printf("device %s%d redefined, please correct mtdparts variable\n",
34806ac0:	e3590002 	cmp	r9, #2
34806ac4:	059f119c 	ldreq	r1, [pc, #412]	; 34806c68 <mtdparts_init+0x5cc>
34806ac8:	0a000003 	beq	34806adc <mtdparts_init+0x440>
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
34806acc:	e59f3198 	ldr	r3, [pc, #408]	; 34806c6c <mtdparts_init+0x5d0>
34806ad0:	e3590004 	cmp	r9, #4
34806ad4:	e59f1194 	ldr	r1, [pc, #404]	; 34806c70 <mtdparts_init+0x5d4>
34806ad8:	01a01003 	moveq	r1, r3
		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
			printf("device %s%d redefined, please correct mtdparts variable\n",
34806adc:	e1a0200b 	mov	r2, fp
34806ae0:	e59f01a0 	ldr	r0, [pc, #416]	; 34806c88 <mtdparts_init+0x5ec>
34806ae4:	eb000c33 	bl	34809bb8 <printf>
34806ae8:	ea00000c 	b	34806b20 <mtdparts_init+0x484>
34806aec:	e5952008 	ldr	r2, [r5, #8]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34806af0:	e59f1194 	ldr	r1, [pc, #404]	; 34806c8c <mtdparts_init+0x5f0>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806af4:	e585a008 	str	sl, [r5, #8]
	new->next = next;
34806af8:	e88a0006 	stm	sl, {r1, r2}
	new->prev = prev;
	prev->next = new;
34806afc:	e582a000 	str	sl, [r2]
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;

	while (p && (*p != '\0')) {
34806b00:	e59d0018 	ldr	r0, [sp, #24]
34806b04:	e3500000 	cmp	r0, #0
34806b08:	0a000002 	beq	34806b18 <mtdparts_init+0x47c>
34806b0c:	e5d02000 	ldrb	r2, [r0]
34806b10:	e3520000 	cmp	r2, #0
34806b14:	1affffd9 	bne	34806a80 <mtdparts_init+0x3e4>
		}

		list_add_tail(&dev->link, &devices);
		err = 0;
	}
	if (err == 1) {
34806b18:	e3530001 	cmp	r3, #1
34806b1c:	1a00003c 	bne	34806c14 <mtdparts_init+0x578>
		device_delall(&devices);
34806b20:	ebfffbe3 	bl	34805ab4 <device_delall.clone.2>
34806b24:	eaffff1d 	b	348067a0 <mtdparts_init+0x104>
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
			printf("mtdparts_init: no valid partitions\n");
34806b28:	e59f0160 	ldr	r0, [pc, #352]	; 34806c90 <mtdparts_init+0x5f4>
34806b2c:	eb000c21 	bl	34809bb8 <printf>
34806b30:	eaffff1a 	b	348067a0 <mtdparts_init+0x104>
			return 1;
		}

		/* ok it's good, save new parts */
		strncpy(last_parts, parts, MTDPARTS_MAXLEN);
34806b34:	e2850020 	add	r0, r5, #32
34806b38:	e1a01004 	mov	r1, r4
34806b3c:	e3a02c02 	mov	r2, #512	; 0x200
34806b40:	eb00566f 	bl	3481c504 <strncpy>

		/* reset first partition from first dev from the list as current */
		current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
34806b44:	e5953004 	ldr	r3, [r5, #4]
34806b48:	e5853000 	str	r3, [r5]
		current_mtd_partnum = 0;
34806b4c:	e3a03000 	mov	r3, #0
34806b50:	e5c5300c 	strb	r3, [r5, #12]
		current_save();
34806b54:	ebfffa88 	bl	3480557c <current_save>
34806b58:	ea000033 	b	34806c2c <mtdparts_init+0x590>
				MTD_DEV_TYPE(current_mtd_dev->id->type),
				current_mtd_dev->id->num, current_mtd_partnum);
	}

	/* mtdparts variable was reset to NULL, delete all devices/partitions */
	if (!parts && (last_parts[0] != '\0'))
34806b5c:	e5d03020 	ldrb	r3, [r0, #32]
34806b60:	e3530000 	cmp	r3, #0
34806b64:	0a000019 	beq	34806bd0 <mtdparts_init+0x534>
		return mtd_devices_init();
34806b68:	ebfffbea 	bl	34805b18 <mtd_devices_init>
34806b6c:	ea00001a 	b	34806bdc <mtdparts_init+0x540>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
34806b70:	e59f50c4 	ldr	r5, [pc, #196]	; 34806c3c <mtdparts_init+0x5a0>
34806b74:	e28d4004 	add	r4, sp, #4
34806b78:	e1a00004 	mov	r0, r4
34806b7c:	e2851010 	add	r1, r5, #16
34806b80:	eb005689 	bl	3481c5ac <strcmp>
34806b84:	e3500000 	cmp	r0, #0
34806b88:	0a00000b 	beq	34806bbc <mtdparts_init+0x520>
		struct mtd_device *cdev;
		u8 pnum;

		debug("--- getting current partition: %s\n", tmp_ep);

		if (find_dev_and_part(tmp_ep, &cdev, &pnum, &p) == 0) {
34806b8c:	e1a00004 	mov	r0, r4
34806b90:	e28d1014 	add	r1, sp, #20
34806b94:	e28d2027 	add	r2, sp, #39	; 0x27
34806b98:	e28d3020 	add	r3, sp, #32
34806b9c:	ebfffe50 	bl	348064e4 <find_dev_and_part>
34806ba0:	e2504000 	subs	r4, r0, #0
34806ba4:	1a00000b 	bne	34806bd8 <mtdparts_init+0x53c>
			current_mtd_dev = cdev;
34806ba8:	e59d3014 	ldr	r3, [sp, #20]
34806bac:	e5853000 	str	r3, [r5]
			current_mtd_partnum = pnum;
34806bb0:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
34806bb4:	e5c5300c 	strb	r3, [r5, #12]
34806bb8:	ea000003 	b	34806bcc <mtdparts_init+0x530>
			current_save();
		}
	} else if (getenv("partition") == NULL) {
34806bbc:	e59f0084 	ldr	r0, [pc, #132]	; 34806c48 <mtdparts_init+0x5ac>
34806bc0:	eb00050e 	bl	34808000 <getenv>
34806bc4:	e2504000 	subs	r4, r0, #0
34806bc8:	1a000002 	bne	34806bd8 <mtdparts_init+0x53c>
		debug("no partition variable set, setting...\n");
		current_save();
34806bcc:	ebfffa6a 	bl	3480557c <current_save>
	if (!parts && (last_parts[0] != '\0'))
		return mtd_devices_init();

	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;
34806bd0:	e1a00004 	mov	r0, r4
34806bd4:	ea000000 	b	34806bdc <mtdparts_init+0x540>
	} else if (getenv("partition") == NULL) {
		debug("no partition variable set, setting...\n");
		current_save();
	}

	return 0;
34806bd8:	e3a00000 	mov	r0, #0
}
34806bdc:	e28dd028 	add	sp, sp, #40	; 0x28
34806be0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
					MTD_DEV_TYPE(type), num);
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
34806be4:	e286b014 	add	fp, r6, #20
34806be8:	e1a0000b 	mov	r0, fp
34806bec:	eb000db8 	bl	3480a2d4 <malloc>
34806bf0:	e2505000 	subs	r5, r0, #0
34806bf4:	1affff4d 	bne	34806930 <mtdparts_init+0x294>
34806bf8:	eaffff49 	b	34806924 <mtdparts_init+0x288>
			mtd_devices_init();
			return 1;
		}

		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
34806bfc:	e59f0090 	ldr	r0, [pc, #144]	; 34806c94 <mtdparts_init+0x5f8>
34806c00:	e1a0100a 	mov	r1, sl
34806c04:	e3a02080 	mov	r2, #128	; 0x80
34806c08:	eb00563d 	bl	3481c504 <strncpy>

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
		ids_changed = 0;
	} else {
		ids_changed = 1;
34806c0c:	e3a05001 	mov	r5, #1
34806c10:	eaffff77 	b	348069f4 <mtdparts_init+0x358>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34806c14:	e59f5020 	ldr	r5, [pc, #32]	; 34806c3c <mtdparts_init+0x5a0>
	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
34806c18:	e5952004 	ldr	r2, [r5, #4]
34806c1c:	e2853004 	add	r3, r5, #4
34806c20:	e1520003 	cmp	r2, r3
34806c24:	1affffc2 	bne	34806b34 <mtdparts_init+0x498>
34806c28:	eaffffbe 	b	34806b28 <mtdparts_init+0x48c>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
34806c2c:	e5dd3004 	ldrb	r3, [sp, #4]
34806c30:	e3530000 	cmp	r3, #0
34806c34:	1affffcd 	bne	34806b70 <mtdparts_init+0x4d4>
34806c38:	eaffffdf 	b	34806bbc <mtdparts_init+0x520>
34806c3c:	34829d54 	.word	0x34829d54
34806c40:	34824a8e 	.word	0x34824a8e
34806c44:	34824804 	.word	0x34824804
34806c48:	34824e4f 	.word	0x34824e4f
34806c4c:	34824a75 	.word	0x34824a75
34806c50:	34824a95 	.word	0x34824a95
34806c54:	34824aad 	.word	0x34824aad
34806c58:	34824add 	.word	0x34824add
34806c5c:	34824af7 	.word	0x34824af7
34806c60:	34824b14 	.word	0x34824b14
34806c64:	34829f74 	.word	0x34829f74
34806c68:	34824a89 	.word	0x34824a89
34806c6c:	34824a86 	.word	0x34824a86
34806c70:	348246b8 	.word	0x348246b8
34806c74:	34824b34 	.word	0x34824b34
34806c78:	348248eb 	.word	0x348248eb
34806c7c:	34824b6e 	.word	0x34824b6e
34806c80:	348247fa 	.word	0x348247fa
34806c84:	34824b90 	.word	0x34824b90
34806c88:	34824bc2 	.word	0x34824bc2
34806c8c:	34829d58 	.word	0x34829d58
34806c90:	34824bfb 	.word	0x34824bfb
34806c94:	34829f80 	.word	0x34829f80

34806c98 <do_mtdparts>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806c98:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	if (argc == 2) {
34806c9c:	e3520002 	cmp	r2, #2
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806ca0:	e24dd060 	sub	sp, sp, #96	; 0x60
34806ca4:	e1a05002 	mov	r5, r2
34806ca8:	e1a04003 	mov	r4, r3
	if (argc == 2) {
34806cac:	1a00001b 	bne	34806d20 <do_mtdparts+0x88>
		if (strcmp(argv[1], "default") == 0) {
34806cb0:	e5930004 	ldr	r0, [r3, #4]
34806cb4:	e59f157c 	ldr	r1, [pc, #1404]	; 34807238 <do_mtdparts+0x5a0>
34806cb8:	eb00563b 	bl	3481c5ac <strcmp>
34806cbc:	e2506000 	subs	r6, r0, #0
34806cc0:	1a00000b 	bne	34806cf4 <do_mtdparts+0x5c>
			setenv("mtdids", (char *)mtdids_default);
34806cc4:	e59f1570 	ldr	r1, [pc, #1392]	; 3480723c <do_mtdparts+0x5a4>
34806cc8:	e59f0570 	ldr	r0, [pc, #1392]	; 34807240 <do_mtdparts+0x5a8>
34806ccc:	eb0003c3 	bl	34807be0 <setenv>
			setenv("mtdparts", (char *)mtdparts_default);
34806cd0:	e59f156c 	ldr	r1, [pc, #1388]	; 34807244 <do_mtdparts+0x5ac>
34806cd4:	e59f056c 	ldr	r0, [pc, #1388]	; 34807248 <do_mtdparts+0x5b0>
34806cd8:	eb0003c0 	bl	34807be0 <setenv>
			setenv("partition", NULL);
34806cdc:	e1a01006 	mov	r1, r6
34806ce0:	e59f0564 	ldr	r0, [pc, #1380]	; 3480724c <do_mtdparts+0x5b4>
34806ce4:	eb0003bd 	bl	34807be0 <setenv>

			mtdparts_init();
34806ce8:	ebfffe6b 	bl	3480669c <mtdparts_init>
			return 0;
34806cec:	e1a00006 	mov	r0, r6
34806cf0:	ea00014e 	b	34807230 <do_mtdparts+0x598>
		} else if (strcmp(argv[1], "delall") == 0) {
34806cf4:	e5940004 	ldr	r0, [r4, #4]
34806cf8:	e59f1550 	ldr	r1, [pc, #1360]	; 34807250 <do_mtdparts+0x5b8>
34806cfc:	eb00562a 	bl	3481c5ac <strcmp>
34806d00:	e2506000 	subs	r6, r0, #0
34806d04:	1a000005 	bne	34806d20 <do_mtdparts+0x88>
			/* this may be the first run, initialize lists if needed */
			mtdparts_init();
34806d08:	ebfffe63 	bl	3480669c <mtdparts_init>

			setenv("mtdparts", NULL);
34806d0c:	e1a01006 	mov	r1, r6
34806d10:	e59f0530 	ldr	r0, [pc, #1328]	; 34807248 <do_mtdparts+0x5b0>
34806d14:	eb0003b1 	bl	34807be0 <setenv>

			/* mtd_devices_init() calls current_save() */
			return mtd_devices_init();
34806d18:	ebfffb7e 	bl	34805b18 <mtd_devices_init>
34806d1c:	ea000143 	b	34807230 <do_mtdparts+0x598>
		}
	}

	/* make sure we are in sync with env variables */
	if (mtdparts_init() != 0)
34806d20:	ebfffe5d 	bl	3480669c <mtdparts_init>
34806d24:	e3500000 	cmp	r0, #0
34806d28:	1a00013d 	bne	34807224 <do_mtdparts+0x58c>
		return 1;

	if (argc == 1) {
34806d2c:	e3550001 	cmp	r5, #1
34806d30:	1a00005b 	bne	34806ea4 <do_mtdparts+0x20c>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806d34:	e59fa518 	ldr	sl, [pc, #1304]	; 34807254 <do_mtdparts+0x5bc>
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806d38:	e59f9518 	ldr	r9, [pc, #1304]	; 34807258 <do_mtdparts+0x5c0>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806d3c:	e5ba4004 	ldr	r4, [sl, #4]!
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806d40:	e59fb514 	ldr	fp, [pc, #1300]	; 3480725c <do_mtdparts+0x5c4>
34806d44:	ea000021 	b	34806dd0 <do_mtdparts+0x138>
34806d48:	e5943008 	ldr	r3, [r4, #8]
34806d4c:	e5d31008 	ldrb	r1, [r3, #8]
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806d50:	e3510002 	cmp	r1, #2
34806d54:	059f1504 	ldreq	r1, [pc, #1284]	; 34807260 <do_mtdparts+0x5c8>
34806d58:	0a000002 	beq	34806d68 <do_mtdparts+0xd0>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806d5c:	e3510004 	cmp	r1, #4
34806d60:	11a01009 	movne	r1, r9
34806d64:	01a0100b 	moveq	r1, fp
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806d68:	e1d400bc 	ldrh	r0, [r4, #12]
34806d6c:	e5d32009 	ldrb	r2, [r3, #9]
34806d70:	e58d0000 	str	r0, [sp]
34806d74:	e5933010 	ldr	r3, [r3, #16]
34806d78:	e59f04e4 	ldr	r0, [pc, #1252]	; 34807264 <do_mtdparts+0x5cc>
34806d7c:	eb000b8d 	bl	34809bb8 <printf>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806d80:	e1a06004 	mov	r6, r4
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");
34806d84:	e59f04dc 	ldr	r0, [pc, #1244]	; 34807268 <do_mtdparts+0x5d0>
34806d88:	eb000b8a 	bl	34809bb8 <printf>
	int part_num;

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);
		/* list partitions for given device */
		part_num = 0;
34806d8c:	e3a07000 	mov	r7, #0
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806d90:	e5b65010 	ldr	r5, [r6, #16]!
34806d94:	ea00000a 	b	34806dc4 <do_mtdparts+0x12c>
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
34806d98:	e5953014 	ldr	r3, [r5, #20]
34806d9c:	e1a01007 	mov	r1, r7
34806da0:	e58d3000 	str	r3, [sp]
34806da4:	e595301c 	ldr	r3, [r5, #28]
34806da8:	e59f04bc 	ldr	r0, [pc, #1212]	; 3480726c <do_mtdparts+0x5d4>
34806dac:	e58d3004 	str	r3, [sp, #4]
34806db0:	e5952008 	ldr	r2, [r5, #8]
34806db4:	e5953010 	ldr	r3, [r5, #16]
34806db8:	eb000b7e 	bl	34809bb8 <printf>
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806dbc:	e5955000 	ldr	r5, [r5]
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					part->offset, part->mask_flags);
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
34806dc0:	e2877001 	add	r7, r7, #1
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806dc4:	e1550006 	cmp	r5, r6
34806dc8:	1afffff2 	bne	34806d98 <do_mtdparts+0x100>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806dcc:	e5944000 	ldr	r4, [r4]
34806dd0:	e154000a 	cmp	r4, sl
34806dd4:	1affffdb 	bne	34806d48 <do_mtdparts+0xb0>
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
		}
	}

	if (list_empty(&devices))
34806dd8:	e59f3474 	ldr	r3, [pc, #1140]	; 34807254 <do_mtdparts+0x5bc>
34806ddc:	e5933004 	ldr	r3, [r3, #4]
34806de0:	e1530004 	cmp	r3, r4
34806de4:	1a000001 	bne	34806df0 <do_mtdparts+0x158>
		printf("no partitions defined\n");
34806de8:	e59f0480 	ldr	r0, [pc, #1152]	; 34807270 <do_mtdparts+0x5d8>
34806dec:	eb000b71 	bl	34809bb8 <printf>

	debug("\n---list_partitions---\n");
	print_partition_table();

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
34806df0:	e59f445c 	ldr	r4, [pc, #1116]	; 34807254 <do_mtdparts+0x5bc>
34806df4:	e5940000 	ldr	r0, [r4]
34806df8:	e3500000 	cmp	r0, #0
34806dfc:	0a00001b 	beq	34806e70 <do_mtdparts+0x1d8>
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34806e00:	e5d4100c 	ldrb	r1, [r4, #12]
34806e04:	ebfff973 	bl	348053d8 <mtd_part_info>
		if (part) {
34806e08:	e3500000 	cmp	r0, #0
34806e0c:	0a000015 	beq	34806e68 <do_mtdparts+0x1d0>
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806e10:	e5943000 	ldr	r3, [r4]
34806e14:	e5933008 	ldr	r3, [r3, #8]
34806e18:	e5d32008 	ldrb	r2, [r3, #8]

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806e1c:	e3520002 	cmp	r2, #2
34806e20:	059f1438 	ldreq	r1, [pc, #1080]	; 34807260 <do_mtdparts+0x5c8>
34806e24:	0a000003 	beq	34806e38 <do_mtdparts+0x1a0>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806e28:	e59fc428 	ldr	ip, [pc, #1064]	; 34807258 <do_mtdparts+0x5c0>
34806e2c:	e3520004 	cmp	r2, #4
34806e30:	e59f1424 	ldr	r1, [pc, #1060]	; 3480725c <do_mtdparts+0x5c4>
34806e34:	11a0100c 	movne	r1, ip

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806e38:	e5d32009 	ldrb	r2, [r3, #9]
34806e3c:	e590c008 	ldr	ip, [r0, #8]
34806e40:	e59f340c 	ldr	r3, [pc, #1036]	; 34807254 <do_mtdparts+0x5bc>
34806e44:	e5d3300c 	ldrb	r3, [r3, #12]
34806e48:	e58dc000 	str	ip, [sp]
34806e4c:	e590c010 	ldr	ip, [r0, #16]
34806e50:	e58dc004 	str	ip, [sp, #4]
34806e54:	e5900014 	ldr	r0, [r0, #20]
34806e58:	e58d0008 	str	r0, [sp, #8]
34806e5c:	e59f0410 	ldr	r0, [pc, #1040]	; 34807274 <do_mtdparts+0x5dc>
34806e60:	eb000b54 	bl	34809bb8 <printf>
34806e64:	ea000001 	b	34806e70 <do_mtdparts+0x1d8>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
					current_mtd_dev->id->num, current_mtd_partnum,
					part->name, part->size, part->offset);
		} else {
			printf("could not get current partition info\n\n");
34806e68:	e59f0408 	ldr	r0, [pc, #1032]	; 34807278 <do_mtdparts+0x5e0>
34806e6c:	eb000b51 	bl	34809bb8 <printf>
		}
	}

	printf("\ndefaults:\n");
34806e70:	e59f0404 	ldr	r0, [pc, #1028]	; 3480727c <do_mtdparts+0x5e4>
34806e74:	eb000b4f 	bl	34809bb8 <printf>
	printf("mtdids  : %s\n",
34806e78:	e59f13bc 	ldr	r1, [pc, #956]	; 3480723c <do_mtdparts+0x5a4>
34806e7c:	e59f03fc 	ldr	r0, [pc, #1020]	; 34807280 <do_mtdparts+0x5e8>
34806e80:	eb000b4c 	bl	34809bb8 <printf>
	/*
	 * Using printf() here results in printbuffer overflow
	 * if default mtdparts string is greater than console
	 * printbuffer. Use puts() to prevent system crashes.
	 */
	puts("mtdparts: ");
34806e84:	e59f03f8 	ldr	r0, [pc, #1016]	; 34807284 <do_mtdparts+0x5ec>
34806e88:	eb000b40 	bl	34809b90 <puts>
	puts(mtdparts_default ? mtdparts_default : "none");
34806e8c:	e59f03b0 	ldr	r0, [pc, #944]	; 34807244 <do_mtdparts+0x5ac>
34806e90:	eb000b3e 	bl	34809b90 <puts>
	puts("\n");
34806e94:	e59f03ec 	ldr	r0, [pc, #1004]	; 34807288 <do_mtdparts+0x5f0>
34806e98:	eb000b3c 	bl	34809b90 <puts>
	if (mtdparts_init() != 0)
		return 1;

	if (argc == 1) {
		list_partitions();
		return 0;
34806e9c:	e3a00000 	mov	r0, #0
34806ea0:	ea0000e2 	b	34807230 <do_mtdparts+0x598>
	}

	/* mtdparts add <mtd-dev> <size>[@<offset>] <name> [ro] */
	if (((argc == 5) || (argc == 6)) && (strncmp(argv[1], "add", 3) == 0)) {
34806ea4:	e2453005 	sub	r3, r5, #5
34806ea8:	e3530001 	cmp	r3, #1
34806eac:	8a000090 	bhi	348070f4 <do_mtdparts+0x45c>
34806eb0:	e59f13d4 	ldr	r1, [pc, #980]	; 3480728c <do_mtdparts+0x5f4>
34806eb4:	e5940004 	ldr	r0, [r4, #4]
34806eb8:	e3a02003 	mov	r2, #3
34806ebc:	eb0055c6 	bl	3481c5dc <strncmp>
34806ec0:	e2501000 	subs	r1, r0, #0
34806ec4:	1a0000d8 	bne	3480722c <do_mtdparts+0x594>
		struct mtd_device *dev;
		struct mtd_device *dev_tmp;
		struct mtdids *id;
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
34806ec8:	e5940008 	ldr	r0, [r4, #8]
34806ecc:	e28d2054 	add	r2, sp, #84	; 0x54
34806ed0:	e28d305f 	add	r3, sp, #95	; 0x5f
34806ed4:	ebfffd3e 	bl	348063d4 <mtd_id_parse>
34806ed8:	e3500000 	cmp	r0, #0
34806edc:	1a0000d0 	bne	34807224 <do_mtdparts+0x58c>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806ee0:	e59f336c 	ldr	r3, [pc, #876]	; 34807254 <do_mtdparts+0x5bc>
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
34806ee4:	e5dd1054 	ldrb	r1, [sp, #84]	; 0x54
34806ee8:	e5dd205f 	ldrb	r2, [sp, #95]	; 0x5f
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806eec:	e5b35220 	ldr	r5, [r3, #544]!	; 0x220
34806ef0:	ea000006 	b	34806f10 <do_mtdparts+0x278>
		id = list_entry(entry, struct mtdids, link);

		if ((id->type == type) && (id->num == num))
34806ef4:	e5d50008 	ldrb	r0, [r5, #8]
34806ef8:	e1500001 	cmp	r0, r1
34806efc:	1a000002 	bne	34806f0c <do_mtdparts+0x274>
34806f00:	e5d50009 	ldrb	r0, [r5, #9]
34806f04:	e1500002 	cmp	r0, r2
34806f08:	0a000003 	beq	34806f1c <do_mtdparts+0x284>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806f0c:	e5955000 	ldr	r5, [r5]
34806f10:	e1550003 	cmp	r5, r3
34806f14:	1afffff6 	bne	34806ef4 <do_mtdparts+0x25c>
34806f18:	ea00000f 	b	34806f5c <do_mtdparts+0x2c4>
		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
34806f1c:	e5950010 	ldr	r0, [r5, #16]
34806f20:	eb0055d5 	bl	3481c67c <strlen>
34806f24:	e1a07000 	mov	r7, r0
		len += strlen(argv[3]);		/* size@offset */
34806f28:	e594000c 	ldr	r0, [r4, #12]
34806f2c:	eb0055d2 	bl	3481c67c <strlen>
34806f30:	e1a06000 	mov	r6, r0
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806f34:	e5940010 	ldr	r0, [r4, #16]
34806f38:	eb0055cf 	bl	3481c67c <strlen>
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
34806f3c:	e0876006 	add	r6, r7, r6
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806f40:	e2866003 	add	r6, r6, #3
34806f44:	e6e06076 	uxtab	r6, r0, r6
		if (argv[5] && (strlen(argv[5]) == 2))
34806f48:	e5940014 	ldr	r0, [r4, #20]
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806f4c:	e6ef6076 	uxtb	r6, r6
		if (argv[5] && (strlen(argv[5]) == 2))
34806f50:	e3500000 	cmp	r0, #0
34806f54:	1a000003 	bne	34806f68 <do_mtdparts+0x2d0>
34806f58:	ea000006 	b	34806f78 <do_mtdparts+0x2e0>

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
34806f5c:	e59f032c 	ldr	r0, [pc, #812]	; 34807290 <do_mtdparts+0x5f8>
34806f60:	e5941008 	ldr	r1, [r4, #8]
34806f64:	ea0000ad 	b	34807220 <do_mtdparts+0x588>
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
34806f68:	eb0055c3 	bl	3481c67c <strlen>
34806f6c:	e3500002 	cmp	r0, #2
			len += 2;		/* 'ro' */
34806f70:	02866002 	addeq	r6, r6, #2
34806f74:	06ef6076 	uxtbeq	r6, r6

		if (len >= PART_ADD_DESC_MAXLEN) {
34806f78:	e356003f 	cmp	r6, #63	; 0x3f
			printf("too long partition description\n");
34806f7c:	859f0310 	ldrhi	r0, [pc, #784]	; 34807294 <do_mtdparts+0x5fc>
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
			len += 2;		/* 'ro' */

		if (len >= PART_ADD_DESC_MAXLEN) {
34806f80:	8a0000a2 	bhi	34807210 <do_mtdparts+0x578>
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
34806f84:	e5941014 	ldr	r1, [r4, #20]

		if (len >= PART_ADD_DESC_MAXLEN) {
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
34806f88:	e59fc308 	ldr	ip, [pc, #776]	; 34807298 <do_mtdparts+0x600>
34806f8c:	e5940010 	ldr	r0, [r4, #16]
34806f90:	e3510000 	cmp	r1, #0
34806f94:	e594300c 	ldr	r3, [r4, #12]
34806f98:	01a0100c 	moveq	r1, ip
34806f9c:	e28d4014 	add	r4, sp, #20
34806fa0:	e5952010 	ldr	r2, [r5, #16]
34806fa4:	e88d0003 	stm	sp, {r0, r1}
34806fa8:	e1a00004 	mov	r0, r4
34806fac:	e59f12e8 	ldr	r1, [pc, #744]	; 3480729c <do_mtdparts+0x604>
34806fb0:	eb0059ea 	bl	3481d760 <sprintf>
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
34806fb4:	e1a00004 	mov	r0, r4
34806fb8:	e3a01000 	mov	r1, #0
34806fbc:	e28d2058 	add	r2, sp, #88	; 0x58
34806fc0:	ebfffbad 	bl	34805e7c <device_parse>
34806fc4:	e3500000 	cmp	r0, #0
34806fc8:	1a000095 	bne	34807224 <do_mtdparts+0x58c>
34806fcc:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
34806fd0:	e3550000 	cmp	r5, #0
34806fd4:	0a000092 	beq	34807224 <do_mtdparts+0x58c>
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806fd8:	e5953008 	ldr	r3, [r5, #8]
			return 1;

		debug("+ %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		p = list_entry(dev->parts.next, struct part_info, link);
34806fdc:	e5954010 	ldr	r4, [r5, #16]
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806fe0:	e5d30008 	ldrb	r0, [r3, #8]
34806fe4:	e5d31009 	ldrb	r1, [r3, #9]
34806fe8:	ebfffb90 	bl	34805e30 <device_find>
		if (dev_tmp == NULL) {
34806fec:	e2506000 	subs	r6, r0, #0
34806ff0:	1a00000e 	bne	34807030 <do_mtdparts+0x398>
34806ff4:	e59f3258 	ldr	r3, [pc, #600]	; 34807254 <do_mtdparts+0x5bc>
 */
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
34806ff8:	e5931004 	ldr	r1, [r3, #4]
34806ffc:	e2832004 	add	r2, r3, #4
34807000:	e1510002 	cmp	r1, r2
		current_mtd_dev = dev;
		current_mtd_partnum = 0;
34807004:	05c3600c 	strbeq	r6, [r3, #12]
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
		current_mtd_dev = dev;
34807008:	05835000 	streq	r5, [r3]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480700c:	e59f3240 	ldr	r3, [pc, #576]	; 34807254 <do_mtdparts+0x5bc>
		current_mtd_partnum = 0;
		current_save_needed = 1;
34807010:	03a06001 	moveq	r6, #1
34807014:	e5932008 	ldr	r2, [r3, #8]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34807018:	e5835008 	str	r5, [r3, #8]
	new->next = next;
3480701c:	e2833004 	add	r3, r3, #4
34807020:	e5853000 	str	r3, [r5]
	new->prev = prev;
34807024:	e5852004 	str	r2, [r5, #4]
	prev->next = new;
34807028:	e5825000 	str	r5, [r2]
3480702c:	ea00006e 	b	348071ec <do_mtdparts+0x554>
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34807030:	e5943010 	ldr	r3, [r4, #16]
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
34807034:	e596c008 	ldr	ip, [r6, #8]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34807038:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
3480703c:	059c200c 	ldreq	r2, [ip, #12]
34807040:	05943014 	ldreq	r3, [r4, #20]
34807044:	00633002 	rsbeq	r3, r3, r2
34807048:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
3480704c:	e5942014 	ldr	r2, [r4, #20]
34807050:	e59c300c 	ldr	r3, [ip, #12]
34807054:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
34807058:	859f0240 	ldrhi	r0, [pc, #576]	; 348072a0 <do_mtdparts+0x608>
3480705c:	859c1010 	ldrhi	r1, [ip, #16]
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
		part->size = id->size - part->offset;

	if (part->offset > id->size) {
34807060:	8a00000e 	bhi	348070a0 <do_mtdparts+0x408>
		printf("%s: offset %08x beyond flash size %08x\n",
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
34807064:	e5941010 	ldr	r1, [r4, #16]
34807068:	e0821001 	add	r1, r2, r1
3480706c:	e1510002 	cmp	r1, r2
34807070:	8a00000c 	bhi	348070a8 <do_mtdparts+0x410>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
34807074:	e5dc3008 	ldrb	r3, [ip, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34807078:	e3530002 	cmp	r3, #2
3480707c:	059f11dc 	ldreq	r1, [pc, #476]	; 34807260 <do_mtdparts+0x5c8>
34807080:	0a000003 	beq	34807094 <do_mtdparts+0x3fc>
				MTD_DEV_TYPE(id->type), id->num, part->name);
34807084:	e59f21d0 	ldr	r2, [pc, #464]	; 3480725c <do_mtdparts+0x5c4>
34807088:	e3530004 	cmp	r3, #4
3480708c:	e59f11c4 	ldr	r1, [pc, #452]	; 34807258 <do_mtdparts+0x5c0>
34807090:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34807094:	e59f0208 	ldr	r0, [pc, #520]	; 348072a4 <do_mtdparts+0x60c>
34807098:	e5dc2009 	ldrb	r2, [ip, #9]
3480709c:	e5943008 	ldr	r3, [r4, #8]
348070a0:	eb000ac4 	bl	34809bb8 <printf>
348070a4:	ea00000f 	b	348070e8 <do_mtdparts+0x450>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
348070a8:	e1510003 	cmp	r1, r3
348070ac:	9a000003 	bls	348070c0 <do_mtdparts+0x428>
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
348070b0:	e59c1010 	ldr	r1, [ip, #16]
348070b4:	e59f01ec 	ldr	r0, [pc, #492]	; 348072a8 <do_mtdparts+0x610>
348070b8:	eb000abe 	bl	34809bb8 <printf>
348070bc:	ea000009 	b	348070e8 <do_mtdparts+0x450>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
348070c0:	e1a0000c 	mov	r0, ip
348070c4:	e1a01004 	mov	r1, r4
348070c8:	ebfffa09 	bl	348058f4 <part_validate_eraseblock>
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
348070cc:	e3500000 	cmp	r0, #0
348070d0:	1a000004 	bne	348070e8 <do_mtdparts+0x450>
		return 1;

	/* partition is ok, add it to the list */
	if (part_sort_add(dev, part) != 0)
348070d4:	e1a00006 	mov	r0, r6
348070d8:	e1a01004 	mov	r1, r4
348070dc:	ebfff952 	bl	3480562c <part_sort_add>
348070e0:	e3500000 	cmp	r0, #0
348070e4:	0a000045 	beq	34807200 <do_mtdparts+0x568>
		dev_tmp = device_find(dev->id->type, dev->id->num);
		if (dev_tmp == NULL) {
			device_add(dev);
		} else if (part_add(dev_tmp, p) != 0) {
			/* merge new partition with existing ones*/
			device_del(dev);
348070e8:	e59d0058 	ldr	r0, [sp, #88]	; 0x58
348070ec:	ebfff9aa 	bl	3480579c <device_del>
348070f0:	ea00004b 	b	34807224 <do_mtdparts+0x58c>

		return 0;
	}

	/* mtdparts del part-id */
	if ((argc == 3) && (strcmp(argv[1], "del") == 0)) {
348070f4:	e3550003 	cmp	r5, #3
348070f8:	1a00004b 	bne	3480722c <do_mtdparts+0x594>
348070fc:	e5940004 	ldr	r0, [r4, #4]
34807100:	e59f11a4 	ldr	r1, [pc, #420]	; 348072ac <do_mtdparts+0x614>
34807104:	eb005528 	bl	3481c5ac <strcmp>
34807108:	e3500000 	cmp	r0, #0
3480710c:	1a000046 	bne	3480722c <do_mtdparts+0x594>
		debug("del: part-id = %s\n", argv[2]);

		return delete_partition(argv[2]);
34807110:	e5944008 	ldr	r4, [r4, #8]
{
	u8 pnum;
	struct mtd_device *dev;
	struct part_info *part;

	if (find_dev_and_part(id, &dev, &pnum, &part) == 0) {
34807114:	e28d1058 	add	r1, sp, #88	; 0x58
34807118:	e1a00004 	mov	r0, r4
3480711c:	e28d205f 	add	r2, sp, #95	; 0x5f
34807120:	e28d3054 	add	r3, sp, #84	; 0x54
34807124:	ebfffcee 	bl	348064e4 <find_dev_and_part>
34807128:	e2506000 	subs	r6, r0, #0
3480712c:	1a000039 	bne	34807218 <do_mtdparts+0x580>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
34807130:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
34807134:	e59d4054 	ldr	r4, [sp, #84]	; 0x54
static int part_del(struct mtd_device *dev, struct part_info *part)
{
	u8 current_save_needed = 0;

	/* if there is only one partition, remove whole device */
	if (dev->num_parts == 1)
34807138:	e1d570bc 	ldrh	r7, [r5, #12]
3480713c:	e3570001 	cmp	r7, #1
34807140:	1a000005 	bne	3480715c <do_mtdparts+0x4c4>
		return device_del(dev);
34807144:	e1a00005 	mov	r0, r5
34807148:	ebfff993 	bl	3480579c <device_del>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
3480714c:	e3500000 	cmp	r0, #0
			return 1;
34807150:	11a00007 	movne	r0, r7

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
34807154:	1a000035 	bne	34807230 <do_mtdparts+0x598>
34807158:	ea000028 	b	34807200 <do_mtdparts+0x568>
	if (dev->num_parts == 1)
		return device_del(dev);

	/* otherwise just delete this partition */

	if (dev == current_mtd_dev) {
3480715c:	e59f30f0 	ldr	r3, [pc, #240]	; 34807254 <do_mtdparts+0x5bc>
34807160:	e5932000 	ldr	r2, [r3]
34807164:	e1550002 	cmp	r5, r2
34807168:	1a000014 	bne	348071c0 <do_mtdparts+0x528>
		/* we are modyfing partitions for the current device,
		 * update current */
		struct part_info *curr_pi;
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
3480716c:	e1a00005 	mov	r0, r5
34807170:	e5d3100c 	ldrb	r1, [r3, #12]
34807174:	ebfff897 	bl	348053d8 <mtd_part_info>

		if (curr_pi) {
34807178:	e2506000 	subs	r6, r0, #0
3480717c:	0a00000f 	beq	348071c0 <do_mtdparts+0x528>
			if (curr_pi == part) {
34807180:	e1560004 	cmp	r6, r4
34807184:	1a000004 	bne	3480719c <do_mtdparts+0x504>
				printf("current partition deleted, resetting current to 0\n");
34807188:	e59f0120 	ldr	r0, [pc, #288]	; 348072b0 <do_mtdparts+0x618>
3480718c:	eb000a89 	bl	34809bb8 <printf>
				current_mtd_partnum = 0;
34807190:	e3a02000 	mov	r2, #0
34807194:	e59f30b8 	ldr	r3, [pc, #184]	; 34807254 <do_mtdparts+0x5bc>
34807198:	ea000006 	b	348071b8 <do_mtdparts+0x520>
			} else if (part->offset <= curr_pi->offset) {
3480719c:	e5942014 	ldr	r2, [r4, #20]
348071a0:	e5963014 	ldr	r3, [r6, #20]
348071a4:	e1520003 	cmp	r2, r3
348071a8:	8a000003 	bhi	348071bc <do_mtdparts+0x524>
				current_mtd_partnum--;
348071ac:	e59f30a0 	ldr	r3, [pc, #160]	; 34807254 <do_mtdparts+0x5bc>
348071b0:	e5d3200c 	ldrb	r2, [r3, #12]
348071b4:	e2422001 	sub	r2, r2, #1
348071b8:	e5c3200c 	strb	r2, [r3, #12]
			}
			current_save_needed = 1;
348071bc:	e3a06001 	mov	r6, #1
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348071c0:	e894000c 	ldm	r4, {r2, r3}
		}
	}

	list_del(&part->link);
	free(part);
348071c4:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348071c8:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348071cc:	e5832000 	str	r2, [r3]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348071d0:	e3a03000 	mov	r3, #0
348071d4:	e5843000 	str	r3, [r4]
	entry->prev = LIST_POISON2;
348071d8:	e5843004 	str	r3, [r4, #4]
348071dc:	eb000bb3 	bl	3480a0b0 <free>
	dev->num_parts--;
348071e0:	e1d530bc 	ldrh	r3, [r5, #12]
348071e4:	e2433001 	sub	r3, r3, #1
348071e8:	e1c530bc 	strh	r3, [r5, #12]

	if (current_save_needed > 0)
348071ec:	e3560000 	cmp	r6, #0
348071f0:	0a000001 	beq	348071fc <do_mtdparts+0x564>
		current_save();
348071f4:	ebfff8e0 	bl	3480557c <current_save>
348071f8:	ea000000 	b	34807200 <do_mtdparts+0x568>
	else
		index_partitions();
348071fc:	ebfff89a 	bl	3480546c <index_partitions>
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
			return 1;

		if (generate_mtdparts_save(last_parts, MTDPARTS_MAXLEN) != 0) {
34807200:	ebfffa4d 	bl	34805b3c <generate_mtdparts_save.clone.1>
34807204:	e3500000 	cmp	r0, #0
34807208:	0a000008 	beq	34807230 <do_mtdparts+0x598>
			printf("generated mtdparts too long, reseting to null\n");
3480720c:	e59f00a0 	ldr	r0, [pc, #160]	; 348072b4 <do_mtdparts+0x61c>
34807210:	eb000a68 	bl	34809bb8 <printf>
34807214:	ea000002 	b	34807224 <do_mtdparts+0x58c>
			return 1;
		}
		return 0;
	}

	printf("partition %s not found\n", id);
34807218:	e59f0098 	ldr	r0, [pc, #152]	; 348072b8 <do_mtdparts+0x620>
3480721c:	e1a01004 	mov	r1, r4
34807220:	eb000a64 	bl	34809bb8 <printf>
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
			return 1;
34807224:	e3a00001 	mov	r0, #1
34807228:	ea000000 	b	34807230 <do_mtdparts+0x598>
#if defined(CONFIG_CMD_MTDPARTS_SPREAD)
	if ((argc == 2) && (strcmp(argv[1], "spread") == 0))
		return spread_partitions();
#endif /* CONFIG_CMD_MTDPARTS_SPREAD */

	return CMD_RET_USAGE;
3480722c:	e3e00000 	mvn	r0, #0
}
34807230:	e28dd060 	add	sp, sp, #96	; 0x60
34807234:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807238:	34824c1f 	.word	0x34824c1f
3480723c:	34824a75 	.word	0x34824a75
34807240:	34824a8e 	.word	0x34824a8e
34807244:	348204a8 	.word	0x348204a8
34807248:	34824804 	.word	0x34824804
3480724c:	34824e4f 	.word	0x34824e4f
34807250:	34824c27 	.word	0x34824c27
34807254:	34829d54 	.word	0x34829d54
34807258:	348246b8 	.word	0x348246b8
3480725c:	34824a86 	.word	0x34824a86
34807260:	34824a89 	.word	0x34824a89
34807264:	34824c2e 	.word	0x34824c2e
34807268:	34824c4f 	.word	0x34824c4f
3480726c:	34824c73 	.word	0x34824c73
34807270:	34824c8f 	.word	0x34824c8f
34807274:	34824ca6 	.word	0x34824ca6
34807278:	34824cd9 	.word	0x34824cd9
3480727c:	34824d00 	.word	0x34824d00
34807280:	34824d0c 	.word	0x34824d0c
34807284:	34824d1a 	.word	0x34824d1a
34807288:	348264dd 	.word	0x348264dd
3480728c:	34824d25 	.word	0x34824d25
34807290:	34824d29 	.word	0x34824d29
34807294:	34824d57 	.word	0x34824d57
34807298:	34824003 	.word	0x34824003
3480729c:	34824d77 	.word	0x34824d77
348072a0:	3482490a 	.word	0x3482490a
348072a4:	34824932 	.word	0x34824932
348072a8:	34824955 	.word	0x34824955
348072ac:	34824db2 	.word	0x34824db2
348072b0:	34824db6 	.word	0x34824db6
348072b4:	34824d83 	.word	0x34824d83
348072b8:	34824de9 	.word	0x34824de9

348072bc <do_chpart>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_chpart(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348072bc:	e92d4030 	push	{r4, r5, lr}
348072c0:	e24dd014 	sub	sp, sp, #20
348072c4:	e1a04002 	mov	r4, r2
348072c8:	e1a05003 	mov	r5, r3
/* command line only */
	struct mtd_device *dev;
	struct part_info *part;
	u8 pnum;

	if (mtdparts_init() !=0)
348072cc:	ebfffcf2 	bl	3480669c <mtdparts_init>
348072d0:	e3500000 	cmp	r0, #0
348072d4:	1a000021 	bne	34807360 <do_chpart+0xa4>
		return 1;

	if (argc < 2) {
348072d8:	e3540001 	cmp	r4, #1
348072dc:	ca000002 	bgt	348072ec <do_chpart+0x30>
		printf("no partition id specified\n");
348072e0:	e59f0084 	ldr	r0, [pc, #132]	; 3480736c <do_chpart+0xb0>
348072e4:	eb000a33 	bl	34809bb8 <printf>
348072e8:	ea00001c 	b	34807360 <do_chpart+0xa4>
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
348072ec:	e5950004 	ldr	r0, [r5, #4]
348072f0:	e28d1008 	add	r1, sp, #8
348072f4:	e28d200f 	add	r2, sp, #15
348072f8:	e28d3004 	add	r3, sp, #4
348072fc:	ebfffc78 	bl	348064e4 <find_dev_and_part>
34807300:	e3500000 	cmp	r0, #0
34807304:	1a000015 	bne	34807360 <do_chpart+0xa4>
		return 1;

	current_mtd_dev = dev;
34807308:	e59f3060 	ldr	r3, [pc, #96]	; 34807370 <do_chpart+0xb4>
3480730c:	e59d2008 	ldr	r2, [sp, #8]
34807310:	e5832000 	str	r2, [r3]
	current_mtd_partnum = pnum;
34807314:	e5dd200f 	ldrb	r2, [sp, #15]
34807318:	e5c3200c 	strb	r2, [r3, #12]
	current_save();
3480731c:	ebfff896 	bl	3480557c <current_save>

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
34807320:	e59d3008 	ldr	r3, [sp, #8]
34807324:	e5933008 	ldr	r3, [r3, #8]
34807328:	e5d32008 	ldrb	r2, [r3, #8]

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
3480732c:	e3520002 	cmp	r2, #2
34807330:	059f103c 	ldreq	r1, [pc, #60]	; 34807374 <do_chpart+0xb8>
34807334:	0a000003 	beq	34807348 <do_chpart+0x8c>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
34807338:	e59f0038 	ldr	r0, [pc, #56]	; 34807378 <do_chpart+0xbc>
3480733c:	e3520004 	cmp	r2, #4
34807340:	e59f1034 	ldr	r1, [pc, #52]	; 3480737c <do_chpart+0xc0>
34807344:	11a01000 	movne	r1, r0

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
34807348:	e5d32009 	ldrb	r2, [r3, #9]
3480734c:	e59f002c 	ldr	r0, [pc, #44]	; 34807380 <do_chpart+0xc4>
34807350:	e5dd300f 	ldrb	r3, [sp, #15]
34807354:	eb000a17 	bl	34809bb8 <printf>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
34807358:	e3a00000 	mov	r0, #0
3480735c:	ea000000 	b	34807364 <do_chpart+0xa8>
		printf("no partition id specified\n");
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
		return 1;
34807360:	e3a00001 	mov	r0, #1

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
}
34807364:	e28dd014 	add	sp, sp, #20
34807368:	e8bd8030 	pop	{r4, r5, pc}
3480736c:	34824e01 	.word	0x34824e01
34807370:	34829d54 	.word	0x34829d54
34807374:	34824a89 	.word	0x34824a89
34807378:	348246b8 	.word	0x348246b8
3480737c:	34824a86 	.word	0x34824a86
34807380:	34824e1c 	.word	0x34824e1c

34807384 <do_env>:

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
34807384:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
}
#endif

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807388:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480738c:	e1a05000 	mov	r5, r0
34807390:	e1a06001 	mov	r6, r1
34807394:	e1a04002 	mov	r4, r2
	cmd_tbl_t *cp;

	if (argc < 2)
		return CMD_RET_USAGE;
34807398:	d3e00000 	mvnle	r0, #0

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
3480739c:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}

	/* drop initial "env" arg */
	argc--;
	argv++;

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
348073a0:	e5930004 	ldr	r0, [r3, #4]
348073a4:	e59f1034 	ldr	r1, [pc, #52]	; 348073e0 <do_env+0x5c>
348073a8:	e3a02008 	mov	r2, #8
	if (argc < 2)
		return CMD_RET_USAGE;

	/* drop initial "env" arg */
	argc--;
	argv++;
348073ac:	e2837004 	add	r7, r3, #4

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
348073b0:	eb000878 	bl	34809598 <find_cmd_tbl>

	if (cp)
348073b4:	e3500000 	cmp	r0, #0
348073b8:	0a000006 	beq	348073d8 <do_env+0x54>
		return cp->cmd(cmdtp, flag, argc, argv);
348073bc:	e590c00c 	ldr	ip, [r0, #12]
348073c0:	e1a01006 	mov	r1, r6
348073c4:	e1a00005 	mov	r0, r5
348073c8:	e2442001 	sub	r2, r4, #1
348073cc:	e1a03007 	mov	r3, r7
348073d0:	e12fff3c 	blx	ip
348073d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

	return CMD_RET_USAGE;
348073d8:	e3e00000 	mvn	r0, #0
}
348073dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348073e0:	348286bc 	.word	0x348286bc

348073e4 <do_env_delete>:
	return cmd_usage(cmdtp);
}

static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
348073e4:	e92d4008 	push	{r3, lr}
	printf("Not implemented yet\n");
348073e8:	e59f0008 	ldr	r0, [pc, #8]	; 348073f8 <do_env_delete+0x14>
348073ec:	eb0009f1 	bl	34809bb8 <printf>
	return 0;
}
348073f0:	e3a00000 	mov	r0, #0
348073f4:	e8bd8008 	pop	{r3, pc}
348073f8:	34825388 	.word	0x34825388

348073fc <do_env_import>:
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
348073fc:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
34807400:	e3a0a000 	mov	sl, #0
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807404:	e1a04002 	mov	r4, r2
34807408:	e24dd01c 	sub	sp, sp, #28
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
	size_t	size;

	cmd = *argv;
3480740c:	e4931004 	ldr	r1, [r3], #4
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
34807410:	e1a0200a 	mov	r2, sl
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
34807414:	e1a0900a 	mov	r9, sl
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
34807418:	e3a0700a 	mov	r7, #10
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
3480741c:	ea00001d 	b	34807498 <do_env_import+0x9c>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
34807420:	e3500063 	cmp	r0, #99	; 0x63
34807424:	0a00000c 	beq	3480745c <do_env_import+0x60>
34807428:	8a000002 	bhi	34807438 <do_env_import+0x3c>
3480742c:	e3500062 	cmp	r0, #98	; 0x62
34807430:	1a000077 	bne	34807614 <do_env_import+0x218>
34807434:	ea000004 	b	3480744c <do_env_import+0x50>
34807438:	e3500064 	cmp	r0, #100	; 0x64
3480743c:	0a000011 	beq	34807488 <do_env_import+0x8c>
34807440:	e3500074 	cmp	r0, #116	; 0x74
34807444:	1a000072 	bne	34807614 <do_env_import+0x218>
34807448:	ea000009 	b	34807474 <do_env_import+0x78>
			case 'b':		/* raw binary format */
				if (fmt++)
3480744c:	e3520000 	cmp	r2, #0
34807450:	1a00006b 	bne	34807604 <do_env_import+0x208>
34807454:	e2822001 	add	r2, r2, #1
34807458:	ea000003 	b	3480746c <do_env_import+0x70>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
3480745c:	e3520000 	cmp	r2, #0
34807460:	1a000067 	bne	34807604 <do_env_import+0x208>
34807464:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\0';
				chk = 1;
34807468:	e1a09002 	mov	r9, r2
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
3480746c:	e3a07000 	mov	r7, #0
34807470:	ea000005 	b	3480748c <do_env_import+0x90>
				chk = 1;
				break;
			case 't':		/* text format */
				if (fmt++)
34807474:	e3520000 	cmp	r2, #0
34807478:	1a000061 	bne	34807604 <do_env_import+0x208>
3480747c:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\n';
34807480:	e3a0700a 	mov	r7, #10
34807484:	ea000000 	b	3480748c <do_env_import+0x90>
				break;
			case 'd':
				del = 1;
34807488:	e3a0a001 	mov	sl, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
3480748c:	e5fc0001 	ldrb	r0, [ip, #1]!
34807490:	e3500000 	cmp	r0, #0
34807494:	1affffe1 	bne	34807420 <do_env_import+0x24>
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807498:	e2444001 	sub	r4, r4, #1
3480749c:	e3540000 	cmp	r4, #0
348074a0:	da00005b 	ble	34807614 <do_env_import+0x218>
348074a4:	e1a05003 	mov	r5, r3
348074a8:	e493c004 	ldr	ip, [r3], #4
348074ac:	e5dc0000 	ldrb	r0, [ip]
348074b0:	e350002d 	cmp	r0, #45	; 0x2d
348074b4:	0afffff4 	beq	3480748c <do_env_import+0x90>
348074b8:	ea000058 	b	34807620 <do_env_import+0x224>

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");
348074bc:	e59f0168 	ldr	r0, [pc, #360]	; 3480762c <do_env_import+0x230>
348074c0:	eb0009bc 	bl	34809bb8 <printf>

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348074c4:	e3a02010 	mov	r2, #16
348074c8:	e5950000 	ldr	r0, [r5]
348074cc:	e3a01000 	mov	r1, #0
348074d0:	eb0057fc 	bl	3481d4c8 <simple_strtoul>

	if (argc == 2) {
348074d4:	e3540002 	cmp	r4, #2
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348074d8:	e1a06000 	mov	r6, r0

	if (argc == 2) {
348074dc:	11a02000 	movne	r2, r0
348074e0:	13a03000 	movne	r3, #0
348074e4:	1a000006 	bne	34807504 <do_env_import+0x108>
		size = simple_strtoul(argv[1], NULL, 16);
348074e8:	e5950004 	ldr	r0, [r5, #4]
348074ec:	e3a01000 	mov	r1, #0
348074f0:	e3a02010 	mov	r2, #16
348074f4:	eb0057f3 	bl	3481d4c8 <simple_strtoul>
348074f8:	e1a05000 	mov	r5, r0
348074fc:	ea000013 	b	34807550 <do_env_import+0x154>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34807500:	e1a03005 	mov	r3, r5
			if ((*s == sep) && (*(s+1) == '\0'))
34807504:	e4d21001 	ldrb	r1, [r2], #1
34807508:	e2835001 	add	r5, r3, #1
3480750c:	e1510007 	cmp	r1, r7
34807510:	1a000002 	bne	34807520 <do_env_import+0x124>
34807514:	e7d61005 	ldrb	r1, [r6, r5]
34807518:	e3510000 	cmp	r1, #0
3480751c:	0a000005 	beq	34807538 <do_env_import+0x13c>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34807520:	e3550601 	cmp	r5, #1048576	; 0x100000
34807524:	1afffff5 	bne	34807500 <do_env_import+0x104>
				break;
			++s;
			++size;
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
34807528:	e1a01005 	mov	r1, r5
3480752c:	e59f00fc 	ldr	r0, [pc, #252]	; 34807630 <do_env_import+0x234>
34807530:	eb0009a0 	bl	34809bb8 <printf>
34807534:	ea000000 	b	3480753c <do_env_import+0x140>
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
			if ((*s == sep) && (*(s+1) == '\0'))
34807538:	e1a05003 	mov	r5, r3
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
				" - truncated\n", MAX_ENV_SIZE);
		}
		size += 2;
3480753c:	e2855002 	add	r5, r5, #2
		printf("## Info: input data size = %zu = 0x%zX\n", size, size);
34807540:	e59f00ec 	ldr	r0, [pc, #236]	; 34807634 <do_env_import+0x238>
34807544:	e1a01005 	mov	r1, r5
34807548:	e1a02005 	mov	r2, r5
3480754c:	eb000999 	bl	34809bb8 <printf>
	}

	if (chk) {
34807550:	e3590000 	cmp	r9, #0
34807554:	0a00000f 	beq	34807598 <do_env_import+0x19c>
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
34807558:	e1a01006 	mov	r1, r6
3480755c:	e3a02004 	mov	r2, #4

	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
34807560:	e2455004 	sub	r5, r5, #4
		memcpy(&crc, &ep->crc, sizeof(crc));
34807564:	e28d0014 	add	r0, sp, #20

		if (crc32(0, ep->data, size) != crc) {
34807568:	e2866004 	add	r6, r6, #4
	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
3480756c:	eb005506 	bl	3481c98c <memcpy>

		if (crc32(0, ep->data, size) != crc) {
34807570:	e3a00000 	mov	r0, #0
34807574:	e1a01006 	mov	r1, r6
34807578:	e1a02005 	mov	r2, r5
3480757c:	eb004d80 	bl	3481ab84 <crc32>
34807580:	e59d3014 	ldr	r3, [sp, #20]
34807584:	e1500003 	cmp	r0, r3
34807588:	0a000002 	beq	34807598 <do_env_import+0x19c>
			puts("## Error: bad CRC, import failed\n");
3480758c:	e59f00a4 	ldr	r0, [pc, #164]	; 34807638 <do_env_import+0x23c>
34807590:	eb00097e 	bl	34809b90 <puts>
34807594:	ea00001c 	b	3480760c <do_env_import+0x210>
			return 1;
		}
		addr = (char *)ep->data;
	}

	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
34807598:	e3a04000 	mov	r4, #0
3480759c:	e22aa001 	eor	sl, sl, #1
348075a0:	e59f0094 	ldr	r0, [pc, #148]	; 3480763c <do_env_import+0x240>
348075a4:	e1a01006 	mov	r1, r6
348075a8:	e1a02005 	mov	r2, r5
348075ac:	e1a03007 	mov	r3, r7
348075b0:	e58da000 	str	sl, [sp]
348075b4:	e58d4004 	str	r4, [sp, #4]
348075b8:	e58d4008 	str	r4, [sp, #8]
348075bc:	e58d400c 	str	r4, [sp, #12]
348075c0:	eb005132 	bl	3481ba90 <himport_r>
348075c4:	e1500004 	cmp	r0, r4
348075c8:	1a000008 	bne	348075f0 <do_env_import+0x1f4>
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
348075cc:	e59f306c 	ldr	r3, [pc, #108]	; 34807640 <do_env_import+0x244>
348075d0:	e59f206c 	ldr	r2, [pc, #108]	; 34807644 <do_env_import+0x248>
348075d4:	e58d3000 	str	r3, [sp]
348075d8:	e59f3068 	ldr	r3, [pc, #104]	; 34807648 <do_env_import+0x24c>
348075dc:	e59f0068 	ldr	r0, [pc, #104]	; 3480764c <do_env_import+0x250>
348075e0:	e5931000 	ldr	r1, [r3]
348075e4:	e30033bd 	movw	r3, #957	; 0x3bd
348075e8:	eb000972 	bl	34809bb8 <printf>
348075ec:	ea000006 	b	3480760c <do_env_import+0x210>
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
348075f0:	e5982004 	ldr	r2, [r8, #4]

	return 0;
348075f4:	e1a00004 	mov	r0, r4
	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
348075f8:	e3822080 	orr	r2, r2, #128	; 0x80
348075fc:	e5882004 	str	r2, [r8, #4]

	return 0;
34807600:	ea000004 	b	34807618 <do_env_import+0x21c>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
34807604:	e59f0044 	ldr	r0, [pc, #68]	; 34807650 <do_env_import+0x254>
34807608:	eb00096a 	bl	34809bb8 <printf>
		cmd);
	return 1;
3480760c:	e3a00001 	mov	r0, #1
34807610:	ea000000 	b	34807618 <do_env_import+0x21c>
			}
		}
	}

	if (argc < 1)
		return CMD_RET_USAGE;
34807614:	e3e00000 	mvn	r0, #0

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
		cmd);
	return 1;
}
34807618:	e28dd01c 	add	sp, sp, #28
3480761c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
34807620:	e3520000 	cmp	r2, #0
34807624:	1affffa6 	bne	348074c4 <do_env_import+0xc8>
34807628:	eaffffa3 	b	348074bc <do_env_import+0xc0>
3480762c:	3482539d 	.word	0x3482539d
34807630:	348253c4 	.word	0x348253c4
34807634:	348253f9 	.word	0x348253f9
34807638:	34825421 	.word	0x34825421
3480763c:	34828c70 	.word	0x34828c70
34807640:	34820524 	.word	0x34820524
34807644:	34825480 	.word	0x34825480
34807648:	3482bee8 	.word	0x3482bee8
3480764c:	34825443 	.word	0x34825443
34807650:	3482548d 	.word	0x3482548d

34807654 <do_env_default>:
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
			  int argc, char * const argv[])
{
34807654:	e92d4070 	push	{r4, r5, r6, lr}
	int all = 0, flag = 0;
34807658:	e3a0c000 	mov	ip, #0

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
3480765c:	ea000009 	b	34807688 <do_env_default+0x34>
		char *arg = *argv;

		while (*++arg) {
			switch (*arg) {
34807660:	e3530061 	cmp	r3, #97	; 0x61
34807664:	0a000002 	beq	34807674 <do_env_default+0x20>
34807668:	e3530066 	cmp	r3, #102	; 0x66
3480766c:	1a000021 	bne	348076f8 <do_env_default+0xa4>
34807670:	ea000000 	b	34807678 <do_env_default+0x24>
			case 'a':		/* default all */
				all = 1;
34807674:	e3a0c001 	mov	ip, #1

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;

		while (*++arg) {
34807678:	e5f13001 	ldrb	r3, [r1, #1]!
3480767c:	e3530000 	cmp	r3, #0
34807680:	1afffff6 	bne	34807660 <do_env_default+0xc>
34807684:	e1a03004 	mov	r3, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34807688:	e2422001 	sub	r2, r2, #1
3480768c:	e3520000 	cmp	r2, #0
		char *arg = *argv;

		while (*++arg) {
34807690:	e1a01003 	mov	r1, r3
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34807694:	da000006 	ble	348076b4 <do_env_default+0x60>

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
34807698:	e2834004 	add	r4, r3, #4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
3480769c:	e5933004 	ldr	r3, [r3, #4]

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
348076a0:	e1a01004 	mov	r1, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
348076a4:	e5d35000 	ldrb	r5, [r3]
348076a8:	e355002d 	cmp	r5, #45	; 0x2d
348076ac:	01a01003 	moveq	r1, r3
348076b0:	0afffff0 	beq	34807678 <do_env_default+0x24>
				return cmd_usage(cmdtp);
			}
		}
	}
	debug("Final value for argc=%d\n", argc);
	if (all && (argc == 0)) {
348076b4:	e3520000 	cmp	r2, #0
348076b8:	13a03000 	movne	r3, #0
348076bc:	020c3001 	andeq	r3, ip, #1
348076c0:	e3530000 	cmp	r3, #0
348076c4:	0a000002 	beq	348076d4 <do_env_default+0x80>
		/* Reset the whole environment */
		set_default_env("## Resetting to default environment\n");
348076c8:	e59f0038 	ldr	r0, [pc, #56]	; 34807708 <do_env_default+0xb4>
348076cc:	eb000e50 	bl	3480b014 <set_default_env>
		return 0;
348076d0:	ea00000a 	b	34807700 <do_env_default+0xac>
	}
	if (!all && (argc > 0)) {
348076d4:	e22cc001 	eor	ip, ip, #1
348076d8:	e3520000 	cmp	r2, #0
348076dc:	d3a0c000 	movle	ip, #0
348076e0:	c20cc001 	andgt	ip, ip, #1
348076e4:	e35c0000 	cmp	ip, #0
348076e8:	0a000002 	beq	348076f8 <do_env_default+0xa4>
		/* Reset individual variables */
		set_default_vars(argc, argv);
348076ec:	e1a00002 	mov	r0, r2
348076f0:	eb000e76 	bl	3480b0d0 <set_default_vars>
		return 0;
348076f4:	ea000001 	b	34807700 <do_env_default+0xac>
	}

	return cmd_usage(cmdtp);
}
348076f8:	e8bd4070 	pop	{r4, r5, r6, lr}
		/* Reset individual variables */
		set_default_vars(argc, argv);
		return 0;
	}

	return cmd_usage(cmdtp);
348076fc:	ea0007d6 	b	3480965c <cmd_usage>
}
34807700:	e3a00000 	mov	r0, #0
34807704:	e8bd8070 	pop	{r4, r5, r6, pc}
34807708:	348254bc 	.word	0x348254bc

3480770c <env_print>:
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
3480770c:	e92d4010 	push	{r4, lr}
	char *res = NULL;
34807710:	e3a02000 	mov	r2, #0
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
34807714:	e24dd018 	sub	sp, sp, #24
	char *res = NULL;
	size_t len;

	if (name) {		/* print a single name */
34807718:	e2503000 	subs	r3, r0, #0
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
	char *res = NULL;
3480771c:	e58d2014 	str	r2, [sp, #20]
	size_t len;

	if (name) {		/* print a single name */
34807720:	0a000010 	beq	34807768 <env_print+0x5c>
		ENTRY e, *ep;

		e.key = name;
34807724:	e58d3008 	str	r3, [sp, #8]
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
34807728:	e59f3074 	ldr	r3, [pc, #116]	; 348077a4 <env_print+0x98>

	if (name) {		/* print a single name */
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
3480772c:	e58d200c 	str	r2, [sp, #12]
		hsearch_r(e, FIND, &ep, &env_htab);
34807730:	e58d3000 	str	r3, [sp]
34807734:	e28d3008 	add	r3, sp, #8
34807738:	e8930003 	ldm	r3, {r0, r1}
3480773c:	e28d3010 	add	r3, sp, #16
34807740:	eb004f41 	bl	3481b44c <hsearch_r>
		if (ep == NULL)
34807744:	e59d3010 	ldr	r3, [sp, #16]
34807748:	e3530000 	cmp	r3, #0
			return 0;
3480774c:	01a04003 	moveq	r4, r3
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
		if (ep == NULL)
34807750:	0a000010 	beq	34807798 <env_print+0x8c>
			return 0;
		len = printf("%s=%s\n", ep->key, ep->data);
34807754:	e59f004c 	ldr	r0, [pc, #76]	; 348077a8 <env_print+0x9c>
34807758:	e8930006 	ldm	r3, {r1, r2}
3480775c:	eb000915 	bl	34809bb8 <printf>
34807760:	e1a04000 	mov	r4, r0
		return len;
34807764:	ea00000b 	b	34807798 <env_print+0x8c>
	}

	/* print whole list */
	len = hexport_r(&env_htab, '\n', &res, 0, 0, NULL);
34807768:	e59f0034 	ldr	r0, [pc, #52]	; 348077a4 <env_print+0x98>
3480776c:	e3a0100a 	mov	r1, #10
34807770:	e28d2014 	add	r2, sp, #20
34807774:	e58d3000 	str	r3, [sp]
34807778:	e58d3004 	str	r3, [sp, #4]
3480777c:	eb005018 	bl	3481b7e4 <hexport_r>

	if (len > 0) {
34807780:	e2504000 	subs	r4, r0, #0
34807784:	0a000003 	beq	34807798 <env_print+0x8c>
		puts(res);
34807788:	e59d0014 	ldr	r0, [sp, #20]
3480778c:	eb0008ff 	bl	34809b90 <puts>
		free(res);
34807790:	e59d0014 	ldr	r0, [sp, #20]
34807794:	eb000a45 	bl	3480a0b0 <free>
		return len;
	}

	/* should never happen */
	return 0;
}
34807798:	e1a00004 	mov	r0, r4
3480779c:	e28dd018 	add	sp, sp, #24
348077a0:	e8bd8010 	pop	{r4, pc}
348077a4:	34828c70 	.word	0x34828c70
348077a8:	348254e1 	.word	0x348254e1

348077ac <do_env_print>:
int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {
348077ac:	e3520001 	cmp	r2, #1
	/* should never happen */
	return 0;
}

int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348077b0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348077b4:	e1a04002 	mov	r4, r2
	int i;
	int rcode = 0;

	if (argc == 1) {
348077b8:	11a07003 	movne	r7, r3
348077bc:	13a05000 	movne	r5, #0
348077c0:	13a06001 	movne	r6, #1
348077c4:	1a000012 	bne	34807814 <do_env_print+0x68>
		/* print all env vars */
		rcode = env_print(NULL);
348077c8:	e3a00000 	mov	r0, #0
348077cc:	ebffffce 	bl	3480770c <env_print>
		if (!rcode)
348077d0:	e2501000 	subs	r1, r0, #0
			return 1;
348077d4:	01a05004 	moveq	r5, r4
	int rcode = 0;

	if (argc == 1) {
		/* print all env vars */
		rcode = env_print(NULL);
		if (!rcode)
348077d8:	0a00000f 	beq	3480781c <do_env_print+0x70>
			return 1;
		printf("\nEnvironment size: %d/%ld bytes\n",
348077dc:	e59f0040 	ldr	r0, [pc, #64]	; 34807824 <do_env_print+0x78>
348077e0:	e59f2040 	ldr	r2, [pc, #64]	; 34807828 <do_env_print+0x7c>
348077e4:	eb0008f3 	bl	34809bb8 <printf>
			rcode, (ulong)ENV_SIZE);
		return 0;
348077e8:	e3a05000 	mov	r5, #0
348077ec:	ea00000a 	b	3480781c <do_env_print+0x70>
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
		int rc = env_print(argv[i]);
348077f0:	e5b70004 	ldr	r0, [r7, #4]!
348077f4:	ebffffc4 	bl	3480770c <env_print>
		if (!rc) {
348077f8:	e3500000 	cmp	r0, #0
348077fc:	1a000003 	bne	34807810 <do_env_print+0x64>
			printf("## Error: \"%s\" not defined\n", argv[i]);
34807800:	e59f0024 	ldr	r0, [pc, #36]	; 3480782c <do_env_print+0x80>
34807804:	e5971000 	ldr	r1, [r7]
34807808:	eb0008ea 	bl	34809bb8 <printf>
			++rcode;
3480780c:	e2855001 	add	r5, r5, #1
			rcode, (ulong)ENV_SIZE);
		return 0;
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
34807810:	e2866001 	add	r6, r6, #1
34807814:	e1560004 	cmp	r6, r4
34807818:	bafffff4 	blt	348077f0 <do_env_print+0x44>
			++rcode;
		}
	}

	return rcode;
}
3480781c:	e1a00005 	mov	r0, r5
34807820:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34807824:	348254e8 	.word	0x348254e8
34807828:	0003fffc 	.word	0x0003fffc
3480782c:	34825509 	.word	0x34825509

34807830 <get_env_id>:
static int env_id = 1;

int get_env_id(void)
{
	return env_id;
}
34807830:	e59f3004 	ldr	r3, [pc, #4]	; 3480783c <get_env_id+0xc>
34807834:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
34807838:	e12fff1e 	bx	lr
3480783c:	348286bc 	.word	0x348286bc

34807840 <env_check_apply>:
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807840:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34807844:	e3520000 	cmp	r2, #0
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807848:	e1a05001 	mov	r5, r1

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
3480784c:	e59f118c 	ldr	r1, [pc, #396]	; 348079e0 <env_check_apply+0x1a0>
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807850:	e1a04000 	mov	r4, r0
34807854:	e1a07003 	mov	r7, r3
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34807858:	e59f6184 	ldr	r6, [pc, #388]	; 348079e4 <env_check_apply+0x1a4>
3480785c:	11a06002 	movne	r6, r2

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
34807860:	eb005351 	bl	3481c5ac <strcmp>
34807864:	e3500000 	cmp	r0, #0
34807868:	0a00000b 	beq	3480789c <env_check_apply+0x5c>
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
3480786c:	e1a00004 	mov	r0, r4
34807870:	e59f1170 	ldr	r1, [pc, #368]	; 348079e8 <env_check_apply+0x1a8>
34807874:	eb00534c 	bl	3481c5ac <strcmp>
34807878:	e3500000 	cmp	r0, #0
		console = stdout;
3480787c:	03a00001 	moveq	r0, #1
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
34807880:	0a000005 	beq	3480789c <env_check_apply+0x5c>
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
34807884:	e1a00004 	mov	r0, r4
34807888:	e59f115c 	ldr	r1, [pc, #348]	; 348079ec <env_check_apply+0x1ac>
3480788c:	eb005346 	bl	3481c5ac <strcmp>
34807890:	e3500000 	cmp	r0, #0
		console = stderr;
34807894:	02800002 	addeq	r0, r0, #2
	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
34807898:	1a00000f 	bne	348078dc <env_check_apply+0x9c>
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
3480789c:	e5d63000 	ldrb	r3, [r6]
348078a0:	e3530000 	cmp	r3, #0
348078a4:	1a000004 	bne	348078bc <env_check_apply+0x7c>
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
348078a8:	e3170002 	tst	r7, #2
				printf("Can't delete \"%s\"\n", name);
348078ac:	059f013c 	ldreq	r0, [pc, #316]	; 348079f0 <env_check_apply+0x1b0>
348078b0:	01a01004 	moveq	r1, r4
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
348078b4:	1a000047 	bne	348079d8 <env_check_apply+0x198>
348078b8:	ea000025 	b	34807954 <env_check_apply+0x114>
#ifdef CONFIG_CONSOLE_MUX
		if (iomux_doenv(console, newval))
			return 1;
#else
		/* Try assigning specified device */
		if (console_assign(console, newval) < 0)
348078bc:	e1a01006 	mov	r1, r6
348078c0:	eb000910 	bl	34809d08 <console_assign>
348078c4:	e3500000 	cmp	r0, #0
348078c8:	ba000042 	blt	348079d8 <env_check_apply+0x198>
			return 1;

#ifdef CONFIG_SERIAL_MULTI
		if (serial_assign(newval) < 0)
348078cc:	e1a00006 	mov	r0, r6
348078d0:	eb001dbf 	bl	3480efd4 <serial_assign>
348078d4:	e3500000 	cmp	r0, #0
348078d8:	ba00003e 	blt	348079d8 <env_check_apply+0x198>
	/*
	 * When we change baudrate, or we are doing an env default -a
	 * (which will erase all variables prior to calling this),
	 * we want the baudrate to actually change - for real.
	 */
	if (oldval != NULL ||			/* variable exists */
348078dc:	e3550000 	cmp	r5, #0
348078e0:	1a000001 	bne	348078ec <env_check_apply+0xac>
348078e4:	e3170001 	tst	r7, #1
348078e8:	1a000027 	bne	3480798c <env_check_apply+0x14c>
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
348078ec:	e59f1100 	ldr	r1, [pc, #256]	; 348079f4 <env_check_apply+0x1b4>
348078f0:	e1a00004 	mov	r0, r4
348078f4:	eb00532c 	bl	3481c5ac <strcmp>
348078f8:	e2501000 	subs	r1, r0, #0
348078fc:	1a000022 	bne	3480798c <env_check_apply+0x14c>
			int baudrate = simple_strtoul(newval, NULL, 10);
34807900:	e1a00006 	mov	r0, r6
34807904:	e3a0200a 	mov	r2, #10
34807908:	eb0056ee 	bl	3481d4c8 <simple_strtoul>
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
3480790c:	e3500d96 	cmp	r0, #9600	; 0x2580
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
			int baudrate = simple_strtoul(newval, NULL, 10);
34807910:	e1a05000 	mov	r5, r0
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
34807914:	0a000008 	beq	3480793c <env_check_apply+0xfc>
34807918:	e3500c4b 	cmp	r0, #19200	; 0x4b00
3480791c:	0a000006 	beq	3480793c <env_check_apply+0xfc>
34807920:	e3500c96 	cmp	r0, #38400	; 0x9600
34807924:	0a000004 	beq	3480793c <env_check_apply+0xfc>
34807928:	e3500ce1 	cmp	r0, #57600	; 0xe100
3480792c:	0a000002 	beq	3480793c <env_check_apply+0xfc>
34807930:	e59f30c0 	ldr	r3, [pc, #192]	; 348079f8 <env_check_apply+0x1b8>
34807934:	e1500003 	cmp	r0, r3
34807938:	1a000024 	bne	348079d0 <env_check_apply+0x190>
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
			}
			if (gd->baudrate == baudrate) {
3480793c:	e5983008 	ldr	r3, [r8, #8]
34807940:	e1530005 	cmp	r3, r5
34807944:	1a000004 	bne	3480795c <env_check_apply+0x11c>
34807948:	ea00001c 	b	348079c0 <env_check_apply+0x180>
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
3480794c:	e59f00a8 	ldr	r0, [pc, #168]	; 348079fc <env_check_apply+0x1bc>
34807950:	e1a01005 	mov	r1, r5
34807954:	eb000897 	bl	34809bb8 <printf>
34807958:	ea00001e 	b	348079d8 <env_check_apply+0x198>
			}
			if (gd->baudrate == baudrate) {
				/* If unchanged, we just say it's OK */
				return 0;
			}
			printf("## Switch baudrate to %d bps and"
3480795c:	e1a01005 	mov	r1, r5
34807960:	e59f0098 	ldr	r0, [pc, #152]	; 34807a00 <env_check_apply+0x1c0>
34807964:	eb000893 	bl	34809bb8 <printf>
				"press ENTER ...\n", baudrate);
			udelay(50000);
34807968:	e30c0350 	movw	r0, #50000	; 0xc350
3480796c:	eb005491 	bl	3481cbb8 <udelay>
			gd->baudrate = baudrate;
34807970:	e5885008 	str	r5, [r8, #8]
#if defined(CONFIG_PPC) || defined(CONFIG_MCF52x2)
			gd->bd->bi_baudrate = baudrate;
#endif

			serial_setbrg();
34807974:	eb001dcd 	bl	3480f0b0 <serial_setbrg>
			udelay(50000);
34807978:	e30c0350 	movw	r0, #50000	; 0xc350
3480797c:	eb00548d 	bl	3481cbb8 <udelay>
			while (getc() != '\r')
34807980:	eb000866 	bl	34809b20 <getc>
34807984:	e350000d 	cmp	r0, #13
34807988:	1afffffc 	bne	34807980 <env_check_apply+0x140>

	/*
	 * Some variables should be updated when the corresponding
	 * entry in the environment is changed
	 */
	if (strcmp(name, "loadaddr") == 0) {
3480798c:	e1a00004 	mov	r0, r4
34807990:	e59f106c 	ldr	r1, [pc, #108]	; 34807a04 <env_check_apply+0x1c4>
34807994:	eb005304 	bl	3481c5ac <strcmp>
34807998:	e2504000 	subs	r4, r0, #0
3480799c:	1a000009 	bne	348079c8 <env_check_apply+0x188>
		load_addr = simple_strtoul(newval, NULL, 16);
348079a0:	e1a00006 	mov	r0, r6
348079a4:	e1a01004 	mov	r1, r4
348079a8:	e3a02010 	mov	r2, #16
348079ac:	eb0056c5 	bl	3481d4c8 <simple_strtoul>
348079b0:	e59f3050 	ldr	r3, [pc, #80]	; 34807a08 <env_check_apply+0x1c8>
348079b4:	e58300c4 	str	r0, [r3, #196]	; 0xc4
		return 0;
348079b8:	e1a00004 	mov	r0, r4
348079bc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
						"supported\n", baudrate);
				return 1;
			}
			if (gd->baudrate == baudrate) {
				/* If unchanged, we just say it's OK */
				return 0;
348079c0:	e3a00000 	mov	r0, #0
348079c4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	else if (strcmp(name, "bootfile") == 0) {
		copy_filename(BootFile, newval, sizeof(BootFile));
		return 0;
	}
#endif
	return 0;
348079c8:	e3a00000 	mov	r0, #0
}
348079cc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
348079d0:	e3170002 	tst	r7, #2
348079d4:	0affffdc 	beq	3480794c <env_check_apply+0x10c>
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
348079d8:	e3a00001 	mov	r0, #1
348079dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348079e0:	34825525 	.word	0x34825525
348079e4:	34824003 	.word	0x34824003
348079e8:	3482552b 	.word	0x3482552b
348079ec:	34825532 	.word	0x34825532
348079f0:	34825539 	.word	0x34825539
348079f4:	34822ba8 	.word	0x34822ba8
348079f8:	0001c200 	.word	0x0001c200
348079fc:	3482554c 	.word	0x3482554c
34807a00:	3482556e 	.word	0x3482556e
34807a04:	34822bb9 	.word	0x34822bb9
34807a08:	348286bc 	.word	0x348286bc

34807a0c <_do_env_set>:
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807a0c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34807a10:	e5924004 	ldr	r4, [r2, #4]
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807a14:	e24dd01c 	sub	sp, sp, #28
34807a18:	e1a06001 	mov	r6, r1
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
34807a1c:	e1a00004 	mov	r0, r4
34807a20:	e3a0103d 	mov	r1, #61	; 0x3d
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807a24:	e1a05002 	mov	r5, r2
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34807a28:	e282a004 	add	sl, r2, #4
	value = argv[2];
34807a2c:	e5927008 	ldr	r7, [r2, #8]

	if (strchr(name, '=')) {
34807a30:	eb0052fb 	bl	3481c624 <strchr>
34807a34:	e2502000 	subs	r2, r0, #0
		printf("## Error: illegal character '='"
34807a38:	159f0168 	ldrne	r0, [pc, #360]	; 34807ba8 <_do_env_set+0x19c>
34807a3c:	11a01004 	movne	r1, r4
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
34807a40:	1a000032 	bne	34807b10 <_do_env_set+0x104>
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807a44:	e59f3160 	ldr	r3, [pc, #352]	; 34807bac <_do_env_set+0x1a0>
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
34807a48:	e58d2010 	str	r2, [sp, #16]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807a4c:	e59310c0 	ldr	r1, [r3, #192]	; 0xc0
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
34807a50:	e58d400c 	str	r4, [sp, #12]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807a54:	e2811001 	add	r1, r1, #1
34807a58:	e58310c0 	str	r1, [r3, #192]	; 0xc0
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
	hsearch_r(e, FIND, &ep, &env_htab);
34807a5c:	e59f314c 	ldr	r3, [pc, #332]	; 34807bb0 <_do_env_set+0x1a4>
34807a60:	e58d3000 	str	r3, [sp]
34807a64:	e28d300c 	add	r3, sp, #12
34807a68:	e8930003 	ldm	r3, {r0, r1}
34807a6c:	e28d3014 	add	r3, sp, #20
34807a70:	eb004e75 	bl	3481b44c <hsearch_r>

	/*
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
34807a74:	e59d1014 	ldr	r1, [sp, #20]
34807a78:	e1a02007 	mov	r2, r7
34807a7c:	e3510000 	cmp	r1, #0
34807a80:	15911004 	ldrne	r1, [r1, #4]
34807a84:	e1a00004 	mov	r0, r4
34807a88:	e3a03001 	mov	r3, #1
34807a8c:	ebffff6b 	bl	34807840 <env_check_apply>
34807a90:	e2507000 	subs	r7, r0, #0
34807a94:	1a000040 	bne	34807b9c <_do_env_set+0x190>
		debug("check function did not approve, refusing\n");
		return 1;
	}

	/* Delete only ? */
	if (argc < 3 || argv[2] == NULL) {
34807a98:	e3560002 	cmp	r6, #2
34807a9c:	da000004 	ble	34807ab4 <_do_env_set+0xa8>
34807aa0:	e5953008 	ldr	r3, [r5, #8]
34807aa4:	e3530000 	cmp	r3, #0
34807aa8:	11a0900a 	movne	r9, sl
34807aac:	13a05002 	movne	r5, #2
34807ab0:	1a000006 	bne	34807ad0 <_do_env_set+0xc4>
		int rc = hdelete_r(name, &env_htab, 0);
34807ab4:	e1a00004 	mov	r0, r4
34807ab8:	e59f10f0 	ldr	r1, [pc, #240]	; 34807bb0 <_do_env_set+0x1a4>
34807abc:	e3a02000 	mov	r2, #0
34807ac0:	eb004f1a 	bl	3481b730 <hdelete_r>
		return !rc;
34807ac4:	e2700001 	rsbs	r0, r0, #1
34807ac8:	33a00000 	movcc	r0, #0
34807acc:	ea000033 	b	34807ba0 <_do_env_set+0x194>

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;
34807ad0:	e5b90004 	ldr	r0, [r9, #4]!
34807ad4:	eb0052e8 	bl	3481c67c <strlen>
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807ad8:	e2855001 	add	r5, r5, #1
		len += strlen(argv[i]) + 1;
34807adc:	e2800001 	add	r0, r0, #1
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807ae0:	e1550006 	cmp	r5, r6
		len += strlen(argv[i]) + 1;
34807ae4:	e0807007 	add	r7, r0, r7
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807ae8:	bafffff8 	blt	34807ad0 <_do_env_set+0xc4>
		len += strlen(argv[i]) + 1;

	value = malloc(len);
34807aec:	e1a00007 	mov	r0, r7
34807af0:	eb0009f7 	bl	3480a2d4 <malloc>
	if (value == NULL) {
34807af4:	e2505000 	subs	r5, r0, #0
34807af8:	11a0c005 	movne	ip, r5
34807afc:	13a01002 	movne	r1, #2
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
34807b00:	13a07020 	movne	r7, #32
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;

	value = malloc(len);
	if (value == NULL) {
34807b04:	1a000003 	bne	34807b18 <_do_env_set+0x10c>
		printf("## Can't malloc %d bytes\n", len);
34807b08:	e59f00a4 	ldr	r0, [pc, #164]	; 34807bb4 <_do_env_set+0x1a8>
34807b0c:	e1a01007 	mov	r1, r7
34807b10:	eb000828 	bl	34809bb8 <printf>
34807b14:	ea000020 	b	34807b9c <_do_env_set+0x190>
		return 1;
34807b18:	e5bae004 	ldr	lr, [sl, #4]!
34807b1c:	e1a0300c 	mov	r3, ip
	}
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
34807b20:	e4de2001 	ldrb	r2, [lr], #1
34807b24:	e1a00003 	mov	r0, r3
34807b28:	e3520000 	cmp	r2, #0
34807b2c:	e4c32001 	strb	r2, [r3], #1
34807b30:	e1a0c003 	mov	ip, r3
34807b34:	1afffff9 	bne	34807b20 <_do_env_set+0x114>
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
34807b38:	e2811001 	add	r1, r1, #1
34807b3c:	e1510006 	cmp	r1, r6
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
34807b40:	e5c07000 	strb	r7, [r0]
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
34807b44:	1afffff3 	bne	34807b18 <_do_env_set+0x10c>

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
34807b48:	e1530005 	cmp	r3, r5
		*--s = '\0';

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
34807b4c:	e59f305c 	ldr	r3, [pc, #92]	; 34807bb0 <_do_env_set+0x1a4>
		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
		*--s = '\0';
34807b50:	15c02000 	strbne	r2, [r0]

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
34807b54:	e58d3000 	str	r3, [sp]
	}
	if (s != value)
		*--s = '\0';

	e.key	= name;
	e.data	= value;
34807b58:	e58d5010 	str	r5, [sp, #16]
	hsearch_r(e, ENTER, &ep, &env_htab);
34807b5c:	e28d300c 	add	r3, sp, #12
34807b60:	e8930003 	ldm	r3, {r0, r1}
34807b64:	e3a02001 	mov	r2, #1
34807b68:	e28d3014 	add	r3, sp, #20
34807b6c:	eb004e36 	bl	3481b44c <hsearch_r>
	free(value);
34807b70:	e1a00005 	mov	r0, r5
34807b74:	eb00094d 	bl	3480a0b0 <free>
	if (!ep) {
34807b78:	e59d3014 	ldr	r3, [sp, #20]
34807b7c:	e3530000 	cmp	r3, #0
		printf("## Error inserting \"%s\" variable, errno=%d\n",
			name, errno);
		return 1;
	}

	return 0;
34807b80:	13a00000 	movne	r0, #0

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
	free(value);
	if (!ep) {
34807b84:	1a000005 	bne	34807ba0 <_do_env_set+0x194>
		printf("## Error inserting \"%s\" variable, errno=%d\n",
34807b88:	e59f3028 	ldr	r3, [pc, #40]	; 34807bb8 <_do_env_set+0x1ac>
34807b8c:	e59f0028 	ldr	r0, [pc, #40]	; 34807bbc <_do_env_set+0x1b0>
34807b90:	e1a01004 	mov	r1, r4
34807b94:	e5932000 	ldr	r2, [r3]
34807b98:	eb000806 	bl	34809bb8 <printf>
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
		debug("check function did not approve, refusing\n");
		return 1;
34807b9c:	e3a00001 	mov	r0, #1
			name, errno);
		return 1;
	}

	return 0;
}
34807ba0:	e28dd01c 	add	sp, sp, #28
34807ba4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
34807ba8:	3482559f 	.word	0x3482559f
34807bac:	348286bc 	.word	0x348286bc
34807bb0:	34828c70 	.word	0x34828c70
34807bb4:	348255d5 	.word	0x348255d5
34807bb8:	3482bee8 	.word	0x3482bee8
34807bbc:	348255ef 	.word	0x348255ef

34807bc0 <do_env_set>:
}

#ifndef CONFIG_SPL_BUILD
int do_env_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
34807bc0:	e3520001 	cmp	r2, #1
34807bc4:	da000003 	ble	34807bd8 <do_env_set+0x18>
		return CMD_RET_USAGE;

	return _do_env_set(flag, argc, argv);
34807bc8:	e1a00001 	mov	r0, r1
34807bcc:	e1a01002 	mov	r1, r2
34807bd0:	e1a02003 	mov	r2, r3
34807bd4:	eaffff8c 	b	34807a0c <_do_env_set>
}
34807bd8:	e3e00000 	mvn	r0, #0
34807bdc:	e12fff1e 	bx	lr

34807be0 <setenv>:

	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
34807be0:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
34807be4:	e59f3040 	ldr	r3, [pc, #64]	; 34807c2c <setenv+0x4c>
34807be8:	e58d0004 	str	r0, [sp, #4]
34807bec:	e3a00000 	mov	r0, #0

	if (varvalue == NULL || varvalue[0] == '\0')
34807bf0:	e1510000 	cmp	r1, r0
	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
34807bf4:	e58d3000 	str	r3, [sp]
34807bf8:	e58d1008 	str	r1, [sp, #8]
34807bfc:	e58d000c 	str	r0, [sp, #12]

	if (varvalue == NULL || varvalue[0] == '\0')
34807c00:	0a000003 	beq	34807c14 <setenv+0x34>
34807c04:	e5d13000 	ldrb	r3, [r1]
34807c08:	e1530000 	cmp	r3, r0
		return _do_env_set(0, 2, (char * const *)argv);
	else
		return _do_env_set(0, 3, (char * const *)argv);
34807c0c:	13a01003 	movne	r1, #3

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };

	if (varvalue == NULL || varvalue[0] == '\0')
34807c10:	1a000001 	bne	34807c1c <setenv+0x3c>
		return _do_env_set(0, 2, (char * const *)argv);
34807c14:	e3a00000 	mov	r0, #0
34807c18:	e3a01002 	mov	r1, #2
	else
		return _do_env_set(0, 3, (char * const *)argv);
34807c1c:	e1a0200d 	mov	r2, sp
34807c20:	ebffff79 	bl	34807a0c <_do_env_set>
}
34807c24:	e28dd014 	add	sp, sp, #20
34807c28:	e8bd8000 	pop	{pc}
34807c2c:	3482561b 	.word	0x3482561b

34807c30 <do_env_export>:
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807c30:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
34807c34:	e3a0a000 	mov	sl, #0
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807c38:	e24dd038 	sub	sp, sp, #56	; 0x38
34807c3c:	e1a0c000 	mov	ip, r0
34807c40:	e1a04002 	mov	r4, r2
34807c44:	e1a05003 	mov	r5, r3
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;
34807c48:	e593b000 	ldr	fp, [r3]
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
34807c4c:	e1a0900a 	mov	r9, sl
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
34807c50:	e3a0600a 	mov	r6, #10
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
34807c54:	e1a0700a 	mov	r7, sl
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807c58:	ea000027 	b	34807cfc <do_env_export+0xcc>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
34807c5c:	e3520063 	cmp	r2, #99	; 0x63
34807c60:	0a00000b 	beq	34807c94 <do_env_export+0x64>
34807c64:	8a000002 	bhi	34807c74 <do_env_export+0x44>
34807c68:	e3520062 	cmp	r2, #98	; 0x62
34807c6c:	1a000072 	bne	34807e3c <do_env_export+0x20c>
34807c70:	ea000004 	b	34807c88 <do_env_export+0x58>
34807c74:	e3520073 	cmp	r2, #115	; 0x73
34807c78:	0a00000a 	beq	34807ca8 <do_env_export+0x78>
34807c7c:	e3520074 	cmp	r2, #116	; 0x74
34807c80:	1a00006d 	bne	34807e3c <do_env_export+0x20c>
34807c84:	ea000014 	b	34807cdc <do_env_export+0xac>
			case 'b':		/* raw binary format */
				if (fmt++)
34807c88:	e3530000 	cmp	r3, #0
34807c8c:	0a000003 	beq	34807ca0 <do_env_export+0x70>
34807c90:	ea000064 	b	34807e28 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
34807c94:	e3530000 	cmp	r3, #0
34807c98:	1a000062 	bne	34807e28 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				chk = 1;
34807c9c:	e3a09001 	mov	r9, #1
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
34807ca0:	e1a06003 	mov	r6, r3
34807ca4:	ea00000f 	b	34807ce8 <do_env_export+0xb8>
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
34807ca8:	e2544001 	subs	r4, r4, #1
34807cac:	1a000002 	bne	34807cbc <do_env_export+0x8c>
					return cmd_usage(cmdtp);
34807cb0:	e1a0000c 	mov	r0, ip
34807cb4:	eb000668 	bl	3480965c <cmd_usage>
34807cb8:	ea000060 	b	34807e40 <do_env_export+0x210>
				size = simple_strtoul(*++argv, NULL, 16);
34807cbc:	e5b50004 	ldr	r0, [r5, #4]!
34807cc0:	e3a01000 	mov	r1, #0
34807cc4:	e3a02010 	mov	r2, #16
34807cc8:	e58dc00c 	str	ip, [sp, #12]
34807ccc:	eb0055fd 	bl	3481d4c8 <simple_strtoul>
				goto NXTARG;
34807cd0:	e59dc00c 	ldr	ip, [sp, #12]
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
34807cd4:	e1a07000 	mov	r7, r0
				goto NXTARG;
34807cd8:	ea000007 	b	34807cfc <do_env_export+0xcc>
			case 't':		/* text format */
				if (fmt++)
34807cdc:	e3530000 	cmp	r3, #0
34807ce0:	1a000050 	bne	34807e28 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\n';
34807ce4:	e3a0600a 	mov	r6, #10
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
34807ce8:	e3a03001 	mov	r3, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34807cec:	e5f02001 	ldrb	r2, [r0, #1]!
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
34807cf0:	e1a0a003 	mov	sl, r3

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34807cf4:	e3520000 	cmp	r2, #0
34807cf8:	1affffd7 	bne	34807c5c <do_env_export+0x2c>
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807cfc:	e2444001 	sub	r4, r4, #1
34807d00:	e3540000 	cmp	r4, #0
34807d04:	da00004c 	ble	34807e3c <do_env_export+0x20c>
34807d08:	e5b50004 	ldr	r0, [r5, #4]!
34807d0c:	e5d03000 	ldrb	r3, [r0]
34807d10:	e353002d 	cmp	r3, #45	; 0x2d
34807d14:	1a00004b 	bne	34807e48 <do_env_export+0x218>
34807d18:	e1a0300a 	mov	r3, sl
34807d1c:	eafffff2 	b	34807cec <do_env_export+0xbc>
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);
34807d20:	e3a01000 	mov	r1, #0
34807d24:	e1a02007 	mov	r2, r7
34807d28:	eb0052f3 	bl	3481c8fc <memset>

	argc--;
	argv++;

	if (sep) {		/* export as text file */
34807d2c:	e3560000 	cmp	r6, #0
	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);

	argc--;
34807d30:	e2444001 	sub	r4, r4, #1
	argv++;
34807d34:	e2855004 	add	r5, r5, #4

	if (sep) {		/* export as text file */
34807d38:	0a000013 	beq	34807d8c <do_env_export+0x15c>
		len = hexport_r(&env_htab, sep, &addr, size, argc, argv);
34807d3c:	e28d2034 	add	r2, sp, #52	; 0x34
34807d40:	e59f011c 	ldr	r0, [pc, #284]	; 34807e64 <do_env_export+0x234>
34807d44:	e1a01006 	mov	r1, r6
34807d48:	e1a03007 	mov	r3, r7
34807d4c:	e88d0030 	stm	sp, {r4, r5}
34807d50:	eb004ea3 	bl	3481b7e4 <hexport_r>
		if (len < 0) {
34807d54:	e2502000 	subs	r2, r0, #0
34807d58:	aa000007 	bge	34807d7c <do_env_export+0x14c>
			error("Cannot export environment: errno = %d\n", errno);
34807d5c:	e59f3104 	ldr	r3, [pc, #260]	; 34807e68 <do_env_export+0x238>
34807d60:	e59f0104 	ldr	r0, [pc, #260]	; 34807e6c <do_env_export+0x23c>
34807d64:	e58d3000 	str	r3, [sp]
34807d68:	e59f3100 	ldr	r3, [pc, #256]	; 34807e70 <do_env_export+0x240>
34807d6c:	e59f2100 	ldr	r2, [pc, #256]	; 34807e74 <do_env_export+0x244>
34807d70:	e5931000 	ldr	r1, [r3]
34807d74:	e3003333 	movw	r3, #819	; 0x333
34807d78:	ea000017 	b	34807ddc <do_env_export+0x1ac>
			return 1;
		}
		sprintf(buf, "%zX", (size_t)len);
34807d7c:	e28d4010 	add	r4, sp, #16
34807d80:	e1a00004 	mov	r0, r4
34807d84:	e59f10ec 	ldr	r1, [pc, #236]	; 34807e78 <do_env_export+0x248>
34807d88:	ea000020 	b	34807e10 <do_env_export+0x1e0>
		setenv("filesize", buf);

		return 0;
	}

	envp = (env_t *)addr;
34807d8c:	e59d6034 	ldr	r6, [sp, #52]	; 0x34

	if (chk)		/* export as checksum protected block */
34807d90:	e3590000 	cmp	r9, #0
		res = (char *)envp->data;
34807d94:	12863004 	addne	r3, r6, #4
34807d98:	158d3030 	strne	r3, [sp, #48]	; 0x30
	else			/* export as raw binary data */
		res = addr;

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807d9c:	e59f00c0 	ldr	r0, [pc, #192]	; 34807e64 <do_env_export+0x234>
34807da0:	e3a01000 	mov	r1, #0
34807da4:	e28d2030 	add	r2, sp, #48	; 0x30
34807da8:	e59f30cc 	ldr	r3, [pc, #204]	; 34807e7c <do_env_export+0x24c>
	envp = (env_t *)addr;

	if (chk)		/* export as checksum protected block */
		res = (char *)envp->data;
	else			/* export as raw binary data */
		res = addr;
34807dac:	058d6030 	streq	r6, [sp, #48]	; 0x30

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807db0:	e88d0030 	stm	sp, {r4, r5}
34807db4:	eb004e8a 	bl	3481b7e4 <hexport_r>
	if (len < 0) {
34807db8:	e2505000 	subs	r5, r0, #0
34807dbc:	aa000008 	bge	34807de4 <do_env_export+0x1b4>
		error("Cannot export environment: errno = %d\n", errno);
34807dc0:	e59f30a0 	ldr	r3, [pc, #160]	; 34807e68 <do_env_export+0x238>
34807dc4:	e59f00a0 	ldr	r0, [pc, #160]	; 34807e6c <do_env_export+0x23c>
34807dc8:	e58d3000 	str	r3, [sp]
34807dcc:	e59f309c 	ldr	r3, [pc, #156]	; 34807e70 <do_env_export+0x240>
34807dd0:	e59f209c 	ldr	r2, [pc, #156]	; 34807e74 <do_env_export+0x244>
34807dd4:	e5931000 	ldr	r1, [r3]
34807dd8:	e3003345 	movw	r3, #837	; 0x345
34807ddc:	eb000775 	bl	34809bb8 <printf>
34807de0:	ea000013 	b	34807e34 <do_env_export+0x204>
		return 1;
	}

	if (chk) {
34807de4:	e3590000 	cmp	r9, #0
34807de8:	0a000004 	beq	34807e00 <do_env_export+0x1d0>
		envp->crc = crc32(0, envp->data, ENV_SIZE);
34807dec:	e3a00000 	mov	r0, #0
34807df0:	e2861004 	add	r1, r6, #4
34807df4:	e59f2080 	ldr	r2, [pc, #128]	; 34807e7c <do_env_export+0x24c>
34807df8:	eb004b61 	bl	3481ab84 <crc32>
34807dfc:	e5860000 	str	r0, [r6]
#ifdef CONFIG_ENV_ADDR_REDUND
		envp->flags = ACTIVE_FLAG;
#endif
	}
	sprintf(buf, "%zX", (size_t)(len + offsetof(env_t, data)));
34807e00:	e28d4010 	add	r4, sp, #16
34807e04:	e59f106c 	ldr	r1, [pc, #108]	; 34807e78 <do_env_export+0x248>
34807e08:	e1a00004 	mov	r0, r4
34807e0c:	e2852004 	add	r2, r5, #4
34807e10:	eb005652 	bl	3481d760 <sprintf>
	setenv("filesize", buf);
34807e14:	e59f0064 	ldr	r0, [pc, #100]	; 34807e80 <do_env_export+0x250>
34807e18:	e1a01004 	mov	r1, r4
34807e1c:	ebffff6f 	bl	34807be0 <setenv>

	return 0;
34807e20:	e3a00000 	mov	r0, #0
34807e24:	ea000005 	b	34807e40 <do_env_export+0x210>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
34807e28:	e59f0054 	ldr	r0, [pc, #84]	; 34807e84 <do_env_export+0x254>
34807e2c:	e1a0100b 	mov	r1, fp
34807e30:	eb000760 	bl	34809bb8 <printf>
	return 1;
34807e34:	e3a00001 	mov	r0, #1
34807e38:	ea000000 	b	34807e40 <do_env_export+0x210>
		}
NXTARG:		;
	}

	if (argc < 1)
		return CMD_RET_USAGE;
34807e3c:	e3e00000 	mvn	r0, #0
	return 0;

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
	return 1;
}
34807e40:	e28dd038 	add	sp, sp, #56	; 0x38
34807e44:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34807e48:	e3a01000 	mov	r1, #0
34807e4c:	e3a02010 	mov	r2, #16
34807e50:	eb00559c 	bl	3481d4c8 <simple_strtoul>

	if (size)
34807e54:	e3570000 	cmp	r7, #0
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34807e58:	e58d0034 	str	r0, [sp, #52]	; 0x34

	if (size)
34807e5c:	0affffb2 	beq	34807d2c <do_env_export+0xfc>
34807e60:	eaffffae 	b	34807d20 <do_env_export+0xf0>
34807e64:	34828c70 	.word	0x34828c70
34807e68:	34820534 	.word	0x34820534
34807e6c:	34825622 	.word	0x34825622
34807e70:	3482bee8 	.word	0x3482bee8
34807e74:	34825480 	.word	0x34825480
34807e78:	3482565f 	.word	0x3482565f
34807e7c:	0003fffc 	.word	0x0003fffc
34807e80:	348234c1 	.word	0x348234c1
34807e84:	3482548d 	.word	0x3482548d

34807e88 <setenv_ulong>:
 * @param varname	Environmet variable to set
 * @param value		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_ulong(const char *varname, ulong value)
{
34807e88:	e92d4010 	push	{r4, lr}
34807e8c:	e1a04000 	mov	r4, r0
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);
34807e90:	e1a00001 	mov	r0, r1
34807e94:	eb005650 	bl	3481d7dc <simple_itoa>
34807e98:	e1a01000 	mov	r1, r0

	return setenv(varname, str);
34807e9c:	e1a00004 	mov	r0, r4
}
34807ea0:	e8bd4010 	pop	{r4, lr}
int setenv_ulong(const char *varname, ulong value)
{
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);

	return setenv(varname, str);
34807ea4:	eaffff4d 	b	34807be0 <setenv>

34807ea8 <setenv_addr>:
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
34807ea8:	e92d4030 	push	{r4, r5, lr}
34807eac:	e24dd01c 	sub	sp, sp, #28
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
34807eb0:	e28d4004 	add	r4, sp, #4
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
34807eb4:	e1a05000 	mov	r5, r0
34807eb8:	e1a02001 	mov	r2, r1
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
34807ebc:	e1a00004 	mov	r0, r4
34807ec0:	e59f1014 	ldr	r1, [pc, #20]	; 34807edc <setenv_addr+0x34>
34807ec4:	eb005625 	bl	3481d760 <sprintf>
	return setenv(varname, str);
34807ec8:	e1a00005 	mov	r0, r5
34807ecc:	e1a01004 	mov	r1, r4
34807ed0:	ebffff42 	bl	34807be0 <setenv>
}
34807ed4:	e28dd01c 	add	sp, sp, #28
34807ed8:	e8bd8030 	pop	{r4, r5, pc}
34807edc:	348233b4 	.word	0x348233b4

34807ee0 <envmatch>:
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
34807ee0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34807ee4:	e1a05001 	mov	r5, r1
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
		return i2;

	return -1;
34807ee8:	e1a06000 	mov	r6, r0
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34807eec:	ea000003 	b	34807f00 <envmatch+0x20>
		if (*s1++ == '=')
34807ef0:	e5563001 	ldrb	r3, [r6, #-1]
34807ef4:	e353003d 	cmp	r3, #61	; 0x3d
34807ef8:	0a00000f 	beq	34807f3c <envmatch+0x5c>
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34807efc:	e1a05004 	mov	r5, r4
34807f00:	e1a00005 	mov	r0, r5
		if (*s1++ == '=')
34807f04:	e1a07006 	mov	r7, r6
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34807f08:	e4d6a001 	ldrb	sl, [r6], #1
34807f0c:	eb000c33 	bl	3480afe0 <env_get_char>
34807f10:	e15a0000 	cmp	sl, r0
34807f14:	e2854001 	add	r4, r5, #1
34807f18:	0afffff4 	beq	34807ef0 <envmatch+0x10>
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34807f1c:	e5d73000 	ldrb	r3, [r7]
34807f20:	e3530000 	cmp	r3, #0
		return i2;

	return -1;
34807f24:	13e04000 	mvnne	r4, #0
{
	while (*s1 == env_get_char(i2++))
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34807f28:	1a000003 	bne	34807f3c <envmatch+0x5c>
34807f2c:	e1a00005 	mov	r0, r5
34807f30:	eb000c2a 	bl	3480afe0 <env_get_char>
		return i2;

	return -1;
34807f34:	e350003d 	cmp	r0, #61	; 0x3d
34807f38:	13e04000 	mvnne	r4, #0
}
34807f3c:	e1a00004 	mov	r0, r4
34807f40:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34807f44 <getenv_f>:

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
34807f44:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34807f48:	e1a05000 	mov	r5, r0
34807f4c:	e1a06001 	mov	r6, r1
34807f50:	e1a0a002 	mov	sl, r2
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807f54:	e3a0b000 	mov	fp, #0
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
34807f58:	e59f9098 	ldr	r9, [pc, #152]	; 34807ff8 <getenv_f+0xb4>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807f5c:	ea00001d 	b	34807fd8 <getenv_f+0x94>
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
34807f60:	e1570009 	cmp	r7, r9
34807f64:	ca000020 	bgt	34807fec <getenv_f+0xa8>
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
34807f68:	e2877001 	add	r7, r7, #1
34807f6c:	e1a00007 	mov	r0, r7
34807f70:	eb000c1a 	bl	3480afe0 <env_get_char>
34807f74:	e2504000 	subs	r4, r0, #0
34807f78:	1afffff8 	bne	34807f60 <getenv_f+0x1c>
			if (nxt >= CONFIG_ENV_SIZE)
				return -1;
		}

		val = envmatch((uchar *)name, i);
34807f7c:	e1a0100b 	mov	r1, fp
34807f80:	e1a00005 	mov	r0, r5
34807f84:	ebffffd5 	bl	34807ee0 <envmatch>
		if (val < 0)
34807f88:	e250b000 	subs	fp, r0, #0
34807f8c:	aa000006 	bge	34807fac <getenv_f+0x68>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807f90:	e287b001 	add	fp, r7, #1
34807f94:	ea00000f 	b	34807fd8 <getenv_f+0x94>
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
34807f98:	eb000c10 	bl	3480afe0 <env_get_char>
			if (*buf == '\0')
34807f9c:	e3500000 	cmp	r0, #0
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
34807fa0:	e4c60001 	strb	r0, [r6], #1
			if (*buf == '\0')
34807fa4:	0a000011 	beq	34807ff0 <getenv_f+0xac>
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
34807fa8:	e2844001 	add	r4, r4, #1
34807fac:	e154000a 	cmp	r4, sl
}

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
34807fb0:	e084000b 	add	r0, r4, fp
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
34807fb4:	3afffff7 	bcc	34807f98 <getenv_f+0x54>
			*buf = env_get_char(val++);
			if (*buf == '\0')
				return n;
		}

		if (n)
34807fb8:	e3540000 	cmp	r4, #0
			*--buf = '\0';
34807fbc:	13a03000 	movne	r3, #0
34807fc0:	15463001 	strbne	r3, [r6, #-1]

		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
34807fc4:	e1a0100a 	mov	r1, sl
34807fc8:	e1a02005 	mov	r2, r5
34807fcc:	e59f0028 	ldr	r0, [pc, #40]	; 34807ffc <getenv_f+0xb8>
34807fd0:	eb0006f8 	bl	34809bb8 <printf>
			len, name);

		return n;
34807fd4:	ea000005 	b	34807ff0 <getenv_f+0xac>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807fd8:	e1a0000b 	mov	r0, fp
34807fdc:	eb000bff 	bl	3480afe0 <env_get_char>
34807fe0:	e3500000 	cmp	r0, #0
34807fe4:	11a0700b 	movne	r7, fp
34807fe8:	1affffdf 	bne	34807f6c <getenv_f+0x28>
			len, name);

		return n;
	}

	return -1;
34807fec:	e3e04000 	mvn	r4, #0
}
34807ff0:	e1a00004 	mov	r0, r4
34807ff4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807ff8:	0003ffff 	.word	0x0003ffff
34807ffc:	34825663 	.word	0x34825663

34808000 <getenv>:
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
34808000:	e92d4010 	push	{r4, lr}
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
34808004:	e5984004 	ldr	r4, [r8, #4]
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
34808008:	e24dd018 	sub	sp, sp, #24
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
3480800c:	e2144080 	ands	r4, r4, #128	; 0x80
34808010:	0a00000c 	beq	34808048 <getenv+0x48>

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
34808014:	e59f304c 	ldr	r3, [pc, #76]	; 34808068 <getenv+0x68>
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
34808018:	e3a02000 	mov	r2, #0
		hsearch_r(e, FIND, &ep, &env_htab);
3480801c:	e58d3000 	str	r3, [sp]
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
34808020:	e58d000c 	str	r0, [sp, #12]
		e.data	= NULL;
34808024:	e58d2010 	str	r2, [sp, #16]
		hsearch_r(e, FIND, &ep, &env_htab);
34808028:	e28d300c 	add	r3, sp, #12
3480802c:	e8930003 	ldm	r3, {r0, r1}
34808030:	e28d3014 	add	r3, sp, #20
34808034:	eb004d04 	bl	3481b44c <hsearch_r>

		return ep ? ep->data : NULL;
34808038:	e59d0014 	ldr	r0, [sp, #20]
3480803c:	e3500000 	cmp	r0, #0
34808040:	15900004 	ldrne	r0, [r0, #4]
34808044:	ea000005 	b	34808060 <getenv+0x60>
	}

	/* restricted capabilities before import */
	if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
34808048:	e2881058 	add	r1, r8, #88	; 0x58
3480804c:	e3a02020 	mov	r2, #32
34808050:	ebffffbb 	bl	34807f44 <getenv_f>
34808054:	e3500000 	cmp	r0, #0
		return (char *)(gd->env_buf);
34808058:	c2880058 	addgt	r0, r8, #88	; 0x58

	return NULL;
3480805c:	d1a00004 	movle	r0, r4
}
34808060:	e28dd018 	add	sp, sp, #24
34808064:	e8bd8010 	pop	{r4, pc}
34808068:	34828c70 	.word	0x34828c70

3480806c <getenv_ulong>:
 * @param default_val	Default value to return if the variable is not
 *			found
 * @return the decoded value, or default_val if not found
 */
ulong getenv_ulong(const char *name, int base, ulong default_val)
{
3480806c:	e92d4070 	push	{r4, r5, r6, lr}
34808070:	e1a04001 	mov	r4, r1
34808074:	e1a05002 	mov	r5, r2
	/*
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);
34808078:	ebffffe0 	bl	34808000 <getenv>

	return str ? simple_strtoul(str, NULL, base) : default_val;
3480807c:	e3500000 	cmp	r0, #0
34808080:	0a000003 	beq	34808094 <getenv_ulong+0x28>
34808084:	e3a01000 	mov	r1, #0
34808088:	e1a02004 	mov	r2, r4
}
3480808c:	e8bd4070 	pop	{r4, r5, r6, lr}
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);

	return str ? simple_strtoul(str, NULL, base) : default_val;
34808090:	ea00550c 	b	3481d4c8 <simple_strtoul>
}
34808094:	e1a00005 	mov	r0, r5
34808098:	e8bd8070 	pop	{r4, r5, r6, pc}

3480809c <do_env_edit>:
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480809c:	e92d4030 	push	{r4, r5, lr}
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
348080a0:	e3520001 	cmp	r2, #1
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348080a4:	e24ddf41 	sub	sp, sp, #260	; 0x104
348080a8:	e1a05003 	mov	r5, r3
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
		return CMD_RET_USAGE;
348080ac:	d3e00000 	mvnle	r0, #0
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
348080b0:	da00000f 	ble	348080f4 <do_env_edit+0x58>
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
348080b4:	e5930004 	ldr	r0, [r3, #4]
348080b8:	ebffffd0 	bl	34808000 <getenv>
	if (init_val)
348080bc:	e2502000 	subs	r2, r0, #0
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';
348080c0:	05cd2000 	strbeq	r2, [sp]
	if (argc < 2)
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
	if (init_val)
348080c4:	0a000002 	beq	348080d4 <do_env_edit+0x38>
		sprintf(buffer, "%s", init_val);
348080c8:	e1a0000d 	mov	r0, sp
348080cc:	e59f1028 	ldr	r1, [pc, #40]	; 348080fc <do_env_edit+0x60>
348080d0:	eb0055a2 	bl	3481d760 <sprintf>
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
348080d4:	e1a0100d 	mov	r1, sp
348080d8:	e59f0020 	ldr	r0, [pc, #32]	; 34808100 <do_env_edit+0x64>
348080dc:	e3a02000 	mov	r2, #0
348080e0:	eb0017a9 	bl	3480df8c <readline_into_buffer>

	return setenv(argv[1], buffer);
348080e4:	e5950004 	ldr	r0, [r5, #4]
348080e8:	e1a0100d 	mov	r1, sp
	if (init_val)
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
348080ec:	e1a0400d 	mov	r4, sp

	return setenv(argv[1], buffer);
348080f0:	ebfffeba 	bl	34807be0 <setenv>
}
348080f4:	e28ddf41 	add	sp, sp, #260	; 0x104
348080f8:	e8bd8030 	pop	{r4, r5, pc}
348080fc:	34824d80 	.word	0x34824d80
34808100:	34825693 	.word	0x34825693

34808104 <do_onenand>:

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *c;

	if (argc < 2)
34808104:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_onenand_sub, ARRAY_SIZE(cmd_onenand_sub));
}
#endif

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808108:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480810c:	e1a05000 	mov	r5, r0
34808110:	e1a06001 	mov	r6, r1
34808114:	e1a04002 	mov	r4, r2
	cmd_tbl_t *c;

	if (argc < 2)
		return CMD_RET_USAGE;
34808118:	d3e00000 	mvnle	r0, #0

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *c;

	if (argc < 2)
3480811c:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
		return CMD_RET_USAGE;

	mtd = &onenand_mtd;
34808120:	e59f1044 	ldr	r1, [pc, #68]	; 3480816c <do_onenand+0x68>
34808124:	e59f2044 	ldr	r2, [pc, #68]	; 34808170 <do_onenand+0x6c>

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
34808128:	e5930004 	ldr	r0, [r3, #4]
	cmd_tbl_t *c;

	if (argc < 2)
		return CMD_RET_USAGE;

	mtd = &onenand_mtd;
3480812c:	e5821000 	str	r1, [r2]

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
34808130:	e59f103c 	ldr	r1, [pc, #60]	; 34808174 <do_onenand+0x70>
34808134:	e3a02009 	mov	r2, #9

	mtd = &onenand_mtd;

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;
34808138:	e2837004 	add	r7, r3, #4

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
3480813c:	eb000515 	bl	34809598 <find_cmd_tbl>

	if (c)
34808140:	e3500000 	cmp	r0, #0
34808144:	0a000006 	beq	34808164 <do_onenand+0x60>
		return c->cmd(cmdtp, flag, argc, argv);
34808148:	e590c00c 	ldr	ip, [r0, #12]
3480814c:	e1a01006 	mov	r1, r6
34808150:	e1a00005 	mov	r0, r5
34808154:	e2442001 	sub	r2, r4, #1
34808158:	e1a03007 	mov	r3, r7
3480815c:	e12fff3c 	blx	ip
34808160:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	else
		return CMD_RET_USAGE;
34808164:	e3e00000 	mvn	r0, #0
}
34808168:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480816c:	3482bd68 	.word	0x3482bd68
34808170:	3482a008 	.word	0x3482a008
34808174:	34828784 	.word	0x34828784

34808178 <str2long>:

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
{
34808178:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
3480817c:	e1a05001 	mov	r5, r1
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
34808180:	e3a02010 	mov	r2, #16
34808184:	e28d1004 	add	r1, sp, #4

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
{
34808188:	e1a04000 	mov	r4, r0
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
3480818c:	eb0054cd 	bl	3481d4c8 <simple_strtoul>
34808190:	e5850000 	str	r0, [r5]
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
34808194:	e5d40000 	ldrb	r0, [r4]
34808198:	e3500000 	cmp	r0, #0
3480819c:	0a000003 	beq	348081b0 <str2long+0x38>
348081a0:	e59d3004 	ldr	r3, [sp, #4]
static struct mtd_info *mtd;

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
348081a4:	e5d30000 	ldrb	r0, [r3]
348081a8:	e2700001 	rsbs	r0, r0, #1
348081ac:	33a00000 	movcc	r0, #0
{
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}
348081b0:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}

348081b4 <do_onenand_markbad>:

	return ret == 0 ? 1 : 0;
}

static int do_onenand_markbad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348081b4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int ret = 0;
	ulong addr;

	argc -= 2;
348081b8:	e2425002 	sub	r5, r2, #2
	argv += 2;

	if (argc <= 0)
348081bc:	e3550000 	cmp	r5, #0
		return CMD_RET_USAGE;
348081c0:	d3e04000 	mvnle	r4, #0
	ulong addr;

	argc -= 2;
	argv += 2;

	if (argc <= 0)
348081c4:	da00001a 	ble	34808234 <do_onenand_markbad+0x80>
		return CMD_RET_USAGE;

	while (argc > 0) {
		addr = simple_strtoul(*argv, NULL, 16);

		if (mtd->block_markbad(mtd, addr)) {
348081c8:	e59fa06c 	ldr	sl, [pc, #108]	; 3480823c <do_onenand_markbad+0x88>
		ret = onenand_dump(mtd, ofs, 0);

	return ret == 0 ? 1 : 0;
}

static int do_onenand_markbad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
348081cc:	e2836004 	add	r6, r3, #4
348081d0:	e3a04000 	mov	r4, #0

	if (argc <= 0)
		return CMD_RET_USAGE;

	while (argc > 0) {
		addr = simple_strtoul(*argv, NULL, 16);
348081d4:	e3a01000 	mov	r1, #0
348081d8:	e3a02010 	mov	r2, #16
348081dc:	e5b60004 	ldr	r0, [r6, #4]!
348081e0:	eb0054b8 	bl	3481d4c8 <simple_strtoul>
348081e4:	e1a07000 	mov	r7, r0

		if (mtd->block_markbad(mtd, addr)) {
348081e8:	e59a0000 	ldr	r0, [sl]
348081ec:	e1a02007 	mov	r2, r7
348081f0:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
348081f4:	e3a03000 	mov	r3, #0
348081f8:	e12fff31 	blx	r1
348081fc:	e3500000 	cmp	r0, #0
34808200:	0a000005 	beq	3480821c <do_onenand_markbad+0x68>
			printf("block 0x%08lx NOT marked "
34808204:	e1a02004 	mov	r2, r4
34808208:	e59f0030 	ldr	r0, [pc, #48]	; 34808240 <do_onenand_markbad+0x8c>
3480820c:	e1a01007 	mov	r1, r7
34808210:	eb000668 	bl	34809bb8 <printf>
				"as bad! ERROR %d\n",
				addr, ret);
			ret = 1;
34808214:	e3a04001 	mov	r4, #1
34808218:	ea000002 	b	34808228 <do_onenand_markbad+0x74>
		} else {
			printf("block 0x%08lx successfully "
3480821c:	e59f0020 	ldr	r0, [pc, #32]	; 34808244 <do_onenand_markbad+0x90>
34808220:	e1a01007 	mov	r1, r7
34808224:	eb000663 	bl	34809bb8 <printf>
				"marked as bad\n",
				addr);
		}
		--argc;
34808228:	e2455001 	sub	r5, r5, #1
	argv += 2;

	if (argc <= 0)
		return CMD_RET_USAGE;

	while (argc > 0) {
3480822c:	e3550000 	cmp	r5, #0
34808230:	caffffe7 	bgt	348081d4 <do_onenand_markbad+0x20>
		}
		--argc;
		++argv;
	}
	return ret;
}
34808234:	e1a00004 	mov	r0, r4
34808238:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480823c:	3482a008 	.word	0x3482a008
34808240:	34825a81 	.word	0x34825a81
34808244:	34825aac 	.word	0x34825aac

34808248 <do_onenand_bad>:
	printf("%s\n", mtd->name);
	return 0;
}

static int do_onenand_bad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808248:	e92d4038 	push	{r3, r4, r5, lr}
	ulong ofs;

	mtd = &onenand_mtd;
3480824c:	e59f3070 	ldr	r3, [pc, #112]	; 348082c4 <do_onenand_bad+0x7c>
34808250:	e59f5070 	ldr	r5, [pc, #112]	; 348082c8 <do_onenand_bad+0x80>
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
34808254:	e59f0070 	ldr	r0, [pc, #112]	; 348082cc <do_onenand_bad+0x84>
34808258:	e3a01000 	mov	r1, #0

static int do_onenand_bad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	ulong ofs;

	mtd = &onenand_mtd;
3480825c:	e5853000 	str	r3, [r5]
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34808260:	e3a04000 	mov	r4, #0
{
	ulong ofs;

	mtd = &onenand_mtd;
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
34808264:	eb000653 	bl	34809bb8 <printf>
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34808268:	ea00000b 	b	3480829c <do_onenand_bad+0x54>
		if (mtd->block_isbad(mtd, ofs))
3480826c:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808270:	e1a02004 	mov	r2, r4
34808274:	e3a03000 	mov	r3, #0
34808278:	e12fff31 	blx	r1
3480827c:	e3500000 	cmp	r0, #0
34808280:	0a000002 	beq	34808290 <do_onenand_bad+0x48>
			printf("  %08x\n", (u32)ofs);
34808284:	e59f0044 	ldr	r0, [pc, #68]	; 348082d0 <do_onenand_bad+0x88>
34808288:	e1a01004 	mov	r1, r4
3480828c:	eb000649 	bl	34809bb8 <printf>
	ulong ofs;

	mtd = &onenand_mtd;
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34808290:	e5953000 	ldr	r3, [r5]
34808294:	e5933010 	ldr	r3, [r3, #16]
34808298:	e0844003 	add	r4, r4, r3
3480829c:	e5950000 	ldr	r0, [r5]
348082a0:	e590300c 	ldr	r3, [r0, #12]
348082a4:	e3530000 	cmp	r3, #0
348082a8:	8affffef 	bhi	3480826c <do_onenand_bad+0x24>
348082ac:	1a000002 	bne	348082bc <do_onenand_bad+0x74>
348082b0:	e5903008 	ldr	r3, [r0, #8]
348082b4:	e1530004 	cmp	r3, r4
348082b8:	8affffeb 	bhi	3480826c <do_onenand_bad+0x24>
		if (mtd->block_isbad(mtd, ofs))
			printf("  %08x\n", (u32)ofs);
	}

	return 0;
}
348082bc:	e3a00000 	mov	r0, #0
348082c0:	e8bd8038 	pop	{r3, r4, r5, pc}
348082c4:	3482bd68 	.word	0x3482bd68
348082c8:	3482a008 	.word	0x3482a008
348082cc:	34825ad6 	.word	0x34825ad6
348082d0:	34826718 	.word	0x34826718

348082d4 <do_onenand_info>:

	return 0;
}

static int do_onenand_info(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348082d4:	e92d4008 	push	{r3, lr}
	printf("%s\n", mtd->name);
348082d8:	e59f3014 	ldr	r3, [pc, #20]	; 348082f4 <do_onenand_info+0x20>
348082dc:	e59f0014 	ldr	r0, [pc, #20]	; 348082f8 <do_onenand_info+0x24>
348082e0:	e5933000 	ldr	r3, [r3]
348082e4:	e5931020 	ldr	r1, [r3, #32]
348082e8:	eb000632 	bl	34809bb8 <printf>
	return 0;
}
348082ec:	e3a00000 	mov	r0, #0
348082f0:	e8bd8008 	pop	{r3, pc}
348082f4:	3482a008 	.word	0x3482a008
348082f8:	34826164 	.word	0x34826164

348082fc <arg_off_size>:
	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
348082fc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	if (argc >= 1) {
34808300:	e2507000 	subs	r7, r0, #0
	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
34808304:	e1a04001 	mov	r4, r1
34808308:	e1a05002 	mov	r5, r2
3480830c:	e1a06003 	mov	r6, r3
	if (argc >= 1) {
34808310:	da000007 	ble	34808334 <arg_off_size+0x38>
		if (!(str2long(argv[0], off))) {
34808314:	e5910000 	ldr	r0, [r1]
34808318:	e1a01002 	mov	r1, r2
3480831c:	ebffff95 	bl	34808178 <str2long>
34808320:	e3500000 	cmp	r0, #0
			printf("'%s' is not a number\n", argv[0]);
34808324:	059f00d0 	ldreq	r0, [pc, #208]	; 348083fc <arg_off_size+0x100>
34808328:	05941000 	ldreq	r1, [r4]
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
	if (argc >= 1) {
		if (!(str2long(argv[0], off))) {
3480832c:	1a000003 	bne	34808340 <arg_off_size+0x44>
34808330:	ea00000b 	b	34808364 <arg_off_size+0x68>
			printf("'%s' is not a number\n", argv[0]);
			return -1;
		}
	} else {
		*off = 0;
34808334:	e3a03000 	mov	r3, #0
34808338:	e5823000 	str	r3, [r2]
3480833c:	ea00000a 	b	3480836c <arg_off_size+0x70>
	}

	if (argc >= 2) {
34808340:	e3570001 	cmp	r7, #1
34808344:	0a000008 	beq	3480836c <arg_off_size+0x70>
		if (!(str2long(argv[1], (ulong *)size))) {
34808348:	e5940004 	ldr	r0, [r4, #4]
3480834c:	e1a01006 	mov	r1, r6
34808350:	ebffff88 	bl	34808178 <str2long>
34808354:	e3500000 	cmp	r0, #0
34808358:	1a000009 	bne	34808384 <arg_off_size+0x88>
			printf("'%s' is not a number\n", argv[1]);
3480835c:	e59f0098 	ldr	r0, [pc, #152]	; 348083fc <arg_off_size+0x100>
34808360:	e5941004 	ldr	r1, [r4, #4]
34808364:	eb000613 	bl	34809bb8 <printf>
34808368:	ea000014 	b	348083c0 <arg_off_size+0xc4>
			return -1;
		}
	} else {
		*size = mtd->size - *off;
3480836c:	e59f308c 	ldr	r3, [pc, #140]	; 34808400 <arg_off_size+0x104>
34808370:	e5933000 	ldr	r3, [r3]
34808374:	e5932008 	ldr	r2, [r3, #8]
34808378:	e5953000 	ldr	r3, [r5]
3480837c:	e0633002 	rsb	r3, r3, r2
34808380:	e5863000 	str	r3, [r6]
	}

	if ((*off + *size) > mtd->size) {
34808384:	e59f3074 	ldr	r3, [pc, #116]	; 34808400 <arg_off_size+0x104>
34808388:	e5951000 	ldr	r1, [r5]
3480838c:	e5933000 	ldr	r3, [r3]
34808390:	e5962000 	ldr	r2, [r6]
34808394:	e593400c 	ldr	r4, [r3, #12]
34808398:	e593c008 	ldr	ip, [r3, #8]
3480839c:	e3a03000 	mov	r3, #0
348083a0:	e1530004 	cmp	r3, r4
348083a4:	e0820001 	add	r0, r2, r1
348083a8:	1a000006 	bne	348083c8 <arg_off_size+0xcc>
348083ac:	e150000c 	cmp	r0, ip
348083b0:	9a000004 	bls	348083c8 <arg_off_size+0xcc>
		printf("total chip size (0x%llx) exceeded!\n", mtd->size);
348083b4:	e59f0048 	ldr	r0, [pc, #72]	; 34808404 <arg_off_size+0x108>
348083b8:	e1a0200c 	mov	r2, ip
348083bc:	eb0005fd 	bl	34809bb8 <printf>
		return -1;
348083c0:	e3e00000 	mvn	r0, #0
348083c4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (*size == mtd->size)
348083c8:	e152000c 	cmp	r2, ip
348083cc:	1a000006 	bne	348083ec <arg_off_size+0xf0>
348083d0:	e3a03000 	mov	r3, #0
348083d4:	e1530004 	cmp	r3, r4
348083d8:	1a000003 	bne	348083ec <arg_off_size+0xf0>
		puts("whole chip\n");
348083dc:	e59f0024 	ldr	r0, [pc, #36]	; 34808408 <arg_off_size+0x10c>
348083e0:	eb0005ea 	bl	34809b90 <puts>
	else
		printf("offset 0x%lx, size 0x%x\n", *off, *size);

	return 0;
348083e4:	e1a00004 	mov	r0, r4
348083e8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (*size == mtd->size)
		puts("whole chip\n");
	else
		printf("offset 0x%lx, size 0x%x\n", *off, *size);
348083ec:	e59f0018 	ldr	r0, [pc, #24]	; 3480840c <arg_off_size+0x110>
348083f0:	eb0005f0 	bl	34809bb8 <printf>

	return 0;
348083f4:	e3a00000 	mov	r0, #0
}
348083f8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348083fc:	34825aee 	.word	0x34825aee
34808400:	3482a008 	.word	0x3482a008
34808404:	34825b04 	.word	0x34825b04
34808408:	34825b28 	.word	0x34825b28
3480840c:	34825b34 	.word	0x34825b34

34808410 <do_onenand_read>:

	return 0;
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808410:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong addr, ofs;
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
34808414:	e3520002 	cmp	r2, #2

	return 0;
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808418:	e24dd048 	sub	sp, sp, #72	; 0x48
3480841c:	e1a04002 	mov	r4, r2
34808420:	e1a06003 	mov	r6, r3
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;
34808424:	d3e00000 	mvnle	r0, #0
	ulong addr, ofs;
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
34808428:	da000065 	ble	348085c4 <do_onenand_read+0x1b4>
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
3480842c:	e5930000 	ldr	r0, [r3]
34808430:	e3a0102e 	mov	r1, #46	; 0x2e
34808434:	eb00507a 	bl	3481c624 <strchr>
	if ((s != NULL) && (!strcmp(s, ".oob")))
34808438:	e2503000 	subs	r3, r0, #0
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	char *s;
	int oob = 0;
3480843c:	058d300c 	streq	r3, [sp, #12]

	if (argc < 3)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
34808440:	0a000004 	beq	34808458 <do_onenand_read+0x48>
34808444:	e59f1180 	ldr	r1, [pc, #384]	; 348085cc <do_onenand_read+0x1bc>
34808448:	eb005057 	bl	3481c5ac <strcmp>
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	char *s;
	int oob = 0;
3480844c:	e2700001 	rsbs	r0, r0, #1
34808450:	33a00000 	movcc	r0, #0
34808454:	e58d000c 	str	r0, [sp, #12]

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
		oob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808458:	e3a01000 	mov	r1, #0
3480845c:	e3a02010 	mov	r2, #16
34808460:	e5960004 	ldr	r0, [r6, #4]
34808464:	eb005417 	bl	3481d4c8 <simple_strtoul>
34808468:	e1a07000 	mov	r7, r0

	printf("\nOneNAND read: ");
3480846c:	e59f015c 	ldr	r0, [pc, #348]	; 348085d0 <do_onenand_read+0x1c0>
34808470:	eb0005d0 	bl	34809bb8 <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808474:	e2861008 	add	r1, r6, #8
34808478:	e2440002 	sub	r0, r4, #2
3480847c:	e28d2044 	add	r2, sp, #68	; 0x44
34808480:	e28d3040 	add	r3, sp, #64	; 0x40
34808484:	ebffff9c 	bl	348082fc <arg_off_size>
34808488:	e2501000 	subs	r1, r0, #0
		return 1;
3480848c:	13a00001 	movne	r0, #1
		oob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808490:	1a00004b 	bne	348085c4 <do_onenand_read+0x1b4>
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
34808494:	e59f3138 	ldr	r3, [pc, #312]	; 348085d4 <do_onenand_read+0x1c4>
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
34808498:	e3a0a001 	mov	sl, #1
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
3480849c:	e5933000 	ldr	r3, [r3]
	int blocks = (int) len >> this->erase_shift;
348084a0:	e59db040 	ldr	fp, [sp, #64]	; 0x40
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
348084a4:	e5933094 	ldr	r3, [r3, #148]	; 0x94
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
348084a8:	e3a02020 	mov	r2, #32
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
348084ac:	e58d301c 	str	r3, [sp, #28]
	int blocks = (int) len >> this->erase_shift;
348084b0:	e5933030 	ldr	r3, [r3, #48]	; 0x30
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
348084b4:	e28d0020 	add	r0, sp, #32
static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
348084b8:	e1a0a31a 	lsl	sl, sl, r3

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
348084bc:	e59d4044 	ldr	r4, [sp, #68]	; 0x44

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = (int) len >> this->erase_shift;
348084c0:	e1a0b35b 	asr	fp, fp, r3
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
348084c4:	eb00510c 	bl	3481c8fc <memset>
		.retlen		= 0,
	};
	int ret;

	if (oob)
348084c8:	e59d200c 	ldr	r2, [sp, #12]

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
348084cc:	e3a05000 	mov	r5, #0
	struct mtd_oob_ops ops = {
		.retlen		= 0,
	};
	int ret;

	if (oob)
348084d0:	e3520000 	cmp	r2, #0
348084d4:	e1a0200a 	mov	r2, sl
348084d8:	e1a03fc2 	asr	r3, r2, #31
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;
348084dc:	058da024 	streq	sl, [sp, #36]	; 0x24
		.retlen		= 0,
	};
	int ret;

	if (oob)
		ops.ooblen = blocksize;
348084e0:	158da02c 	strne	sl, [sp, #44]	; 0x2c
	if (argc < 3)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
		oob = 1;
348084e4:	e3a09000 	mov	r9, #0
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
348084e8:	e59f60e4 	ldr	r6, [pc, #228]	; 348085d4 <do_onenand_read+0x1c4>
348084ec:	e1cd21f0 	strd	r2, [sp, #16]
348084f0:	ea00002c 	b	348085a8 <do_onenand_read+0x198>
348084f4:	e5960000 	ldr	r0, [r6]
348084f8:	e1a02004 	mov	r2, r4
348084fc:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808500:	e1a03005 	mov	r3, r5
34808504:	e12fff31 	blx	r1
		if (ret) {
34808508:	e3500000 	cmp	r0, #0
3480850c:	0a000008 	beq	34808534 <do_onenand_read+0x124>
			printk("Bad blocks %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808510:	e59d301c 	ldr	r3, [sp, #28]
34808514:	e1a00004 	mov	r0, r4
34808518:	e5932030 	ldr	r2, [r3, #48]	; 0x30
3480851c:	e1a01005 	mov	r1, r5
34808520:	eb005f7b 	bl	34820314 <__ashrdi3>
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808524:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808528:	e1a01000 	mov	r1, r0
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
3480852c:	e59f00a4 	ldr	r0, [pc, #164]	; 348085d8 <do_onenand_read+0x1c8>
34808530:	ea000010 	b	34808578 <do_onenand_read+0x168>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			ofs += blocksize;
			continue;
		}

		if (oob)
34808534:	e59d300c 	ldr	r3, [sp, #12]
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
		ret = mtd->read_oob(mtd, ofs, &ops);
34808538:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			ofs += blocksize;
			continue;
		}

		if (oob)
3480853c:	e3530000 	cmp	r3, #0
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
		ret = mtd->read_oob(mtd, ofs, &ops);
34808540:	e28d3020 	add	r3, sp, #32
34808544:	e58d3000 	str	r3, [sp]
		if (oob)
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
34808548:	e3a02000 	mov	r2, #0
			ofs += blocksize;
			continue;
		}

		if (oob)
			ops.oobbuf = buf;
3480854c:	158d703c 	strne	r7, [sp, #60]	; 0x3c
		else
			ops.datbuf = buf;
34808550:	058d7038 	streq	r7, [sp, #56]	; 0x38

		ops.retlen = 0;
34808554:	e58d2028 	str	r2, [sp, #40]	; 0x28
		ret = mtd->read_oob(mtd, ofs, &ops);
34808558:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
3480855c:	e1a02004 	mov	r2, r4
34808560:	e1a03005 	mov	r3, r5
34808564:	e12fff31 	blx	r1
		if (ret) {
34808568:	e2502000 	subs	r2, r0, #0
3480856c:	0a000006 	beq	3480858c <do_onenand_read+0x17c>
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
34808570:	e59f0064 	ldr	r0, [pc, #100]	; 348085dc <do_onenand_read+0x1cc>
34808574:	e1a01004 	mov	r1, r4
34808578:	eb00058e 	bl	34809bb8 <printf>
			ofs += blocksize;
3480857c:	e1cd21d0 	ldrd	r2, [sp, #16]
34808580:	e0944002 	adds	r4, r4, r2
34808584:	e0a55003 	adc	r5, r5, r3
34808588:	ea000006 	b	348085a8 <do_onenand_read+0x198>
			continue;
		}
		ofs += blocksize;
3480858c:	e1cd21d0 	ldrd	r2, [sp, #16]
34808590:	e0944002 	adds	r4, r4, r2
34808594:	e0a55003 	adc	r5, r5, r3
		buf += blocksize;
		blocks--;
		*retlen += ops.retlen;
34808598:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
			ofs += blocksize;
			continue;
		}
		ofs += blocksize;
		buf += blocksize;
3480859c:	e087700a 	add	r7, r7, sl
		blocks--;
348085a0:	e24bb001 	sub	fp, fp, #1
		*retlen += ops.retlen;
348085a4:	e0899003 	add	r9, r9, r3
	if (oob)
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;

	while (blocks) {
348085a8:	e35b0000 	cmp	fp, #0
348085ac:	1affffd0 	bne	348084f4 <do_onenand_read+0xe4>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);

	printf(" %d bytes read: %s\n", retlen, ret ? "ERROR" : "OK");
348085b0:	e59f0028 	ldr	r0, [pc, #40]	; 348085e0 <do_onenand_read+0x1d0>
348085b4:	e1a01009 	mov	r1, r9
348085b8:	e59f2024 	ldr	r2, [pc, #36]	; 348085e4 <do_onenand_read+0x1d4>
348085bc:	eb00057d 	bl	34809bb8 <printf>

	return ret == 0 ? 0 : 1;
348085c0:	e1a0000b 	mov	r0, fp
}
348085c4:	e28dd048 	add	sp, sp, #72	; 0x48
348085c8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348085cc:	34825b4d 	.word	0x34825b4d
348085d0:	34825b52 	.word	0x34825b52
348085d4:	3482a008 	.word	0x3482a008
348085d8:	34825b62 	.word	0x34825b62
348085dc:	34825b79 	.word	0x34825b79
348085e0:	34825b8f 	.word	0x34825b8f
348085e4:	3482437d 	.word	0x3482437d

348085e8 <onenand_dump>:

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
348085e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348085ec:	e1a06000 	mov	r6, r0
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
348085f0:	e5963014 	ldr	r3, [r6, #20]
348085f4:	e5900018 	ldr	r0, [r0, #24]

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
348085f8:	e24dd058 	sub	sp, sp, #88	; 0x58
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
348085fc:	e0800003 	add	r0, r0, r3

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
34808600:	e1a09001 	mov	r9, r1
34808604:	e1a0b002 	mov	fp, r2
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
34808608:	eb000731 	bl	3480a2d4 <malloc>
3480860c:	e1a05000 	mov	r5, r0
	oobbuf = malloc(mtd->oobsize);
34808610:	e5960018 	ldr	r0, [r6, #24]
34808614:	eb00072e 	bl	3480a2d4 <malloc>
	if (!datbuf || !oobbuf) {
34808618:	e3550000 	cmp	r5, #0
3480861c:	13500000 	cmpne	r0, #0
34808620:	e1a07000 	mov	r7, r0
34808624:	13a04000 	movne	r4, #0
34808628:	03a04001 	moveq	r4, #1
3480862c:	1a000002 	bne	3480863c <onenand_dump+0x54>
		puts("No memory for page buffer\n");
34808630:	e59f01b4 	ldr	r0, [pc, #436]	; 348087ec <onenand_dump+0x204>
34808634:	eb000555 	bl	34809b90 <puts>
34808638:	ea00001d 	b	348086b4 <onenand_dump+0xcc>
		return 1;
	}
	off &= ~(mtd->writesize - 1);
3480863c:	e596a014 	ldr	sl, [r6, #20]
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
34808640:	e1a01004 	mov	r1, r4
	oobbuf = malloc(mtd->oobsize);
	if (!datbuf || !oobbuf) {
		puts("No memory for page buffer\n");
		return 1;
	}
	off &= ~(mtd->writesize - 1);
34808644:	e26aa000 	rsb	sl, sl, #0
34808648:	e009a00a 	and	sl, r9, sl
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
3480864c:	e28d9038 	add	r9, sp, #56	; 0x38
34808650:	e3a02020 	mov	r2, #32
34808654:	e1a00009 	mov	r0, r9
34808658:	eb0050a7 	bl	3481c8fc <memset>
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
3480865c:	e5963014 	ldr	r3, [r6, #20]
		return 1;
	}
	off &= ~(mtd->writesize - 1);
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
34808660:	e58d5050 	str	r5, [sp, #80]	; 0x50
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
34808664:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	ops.ooblen = mtd->oobsize;
34808668:	e5963018 	ldr	r3, [r6, #24]
	ops.retlen = 0;
	i = mtd->read_oob(mtd, addr, &ops);
3480866c:	e58d9000 	str	r9, [sp]
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
	ops.ooblen = mtd->oobsize;
34808670:	e58d3044 	str	r3, [sp, #68]	; 0x44
	ops.retlen = 0;
	i = mtd->read_oob(mtd, addr, &ops);
34808674:	e596104c 	ldr	r1, [r6, #76]	; 0x4c
	}
	off &= ~(mtd->writesize - 1);
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
34808678:	e58d7054 	str	r7, [sp, #84]	; 0x54
	ops.len = mtd->writesize;
	ops.ooblen = mtd->oobsize;
	ops.retlen = 0;
3480867c:	e58d4040 	str	r4, [sp, #64]	; 0x40
	i = mtd->read_oob(mtd, addr, &ops);
34808680:	e1a00006 	mov	r0, r6
34808684:	e1a0200a 	mov	r2, sl
34808688:	e1a03004 	mov	r3, r4
3480868c:	e12fff31 	blx	r1
	if (i < 0) {
34808690:	e2501000 	subs	r1, r0, #0
34808694:	aa000008 	bge	348086bc <onenand_dump+0xd4>
		printf("Error (%d) reading page %08lx\n", i, off);
34808698:	e1a0200a 	mov	r2, sl
3480869c:	e59f014c 	ldr	r0, [pc, #332]	; 348087f0 <onenand_dump+0x208>
348086a0:	eb000544 	bl	34809bb8 <printf>
		free(datbuf);
348086a4:	e1a00005 	mov	r0, r5
348086a8:	eb000680 	bl	3480a0b0 <free>
		free(oobbuf);
348086ac:	e1a00007 	mov	r0, r7
348086b0:	eb00067e 	bl	3480a0b0 <free>
		return 1;
348086b4:	e3a00001 	mov	r0, #1
348086b8:	ea000049 	b	348087e4 <onenand_dump+0x1fc>
	}
	printf("Page %08lx dump:\n", off);
348086bc:	e1a0100a 	mov	r1, sl
348086c0:	e59f012c 	ldr	r0, [pc, #300]	; 348087f4 <onenand_dump+0x20c>
348086c4:	eb00053b 	bl	34809bb8 <printf>
	i = mtd->writesize >> 4;
348086c8:	e596a014 	ldr	sl, [r6, #20]
	p = datbuf;

	while (i--) {
348086cc:	e1a04005 	mov	r4, r5
		free(datbuf);
		free(oobbuf);
		return 1;
	}
	printf("Page %08lx dump:\n", off);
	i = mtd->writesize >> 4;
348086d0:	e1a0a22a 	lsr	sl, sl, #4
	p = datbuf;

	while (i--) {
348086d4:	ea000022 	b	34808764 <onenand_dump+0x17c>
		if (!only_oob)
348086d8:	e35b0000 	cmp	fp, #0
348086dc:	1a00001e 	bne	3480875c <onenand_dump+0x174>
			printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
348086e0:	e5d40003 	ldrb	r0, [r4, #3]
348086e4:	e5d41000 	ldrb	r1, [r4]
348086e8:	e5d42001 	ldrb	r2, [r4, #1]
348086ec:	e5d43002 	ldrb	r3, [r4, #2]
348086f0:	e58d0000 	str	r0, [sp]
348086f4:	e5d40004 	ldrb	r0, [r4, #4]
348086f8:	e58d0004 	str	r0, [sp, #4]
348086fc:	e5d40005 	ldrb	r0, [r4, #5]
34808700:	e58d0008 	str	r0, [sp, #8]
34808704:	e5d40006 	ldrb	r0, [r4, #6]
34808708:	e58d000c 	str	r0, [sp, #12]
3480870c:	e5d40007 	ldrb	r0, [r4, #7]
34808710:	e58d0010 	str	r0, [sp, #16]
34808714:	e5d40008 	ldrb	r0, [r4, #8]
34808718:	e58d0014 	str	r0, [sp, #20]
3480871c:	e5d40009 	ldrb	r0, [r4, #9]
34808720:	e58d0018 	str	r0, [sp, #24]
34808724:	e5d4000a 	ldrb	r0, [r4, #10]
34808728:	e58d001c 	str	r0, [sp, #28]
3480872c:	e5d4000b 	ldrb	r0, [r4, #11]
34808730:	e58d0020 	str	r0, [sp, #32]
34808734:	e5d4000c 	ldrb	r0, [r4, #12]
34808738:	e58d0024 	str	r0, [sp, #36]	; 0x24
3480873c:	e5d4000d 	ldrb	r0, [r4, #13]
34808740:	e58d0028 	str	r0, [sp, #40]	; 0x28
34808744:	e5d4000e 	ldrb	r0, [r4, #14]
34808748:	e58d002c 	str	r0, [sp, #44]	; 0x2c
3480874c:	e5d4000f 	ldrb	r0, [r4, #15]
34808750:	e58d0030 	str	r0, [sp, #48]	; 0x30
34808754:	e59f009c 	ldr	r0, [pc, #156]	; 348087f8 <onenand_dump+0x210>
34808758:	eb000516 	bl	34809bb8 <printf>
			       "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
3480875c:	e2844010 	add	r4, r4, #16
34808760:	e24aa001 	sub	sl, sl, #1
	}
	printf("Page %08lx dump:\n", off);
	i = mtd->writesize >> 4;
	p = datbuf;

	while (i--) {
34808764:	e35a0000 	cmp	sl, #0
34808768:	1affffda 	bne	348086d8 <onenand_dump+0xf0>
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
	}
	puts("OOB:\n");
3480876c:	e59f0088 	ldr	r0, [pc, #136]	; 348087fc <onenand_dump+0x214>
34808770:	eb000506 	bl	34809b90 <puts>
	i = mtd->oobsize >> 3;
34808774:	e5966018 	ldr	r6, [r6, #24]
34808778:	e1a04007 	mov	r4, r7
3480877c:	e1a061a6 	lsr	r6, r6, #3
	p = oobbuf;

	while (i--) {
34808780:	ea00000f 	b	348087c4 <onenand_dump+0x1dc>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
34808784:	e5540005 	ldrb	r0, [r4, #-5]
34808788:	e5541008 	ldrb	r1, [r4, #-8]
3480878c:	e5542007 	ldrb	r2, [r4, #-7]
34808790:	e5543006 	ldrb	r3, [r4, #-6]
34808794:	e58d0000 	str	r0, [sp]
34808798:	e5540004 	ldrb	r0, [r4, #-4]
3480879c:	e2466001 	sub	r6, r6, #1
348087a0:	e58d0004 	str	r0, [sp, #4]
348087a4:	e5540003 	ldrb	r0, [r4, #-3]
348087a8:	e58d0008 	str	r0, [sp, #8]
348087ac:	e5540002 	ldrb	r0, [r4, #-2]
348087b0:	e58d000c 	str	r0, [sp, #12]
348087b4:	e5540001 	ldrb	r0, [r4, #-1]
348087b8:	e58d0010 	str	r0, [sp, #16]
348087bc:	e59f003c 	ldr	r0, [pc, #60]	; 34808800 <onenand_dump+0x218>
348087c0:	eb0004fc 	bl	34809bb8 <printf>
	}
	puts("OOB:\n");
	i = mtd->oobsize >> 3;
	p = oobbuf;

	while (i--) {
348087c4:	e3560000 	cmp	r6, #0
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
348087c8:	e2844008 	add	r4, r4, #8
	}
	puts("OOB:\n");
	i = mtd->oobsize >> 3;
	p = oobbuf;

	while (i--) {
348087cc:	1affffec 	bne	34808784 <onenand_dump+0x19c>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
		       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
		p += 8;
	}
	free(datbuf);
348087d0:	e1a00005 	mov	r0, r5
348087d4:	eb000635 	bl	3480a0b0 <free>
	free(oobbuf);
348087d8:	e1a00007 	mov	r0, r7
348087dc:	eb000633 	bl	3480a0b0 <free>

	return 0;
348087e0:	e1a00006 	mov	r0, r6
}
348087e4:	e28dd058 	add	sp, sp, #88	; 0x58
348087e8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348087ec:	34825ba3 	.word	0x34825ba3
348087f0:	34825bbe 	.word	0x34825bbe
348087f4:	34825bdd 	.word	0x34825bdd
348087f8:	34825bef 	.word	0x34825bef
348087fc:	34825c42 	.word	0x34825c42
34808800:	34825c48 	.word	0x34825c48

34808804 <do_onenand_dump>:
{
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
34808804:	e3520001 	cmp	r2, #1

	return ret == 0 ? 0 : 1;
}

static int do_onenand_dump(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808808:	e92d4038 	push	{r3, r4, r5, lr}
3480880c:	e1a05003 	mov	r5, r3
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
34808810:	da00001b 	ble	34808884 <do_onenand_dump+0x80>
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
34808814:	e5930000 	ldr	r0, [r3]
34808818:	e3a0102e 	mov	r1, #46	; 0x2e
3480881c:	eb004f80 	bl	3481c624 <strchr>
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34808820:	e3a01000 	mov	r1, #0
	char *s;

	if (argc < 2)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
34808824:	e1a04000 	mov	r4, r0
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34808828:	e3a02010 	mov	r2, #16
3480882c:	e5950004 	ldr	r0, [r5, #4]
34808830:	eb005324 	bl	3481d4c8 <simple_strtoul>

	if (s != NULL && strcmp(s, ".oob") == 0)
34808834:	e3540000 	cmp	r4, #0

	if (argc < 2)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34808838:	e1a05000 	mov	r5, r0

	if (s != NULL && strcmp(s, ".oob") == 0)
3480883c:	0a000008 	beq	34808864 <do_onenand_dump+0x60>
34808840:	e1a00004 	mov	r0, r4
34808844:	e59f1040 	ldr	r1, [pc, #64]	; 3480888c <do_onenand_dump+0x88>
34808848:	eb004f57 	bl	3481c5ac <strcmp>
3480884c:	e3500000 	cmp	r0, #0
		ret = onenand_dump(mtd, ofs, 1);
34808850:	059f3038 	ldreq	r3, [pc, #56]	; 34808890 <do_onenand_dump+0x8c>
34808854:	01a01005 	moveq	r1, r5
34808858:	05930000 	ldreq	r0, [r3]
3480885c:	03a02001 	moveq	r2, #1
34808860:	0a000003 	beq	34808874 <do_onenand_dump+0x70>
	else
		ret = onenand_dump(mtd, ofs, 0);
34808864:	e59f3024 	ldr	r3, [pc, #36]	; 34808890 <do_onenand_dump+0x8c>
34808868:	e1a01005 	mov	r1, r5
3480886c:	e5930000 	ldr	r0, [r3]
34808870:	e3a02000 	mov	r2, #0
34808874:	ebffff5b 	bl	348085e8 <onenand_dump>

	return ret == 0 ? 1 : 0;
34808878:	e2700001 	rsbs	r0, r0, #1
3480887c:	33a00000 	movcc	r0, #0
34808880:	e8bd8038 	pop	{r3, r4, r5, pc}
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
		return CMD_RET_USAGE;
34808884:	e3e00000 	mvn	r0, #0
		ret = onenand_dump(mtd, ofs, 1);
	else
		ret = onenand_dump(mtd, ofs, 0);

	return ret == 0 ? 1 : 0;
}
34808888:	e8bd8038 	pop	{r3, r4, r5, pc}
3480888c:	34825b4d 	.word	0x34825b4d
34808890:	3482a008 	.word	0x3482a008

34808894 <do_onenand_test>:

	return ret == 0 ? 0 : 1;
}

static int do_onenand_test(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808894:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand test [force] [off size]
	 */

	printf("\nOneNAND test: ");
34808898:	e59f0258 	ldr	r0, [pc, #600]	; 34808af8 <do_onenand_test+0x264>

	return ret == 0 ? 0 : 1;
}

static int do_onenand_test(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480889c:	e24dd078 	sub	sp, sp, #120	; 0x78
348088a0:	e1a04002 	mov	r4, r2
348088a4:	e1a06003 	mov	r6, r3
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand test [force] [off size]
	 */

	printf("\nOneNAND test: ");
348088a8:	eb0004c2 	bl	34809bb8 <printf>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
348088ac:	e2861004 	add	r1, r6, #4
348088b0:	e2440001 	sub	r0, r4, #1
348088b4:	e28d2074 	add	r2, sp, #116	; 0x74
348088b8:	e28d3070 	add	r3, sp, #112	; 0x70
348088bc:	ebfffe8e 	bl	348082fc <arg_off_size>
348088c0:	e2501000 	subs	r1, r0, #0
		return 1;
348088c4:	13a00001 	movne	r0, #1
	 */

	printf("\nOneNAND test: ");

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
348088c8:	1a000088 	bne	34808af0 <do_onenand_test+0x25c>
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
348088cc:	e59f6228 	ldr	r6, [pc, #552]	; 34808afc <do_onenand_test+0x268>
	struct erase_info instr = {
348088d0:	e3a02048 	mov	r2, #72	; 0x48
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
348088d4:	e5963000 	ldr	r3, [r6]
	struct erase_info instr = {
348088d8:	e28d0020 	add	r0, sp, #32
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
348088dc:	e5937094 	ldr	r7, [r3, #148]	; 0x94

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);
348088e0:	e59d4074 	ldr	r4, [sp, #116]	; 0x74
348088e4:	e59db070 	ldr	fp, [sp, #112]	; 0x70
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
	struct erase_info instr = {
348088e8:	eb005003 	bl	3481c8fc <memset>
		.priv		= 0,
	};

	int blocks;
	loff_t ofs;
	int blocksize = 1 << this->erase_shift;
348088ec:	e5973030 	ldr	r3, [r7, #48]	; 0x30
348088f0:	e3a0a001 	mov	sl, #1
348088f4:	e1a0a31a 	lsl	sl, sl, r3
	size_t retlen;
	u_char *buf;
	u_char *verify_buf;
	int ret;

	buf = malloc(blocksize);
348088f8:	e1a0000a 	mov	r0, sl
348088fc:	eb000674 	bl	3480a2d4 <malloc>
	if (!buf) {
34808900:	e3500000 	cmp	r0, #0
34808904:	e58d0010 	str	r0, [sp, #16]
34808908:	0a000004 	beq	34808920 <do_onenand_test+0x8c>
		printf("Not enough malloc space available!\n");
		return -1;
	}

	verify_buf = malloc(blocksize);
3480890c:	e1a0000a 	mov	r0, sl
34808910:	eb00066f 	bl	3480a2d4 <malloc>
	if (!verify_buf) {
34808914:	e3500000 	cmp	r0, #0
34808918:	e58d0014 	str	r0, [sp, #20]
3480891c:	1a000004 	bne	34808934 <do_onenand_test+0xa0>
		printf("Not enough malloc space available!\n");
34808920:	e59f01d8 	ldr	r0, [pc, #472]	; 34808b00 <do_onenand_test+0x26c>
34808924:	eb0004a3 	bl	34809bb8 <printf>
	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;
34808928:	e3e04000 	mvn	r4, #0
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
3480892c:	e59f11d0 	ldr	r1, [pc, #464]	; 34808b04 <do_onenand_test+0x270>
34808930:	ea00006b 	b	34808ae4 <do_onenand_test+0x250>
	if (!verify_buf) {
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
34808934:	e5972030 	ldr	r2, [r7, #48]	; 0x30

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
34808938:	e5963000 	ldr	r3, [r6]
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;
3480893c:	e08bb004 	add	fp, fp, r4
34808940:	e1a0b23b 	lsr	fp, fp, r2

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
34808944:	e1c300d8 	ldrd	r0, [r3, #8]
	if (!verify_buf) {
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
34808948:	e1a09234 	lsr	r9, r4, r2

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
3480894c:	eb005e69 	bl	348202f8 <__lshrdi3>
34808950:	e1a0200b 	mov	r2, fp
34808954:	e1a03fc2 	asr	r3, r2, #31
	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;
34808958:	e3590002 	cmp	r9, #2
3480895c:	b3a09002 	movlt	r9, #2

	if (end_block > (mtd->size >> this->erase_shift))
34808960:	e1530001 	cmp	r3, r1
34808964:	8a000002 	bhi	34808974 <do_onenand_test+0xe0>
34808968:	1a000002 	bne	34808978 <do_onenand_test+0xe4>
3480896c:	e1520000 	cmp	r2, r0
34808970:	9a000000 	bls	34808978 <do_onenand_test+0xe4>
		end_block = mtd->size >> this->erase_shift;
34808974:	e1a0b000 	mov	fp, r0
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808978:	e1a0200a 	mov	r2, sl
3480897c:	e1a03fc2 	asr	r3, r2, #31

	if (end_block > (mtd->size >> this->erase_shift))
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
34808980:	e3a05000 	mov	r5, #0
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
34808984:	e59f6170 	ldr	r6, [pc, #368]	; 34808afc <do_onenand_test+0x268>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808988:	e1cd21f8 	strd	r2, [sp, #24]
3480898c:	ea00004a 	b	34808abc <do_onenand_test+0x228>
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);
34808990:	e5972030 	ldr	r2, [r7, #48]	; 0x30
34808994:	e1a00004 	mov	r0, r4
34808998:	e1a01005 	mov	r1, r5
3480899c:	eb005e5c 	bl	34820314 <__ashrdi3>
348089a0:	e1a02004 	mov	r2, r4
348089a4:	e1a01000 	mov	r1, r0
348089a8:	e59f0158 	ldr	r0, [pc, #344]	; 34808b08 <do_onenand_test+0x274>
348089ac:	eb000481 	bl	34809bb8 <printf>

		ret = mtd->block_isbad(mtd, ofs);
348089b0:	e5960000 	ldr	r0, [r6]
348089b4:	e1a02004 	mov	r2, r4
348089b8:	e5901078 	ldr	r1, [r0, #120]	; 0x78
348089bc:	e1a03005 	mov	r3, r5
348089c0:	e12fff31 	blx	r1
		if (ret) {
348089c4:	e3500000 	cmp	r0, #0
348089c8:	0a000007 	beq	348089ec <do_onenand_test+0x158>
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348089cc:	e5972030 	ldr	r2, [r7, #48]	; 0x30
348089d0:	e1a00004 	mov	r0, r4
348089d4:	e1a01005 	mov	r1, r5
348089d8:	eb005e4d 	bl	34820314 <__ashrdi3>
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printf("Skip erase bad block %d at 0x%x\n",
348089dc:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348089e0:	e1a01000 	mov	r1, r0
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printf("Skip erase bad block %d at 0x%x\n",
348089e4:	e59f0120 	ldr	r0, [pc, #288]	; 34808b0c <do_onenand_test+0x278>
348089e8:	ea00000a 	b	34808a18 <do_onenand_test+0x184>
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
		ret = mtd->erase(mtd, &instr);
348089ec:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
348089f0:	e1cd21d8 	ldrd	r2, [sp, #24]
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
348089f4:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
		instr.len = blocksize;
348089f8:	e1cd23f0 	strd	r2, [sp, #48]	; 0x30
		ret = mtd->erase(mtd, &instr);
348089fc:	e28d1020 	add	r1, sp, #32
34808a00:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34808a04:	e12fff33 	blx	r3
		if (ret) {
34808a08:	e2502000 	subs	r2, r0, #0
34808a0c:	0a000003 	beq	34808a20 <do_onenand_test+0x18c>
			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
34808a10:	e59f00f8 	ldr	r0, [pc, #248]	; 34808b10 <do_onenand_test+0x27c>
34808a14:	e1a01004 	mov	r1, r4
34808a18:	eb000466 	bl	34809bb8 <printf>
34808a1c:	ea000022 	b	34808aac <do_onenand_test+0x218>
			goto next;
		}

		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
34808a20:	e59d2010 	ldr	r2, [sp, #16]
34808a24:	e5960000 	ldr	r0, [r6]
34808a28:	e28d306c 	add	r3, sp, #108	; 0x6c
34808a2c:	e58d3004 	str	r3, [sp, #4]
34808a30:	e58d2008 	str	r2, [sp, #8]
34808a34:	e58da000 	str	sl, [sp]
34808a38:	e1a02004 	mov	r2, r4
34808a3c:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34808a40:	e1a03005 	mov	r3, r5
34808a44:	e12fff31 	blx	r1
		if (ret) {
34808a48:	e2502000 	subs	r2, r0, #0
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
34808a4c:	159f00c0 	ldrne	r0, [pc, #192]	; 34808b14 <do_onenand_test+0x280>
			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
		if (ret) {
34808a50:	1affffef 	bne	34808a14 <do_onenand_test+0x180>
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
34808a54:	e59d2014 	ldr	r2, [sp, #20]
34808a58:	e5960000 	ldr	r0, [r6]
34808a5c:	e28d306c 	add	r3, sp, #108	; 0x6c
34808a60:	e58d3004 	str	r3, [sp, #4]
34808a64:	e58d2008 	str	r2, [sp, #8]
34808a68:	e58da000 	str	sl, [sp]
34808a6c:	e1a02004 	mov	r2, r4
34808a70:	e5901040 	ldr	r1, [r0, #64]	; 0x40
34808a74:	e1a03005 	mov	r3, r5
34808a78:	e12fff31 	blx	r1
		if (ret) {
34808a7c:	e2502000 	subs	r2, r0, #0
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
34808a80:	159f0090 	ldrne	r0, [pc, #144]	; 34808b18 <do_onenand_test+0x284>
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
		if (ret) {
34808a84:	1affffe2 	bne	34808a14 <do_onenand_test+0x180>
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		if (memcmp(buf, verify_buf, blocksize))
34808a88:	e59d0010 	ldr	r0, [sp, #16]
34808a8c:	e59d1014 	ldr	r1, [sp, #20]
34808a90:	e1a0200a 	mov	r2, sl
34808a94:	eb004fef 	bl	3481ca58 <memcmp>
34808a98:	e3500000 	cmp	r0, #0
34808a9c:	0a000002 	beq	34808aac <do_onenand_test+0x218>
			printk("\nRead/Write test failed at 0x%x\n", (u32)ofs);
34808aa0:	e59f0074 	ldr	r0, [pc, #116]	; 34808b1c <do_onenand_test+0x288>
34808aa4:	e1a01004 	mov	r1, r4
34808aa8:	eb000442 	bl	34809bb8 <printf>

next:
		ofs += blocksize;
34808aac:	e1cd21d8 	ldrd	r2, [sp, #24]
34808ab0:	e0944002 	adds	r4, r4, r2
34808ab4:	e0a55003 	adc	r5, r5, r3
		blocks++;
34808ab8:	e2899001 	add	r9, r9, #1
	if (end_block > (mtd->size >> this->erase_shift))
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
	while (blocks < end_block) {
34808abc:	e159000b 	cmp	r9, fp
34808ac0:	baffffb2 	blt	34808990 <do_onenand_test+0xfc>

next:
		ofs += blocksize;
		blocks++;
	}
	printf("...Done\n");
34808ac4:	e59f0054 	ldr	r0, [pc, #84]	; 34808b20 <do_onenand_test+0x28c>
34808ac8:	eb00043a 	bl	34809bb8 <printf>

	free(buf);
34808acc:	e59d0010 	ldr	r0, [sp, #16]
34808ad0:	eb000576 	bl	3480a0b0 <free>
	free(verify_buf);
34808ad4:	e59d0014 	ldr	r0, [sp, #20]
34808ad8:	eb000574 	bl	3480a0b0 <free>
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
34808adc:	e59f1040 	ldr	r1, [pc, #64]	; 34808b24 <do_onenand_test+0x290>
	printf("...Done\n");

	free(buf);
	free(verify_buf);

	return 0;
34808ae0:	e3a04000 	mov	r4, #0
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
34808ae4:	e59f003c 	ldr	r0, [pc, #60]	; 34808b28 <do_onenand_test+0x294>
34808ae8:	eb000432 	bl	34809bb8 <printf>

	return ret == 0 ? 0 : 1;
34808aec:	e2640000 	rsb	r0, r4, #0
}
34808af0:	e28dd078 	add	sp, sp, #120	; 0x78
34808af4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808af8:	34825c72 	.word	0x34825c72
34808afc:	3482a008 	.word	0x3482a008
34808b00:	34825c82 	.word	0x34825c82
34808b04:	34824380 	.word	0x34824380
34808b08:	34825ca6 	.word	0x34825ca6
34808b0c:	34825cc0 	.word	0x34825cc0
34808b10:	34825ce1 	.word	0x34825ce1
34808b14:	34825cf8 	.word	0x34825cf8
34808b18:	34825b79 	.word	0x34825b79
34808b1c:	34825d0f 	.word	0x34825d0f
34808b20:	34825d30 	.word	0x34825d30
34808b24:	3482437d 	.word	0x3482437d
34808b28:	34826164 	.word	0x34826164

34808b2c <do_onenand_write>:

	return ret == 0 ? 0 : 1;
}

static int do_onenand_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808b2c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong addr, ofs;
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
34808b30:	e3520002 	cmp	r2, #2

	return ret == 0 ? 0 : 1;
}

static int do_onenand_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808b34:	e24dd078 	sub	sp, sp, #120	; 0x78
34808b38:	e1a04002 	mov	r4, r2
34808b3c:	e1a07003 	mov	r7, r3
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;
34808b40:	d3e00000 	mvnle	r0, #0
	ulong addr, ofs;
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
34808b44:	da0000b5 	ble	34808e20 <do_onenand_write+0x2f4>
		return CMD_RET_USAGE;

	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
34808b48:	e5930000 	ldr	r0, [r3]
34808b4c:	e59f12d4 	ldr	r1, [pc, #724]	; 34808e28 <do_onenand_write+0x2fc>
34808b50:	e3a02005 	mov	r2, #5
34808b54:	e2800006 	add	r0, r0, #6
34808b58:	eb004e9f 	bl	3481c5dc <strncmp>
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808b5c:	e3a01000 	mov	r1, #0
34808b60:	e3a02010 	mov	r2, #16
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;

	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
34808b64:	e58d001c 	str	r0, [sp, #28]
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808b68:	e5970004 	ldr	r0, [r7, #4]
34808b6c:	eb005255 	bl	3481d4c8 <simple_strtoul>
34808b70:	e1a06000 	mov	r6, r0

	printf("\nOneNAND write: ");
34808b74:	e59f02b0 	ldr	r0, [pc, #688]	; 34808e2c <do_onenand_write+0x300>
34808b78:	eb00040e 	bl	34809bb8 <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808b7c:	e2440002 	sub	r0, r4, #2
34808b80:	e2871008 	add	r1, r7, #8
34808b84:	e28d2074 	add	r2, sp, #116	; 0x74
34808b88:	e28d3070 	add	r3, sp, #112	; 0x70
34808b8c:	ebfffdda 	bl	348082fc <arg_off_size>
34808b90:	e3500000 	cmp	r0, #0
		return 1;
34808b94:	13a00001 	movne	r0, #1
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808b98:	1a0000a0 	bne	34808e20 <do_onenand_write+0x2f4>
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808b9c:	e59fc28c 	ldr	ip, [pc, #652]	; 34808e30 <do_onenand_write+0x304>

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808ba0:	e59d1070 	ldr	r1, [sp, #112]	; 0x70
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808ba4:	e59c3000 	ldr	r3, [ip]

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808ba8:	e59d4074 	ldr	r4, [sp, #116]	; 0x74
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808bac:	e5933094 	ldr	r3, [r3, #148]	; 0x94

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808bb0:	e3a05000 	mov	r5, #0
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808bb4:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int blocks = len >> this->erase_shift;
34808bb8:	e5933030 	ldr	r3, [r3, #48]	; 0x30

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808bbc:	e58d6014 	str	r6, [sp, #20]

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
34808bc0:	e1a02331 	lsr	r2, r1, r3
34808bc4:	e58d2018 	str	r2, [sp, #24]
	int blocksize = (1 << this->erase_shift);
34808bc8:	e3a02001 	mov	r2, #1
34808bcc:	e1a02312 	lsl	r2, r2, r3
	loff_t ofs;
	size_t _retlen = 0;
	int ret;

	if (to == next_ofs) {
34808bd0:	e59c3008 	ldr	r3, [ip, #8]
static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
34808bd4:	e58d2024 	str	r2, [sp, #36]	; 0x24
	loff_t ofs;
	size_t _retlen = 0;
	int ret;

	if (to == next_ofs) {
34808bd8:	e1530004 	cmp	r3, r4
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
	loff_t ofs;
	size_t _retlen = 0;
34808bdc:	e58d006c 	str	r0, [sp, #108]	; 0x6c
	int ret;

	if (to == next_ofs) {
34808be0:	1a000010 	bne	34808c28 <do_onenand_write+0xfc>
34808be4:	e59c300c 	ldr	r3, [ip, #12]
34808be8:	e3530000 	cmp	r3, #0
34808bec:	1a00000d 	bne	34808c28 <do_onenand_write+0xfc>
		next_ofs = to + len;
34808bf0:	e0942001 	adds	r2, r4, r1
34808bf4:	e2a53000 	adc	r3, r5, #0
34808bf8:	e1cc20f8 	strd	r2, [ip, #8]
		to += skip_ofs;
34808bfc:	e1cc21d0 	ldrd	r2, [ip, #16]
34808c00:	e0944002 	adds	r4, r4, r2
34808c04:	e0a55003 	adc	r5, r5, r3
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
34808c08:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
34808c0c:	e3a03000 	mov	r3, #0
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
34808c10:	e1a00001 	mov	r0, r1
34808c14:	e1a01fc0 	asr	r1, r0, #31
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
34808c18:	e58d3020 	str	r3, [sp, #32]
		skip_ofs = 0;
	}
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
34808c1c:	e59f620c 	ldr	r6, [pc, #524]	; 34808e30 <do_onenand_write+0x304>
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
34808c20:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
34808c24:	ea000075 	b	34808e00 <do_onenand_write+0x2d4>

	if (to == next_ofs) {
		next_ofs = to + len;
		to += skip_ofs;
	} else {
		next_ofs = to + len;
34808c28:	e0942001 	adds	r2, r4, r1
34808c2c:	e59f01fc 	ldr	r0, [pc, #508]	; 34808e30 <do_onenand_write+0x304>
34808c30:	e2a53000 	adc	r3, r5, #0
34808c34:	e1c020f8 	strd	r2, [r0, #8]
		skip_ofs = 0;
34808c38:	e3a02000 	mov	r2, #0
34808c3c:	e3a03000 	mov	r3, #0
34808c40:	e1c021f0 	strd	r2, [r0, #16]
34808c44:	eaffffef 	b	34808c08 <do_onenand_write+0xdc>
	}
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
34808c48:	e5960000 	ldr	r0, [r6]
34808c4c:	e1a02004 	mov	r2, r4
34808c50:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808c54:	e1a03005 	mov	r3, r5
34808c58:	e12fff31 	blx	r1
		if (ret) {
34808c5c:	e3500000 	cmp	r0, #0
34808c60:	e58d0010 	str	r0, [sp, #16]
34808c64:	0a000008 	beq	34808c8c <do_onenand_write+0x160>
			printk("Bad blocks %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808c68:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
34808c6c:	e1a00004 	mov	r0, r4
34808c70:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34808c74:	e1a01005 	mov	r1, r5
34808c78:	eb005da5 	bl	34820314 <__ashrdi3>
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808c7c:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808c80:	e1a01000 	mov	r1, r0
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808c84:	e59f01a8 	ldr	r0, [pc, #424]	; 34808e34 <do_onenand_write+0x308>
34808c88:	ea000047 	b	34808dac <do_onenand_write+0x280>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			skip_ofs += blocksize;
			goto next;
		}

		if (!withoob)
34808c8c:	e59d101c 	ldr	r1, [sp, #28]
34808c90:	e3510000 	cmp	r1, #0
34808c94:	0a00000b 	beq	34808cc8 <do_onenand_write+0x19c>
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
34808c98:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34808c9c:	e59d1014 	ldr	r1, [sp, #20]
34808ca0:	e5960000 	ldr	r0, [r6]
34808ca4:	e28d306c 	add	r3, sp, #108	; 0x6c
34808ca8:	e88d000c 	stm	sp, {r2, r3}
34808cac:	e58d1008 	str	r1, [sp, #8]
34808cb0:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34808cb4:	e1a02004 	mov	r2, r4
34808cb8:	e1a03005 	mov	r3, r5
34808cbc:	e12fff31 	blx	r1
34808cc0:	e58d0010 	str	r0, [sp, #16]
34808cc4:	ea000032 	b	34808d94 <do_onenand_write+0x268>

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
		.len = mtd->writesize,
34808cc8:	e5963000 	ldr	r3, [r6]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808ccc:	e3a02020 	mov	r2, #32
34808cd0:	e28d004c 	add	r0, sp, #76	; 0x4c
34808cd4:	e59d101c 	ldr	r1, [sp, #28]
		.len = mtd->writesize,
34808cd8:	e5937014 	ldr	r7, [r3, #20]
		.ooblen = mtd->oobsize,
34808cdc:	e593a018 	ldr	sl, [r3, #24]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808ce0:	eb004f05 	bl	3481c8fc <memset>
		.len = mtd->writesize,
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808ce4:	e59dc01c 	ldr	ip, [sp, #28]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808ce8:	e3a02001 	mov	r2, #1
34808cec:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
34808cf0:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
34808cf4:	e58d204c 	str	r2, [sp, #76]	; 0x4c
34808cf8:	e58d7050 	str	r7, [sp, #80]	; 0x50
34808cfc:	e58da058 	str	sl, [sp, #88]	; 0x58
34808d00:	e59d9014 	ldr	r9, [sp, #20]
34808d04:	e1a0400c 	mov	r4, ip
34808d08:	ea000013 	b	34808d5c <do_onenand_write+0x230>
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
34808d0c:	e28d304c 	add	r3, sp, #76	; 0x4c
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
34808d10:	e58d9064 	str	r9, [sp, #100]	; 0x64
		buf += mtd->writesize;
34808d14:	e0899007 	add	r9, r9, r7
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
34808d18:	e59b7018 	ldr	r7, [fp, #24]
		ret = mtd->write_oob(mtd, to, &ops);
34808d1c:	e58d3000 	str	r3, [sp]
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
34808d20:	e58d9068 	str	r9, [sp, #104]	; 0x68
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
34808d24:	e59b1050 	ldr	r1, [fp, #80]	; 0x50
34808d28:	e1a0000b 	mov	r0, fp
34808d2c:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
34808d30:	e12fff31 	blx	r1
		if (ret)
34808d34:	e3500000 	cmp	r0, #0
34808d38:	1a000011 	bne	34808d84 <do_onenand_write+0x258>
			break;
		to += mtd->writesize;
34808d3c:	e5963000 	ldr	r3, [r6]
34808d40:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
34808d44:	e5933014 	ldr	r3, [r3, #20]
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
34808d48:	e0899007 	add	r9, r9, r7
		ret = mtd->write_oob(mtd, to, &ops);
		if (ret)
			break;
		to += mtd->writesize;
34808d4c:	e0900003 	adds	r0, r0, r3
34808d50:	e2a11000 	adc	r1, r1, #0
34808d54:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
		.len = mtd->writesize,
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808d58:	e2844001 	add	r4, r4, #1
34808d5c:	e596b000 	ldr	fp, [r6]
34808d60:	e59ba010 	ldr	sl, [fp, #16]
34808d64:	e59b7014 	ldr	r7, [fp, #20]
34808d68:	e1a0000a 	mov	r0, sl
34808d6c:	e1a01007 	mov	r1, r7
34808d70:	eb005c4d 	bl	3481feac <__udivsi3>
34808d74:	e1540000 	cmp	r4, r0
34808d78:	3affffe3 	bcc	34808d0c <do_onenand_write+0x1e0>
34808d7c:	e1cd44d0 	ldrd	r4, [sp, #64]	; 0x40
34808d80:	ea000002 	b	34808d90 <do_onenand_write+0x264>
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
34808d84:	e58d0010 	str	r0, [sp, #16]
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
34808d88:	e3a0a000 	mov	sl, #0
34808d8c:	e1cd44d0 	ldrd	r4, [sp, #64]	; 0x40
34808d90:	e58da06c 	str	sl, [sp, #108]	; 0x6c

		if (!withoob)
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
34808d94:	e59d1010 	ldr	r1, [sp, #16]
34808d98:	e3510000 	cmp	r1, #0
34808d9c:	0a000009 	beq	34808dc8 <do_onenand_write+0x29c>
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
34808da0:	e59f0090 	ldr	r0, [pc, #144]	; 34808e38 <do_onenand_write+0x30c>
34808da4:	e59d2010 	ldr	r2, [sp, #16]
34808da8:	e1a01004 	mov	r1, r4
34808dac:	eb000381 	bl	34809bb8 <printf>
			skip_ofs += blocksize;
34808db0:	e1c621d0 	ldrd	r2, [r6, #16]
34808db4:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
34808db8:	e0922000 	adds	r2, r2, r0
34808dbc:	e0a33001 	adc	r3, r3, r1
34808dc0:	e1c621f0 	strd	r2, [r6, #16]
34808dc4:	ea00000a 	b	34808df4 <do_onenand_write+0x2c8>
			goto next;
		}

		buf += blocksize;
		blocks--;
34808dc8:	e59d3018 	ldr	r3, [sp, #24]
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808dcc:	e59d1014 	ldr	r1, [sp, #20]
		blocks--;
34808dd0:	e2433001 	sub	r3, r3, #1
		*retlen += _retlen;
34808dd4:	e59d0020 	ldr	r0, [sp, #32]
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808dd8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		blocks--;
34808ddc:	e58d3018 	str	r3, [sp, #24]
		*retlen += _retlen;
34808de0:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808de4:	e0811002 	add	r1, r1, r2
		blocks--;
		*retlen += _retlen;
34808de8:	e0800003 	add	r0, r0, r3
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808dec:	e58d1014 	str	r1, [sp, #20]
		blocks--;
		*retlen += _retlen;
34808df0:	e58d0020 	str	r0, [sp, #32]
next:
		ofs += blocksize;
34808df4:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
34808df8:	e0944002 	adds	r4, r4, r2
34808dfc:	e0a55003 	adc	r5, r5, r3
		next_ofs = to + len;
		skip_ofs = 0;
	}
	ofs = to;

	while (blocks) {
34808e00:	e59d3018 	ldr	r3, [sp, #24]
34808e04:	e3530000 	cmp	r3, #0
34808e08:	1affff8e 	bne	34808c48 <do_onenand_write+0x11c>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);

	printf(" %d bytes written: %s\n", retlen, ret ? "ERROR" : "OK");
34808e0c:	e59f0028 	ldr	r0, [pc, #40]	; 34808e3c <do_onenand_write+0x310>
34808e10:	e59d1020 	ldr	r1, [sp, #32]
34808e14:	e59f2024 	ldr	r2, [pc, #36]	; 34808e40 <do_onenand_write+0x314>
34808e18:	eb000366 	bl	34809bb8 <printf>

	return ret == 0 ? 0 : 1;
34808e1c:	e59d0018 	ldr	r0, [sp, #24]
}
34808e20:	e28dd078 	add	sp, sp, #120	; 0x78
34808e24:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808e28:	34825fbe 	.word	0x34825fbe
34808e2c:	34825d39 	.word	0x34825d39
34808e30:	3482a008 	.word	0x3482a008
34808e34:	34825b62 	.word	0x34825b62
34808e38:	34825d4a 	.word	0x34825d4a
34808e3c:	34825d60 	.word	0x34825d60
34808e40:	3482437d 	.word	0x3482437d

34808e44 <do_onenand_erase>:

static int do_onenand_erase(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808e44:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 *   0       1     2       3    4
	 *   onenand erase [force] [off size]
	 */
	argc--;
	argv++;
	if (argc)
34808e48:	e2526001 	subs	r6, r2, #1

	return ret == 0 ? 0 : 1;
}

static int do_onenand_erase(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34808e4c:	e24dd068 	sub	sp, sp, #104	; 0x68
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand erase [force] [off size]
	 */
	argc--;
	argv++;
34808e50:	e2834004 	add	r4, r3, #4
	if (argc)
34808e54:	0a000005 	beq	34808e70 <do_onenand_erase+0x2c>
	{
		if (!strcmp("force", argv[0]))
34808e58:	e59f0134 	ldr	r0, [pc, #308]	; 34808f94 <do_onenand_erase+0x150>
34808e5c:	e5931004 	ldr	r1, [r3, #4]
34808e60:	eb004dd1 	bl	3481c5ac <strcmp>
34808e64:	e3500000 	cmp	r0, #0
		{
			force = 1;
			argc--;
34808e68:	02466001 	subeq	r6, r6, #1
			argv++;
34808e6c:	02844004 	addeq	r4, r4, #4
		}
	}
	printf("\nOneNAND erase: ");
34808e70:	e59f0120 	ldr	r0, [pc, #288]	; 34808f98 <do_onenand_erase+0x154>
34808e74:	eb00034f 	bl	34809bb8 <printf>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808e78:	e1a00006 	mov	r0, r6
34808e7c:	e1a01004 	mov	r1, r4
34808e80:	e28d2064 	add	r2, sp, #100	; 0x64
34808e84:	e28d3060 	add	r3, sp, #96	; 0x60
34808e88:	ebfffd1b 	bl	348082fc <arg_off_size>
34808e8c:	e2509000 	subs	r9, r0, #0
		return 1;
34808e90:	13a00001 	movne	r0, #1
		}
	}
	printf("\nOneNAND erase: ");

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808e94:	1a00003c 	bne	34808f8c <do_onenand_erase+0x148>
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808e98:	e59f60fc 	ldr	r6, [pc, #252]	; 34808f9c <do_onenand_erase+0x158>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);
34808e9c:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808ea0:	e5962000 	ldr	r2, [r6]
	struct erase_info instr = {
34808ea4:	e28db018 	add	fp, sp, #24
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808ea8:	e5927094 	ldr	r7, [r2, #148]	; 0x94
	struct erase_info instr = {
34808eac:	e1a01009 	mov	r1, r9
34808eb0:	e3a02048 	mov	r2, #72	; 0x48
34808eb4:	e1a0000b 	mov	r0, fp

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);
34808eb8:	e59da064 	ldr	sl, [sp, #100]	; 0x64
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
	struct erase_info instr = {
34808ebc:	e58d3004 	str	r3, [sp, #4]
34808ec0:	eb004e8d 	bl	3481c8fc <memset>
		.callback	= NULL,
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;
34808ec4:	e5971030 	ldr	r1, [r7, #48]	; 0x30
34808ec8:	e3a02001 	mov	r2, #1
34808ecc:	e1a0c112 	lsl	ip, r2, r1

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808ed0:	e59d3004 	ldr	r3, [sp, #4]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808ed4:	e1a0000c 	mov	r0, ip
34808ed8:	e1a01fc0 	asr	r1, r0, #31
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808edc:	e083300a 	add	r3, r3, sl
34808ee0:	e1a0400a 	mov	r4, sl
34808ee4:	e3a05000 	mov	r5, #0
34808ee8:	e58d3014 	str	r3, [sp, #20]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808eec:	e1cd00f8 	strd	r0, [sp, #8]
		instr.priv = force;
34808ef0:	e1a0a002 	mov	sl, r2
34808ef4:	ea00001a 	b	34808f64 <do_onenand_erase+0x120>
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
		ret = mtd->block_isbad(mtd, ofs);
34808ef8:	e5960000 	ldr	r0, [r6]
34808efc:	e1a02004 	mov	r2, r4
34808f00:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808f04:	e1a03005 	mov	r3, r5
34808f08:	e12fff31 	blx	r1
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808f0c:	e1cd20d8 	ldrd	r2, [sp, #8]
		instr.priv = force;
		instr.mtd = mtd;
34808f10:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808f14:	e1cd22f8 	strd	r2, [sp, #40]	; 0x28
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
34808f18:	e1cd42f0 	strd	r4, [sp, #32]
		instr.len = blocksize;
		instr.priv = force;
34808f1c:	e58da04c 	str	sl, [sp, #76]	; 0x4c
		instr.mtd = mtd;
34808f20:	e58d0018 	str	r0, [sp, #24]
		ret = mtd->erase(mtd, &instr);
34808f24:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34808f28:	e1a0100b 	mov	r1, fp
34808f2c:	e12fff33 	blx	r3
		if (ret) {
34808f30:	e3500000 	cmp	r0, #0
34808f34:	0a000007 	beq	34808f58 <do_onenand_erase+0x114>
			printf("erase failed block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808f38:	e5972030 	ldr	r2, [r7, #48]	; 0x30
34808f3c:	e1a00004 	mov	r0, r4
34808f40:	e1a01005 	mov	r1, r5
34808f44:	eb005cf2 	bl	34820314 <__ashrdi3>
		instr.len = blocksize;
		instr.priv = force;
		instr.mtd = mtd;
		ret = mtd->erase(mtd, &instr);
		if (ret) {
			printf("erase failed block %d at 0x%x\n",
34808f48:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808f4c:	e1a01000 	mov	r1, r0
		instr.len = blocksize;
		instr.priv = force;
		instr.mtd = mtd;
		ret = mtd->erase(mtd, &instr);
		if (ret) {
			printf("erase failed block %d at 0x%x\n",
34808f50:	e59f0048 	ldr	r0, [pc, #72]	; 34808fa0 <do_onenand_erase+0x15c>
34808f54:	eb000317 	bl	34809bb8 <printf>
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808f58:	e1cd00d8 	ldrd	r0, [sp, #8]
34808f5c:	e0944000 	adds	r4, r4, r0
34808f60:	e0a55001 	adc	r5, r5, r1
34808f64:	e1590005 	cmp	r9, r5
34808f68:	caffffe2 	bgt	34808ef8 <do_onenand_erase+0xb4>
34808f6c:	1a000002 	bne	34808f7c <do_onenand_erase+0x138>
34808f70:	e59d1014 	ldr	r1, [sp, #20]
34808f74:	e1510004 	cmp	r1, r4
34808f78:	8affffde 	bhi	34808ef8 <do_onenand_erase+0xb4>
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);

	printf("%s\n", ret ? "ERROR" : "OK");
34808f7c:	e59f0020 	ldr	r0, [pc, #32]	; 34808fa4 <do_onenand_erase+0x160>
34808f80:	e59f1020 	ldr	r1, [pc, #32]	; 34808fa8 <do_onenand_erase+0x164>
34808f84:	eb00030b 	bl	34809bb8 <printf>

	return ret == 0 ? 0 : 1;
34808f88:	e3a00000 	mov	r0, #0
}
34808f8c:	e28dd068 	add	sp, sp, #104	; 0x68
34808f90:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808f94:	34825d77 	.word	0x34825d77
34808f98:	34825d7d 	.word	0x34825d7d
34808f9c:	3482a008 	.word	0x3482a008
34808fa0:	34825d8e 	.word	0x34825d8e
34808fa4:	34826164 	.word	0x34826164
34808fa8:	3482437d 	.word	0x3482437d

34808fac <do_reginfo>:
# endif

#endif /* CONFIG_BLACKFIN */

	return 0;
}
34808fac:	e3a00000 	mov	r0, #0
34808fb0:	e12fff1e 	bx	lr

34808fb4 <__fswab32>:
34808fb4:	e6bf0f30 	rev	r0, r0
34808fb8:	e12fff1e 	bx	lr

34808fbc <source>:
#include <mpc8xx.h>
#endif

int
source (ulong addr, const char *fit_uname)
{
34808fbc:	e92d4070 	push	{r4, r5, r6, lr}
34808fc0:	e1a04000 	mov	r4, r0
	int		noffset;
	const void	*fit_data;
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");
34808fc4:	e59f00b0 	ldr	r0, [pc, #176]	; 3480907c <source+0xc0>
34808fc8:	eb0011a9 	bl	3480d674 <getenv_yesno>
34808fcc:	e1a05000 	mov	r5, r0

	switch (genimg_get_format ((void *)addr)) {
34808fd0:	e1a00004 	mov	r0, r4
34808fd4:	eb00129a 	bl	3480da44 <genimg_get_format>
34808fd8:	e3500001 	cmp	r0, #1
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34808fdc:	159f009c 	ldrne	r0, [pc, #156]	; 34809080 <source+0xc4>
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");

	switch (genimg_get_format ((void *)addr)) {
34808fe0:	1a00001f 	bne	34809064 <source+0xa8>
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34808fe4:	e5940000 	ldr	r0, [r4]
34808fe8:	ebfffff1 	bl	34808fb4 <__fswab32>
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
34808fec:	e59f3090 	ldr	r3, [pc, #144]	; 34809084 <source+0xc8>
34808ff0:	e1500003 	cmp	r0, r3
			puts ("Bad magic number\n");
34808ff4:	159f008c 	ldrne	r0, [pc, #140]	; 34809088 <source+0xcc>

	switch (genimg_get_format ((void *)addr)) {
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
34808ff8:	1a000019 	bne	34809064 <source+0xa8>
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
34808ffc:	e1a00004 	mov	r0, r4
34809000:	eb00114e 	bl	3480d540 <image_check_hcrc>
34809004:	e3500000 	cmp	r0, #0
			puts ("Bad header crc\n");
34809008:	059f007c 	ldreq	r0, [pc, #124]	; 3480908c <source+0xd0>
		if (!image_check_magic (hdr)) {
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
3480900c:	0a000014 	beq	34809064 <source+0xa8>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
34809010:	e3550000 	cmp	r5, #0
34809014:	0a000004 	beq	3480902c <source+0x70>
			if (!image_check_dcrc (hdr)) {
34809018:	e1a00004 	mov	r0, r4
3480901c:	eb00115b 	bl	3480d590 <image_check_dcrc>
34809020:	e3500000 	cmp	r0, #0
				puts ("Bad data crc\n");
34809024:	059f0064 	ldreq	r0, [pc, #100]	; 34809090 <source+0xd4>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
			if (!image_check_dcrc (hdr)) {
34809028:	0a00000d 	beq	34809064 <source+0xa8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
3480902c:	e5d4301e 	ldrb	r3, [r4, #30]
34809030:	e3530006 	cmp	r3, #6
			puts ("Bad image type\n");
34809034:	159f0058 	ldrne	r0, [pc, #88]	; 34809094 <source+0xd8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
34809038:	1a000009 	bne	34809064 <source+0xa8>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
3480903c:	e5940040 	ldr	r0, [r4, #64]	; 0x40
34809040:	ebffffdb 	bl	34808fb4 <__fswab32>
34809044:	e2501000 	subs	r1, r0, #0
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
34809048:	e2845040 	add	r5, r4, #64	; 0x40
			puts ("Empty Script\n");
3480904c:	059f0044 	ldreq	r0, [pc, #68]	; 34809098 <source+0xdc>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
34809050:	0a000003 	beq	34809064 <source+0xa8>
		/*
		 * scripts are just multi-image files with one component, seek
		 * past the zero-terminated sequence of image lengths to get
		 * to the actual image data
		 */
		while (*data++);
34809054:	e4952004 	ldr	r2, [r5], #4
34809058:	e3520000 	cmp	r2, #0
3480905c:	1afffffc 	bne	34809054 <source+0x98>
34809060:	ea000002 	b	34809070 <source+0xb4>
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34809064:	eb0002c9 	bl	34809b90 <puts>
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
}
34809068:	e3a00001 	mov	r0, #1
3480906c:	e8bd8070 	pop	{r4, r5, r6, pc}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
34809070:	e1a00005 	mov	r0, r5
}
34809074:	e8bd4070 	pop	{r4, r5, r6, lr}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
34809078:	ea00162a 	b	3480e928 <run_command_list>
3480907c:	34823262 	.word	0x34823262
34809080:	34826042 	.word	0x34826042
34809084:	27051956 	.word	0x27051956
34809088:	34825ff4 	.word	0x34825ff4
3480908c:	34826006 	.word	0x34826006
34809090:	34826016 	.word	0x34826016
34809094:	34826024 	.word	0x34826024
34809098:	34826034 	.word	0x34826034

3480909c <do_source>:
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
3480909c:	e3520001 	cmp	r2, #1

/**************************************************/
#if defined(CONFIG_CMD_SOURCE)
int
do_source (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348090a0:	e92d4010 	push	{r4, lr}
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
		addr = CONFIG_SYS_LOAD_ADDR;
348090a4:	d3a04309 	movle	r4, #603979776	; 0x24000000
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
348090a8:	da000004 	ble	348090c0 <do_source+0x24>
	} else if (fit_parse_subimage (argv[1], load_addr, &addr, &fit_uname)) {
		debug ("*  source: subimage '%s' from FIT image at 0x%08lx\n",
				fit_uname, addr);
#endif
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
348090ac:	e5930004 	ldr	r0, [r3, #4]
348090b0:	e3a01000 	mov	r1, #0
348090b4:	e3a02010 	mov	r2, #16
348090b8:	eb005102 	bl	3481d4c8 <simple_strtoul>
348090bc:	e1a04000 	mov	r4, r0
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
348090c0:	e1a01004 	mov	r1, r4
348090c4:	e59f0010 	ldr	r0, [pc, #16]	; 348090dc <do_source+0x40>
348090c8:	eb0002ba 	bl	34809bb8 <printf>
	rcode = source (addr, fit_uname);
348090cc:	e1a00004 	mov	r0, r4
348090d0:	e3a01000 	mov	r1, #0
	return rcode;
}
348090d4:	e8bd4010 	pop	{r4, lr}
		addr = simple_strtoul(argv[1], NULL, 16);
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
	rcode = source (addr, fit_uname);
348090d8:	eaffffb7 	b	34808fbc <source>
348090dc:	3482606b 	.word	0x3482606b

348090e0 <do_false>:
);

int do_false(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 1;
}
348090e0:	e3a00001 	mov	r0, #1
348090e4:	e12fff1e 	bx	lr

348090e8 <do_true>:
);

int do_true(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 0;
}
348090e8:	e3a00000 	mov	r0, #0
348090ec:	e12fff1e 	bx	lr

348090f0 <do_test>:
{
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
348090f0:	e3520002 	cmp	r2, #2

#include <common.h>
#include <command.h>

int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348090f4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
348090f8:	da0000fd 	ble	348094f4 <do_test+0x404>
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
348090fc:	e5930004 	ldr	r0, [r3, #4]
34809100:	e59f141c 	ldr	r1, [pc, #1052]	; 34809524 <do_test+0x434>
			debug(" '%s'", argv[left++]);
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
34809104:	e2426001 	sub	r6, r2, #1
34809108:	e2834004 	add	r4, r3, #4
	if (left > 0 && strcmp(ap[0], "!") == 0) {
3480910c:	eb004d26 	bl	3481c5ac <strcmp>
		left--;
	} else
		neg = 0;

	expr = -1;
	last_cmp = -1;
34809110:	e3e05000 	mvn	r5, #0
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
34809114:	e3500000 	cmp	r0, #0
		neg = 1;
		ap++;
34809118:	02844004 	addeq	r4, r4, #4
		left--;
3480911c:	02466001 	subeq	r6, r6, #1
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
		neg = 1;
34809120:	03a0b001 	moveq	fp, #1
		ap++;
		left--;
	} else
		neg = 0;
34809124:	13a0b000 	movne	fp, #0

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
34809128:	e1a07005 	mov	r7, r5
		ap++;
		left--;
	} else
		neg = 0;

	expr = -1;
3480912c:	e1a0a005 	mov	sl, r5
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
34809130:	e5940000 	ldr	r0, [r4]
34809134:	e59f13ec 	ldr	r1, [pc, #1004]	; 34809528 <do_test+0x438>
34809138:	eb004d1b 	bl	3481c5ac <strcmp>
3480913c:	e3500000 	cmp	r0, #0
34809140:	0a0000ed 	beq	348094fc <do_test+0x40c>
34809144:	e5940000 	ldr	r0, [r4]
34809148:	e59f13dc 	ldr	r1, [pc, #988]	; 3480952c <do_test+0x43c>
3480914c:	eb004d16 	bl	3481c5ac <strcmp>
34809150:	e3500000 	cmp	r0, #0
34809154:	0a0000e8 	beq	348094fc <do_test+0x40c>
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
34809158:	e5940000 	ldr	r0, [r4]
3480915c:	e59f13cc 	ldr	r1, [pc, #972]	; 34809530 <do_test+0x440>
34809160:	eb004d11 	bl	3481c5ac <strcmp>
34809164:	e3500000 	cmp	r0, #0
			adv = 2;
34809168:	03a09002 	moveq	r9, #2
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
3480916c:	0a000005 	beq	34809188 <do_test+0x98>
34809170:	e5940000 	ldr	r0, [r4]
34809174:	e59f13b8 	ldr	r1, [pc, #952]	; 34809534 <do_test+0x444>
34809178:	eb004d0b 	bl	3481c5ac <strcmp>
			adv = 2;
		else
			adv = 3;
3480917c:	e3500000 	cmp	r0, #0
34809180:	03a09002 	moveq	r9, #2
34809184:	13a09003 	movne	r9, #3

		if (left < adv) {
34809188:	e1560009 	cmp	r6, r9
3480918c:	aa000006 	bge	348091ac <do_test+0xbc>
34809190:	ea0000cf 	b	348094d4 <do_test+0x3e4>

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
34809194:	e5940000 	ldr	r0, [r4]
34809198:	e59f138c 	ldr	r1, [pc, #908]	; 3480952c <do_test+0x43c>
3480919c:	eb004d02 	bl	3481c5ac <strcmp>
348091a0:	e3500000 	cmp	r0, #0
348091a4:	0a0000da 	beq	34809514 <do_test+0x424>
348091a8:	ea0000c9 	b	348094d4 <do_test+0x3e4>
				expr = 1;
				break;
			}
		}

		if (adv == 2) {
348091ac:	e3590002 	cmp	r9, #2
348091b0:	1a00001e 	bne	34809230 <do_test+0x140>
			if (strcmp(ap[0], "-z") == 0)
348091b4:	e5940000 	ldr	r0, [r4]
348091b8:	e59f1370 	ldr	r1, [pc, #880]	; 34809530 <do_test+0x440>
348091bc:	eb004cfa 	bl	3481c5ac <strcmp>
348091c0:	e3500000 	cmp	r0, #0
348091c4:	1a000004 	bne	348091dc <do_test+0xec>
				expr = strlen(ap[1]) == 0 ? 1 : 0;
348091c8:	e5940004 	ldr	r0, [r4, #4]
348091cc:	eb004d2a 	bl	3481c67c <strlen>
348091d0:	e270a001 	rsbs	sl, r0, #1
348091d4:	33a0a000 	movcc	sl, #0
348091d8:	ea000008 	b	34809200 <do_test+0x110>
			else if (strcmp(ap[0], "-n") == 0)
348091dc:	e5940000 	ldr	r0, [r4]
348091e0:	e59f134c 	ldr	r1, [pc, #844]	; 34809534 <do_test+0x444>
348091e4:	eb004cf0 	bl	3481c5ac <strcmp>
348091e8:	e3500000 	cmp	r0, #0
348091ec:	1a0000b8 	bne	348094d4 <do_test+0x3e4>
				expr = strlen(ap[1]) == 0 ? 0 : 1;
348091f0:	e5940004 	ldr	r0, [r4, #4]
348091f4:	eb004d20 	bl	3481c67c <strlen>
348091f8:	e250a000 	subs	sl, r0, #0
348091fc:	13a0a001 	movne	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
34809200:	e3550000 	cmp	r5, #0
34809204:	1a000003 	bne	34809218 <do_test+0x128>
				expr = last_expr || expr;
34809208:	e19aa007 	orrs	sl, sl, r7
3480920c:	03a0a000 	moveq	sl, #0
34809210:	13a0a001 	movne	sl, #1
34809214:	ea0000a8 	b	348094bc <do_test+0x3cc>
			else if (last_cmp == 1)
34809218:	e3550001 	cmp	r5, #1
3480921c:	1a0000a6 	bne	348094bc <do_test+0x3cc>
				expr = last_expr && expr;
34809220:	e3570000 	cmp	r7, #0
34809224:	03a0a000 	moveq	sl, #0
34809228:	120aa001 	andne	sl, sl, #1
3480922c:	ea0000a2 	b	348094bc <do_test+0x3cc>
			last_cmp = -1;
		}

		if (adv == 3) {
			if (strcmp(ap[1], "=") == 0)
34809230:	e5940004 	ldr	r0, [r4, #4]
34809234:	e59f12fc 	ldr	r1, [pc, #764]	; 34809538 <do_test+0x448>
34809238:	eb004cdb 	bl	3481c5ac <strcmp>
3480923c:	e3500000 	cmp	r0, #0
34809240:	e284a004 	add	sl, r4, #4
34809244:	1a000005 	bne	34809260 <do_test+0x170>
				expr = strcmp(ap[0], ap[2]) == 0;
34809248:	e5940000 	ldr	r0, [r4]
3480924c:	e5941008 	ldr	r1, [r4, #8]
34809250:	eb004cd5 	bl	3481c5ac <strcmp>
34809254:	e270a001 	rsbs	sl, r0, #1
34809258:	33a0a000 	movcc	sl, #0
3480925c:	ea00008a 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "!=") == 0)
34809260:	e5940004 	ldr	r0, [r4, #4]
34809264:	e59f12d0 	ldr	r1, [pc, #720]	; 3480953c <do_test+0x44c>
34809268:	eb004ccf 	bl	3481c5ac <strcmp>
3480926c:	e3500000 	cmp	r0, #0
34809270:	1a000005 	bne	3480928c <do_test+0x19c>
				expr = strcmp(ap[0], ap[2]) != 0;
34809274:	e5940000 	ldr	r0, [r4]
34809278:	e5941008 	ldr	r1, [r4, #8]
3480927c:	eb004cca 	bl	3481c5ac <strcmp>
34809280:	e250a000 	subs	sl, r0, #0
34809284:	13a0a001 	movne	sl, #1
34809288:	ea00007f 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], ">") == 0)
3480928c:	e59a0000 	ldr	r0, [sl]
34809290:	e59f12a8 	ldr	r1, [pc, #680]	; 34809540 <do_test+0x450>
34809294:	eb004cc4 	bl	3481c5ac <strcmp>
34809298:	e3500000 	cmp	r0, #0
3480929c:	1a000006 	bne	348092bc <do_test+0x1cc>
				expr = strcmp(ap[0], ap[2]) > 0;
348092a0:	e5940000 	ldr	r0, [r4]
348092a4:	e5941008 	ldr	r1, [r4, #8]
348092a8:	eb004cbf 	bl	3481c5ac <strcmp>
348092ac:	e3500000 	cmp	r0, #0
348092b0:	d3a0a000 	movle	sl, #0
348092b4:	c3a0a001 	movgt	sl, #1
348092b8:	ea000073 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "<") == 0)
348092bc:	e59a0000 	ldr	r0, [sl]
348092c0:	e59f127c 	ldr	r1, [pc, #636]	; 34809544 <do_test+0x454>
348092c4:	eb004cb8 	bl	3481c5ac <strcmp>
348092c8:	e3500000 	cmp	r0, #0
348092cc:	1a000004 	bne	348092e4 <do_test+0x1f4>
				expr = strcmp(ap[0], ap[2]) < 0;
348092d0:	e5940000 	ldr	r0, [r4]
348092d4:	e5941008 	ldr	r1, [r4, #8]
348092d8:	eb004cb3 	bl	3481c5ac <strcmp>
348092dc:	e1a0afa0 	lsr	sl, r0, #31
348092e0:	ea000069 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "-eq") == 0)
348092e4:	e59a0000 	ldr	r0, [sl]
348092e8:	e59f1258 	ldr	r1, [pc, #600]	; 34809548 <do_test+0x458>
348092ec:	eb004cae 	bl	3481c5ac <strcmp>
348092f0:	e2509000 	subs	r9, r0, #0
348092f4:	1a00000c 	bne	3480932c <do_test+0x23c>
				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
348092f8:	e1a01009 	mov	r1, r9
348092fc:	e3a0200a 	mov	r2, #10
34809300:	e5940000 	ldr	r0, [r4]
34809304:	eb0050b8 	bl	3481d5ec <simple_strtol>
34809308:	e1a01009 	mov	r1, r9
3480930c:	e1a0a000 	mov	sl, r0
34809310:	e3a0200a 	mov	r2, #10
34809314:	e5940008 	ldr	r0, [r4, #8]
34809318:	eb0050b3 	bl	3481d5ec <simple_strtol>
3480931c:	e15a0000 	cmp	sl, r0
34809320:	13a0a000 	movne	sl, #0
34809324:	03a0a001 	moveq	sl, #1
34809328:	ea000057 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "-ne") == 0)
3480932c:	e59a0000 	ldr	r0, [sl]
34809330:	e59f1214 	ldr	r1, [pc, #532]	; 3480954c <do_test+0x45c>
34809334:	eb004c9c 	bl	3481c5ac <strcmp>
34809338:	e2509000 	subs	r9, r0, #0
3480933c:	1a00000b 	bne	34809370 <do_test+0x280>
				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
34809340:	e1a01009 	mov	r1, r9
34809344:	e3a0200a 	mov	r2, #10
34809348:	e5940000 	ldr	r0, [r4]
3480934c:	eb0050a6 	bl	3481d5ec <simple_strtol>
34809350:	e1a01009 	mov	r1, r9
34809354:	e1a0a000 	mov	sl, r0
34809358:	e3a0200a 	mov	r2, #10
3480935c:	e5940008 	ldr	r0, [r4, #8]
34809360:	eb0050a1 	bl	3481d5ec <simple_strtol>
34809364:	e05aa000 	subs	sl, sl, r0
34809368:	13a0a001 	movne	sl, #1
3480936c:	ea000046 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "-lt") == 0)
34809370:	e59a0000 	ldr	r0, [sl]
34809374:	e59f11d4 	ldr	r1, [pc, #468]	; 34809550 <do_test+0x460>
34809378:	eb004c8b 	bl	3481c5ac <strcmp>
3480937c:	e2509000 	subs	r9, r0, #0
34809380:	1a00000c 	bne	348093b8 <do_test+0x2c8>
				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
34809384:	e1a01009 	mov	r1, r9
34809388:	e3a0200a 	mov	r2, #10
3480938c:	e5940000 	ldr	r0, [r4]
34809390:	eb005095 	bl	3481d5ec <simple_strtol>
34809394:	e1a01009 	mov	r1, r9
34809398:	e1a0a000 	mov	sl, r0
3480939c:	e3a0200a 	mov	r2, #10
348093a0:	e5940008 	ldr	r0, [r4, #8]
348093a4:	eb005090 	bl	3481d5ec <simple_strtol>
348093a8:	e15a0000 	cmp	sl, r0
348093ac:	a3a0a000 	movge	sl, #0
348093b0:	b3a0a001 	movlt	sl, #1
348093b4:	ea000034 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "-le") == 0)
348093b8:	e59a0000 	ldr	r0, [sl]
348093bc:	e59f1190 	ldr	r1, [pc, #400]	; 34809554 <do_test+0x464>
348093c0:	eb004c79 	bl	3481c5ac <strcmp>
348093c4:	e3500000 	cmp	r0, #0
348093c8:	1a00000c 	bne	34809400 <do_test+0x310>
				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
348093cc:	e3a01000 	mov	r1, #0
348093d0:	e3a0200a 	mov	r2, #10
348093d4:	e5940000 	ldr	r0, [r4]
348093d8:	eb005083 	bl	3481d5ec <simple_strtol>
348093dc:	e3a01000 	mov	r1, #0
348093e0:	e1a0a000 	mov	sl, r0
348093e4:	e3a0200a 	mov	r2, #10
348093e8:	e5940008 	ldr	r0, [r4, #8]
348093ec:	eb00507e 	bl	3481d5ec <simple_strtol>
348093f0:	e15a0000 	cmp	sl, r0
348093f4:	c3a0a000 	movgt	sl, #0
348093f8:	d3a0a001 	movle	sl, #1
348093fc:	ea000022 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "-gt") == 0)
34809400:	e59a0000 	ldr	r0, [sl]
34809404:	e59f114c 	ldr	r1, [pc, #332]	; 34809558 <do_test+0x468>
34809408:	eb004c67 	bl	3481c5ac <strcmp>
3480940c:	e2509000 	subs	r9, r0, #0
34809410:	1a00000c 	bne	34809448 <do_test+0x358>
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
34809414:	e1a01009 	mov	r1, r9
34809418:	e3a0200a 	mov	r2, #10
3480941c:	e5940000 	ldr	r0, [r4]
34809420:	eb005071 	bl	3481d5ec <simple_strtol>
34809424:	e1a01009 	mov	r1, r9
34809428:	e1a0a000 	mov	sl, r0
3480942c:	e3a0200a 	mov	r2, #10
34809430:	e5940008 	ldr	r0, [r4, #8]
34809434:	eb00506c 	bl	3481d5ec <simple_strtol>
34809438:	e15a0000 	cmp	sl, r0
3480943c:	d3a0a000 	movle	sl, #0
34809440:	c3a0a001 	movgt	sl, #1
34809444:	ea000010 	b	3480948c <do_test+0x39c>
			else if (strcmp(ap[1], "-ge") == 0)
34809448:	e59a0000 	ldr	r0, [sl]
3480944c:	e59f1108 	ldr	r1, [pc, #264]	; 3480955c <do_test+0x46c>
34809450:	eb004c55 	bl	3481c5ac <strcmp>
34809454:	e2509000 	subs	r9, r0, #0
34809458:	1a00001d 	bne	348094d4 <do_test+0x3e4>
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
3480945c:	e1a01009 	mov	r1, r9
34809460:	e3a0200a 	mov	r2, #10
34809464:	e5940000 	ldr	r0, [r4]
34809468:	eb00505f 	bl	3481d5ec <simple_strtol>
3480946c:	e1a01009 	mov	r1, r9
34809470:	e1a0a000 	mov	sl, r0
34809474:	e3a0200a 	mov	r2, #10
34809478:	e5940008 	ldr	r0, [r4, #8]
3480947c:	eb00505a 	bl	3481d5ec <simple_strtol>
34809480:	e15a0000 	cmp	sl, r0
34809484:	b3a0a000 	movlt	sl, #0
34809488:	a3a0a001 	movge	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
3480948c:	e3550000 	cmp	r5, #0
34809490:	1a000003 	bne	348094a4 <do_test+0x3b4>
				expr = last_expr || expr;
34809494:	e19aa007 	orrs	sl, sl, r7
34809498:	03a0a000 	moveq	sl, #0
3480949c:	13a0a001 	movne	sl, #1
348094a0:	ea000004 	b	348094b8 <do_test+0x3c8>
			else if (last_cmp == 1)
348094a4:	e3550001 	cmp	r5, #1
348094a8:	1a000002 	bne	348094b8 <do_test+0x3c8>
				expr = last_expr && expr;
348094ac:	e3570000 	cmp	r7, #0
348094b0:	03a0a000 	moveq	sl, #0
348094b4:	120aa001 	andne	sl, sl, #1
				break;
			}

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
348094b8:	e3a09003 	mov	r9, #3
				expr = last_expr && expr;
			last_cmp = -1;
348094bc:	e3e05000 	mvn	r5, #0
		}

		ap += adv; left -= adv;
348094c0:	e0696006 	rsb	r6, r9, r6
		neg = 0;

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {
348094c4:	e3560000 	cmp	r6, #0
348094c8:	da000002 	ble	348094d8 <do_test+0x3e8>
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
		}

		ap += adv; left -= adv;
348094cc:	e0844109 	add	r4, r4, r9, lsl #2
348094d0:	eaffff16 	b	34809130 <do_test+0x40>
			else if (strcmp(ap[1], "-gt") == 0)
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-ge") == 0)
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
			else {
				expr = 1;
348094d4:	e3a0a001 	mov	sl, #1
		}

		ap += adv; left -= adv;
	}

	if (neg)
348094d8:	e35b0000 	cmp	fp, #0
348094dc:	0a000001 	beq	348094e8 <do_test+0x3f8>
		expr = !expr;
348094e0:	e27aa001 	rsbs	sl, sl, #1
348094e4:	33a0a000 	movcc	sl, #0

	expr = !expr;
348094e8:	e27a0001 	rsbs	r0, sl, #1
348094ec:	33a00000 	movcc	r0, #0

	debug (": returns %d\n", expr);

	return expr;
348094f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
		return 1;
348094f4:	e3a00001 	mov	r0, #1
	expr = !expr;

	debug (": returns %d\n", expr);

	return expr;
}
348094f8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			expr = 1;
			break;
		}

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
348094fc:	e5940000 	ldr	r0, [r4]
34809500:	e59f1020 	ldr	r1, [pc, #32]	; 34809528 <do_test+0x438>
34809504:	eb004c28 	bl	3481c5ac <strcmp>
34809508:	e2505000 	subs	r5, r0, #0
3480950c:	0a000001 	beq	34809518 <do_test+0x428>
34809510:	eaffff1f 	b	34809194 <do_test+0xa4>
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
				last_expr = expr;
				last_cmp = 1;
34809514:	e3a05001 	mov	r5, #1

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
34809518:	e1a0700a 	mov	r7, sl
3480951c:	e3a09001 	mov	r9, #1
34809520:	eaffffe6 	b	348094c0 <do_test+0x3d0>
34809524:	348273fb 	.word	0x348273fb
34809528:	348260f5 	.word	0x348260f5
3480952c:	348260f8 	.word	0x348260f8
34809530:	348260fb 	.word	0x348260fb
34809534:	348260fe 	.word	0x348260fe
34809538:	34823c2a 	.word	0x34823c2a
3480953c:	34823c29 	.word	0x34823c29
34809540:	34823c2d 	.word	0x34823c2d
34809544:	34823c18 	.word	0x34823c18
34809548:	34823c1e 	.word	0x34823c1e
3480954c:	34823c25 	.word	0x34823c25
34809550:	34823c14 	.word	0x34823c14
34809554:	34823c36 	.word	0x34823c36
34809558:	34823c1a 	.word	0x34823c1a
3480955c:	34823c2f 	.word	0x34823c2f

34809560 <do_version>:
#include <linux/compiler.h>

const char __weak version_string[] = U_BOOT_VERSION_STRING;

int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34809560:	e92d4008 	push	{r3, lr}
	printf("\n%s\n", version_string);
34809564:	e59f101c 	ldr	r1, [pc, #28]	; 34809588 <do_version+0x28>
34809568:	e59f001c 	ldr	r0, [pc, #28]	; 3480958c <do_version+0x2c>
3480956c:	eb000191 	bl	34809bb8 <printf>
#ifdef CC_VERSION_STRING
	puts(CC_VERSION_STRING "\n");
34809570:	e59f0018 	ldr	r0, [pc, #24]	; 34809590 <do_version+0x30>
34809574:	eb000185 	bl	34809b90 <puts>
#endif
#ifdef LD_VERSION_STRING
	puts(LD_VERSION_STRING "\n");
34809578:	e59f0014 	ldr	r0, [pc, #20]	; 34809594 <do_version+0x34>
3480957c:	eb000183 	bl	34809b90 <puts>
#endif

	return 0;
}
34809580:	e3a00000 	mov	r0, #0
34809584:	e8bd8008 	pop	{r3, pc}
34809588:	34820544 	.word	0x34820544
3480958c:	34826163 	.word	0x34826163
34809590:	34826168 	.word	0x34826168
34809594:	3482618d 	.word	0x3482618d

34809598 <find_cmd_tbl>:

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
34809598:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
3480959c:	e2505000 	subs	r5, r0, #0

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
348095a0:	e1a04002 	mov	r4, r2
348095a4:	e1a06001 	mov	r6, r1
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
		return NULL;
348095a8:	01a04005 	moveq	r4, r5
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
348095ac:	0a00001e 	beq	3480962c <find_cmd_tbl+0x94>
		return NULL;
	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
348095b0:	e3a0102e 	mov	r1, #46	; 0x2e
348095b4:	eb004c1a 	bl	3481c624 <strchr>
348095b8:	e3500000 	cmp	r0, #0
348095bc:	1065a000 	rsbne	sl, r5, r0
348095c0:	1a000002 	bne	348095d0 <find_cmd_tbl+0x38>
348095c4:	e1a00005 	mov	r0, r5
348095c8:	eb004c2b 	bl	3481c67c <strlen>
348095cc:	e1a0a000 	mov	sl, r0

	for (cmdtp = table;
	     cmdtp != table + table_len;
348095d0:	e3a09018 	mov	r9, #24
348095d4:	e0296499 	mla	r9, r9, r4, r6
{
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;
348095d8:	e3a07000 	mov	r7, #0
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
348095dc:	e1a04006 	mov	r4, r6
348095e0:	ea00000c 	b	34809618 <find_cmd_tbl+0x80>
	     cmdtp != table + table_len;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
348095e4:	e1a00005 	mov	r0, r5
348095e8:	e5941000 	ldr	r1, [r4]
348095ec:	e1a0200a 	mov	r2, sl
348095f0:	eb004bf9 	bl	3481c5dc <strncmp>
348095f4:	e3500000 	cmp	r0, #0
348095f8:	1a000005 	bne	34809614 <find_cmd_tbl+0x7c>
			if (len == strlen (cmdtp->name))
348095fc:	e5940000 	ldr	r0, [r4]
34809600:	eb004c1d 	bl	3481c67c <strlen>
34809604:	e15a0000 	cmp	sl, r0
34809608:	0a000007 	beq	3480962c <find_cmd_tbl+0x94>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
3480960c:	e2877001 	add	r7, r7, #1
34809610:	e1a06004 	mov	r6, r4
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
	     cmdtp != table + table_len;
	     cmdtp++) {
34809614:	e2844018 	add	r4, r4, #24
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
34809618:	e1540009 	cmp	r4, r9
3480961c:	1afffff0 	bne	348095e4 <find_cmd_tbl+0x4c>
	}
	if (n_found == 1) {			/* exactly one match */
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
34809620:	e3570001 	cmp	r7, #1
34809624:	01a04006 	moveq	r4, r6
34809628:	13a04000 	movne	r4, #0
}
3480962c:	e1a00004 	mov	r0, r4
34809630:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

34809634 <find_cmd>:

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34809634:	e59f1014 	ldr	r1, [pc, #20]	; 34809650 <find_cmd+0x1c>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
34809638:	e59f3014 	ldr	r3, [pc, #20]	; 34809654 <find_cmd+0x20>
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
3480963c:	e59f2014 	ldr	r2, [pc, #20]	; 34809658 <find_cmd+0x24>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
34809640:	e0613003 	rsb	r3, r1, r3
34809644:	e1a031c3 	asr	r3, r3, #3
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34809648:	e0020392 	mul	r2, r2, r3
3480964c:	eaffffd1 	b	34809598 <find_cmd_tbl>
	...
34809658:	aaaaaaab 	.word	0xaaaaaaab

3480965c <cmd_usage>:
}

int cmd_usage(const cmd_tbl_t *cmdtp)
{
3480965c:	e92d4010 	push	{r4, lr}
34809660:	e1a04000 	mov	r4, r0
	printf("%s - %s\n\n", cmdtp->name, cmdtp->usage);
34809664:	e5941000 	ldr	r1, [r4]
34809668:	e5942010 	ldr	r2, [r4, #16]
3480966c:	e59f0038 	ldr	r0, [pc, #56]	; 348096ac <cmd_usage+0x50>
34809670:	eb000150 	bl	34809bb8 <printf>

#ifdef	CONFIG_SYS_LONGHELP
	printf("Usage:\n%s ", cmdtp->name);
34809674:	e59f0034 	ldr	r0, [pc, #52]	; 348096b0 <cmd_usage+0x54>
34809678:	e5941000 	ldr	r1, [r4]
3480967c:	eb00014d 	bl	34809bb8 <printf>

	if (!cmdtp->help) {
34809680:	e5940014 	ldr	r0, [r4, #20]
34809684:	e3500000 	cmp	r0, #0
34809688:	1a000002 	bne	34809698 <cmd_usage+0x3c>
		puts ("- No additional help available.\n");
3480968c:	e59f0020 	ldr	r0, [pc, #32]	; 348096b4 <cmd_usage+0x58>
34809690:	eb00013e 	bl	34809b90 <puts>
		return 1;
34809694:	ea000002 	b	348096a4 <cmd_usage+0x48>
	}

	puts (cmdtp->help);
34809698:	eb00013c 	bl	34809b90 <puts>
	putc ('\n');
3480969c:	e3a0000a 	mov	r0, #10
348096a0:	eb000130 	bl	34809b68 <putc>
#endif	/* CONFIG_SYS_LONGHELP */
	return 1;
}
348096a4:	e3a00001 	mov	r0, #1
348096a8:	e8bd8010 	pop	{r4, pc}
348096ac:	348261df 	.word	0x348261df
348096b0:	348261e9 	.word	0x348261e9
348096b4:	348261f4 	.word	0x348261f4

348096b8 <_do_help>:
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
348096b8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348096bc:	e28db01c 	add	fp, sp, #28
348096c0:	e24dd010 	sub	sp, sp, #16
348096c4:	e59b9004 	ldr	r9, [fp, #4]
348096c8:	e1a0a000 	mov	sl, r0
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
348096cc:	e3590001 	cmp	r9, #1
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
348096d0:	e1a04001 	mov	r4, r1
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
348096d4:	159b7008 	ldrne	r7, [fp, #8]
348096d8:	13a05000 	movne	r5, #0
348096dc:	13a06001 	movne	r6, #1
348096e0:	1a00004f 	bne	34809824 <_do_help+0x16c>
		cmd_tbl_t *cmd_array[cmd_items];
348096e4:	e1a03101 	lsl	r3, r1, #2
348096e8:	e283300e 	add	r3, r3, #14
348096ec:	e3c33007 	bic	r3, r3, #7
	      flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
348096f0:	e50bd024 	str	sp, [fp, #-36]	; 0x24
		cmd_tbl_t *cmd_array[cmd_items];
348096f4:	e04dd003 	sub	sp, sp, r3
348096f8:	e1a0300d 	mov	r3, sp
348096fc:	e50bd020 	str	sp, [fp, #-32]
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34809700:	e1a0100d 	mov	r1, sp
34809704:	e3a02000 	mov	r2, #0
34809708:	ea000002 	b	34809718 <_do_help+0x60>
			cmd_array[i] = cmdtp++;
3480970c:	e481a004 	str	sl, [r1], #4
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34809710:	e2822001 	add	r2, r2, #1
			cmd_array[i] = cmdtp++;
34809714:	e28aa018 	add	sl, sl, #24
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34809718:	e1520004 	cmp	r2, r4
3480971c:	bafffffa 	blt	3480970c <_do_help+0x54>
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
34809720:	e2446001 	sub	r6, r4, #1
34809724:	ea000017 	b	34809788 <_do_help+0xd0>
34809728:	e3a07000 	mov	r7, #0
3480972c:	e1a05003 	mov	r5, r3
34809730:	e1a0a007 	mov	sl, r7
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34809734:	e5952000 	ldr	r2, [r5]
					    cmd_array[j + 1]->name) > 0) {
34809738:	e5b59004 	ldr	r9, [r5, #4]!

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
3480973c:	e5920000 	ldr	r0, [r2]
34809740:	e5991000 	ldr	r1, [r9]
34809744:	e50b2028 	str	r2, [fp, #-40]	; 0x28
34809748:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
3480974c:	eb004b96 	bl	3481c5ac <strcmp>
34809750:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
34809754:	e3500000 	cmp	r0, #0
					    cmd_array[j + 1]->name) > 0) {
34809758:	e28aa001 	add	sl, sl, #1

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
3480975c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
34809760:	c2877001 	addgt	r7, r7, #1
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
34809764:	c5059004 	strgt	r9, [r5, #-4]
					cmd_array[j + 1] = tmp;
34809768:	c5852000 	strgt	r2, [r5]
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
3480976c:	e15a0006 	cmp	sl, r6
34809770:	baffffef 	blt	34809734 <_do_help+0x7c>
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
				}
			}
			if (!swaps)
34809774:	e3570000 	cmp	r7, #0
34809778:	1a000001 	bne	34809784 <_do_help+0xcc>
		for (i = 0; i < cmd_items; i++) {
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
3480977c:	e3a05000 	mov	r5, #0
34809780:	ea000012 	b	348097d0 <_do_help+0x118>
34809784:	e2466001 	sub	r6, r6, #1
34809788:	e3560000 	cmp	r6, #0
3480978c:	caffffe5 	bgt	34809728 <_do_help+0x70>
34809790:	eafffff9 	b	3480977c <_do_help+0xc4>
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;
34809794:	e51b3020 	ldr	r3, [fp, #-32]
34809798:	e4937004 	ldr	r7, [r3], #4
3480979c:	e50b3020 	str	r3, [fp, #-32]
348097a0:	e5976010 	ldr	r6, [r7, #16]

			/* allow user abort */
			if (ctrlc ())
348097a4:	eb000128 	bl	34809c4c <ctrlc>
348097a8:	e3500000 	cmp	r0, #0
348097ac:	1a00000b 	bne	348097e0 <_do_help+0x128>
				return 1;
			if (usage == NULL)
348097b0:	e3560000 	cmp	r6, #0
348097b4:	0a000004 	beq	348097cc <_do_help+0x114>
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
348097b8:	e59f0078 	ldr	r0, [pc, #120]	; 34809838 <_do_help+0x180>
348097bc:	e3a01008 	mov	r1, #8
348097c0:	e5972000 	ldr	r2, [r7]
348097c4:	e1a03006 	mov	r3, r6
348097c8:	eb0000fa 	bl	34809bb8 <printf>
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
348097cc:	e2855001 	add	r5, r5, #1
348097d0:	e1550004 	cmp	r5, r4
348097d4:	baffffee 	blt	34809794 <_do_help+0xdc>
			if (usage == NULL)
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
			       cmd_array[i]->name, usage);
		}
		return 0;
348097d8:	e3a05000 	mov	r5, #0
348097dc:	ea000000 	b	348097e4 <_do_help+0x12c>
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;

			/* allow user abort */
			if (ctrlc ())
				return 1;
348097e0:	e3a05001 	mov	r5, #1
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
348097e4:	e51bd024 	ldr	sp, [fp, #-36]	; 0x24
348097e8:	ea00000f 	b	3480982c <_do_help+0x174>
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
		if ((cmdtp = find_cmd_tbl (argv[i], cmd_start, cmd_items )) != NULL) {
348097ec:	e5b70004 	ldr	r0, [r7, #4]!
348097f0:	e1a0100a 	mov	r1, sl
348097f4:	e1a02004 	mov	r2, r4
348097f8:	ebffff66 	bl	34809598 <find_cmd_tbl>
348097fc:	e3500000 	cmp	r0, #0
34809800:	0a000002 	beq	34809810 <_do_help+0x158>
			rcode |= cmd_usage(cmdtp);
34809804:	ebffff94 	bl	3480965c <cmd_usage>
34809808:	e1855000 	orr	r5, r5, r0
3480980c:	ea000003 	b	34809820 <_do_help+0x168>
		} else {
			printf ("Unknown command '%s' - try 'help'"
34809810:	e59f0024 	ldr	r0, [pc, #36]	; 3480983c <_do_help+0x184>
34809814:	e5971000 	ldr	r1, [r7]
34809818:	eb0000e6 	bl	34809bb8 <printf>
				" without arguments for list of all"
				" known commands\n\n", argv[i]
					);
			rcode = 1;
3480981c:	e3a05001 	mov	r5, #1
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
34809820:	e2866001 	add	r6, r6, #1
34809824:	e1560009 	cmp	r6, r9
34809828:	baffffef 	blt	348097ec <_do_help+0x134>
					);
			rcode = 1;
		}
	}
	return rcode;
}
3480982c:	e1a00005 	mov	r0, r5
34809830:	e24bd01c 	sub	sp, fp, #28
34809834:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34809838:	34826215 	.word	0x34826215
3480983c:	3482621f 	.word	0x3482621f

34809840 <cmd_get_data_size>:

#endif

#ifdef CMD_DATA_SIZE
int cmd_get_data_size(char* arg, int default_size)
{
34809840:	e92d4038 	push	{r3, r4, r5, lr}
34809844:	e1a04000 	mov	r4, r0
34809848:	e1a05001 	mov	r5, r1
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
3480984c:	eb004b8a 	bl	3481c67c <strlen>
	if (len > 2 && arg[len-2] == '.') {
34809850:	e3500002 	cmp	r0, #2
34809854:	da00000a 	ble	34809884 <cmd_get_data_size+0x44>
34809858:	e0844000 	add	r4, r4, r0
3480985c:	e5543002 	ldrb	r3, [r4, #-2]
34809860:	e353002e 	cmp	r3, #46	; 0x2e
34809864:	1a000006 	bne	34809884 <cmd_get_data_size+0x44>
		switch(arg[len-1]) {
34809868:	e5543001 	ldrb	r3, [r4, #-1]
3480986c:	e2433062 	sub	r3, r3, #98	; 0x62
34809870:	e6ef3073 	uxtb	r3, r3
34809874:	e3530015 	cmp	r3, #21
34809878:	959f200c 	ldrls	r2, [pc, #12]	; 3480988c <cmd_get_data_size+0x4c>
3480987c:	83e05000 	mvnhi	r5, #0
34809880:	97925103 	ldrls	r5, [r2, r3, lsl #2]
		default:
			return -1;
		}
	}
	return default_size;
}
34809884:	e1a00005 	mov	r0, r5
34809888:	e8bd8038 	pop	{r3, r4, r5, pc}
3480988c:	3482056c 	.word	0x3482056c

34809890 <cmd_process>:
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
34809890:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34809894:	e1a05000 	mov	r5, r0
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
34809898:	e5920000 	ldr	r0, [r2]
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
3480989c:	e1a0a001 	mov	sl, r1
348098a0:	e1a06002 	mov	r6, r2
348098a4:	e1a07003 	mov	r7, r3
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
348098a8:	ebffff61 	bl	34809634 <find_cmd>
	if (cmdtp == NULL) {
348098ac:	e2504000 	subs	r4, r0, #0
348098b0:	1a000003 	bne	348098c4 <cmd_process+0x34>
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
348098b4:	e5961000 	ldr	r1, [r6]
348098b8:	e59f0078 	ldr	r0, [pc, #120]	; 34809938 <cmd_process+0xa8>
348098bc:	eb0000bd 	bl	34809bb8 <printf>
348098c0:	ea00000b 	b	348098f4 <cmd_process+0x64>
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
348098c4:	e5943004 	ldr	r3, [r4, #4]
348098c8:	e15a0003 	cmp	sl, r3
348098cc:	ca00000a 	bgt	348098fc <cmd_process+0x6c>
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
348098d0:	e594c00c 	ldr	ip, [r4, #12]
348098d4:	e59f3060 	ldr	r3, [pc, #96]	; 3480993c <cmd_process+0xac>
348098d8:	e15c0003 	cmp	ip, r3
348098dc:	1a000009 	bne	34809908 <cmd_process+0x78>
		if (flag & CMD_FLAG_BOOTD) {
348098e0:	e3150002 	tst	r5, #2
			puts("'bootd' recursion detected\n");
			rc = CMD_RET_FAILURE;
		} else {
			flag |= CMD_FLAG_BOOTD;
348098e4:	03855002 	orreq	r5, r5, #2
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
		if (flag & CMD_FLAG_BOOTD) {
348098e8:	0a000006 	beq	34809908 <cmd_process+0x78>
			puts("'bootd' recursion detected\n");
348098ec:	e59f004c 	ldr	r0, [pc, #76]	; 34809940 <cmd_process+0xb0>
348098f0:	eb0000a6 	bl	34809b90 <puts>
			rc = CMD_RET_FAILURE;
348098f4:	e3a00001 	mov	r0, #1
348098f8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
348098fc:	e1a00004 	mov	r0, r4
	return rc;
}
34809900:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
34809904:	eaffff54 	b	3480965c <cmd_usage>
 */
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int result;

	result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
34809908:	e1a0200a 	mov	r2, sl
3480990c:	e1a03006 	mov	r3, r6
34809910:	e1a00004 	mov	r0, r4
34809914:	e1a01005 	mov	r1, r5
34809918:	e12fff3c 	blx	ip
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
3480991c:	e5972000 	ldr	r2, [r7]
34809920:	e5943008 	ldr	r3, [r4, #8]
	}
	if (rc == CMD_RET_USAGE)
34809924:	e3700001 	cmn	r0, #1
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
34809928:	e0023003 	and	r3, r2, r3
3480992c:	e5873000 	str	r3, [r7]
	}
	if (rc == CMD_RET_USAGE)
34809930:	18bd84f0 	popne	{r4, r5, r6, r7, sl, pc}
34809934:	eafffff0 	b	348098fc <cmd_process+0x6c>
34809938:	34826274 	.word	0x34826274
3480993c:	3480259c 	.word	0x3480259c
34809940:	34826297 	.word	0x34826297

34809944 <console_setfile>:
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
34809944:	e92d4038 	push	{r3, r4, r5, lr}
	int error = 0;

	if (dev == NULL)
34809948:	e2515000 	subs	r5, r1, #0
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
3480994c:	e1a04000 	mov	r4, r0
	int error = 0;

	if (dev == NULL)
		return -1;
34809950:	03e00000 	mvneq	r0, #0

static int console_setfile(int file, struct stdio_dev * dev)
{
	int error = 0;

	if (dev == NULL)
34809954:	08bd8038 	popeq	{r3, r4, r5, pc}
		return -1;

	switch (file) {
34809958:	e3540002 	cmp	r4, #2
3480995c:	8a00001d 	bhi	348099d8 <console_setfile+0x94>
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
34809960:	e5950018 	ldr	r0, [r5, #24]
34809964:	e3500000 	cmp	r0, #0
34809968:	0a000002 	beq	34809978 <console_setfile+0x34>
			error = dev->start();
3480996c:	e12fff30 	blx	r0
			/* If it's not started dont use it */
			if (error < 0)
34809970:	e3500000 	cmp	r0, #0
34809974:	b8bd8038 	poplt	{r3, r4, r5, pc}
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34809978:	e59f3060 	ldr	r3, [pc, #96]	; 348099e0 <console_setfile+0x9c>

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
3480997c:	e3540000 	cmp	r4, #0
			if (error < 0)
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34809980:	e7835104 	str	r5, [r3, r4, lsl #2]

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
34809984:	0a000002 	beq	34809994 <console_setfile+0x50>
34809988:	e3540001 	cmp	r4, #1
3480998c:	18bd8038 	popne	{r3, r4, r5, pc}
34809990:	ea000006 	b	348099b0 <console_setfile+0x6c>
		case stdin:
			gd->jt[XF_getc] = dev->getc;
34809994:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809998:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
			gd->jt[XF_tstc] = dev->tstc;
3480999c:	e5983054 	ldr	r3, [r8, #84]	; 0x54
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
		case stdin:
			gd->jt[XF_getc] = dev->getc;
348099a0:	e5821004 	str	r1, [r2, #4]
			gd->jt[XF_tstc] = dev->tstc;
348099a4:	e5952028 	ldr	r2, [r5, #40]	; 0x28
348099a8:	e5832008 	str	r2, [r3, #8]
			break;
348099ac:	e8bd8038 	pop	{r3, r4, r5, pc}
		case stdout:
			gd->jt[XF_putc] = dev->putc;
348099b0:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348099b4:	e5951020 	ldr	r1, [r5, #32]
348099b8:	e582100c 	str	r1, [r2, #12]
			gd->jt[XF_puts] = dev->puts;
348099bc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348099c0:	e5951024 	ldr	r1, [r5, #36]	; 0x24
			gd->jt[XF_printf] = printf;
348099c4:	e5983054 	ldr	r3, [r8, #84]	; 0x54
			gd->jt[XF_getc] = dev->getc;
			gd->jt[XF_tstc] = dev->tstc;
			break;
		case stdout:
			gd->jt[XF_putc] = dev->putc;
			gd->jt[XF_puts] = dev->puts;
348099c8:	e5821010 	str	r1, [r2, #16]
			gd->jt[XF_printf] = printf;
348099cc:	e59f2010 	ldr	r2, [pc, #16]	; 348099e4 <console_setfile+0xa0>
348099d0:	e5832014 	str	r2, [r3, #20]
			break;
348099d4:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
348099d8:	e3e00000 	mvn	r0, #0
	}
	return error;
}
348099dc:	e8bd8038 	pop	{r3, r4, r5, pc}
348099e0:	3482b868 	.word	0x3482b868
348099e4:	34809bb8 	.word	0x34809bb8

348099e8 <serial_printf>:
#endif /* defined(CONFIG_CONSOLE_MUX) */

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

int serial_printf(const char *fmt, ...)
{
348099e8:	e92d000f 	push	{r0, r1, r2, r3}
348099ec:	e92d4030 	push	{r4, r5, lr}
348099f0:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348099f4:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
348099f8:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348099fc:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
34809a00:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34809a04:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809a08:	eb004f53 	bl	3481d75c <vsprintf>
34809a0c:	e1a05000 	mov	r5, r0
	va_end(args);

	serial_puts(printbuffer);
34809a10:	e1a00004 	mov	r0, r4
34809a14:	eb0015bb 	bl	3480f108 <serial_puts>
	return i;
}
34809a18:	e1a00005 	mov	r0, r5
34809a1c:	e28ddf63 	add	sp, sp, #396	; 0x18c
34809a20:	e8bd4030 	pop	{r4, r5, lr}
34809a24:	e28dd010 	add	sp, sp, #16
34809a28:	e12fff1e 	bx	lr

34809a2c <fgetc>:

int fgetc(int file)
{
	if (file < MAX_FILES) {
34809a2c:	e3500002 	cmp	r0, #2
	serial_puts(printbuffer);
	return i;
}

int fgetc(int file)
{
34809a30:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES) {
34809a34:	ca000004 	bgt	34809a4c <fgetc+0x20>
	iomux_doenv(file, dev->name);
}
#else
static inline int console_getc(int file)
{
	return stdio_devices[file]->getc();
34809a38:	e59f3014 	ldr	r3, [pc, #20]	; 34809a54 <fgetc+0x28>
34809a3c:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34809a40:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
34809a44:	e12fff33 	blx	r3
			 */
			 udelay(1);
#endif
		}
#else
		return console_getc(file);
34809a48:	e8bd8008 	pop	{r3, pc}
#endif
	}

	return -1;
34809a4c:	e3e00000 	mvn	r0, #0
}
34809a50:	e8bd8008 	pop	{r3, pc}
34809a54:	3482b868 	.word	0x3482b868

34809a58 <ftstc>:

int ftstc(int file)
{
	if (file < MAX_FILES)
34809a58:	e3500002 	cmp	r0, #2

	return -1;
}

int ftstc(int file)
{
34809a5c:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34809a60:	ca000004 	bgt	34809a78 <ftstc+0x20>
	return stdio_devices[file]->getc();
}

static inline int console_tstc(int file)
{
	return stdio_devices[file]->tstc();
34809a64:	e59f3014 	ldr	r3, [pc, #20]	; 34809a80 <ftstc+0x28>
34809a68:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34809a6c:	e5933028 	ldr	r3, [r3, #40]	; 0x28
34809a70:	e12fff33 	blx	r3
}

int ftstc(int file)
{
	if (file < MAX_FILES)
		return console_tstc(file);
34809a74:	e8bd8008 	pop	{r3, pc}

	return -1;
34809a78:	e3e00000 	mvn	r0, #0
}
34809a7c:	e8bd8008 	pop	{r3, pc}
34809a80:	3482b868 	.word	0x3482b868

34809a84 <fputc>:

void fputc(int file, const char c)
{
	if (file < MAX_FILES)
34809a84:	e3500002 	cmp	r0, #2

	return -1;
}

void fputc(int file, const char c)
{
34809a88:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34809a8c:	c8bd8008 	popgt	{r3, pc}
	return stdio_devices[file]->tstc();
}

static inline void console_putc(int file, const char c)
{
	stdio_devices[file]->putc(c);
34809a90:	e59f2010 	ldr	r2, [pc, #16]	; 34809aa8 <fputc+0x24>
34809a94:	e7923100 	ldr	r3, [r2, r0, lsl #2]
34809a98:	e1a00001 	mov	r0, r1
34809a9c:	e5933020 	ldr	r3, [r3, #32]
34809aa0:	e12fff33 	blx	r3
34809aa4:	e8bd8008 	pop	{r3, pc}
34809aa8:	3482b868 	.word	0x3482b868

34809aac <fputs>:
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
	if (file < MAX_FILES)
34809aac:	e3500002 	cmp	r0, #2
	if (file < MAX_FILES)
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
34809ab0:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34809ab4:	c8bd8008 	popgt	{r3, pc}
	stdio_devices[file]->putc(c);
}

static inline void console_puts(int file, const char *s)
{
	stdio_devices[file]->puts(s);
34809ab8:	e59f2010 	ldr	r2, [pc, #16]	; 34809ad0 <fputs+0x24>
34809abc:	e7923100 	ldr	r3, [r2, r0, lsl #2]
34809ac0:	e1a00001 	mov	r0, r1
34809ac4:	e5933024 	ldr	r3, [r3, #36]	; 0x24
34809ac8:	e12fff33 	blx	r3
34809acc:	e8bd8008 	pop	{r3, pc}
34809ad0:	3482b868 	.word	0x3482b868

34809ad4 <fprintf>:
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
34809ad4:	e92d000e 	push	{r1, r2, r3}
34809ad8:	e92d4070 	push	{r4, r5, r6, lr}
34809adc:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809ae0:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34809ae4:	e28d2e1a 	add	r2, sp, #416	; 0x1a0
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
34809ae8:	e1a05000 	mov	r5, r0
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809aec:	e59d119c 	ldr	r1, [sp, #412]	; 0x19c
34809af0:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34809af4:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809af8:	eb004f17 	bl	3481d75c <vsprintf>
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
34809afc:	e1a01004 	mov	r1, r4
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809b00:	e1a06000 	mov	r6, r0
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
34809b04:	e1a00005 	mov	r0, r5
34809b08:	ebffffe7 	bl	34809aac <fputs>
	return i;
}
34809b0c:	e1a00006 	mov	r0, r6
34809b10:	e28ddf63 	add	sp, sp, #396	; 0x18c
34809b14:	e8bd4070 	pop	{r4, r5, r6, lr}
34809b18:	e28dd00c 	add	sp, sp, #12
34809b1c:	e12fff1e 	bx	lr

34809b20 <getc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
34809b20:	e598000c 	ldr	r0, [r8, #12]
34809b24:	e3500000 	cmp	r0, #0
34809b28:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
34809b2c:	e5983004 	ldr	r3, [r8, #4]
34809b30:	e3130002 	tst	r3, #2
34809b34:	0a000001 	beq	34809b40 <getc+0x20>
		/* Get from the standard input */
		return fgetc(stdin);
34809b38:	e3a00000 	mov	r0, #0
34809b3c:	eaffffba 	b	34809a2c <fgetc>
	}

	/* Send directly to the handler */
	return serial_getc();
34809b40:	ea00155f 	b	3480f0c4 <serial_getc>

34809b44 <tstc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
34809b44:	e598000c 	ldr	r0, [r8, #12]
34809b48:	e3500000 	cmp	r0, #0
34809b4c:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
34809b50:	e5983004 	ldr	r3, [r8, #4]
34809b54:	e3130002 	tst	r3, #2
34809b58:	0a000001 	beq	34809b64 <tstc+0x20>
		/* Test the standard input */
		return ftstc(stdin);
34809b5c:	e3a00000 	mov	r0, #0
34809b60:	eaffffbc 	b	34809a58 <ftstc>
	}

	/* Send directly to the handler */
	return serial_tstc();
34809b64:	ea00155b 	b	3480f0d8 <serial_tstc>

34809b68 <putc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809b68:	e598200c 	ldr	r2, [r8, #12]
static inline void pre_console_puts(const char *s) {}
static inline void print_pre_console_buffer(void) {}
#endif

void putc(const char c)
{
34809b6c:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809b70:	e3520000 	cmp	r2, #0
34809b74:	012fff1e 	bxeq	lr
		return pre_console_putc(c);

	if (gd->flags & GD_FLG_DEVINIT) {
34809b78:	e5983004 	ldr	r3, [r8, #4]
34809b7c:	e3130002 	tst	r3, #2
34809b80:	0a000001 	beq	34809b8c <putc+0x24>
		/* Send to the standard output */
		fputc(stdout, c);
34809b84:	e3a00001 	mov	r0, #1
34809b88:	eaffffbd 	b	34809a84 <fputc>
	} else {
		/* Send directly to the handler */
		serial_putc(c);
34809b8c:	ea001556 	b	3480f0ec <serial_putc>

34809b90 <puts>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809b90:	e598200c 	ldr	r2, [r8, #12]
		serial_putc(c);
	}
}

void puts(const char *s)
{
34809b94:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809b98:	e3520000 	cmp	r2, #0
34809b9c:	012fff1e 	bxeq	lr
		return pre_console_puts(s);

	if (gd->flags & GD_FLG_DEVINIT) {
34809ba0:	e5983004 	ldr	r3, [r8, #4]
34809ba4:	e3130002 	tst	r3, #2
34809ba8:	0a000001 	beq	34809bb4 <puts+0x24>
		/* Send to the standard output */
		fputs(stdout, s);
34809bac:	e3a00001 	mov	r0, #1
34809bb0:	eaffffbd 	b	34809aac <fputs>
	} else {
		/* Send directly to the handler */
		serial_puts(s);
34809bb4:	ea001553 	b	3480f108 <serial_puts>

34809bb8 <printf>:
	}
}

int printf(const char *fmt, ...)
{
34809bb8:	e92d000f 	push	{r0, r1, r2, r3}
34809bbc:	e92d4030 	push	{r4, r5, lr}
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809bc0:	e598500c 	ldr	r5, [r8, #12]
		serial_puts(s);
	}
}

int printf(const char *fmt, ...)
{
34809bc4:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809bc8:	e3550000 	cmp	r5, #0
34809bcc:	0a000008 	beq	34809bf4 <printf+0x3c>
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809bd0:	e28d4004 	add	r4, sp, #4
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
34809bd4:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809bd8:	e1a00004 	mov	r0, r4
34809bdc:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
34809be0:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809be4:	eb004edc 	bl	3481d75c <vsprintf>
34809be8:	e1a05000 	mov	r5, r0
	va_end(args);

	/* Print the string */
	puts(printbuffer);
34809bec:	e1a00004 	mov	r0, r4
34809bf0:	ebffffe6 	bl	34809b90 <puts>
	return i;
}
34809bf4:	e1a00005 	mov	r0, r5
34809bf8:	e28ddf63 	add	sp, sp, #396	; 0x18c
34809bfc:	e8bd4030 	pop	{r4, r5, lr}
34809c00:	e28dd010 	add	sp, sp, #16
34809c04:	e12fff1e 	bx	lr

34809c08 <vprintf>:

int vprintf(const char *fmt, va_list args)
{
34809c08:	e92d4030 	push	{r4, r5, lr}
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809c0c:	e598500c 	ldr	r5, [r8, #12]
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
34809c10:	e24ddf61 	sub	sp, sp, #388	; 0x184
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809c14:	e3550000 	cmp	r5, #0
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
34809c18:	e1a03000 	mov	r3, r0
34809c1c:	e1a02001 	mov	r2, r1
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809c20:	0a000006 	beq	34809c40 <vprintf+0x38>
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809c24:	e1a0000d 	mov	r0, sp
34809c28:	e1a01003 	mov	r1, r3
34809c2c:	eb004eca 	bl	3481d75c <vsprintf>
34809c30:	e1a05000 	mov	r5, r0

	/* Print the string */
	puts(printbuffer);
34809c34:	e1a0000d 	mov	r0, sp
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809c38:	e1a0400d 	mov	r4, sp

	/* Print the string */
	puts(printbuffer);
34809c3c:	ebffffd3 	bl	34809b90 <puts>
	return i;
}
34809c40:	e1a00005 	mov	r0, r5
34809c44:	e28ddf61 	add	sp, sp, #388	; 0x184
34809c48:	e8bd8030 	pop	{r4, r5, pc}

34809c4c <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
34809c4c:	e92d4038 	push	{r3, r4, r5, lr}
	if (!ctrlc_disabled && gd->have_console) {
34809c50:	e59f503c 	ldr	r5, [pc, #60]	; 34809c94 <ctrlc+0x48>
34809c54:	e5954000 	ldr	r4, [r5]
34809c58:	e3540000 	cmp	r4, #0
			default:
				break;
			}
		}
	}
	return 0;
34809c5c:	13a00000 	movne	r0, #0
/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
	if (!ctrlc_disabled && gd->have_console) {
34809c60:	18bd8038 	popne	{r3, r4, r5, pc}
34809c64:	e598000c 	ldr	r0, [r8, #12]
34809c68:	e3500000 	cmp	r0, #0
34809c6c:	08bd8038 	popeq	{r3, r4, r5, pc}
		if (tstc()) {
34809c70:	ebffffb3 	bl	34809b44 <tstc>
34809c74:	e3500000 	cmp	r0, #0
34809c78:	08bd8038 	popeq	{r3, r4, r5, pc}
			switch (getc()) {
34809c7c:	ebffffa7 	bl	34809b20 <getc>
34809c80:	e3500003 	cmp	r0, #3
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
34809c84:	03a00001 	moveq	r0, #1
34809c88:	05850004 	streq	r0, [r5, #4]
			default:
				break;
			}
		}
	}
	return 0;
34809c8c:	11a00004 	movne	r0, r4
}
34809c90:	e8bd8038 	pop	{r3, r4, r5, pc}
34809c94:	3482a020 	.word	0x3482a020

34809c98 <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc(int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
34809c98:	e59f300c 	ldr	r3, [pc, #12]	; 34809cac <disable_ctrlc+0x14>
34809c9c:	e5932000 	ldr	r2, [r3]

	ctrlc_disabled = disable;
34809ca0:	e5830000 	str	r0, [r3]
	return prev;
}
34809ca4:	e1a00002 	mov	r0, r2
34809ca8:	e12fff1e 	bx	lr
34809cac:	3482a020 	.word	0x3482a020

34809cb0 <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
}
34809cb0:	e59f3004 	ldr	r3, [pc, #4]	; 34809cbc <had_ctrlc+0xc>
34809cb4:	e5930004 	ldr	r0, [r3, #4]
34809cb8:	e12fff1e 	bx	lr
34809cbc:	3482a020 	.word	0x3482a020

34809cc0 <clear_ctrlc>:

void clear_ctrlc(void)
{
	ctrlc_was_pressed = 0;
34809cc0:	e59f3008 	ldr	r3, [pc, #8]	; 34809cd0 <clear_ctrlc+0x10>
34809cc4:	e3a02000 	mov	r2, #0
34809cc8:	e5832004 	str	r2, [r3, #4]
}
34809ccc:	e12fff1e 	bx	lr
34809cd0:	3482a020 	.word	0x3482a020

34809cd4 <dbg>:
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
34809cd4:	e92d000f 	push	{r0, r1, r2, r3}
}
34809cd8:	e28dd010 	add	sp, sp, #16
34809cdc:	e12fff1e 	bx	lr

34809ce0 <search_device>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

struct stdio_dev *search_device(int flags, const char *name)
{
34809ce0:	e92d4010 	push	{r4, lr}
34809ce4:	e1a04000 	mov	r4, r0
	struct stdio_dev *dev;

	dev = stdio_get_by_name(name);
34809ce8:	e1a00001 	mov	r0, r1
34809cec:	eb00150f 	bl	3480f130 <stdio_get_by_name>

	if (dev && (dev->flags & flags))
34809cf0:	e3500000 	cmp	r0, #0
34809cf4:	08bd8010 	popeq	{r4, pc}
34809cf8:	e5903000 	ldr	r3, [r0]
34809cfc:	e0144003 	ands	r4, r4, r3
		return dev;

	return NULL;
34809d00:	01a00004 	moveq	r0, r4
}
34809d04:	e8bd8010 	pop	{r4, pc}

34809d08 <console_assign>:

int console_assign(int file, const char *devname)
{
34809d08:	e92d4010 	push	{r4, lr}
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
34809d0c:	e2504000 	subs	r4, r0, #0
	case stdin:
		flag = DEV_FLAGS_INPUT;
34809d10:	03a00001 	moveq	r0, #1
{
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
34809d14:	0a000003 	beq	34809d28 <console_assign+0x20>
34809d18:	ba000008 	blt	34809d40 <console_assign+0x38>
34809d1c:	e3540002 	cmp	r4, #2
34809d20:	ca000006 	bgt	34809d40 <console_assign+0x38>
	case stdin:
		flag = DEV_FLAGS_INPUT;
		break;
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
34809d24:	e3a00002 	mov	r0, #2
		return -1;
	}

	/* Check for valid device name */

	dev = search_device(flag, devname);
34809d28:	ebffffec 	bl	34809ce0 <search_device>

	if (dev)
34809d2c:	e2501000 	subs	r1, r0, #0
34809d30:	0a000002 	beq	34809d40 <console_assign+0x38>
		return console_setfile(file, dev);
34809d34:	e1a00004 	mov	r0, r4

	return -1;
}
34809d38:	e8bd4010 	pop	{r4, lr}
	/* Check for valid device name */

	dev = search_device(flag, devname);

	if (dev)
		return console_setfile(file, dev);
34809d3c:	eaffff00 	b	34809944 <console_setfile>

	return -1;
}
34809d40:	e3e00000 	mvn	r0, #0
34809d44:	e8bd8010 	pop	{r4, pc}

34809d48 <console_init_f>:

/* Called before relocation - use serial functions */
int console_init_f(void)
{
	gd->have_console = 1;
34809d48:	e3a02001 	mov	r2, #1
34809d4c:	e588200c 	str	r2, [r8, #12]
#endif

	print_pre_console_buffer();

	return 0;
}
34809d50:	e3a00000 	mov	r0, #0
34809d54:	e12fff1e 	bx	lr

34809d58 <stdio_print_current_devices>:

void stdio_print_current_devices(void)
{
34809d58:	e92d4010 	push	{r4, lr}
#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	/* Print information */
	puts("In:    ");
34809d5c:	e59f008c 	ldr	r0, [pc, #140]	; 34809df0 <stdio_print_current_devices+0x98>
34809d60:	ebffff8a 	bl	34809b90 <puts>
	if (stdio_devices[stdin] == NULL) {
34809d64:	e59f3088 	ldr	r3, [pc, #136]	; 34809df4 <stdio_print_current_devices+0x9c>
34809d68:	e5931000 	ldr	r1, [r3]
34809d6c:	e3510000 	cmp	r1, #0
34809d70:	1a000002 	bne	34809d80 <stdio_print_current_devices+0x28>
		puts("No input devices available!\n");
34809d74:	e59f007c 	ldr	r0, [pc, #124]	; 34809df8 <stdio_print_current_devices+0xa0>
34809d78:	ebffff84 	bl	34809b90 <puts>
34809d7c:	ea000002 	b	34809d8c <stdio_print_current_devices+0x34>
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
34809d80:	e59f0074 	ldr	r0, [pc, #116]	; 34809dfc <stdio_print_current_devices+0xa4>
34809d84:	e2811008 	add	r1, r1, #8
34809d88:	ebffff8a 	bl	34809bb8 <printf>
	}

	puts("Out:   ");
34809d8c:	e59f006c 	ldr	r0, [pc, #108]	; 34809e00 <stdio_print_current_devices+0xa8>
34809d90:	ebffff7e 	bl	34809b90 <puts>
	if (stdio_devices[stdout] == NULL) {
34809d94:	e59f3058 	ldr	r3, [pc, #88]	; 34809df4 <stdio_print_current_devices+0x9c>
34809d98:	e5931004 	ldr	r1, [r3, #4]
34809d9c:	e3510000 	cmp	r1, #0
34809da0:	1a000002 	bne	34809db0 <stdio_print_current_devices+0x58>
		puts("No output devices available!\n");
34809da4:	e59f0058 	ldr	r0, [pc, #88]	; 34809e04 <stdio_print_current_devices+0xac>
34809da8:	ebffff78 	bl	34809b90 <puts>
34809dac:	ea000002 	b	34809dbc <stdio_print_current_devices+0x64>
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
34809db0:	e59f0044 	ldr	r0, [pc, #68]	; 34809dfc <stdio_print_current_devices+0xa4>
34809db4:	e2811008 	add	r1, r1, #8
34809db8:	ebffff7e 	bl	34809bb8 <printf>
	}

	puts("Err:   ");
34809dbc:	e59f0044 	ldr	r0, [pc, #68]	; 34809e08 <stdio_print_current_devices+0xb0>
34809dc0:	ebffff72 	bl	34809b90 <puts>
	if (stdio_devices[stderr] == NULL) {
34809dc4:	e59f3028 	ldr	r3, [pc, #40]	; 34809df4 <stdio_print_current_devices+0x9c>
34809dc8:	e5931008 	ldr	r1, [r3, #8]
34809dcc:	e3510000 	cmp	r1, #0
34809dd0:	1a000002 	bne	34809de0 <stdio_print_current_devices+0x88>
		puts("No error devices available!\n");
34809dd4:	e59f0030 	ldr	r0, [pc, #48]	; 34809e0c <stdio_print_current_devices+0xb4>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
34809dd8:	e8bd4010 	pop	{r4, lr}
		printf ("%s\n", stdio_devices[stdout]->name);
	}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
34809ddc:	eaffff6b 	b	34809b90 <puts>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
34809de0:	e59f0014 	ldr	r0, [pc, #20]	; 34809dfc <stdio_print_current_devices+0xa4>
34809de4:	e2811008 	add	r1, r1, #8
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
34809de8:	e8bd4010 	pop	{r4, lr}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
34809dec:	eaffff71 	b	34809bb8 <printf>
34809df0:	348262b3 	.word	0x348262b3
34809df4:	3482b868 	.word	0x3482b868
34809df8:	348262bb 	.word	0x348262bb
34809dfc:	34826164 	.word	0x34826164
34809e00:	348262d8 	.word	0x348262d8
34809e04:	348262e0 	.word	0x348262e0
34809e08:	348262fe 	.word	0x348262fe
34809e0c:	34826306 	.word	0x34826306

34809e10 <console_init_r>:
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
34809e10:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809e14:	e59f1124 	ldr	r1, [pc, #292]	; 34809f40 <console_init_r+0x130>
}

#ifdef CONFIG_SYS_CONSOLE_IS_IN_ENV
/* Called after the relocation - use desired console functions */
int console_init_r(void)
{
34809e18:	e92d4070 	push	{r4, r5, r6, lr}
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
34809e1c:	e5821004 	str	r1, [r2, #4]
	gd->jt[XF_tstc] = serial_tstc;
34809e20:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809e24:	e59f1118 	ldr	r1, [pc, #280]	; 34809f44 <console_init_r+0x134>
	gd->jt[XF_puts] = serial_puts;
	gd->jt[XF_printf] = serial_printf;

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
34809e28:	e59f0118 	ldr	r0, [pc, #280]	; 34809f48 <console_init_r+0x138>
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
34809e2c:	e5821008 	str	r1, [r2, #8]
	gd->jt[XF_putc] = serial_putc;
34809e30:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809e34:	e59f1110 	ldr	r1, [pc, #272]	; 34809f4c <console_init_r+0x13c>
34809e38:	e582100c 	str	r1, [r2, #12]
	gd->jt[XF_puts] = serial_puts;
34809e3c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34809e40:	e59f1108 	ldr	r1, [pc, #264]	; 34809f50 <console_init_r+0x140>
	gd->jt[XF_printf] = serial_printf;
34809e44:	e5983054 	ldr	r3, [r8, #84]	; 0x54

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
	gd->jt[XF_putc] = serial_putc;
	gd->jt[XF_puts] = serial_puts;
34809e48:	e5821010 	str	r1, [r2, #16]
	gd->jt[XF_printf] = serial_printf;
34809e4c:	e59f2100 	ldr	r2, [pc, #256]	; 34809f54 <console_init_r+0x144>
34809e50:	e5832014 	str	r2, [r3, #20]

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
34809e54:	ebfff869 	bl	34808000 <getenv>
34809e58:	e1a04000 	mov	r4, r0
	stdoutname = getenv("stdout");
34809e5c:	e59f00f4 	ldr	r0, [pc, #244]	; 34809f58 <console_init_r+0x148>
34809e60:	ebfff866 	bl	34808000 <getenv>
34809e64:	e1a06000 	mov	r6, r0
	stderrname = getenv("stderr");
34809e68:	e59f00ec 	ldr	r0, [pc, #236]	; 34809f5c <console_init_r+0x14c>
34809e6c:	ebfff863 	bl	34808000 <getenv>

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809e70:	e1a01004 	mov	r1, r4

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");
34809e74:	e1a05000 	mov	r5, r0

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809e78:	e3a00001 	mov	r0, #1
34809e7c:	ebffff97 	bl	34809ce0 <search_device>
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809e80:	e1a01006 	mov	r1, r6
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809e84:	e1a04000 	mov	r4, r0
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809e88:	e3a00002 	mov	r0, #2
34809e8c:	ebffff93 	bl	34809ce0 <search_device>
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809e90:	e1a01005 	mov	r1, r5
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809e94:	e1a06000 	mov	r6, r0
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809e98:	e3a00002 	mov	r0, #2
34809e9c:	ebffff8f 	bl	34809ce0 <search_device>
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
34809ea0:	e3540000 	cmp	r4, #0
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809ea4:	e1a05000 	mov	r5, r0
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
34809ea8:	1a000003 	bne	34809ebc <console_init_r+0xac>
		inputdev  = search_device(DEV_FLAGS_INPUT,  "serial");
34809eac:	e3a00001 	mov	r0, #1
34809eb0:	e59f10a8 	ldr	r1, [pc, #168]	; 34809f60 <console_init_r+0x150>
34809eb4:	ebffff89 	bl	34809ce0 <search_device>
34809eb8:	e1a04000 	mov	r4, r0
	}
	if (outputdev == NULL) {
34809ebc:	e3560000 	cmp	r6, #0
34809ec0:	1a000003 	bne	34809ed4 <console_init_r+0xc4>
		outputdev = search_device(DEV_FLAGS_OUTPUT, "serial");
34809ec4:	e3a00002 	mov	r0, #2
34809ec8:	e59f1090 	ldr	r1, [pc, #144]	; 34809f60 <console_init_r+0x150>
34809ecc:	ebffff83 	bl	34809ce0 <search_device>
34809ed0:	e1a06000 	mov	r6, r0
	}
	if (errdev == NULL) {
34809ed4:	e3550000 	cmp	r5, #0
34809ed8:	1a000003 	bne	34809eec <console_init_r+0xdc>
		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
34809edc:	e3a00002 	mov	r0, #2
34809ee0:	e59f1078 	ldr	r1, [pc, #120]	; 34809f60 <console_init_r+0x150>
34809ee4:	ebffff7d 	bl	34809ce0 <search_device>
34809ee8:	e1a05000 	mov	r5, r0
	}
	/* Initializes output console first */
	if (outputdev != NULL) {
34809eec:	e3560000 	cmp	r6, #0
34809ef0:	0a000002 	beq	34809f00 <console_init_r+0xf0>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
34809ef4:	e3a00001 	mov	r0, #1
34809ef8:	e1a01006 	mov	r1, r6
34809efc:	ebfffe90 	bl	34809944 <console_setfile>
	/* Initializes output console first */
	if (outputdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stdout, outputdev);
	}
	if (errdev != NULL) {
34809f00:	e3550000 	cmp	r5, #0
34809f04:	0a000002 	beq	34809f14 <console_init_r+0x104>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
34809f08:	e3a00002 	mov	r0, #2
34809f0c:	e1a01005 	mov	r1, r5
34809f10:	ebfffe8b 	bl	34809944 <console_setfile>
	}
	if (errdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stderr, errdev);
	}
	if (inputdev != NULL) {
34809f14:	e3540000 	cmp	r4, #0
34809f18:	0a000002 	beq	34809f28 <console_init_r+0x118>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
34809f1c:	e3a00000 	mov	r0, #0
34809f20:	e1a01004 	mov	r1, r4
34809f24:	ebfffe86 	bl	34809944 <console_setfile>

#ifdef CONFIG_CONSOLE_MUX
done:
#endif

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
34809f28:	e5982004 	ldr	r2, [r8, #4]
34809f2c:	e3822002 	orr	r2, r2, #2
34809f30:	e5882004 	str	r2, [r8, #4]

	stdio_print_current_devices();
34809f34:	ebffff87 	bl	34809d58 <stdio_print_current_devices>
	/* If nothing usable installed, use only the initial console */
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return 0;
#endif
	return 0;
}
34809f38:	e3a00000 	mov	r0, #0
34809f3c:	e8bd8070 	pop	{r4, r5, r6, pc}
34809f40:	3480f0c4 	.word	0x3480f0c4
34809f44:	3480f0d8 	.word	0x3480f0d8
34809f48:	34825525 	.word	0x34825525
34809f4c:	3480f0ec 	.word	0x3480f0ec
34809f50:	3480f108 	.word	0x3480f108
34809f54:	348099e8 	.word	0x348099e8
34809f58:	3482552b 	.word	0x3482552b
34809f5c:	34825532 	.word	0x34825532
34809f60:	34826323 	.word	0x34826323

34809f64 <sbrk>:
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
34809f64:	e92d4038 	push	{r3, r4, r5, lr}
	ulong old = mem_malloc_brk;
34809f68:	e59f304c 	ldr	r3, [pc, #76]	; 34809fbc <sbrk+0x58>

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809f6c:	e3500000 	cmp	r0, #0
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
34809f70:	e5935000 	ldr	r5, [r3]
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
34809f74:	e1a02000 	mov	r2, r0
	ulong old = mem_malloc_brk;
	ulong new = old + increment;
34809f78:	e0804005 	add	r4, r0, r5

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809f7c:	aa000003 	bge	34809f90 <sbrk+0x2c>
		memset((void *)new, 0, -increment);
34809f80:	e1a00004 	mov	r0, r4
34809f84:	e3a01000 	mov	r1, #0
34809f88:	e2622000 	rsb	r2, r2, #0
34809f8c:	eb004a5a 	bl	3481c8fc <memset>

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
34809f90:	e59f3024 	ldr	r3, [pc, #36]	; 34809fbc <sbrk+0x58>
34809f94:	e5932004 	ldr	r2, [r3, #4]
34809f98:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;
34809f9c:	33e00000 	mvncc	r0, #0
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
34809fa0:	38bd8038 	popcc	{r3, r4, r5, pc}
34809fa4:	e5932008 	ldr	r2, [r3, #8]
34809fa8:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;

	mem_malloc_brk = new;
34809fac:	95834000 	strls	r4, [r3]

	return (void *)old;
34809fb0:	91a00005 	movls	r0, r5
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
		return (void *)MORECORE_FAILURE;
34809fb4:	83e00000 	mvnhi	r0, #0

	mem_malloc_brk = new;

	return (void *)old;
}
34809fb8:	e8bd8038 	pop	{r3, r4, r5, pc}
34809fbc:	3482a028 	.word	0x3482a028

34809fc0 <mem_malloc_init>:

void mem_malloc_init(ulong start, ulong size)
{
34809fc0:	e1a02001 	mov	r2, r1
	mem_malloc_start = start;
34809fc4:	e59f1010 	ldr	r1, [pc, #16]	; 34809fdc <mem_malloc_init+0x1c>
	mem_malloc_end = start + size;
34809fc8:	e082c000 	add	ip, r2, r0
	return (void *)old;
}

void mem_malloc_init(ulong start, ulong size)
{
	mem_malloc_start = start;
34809fcc:	e9811001 	stmib	r1, {r0, ip}
	mem_malloc_end = start + size;
	mem_malloc_brk = start;
34809fd0:	e5810000 	str	r0, [r1]

	memset((void *)mem_malloc_start, 0, size);
34809fd4:	e3a01000 	mov	r1, #0
34809fd8:	ea004a47 	b	3481c8fc <memset>
34809fdc:	3482a028 	.word	0x3482a028

34809fe0 <malloc_trim>:
#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
34809fe0:	e92d4070 	push	{r4, r5, r6, lr}
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
34809fe4:	e59f40bc 	ldr	r4, [pc, #188]	; 3480a0a8 <malloc_trim+0xc8>
34809fe8:	e5943008 	ldr	r3, [r4, #8]
34809fec:	e5936004 	ldr	r6, [r3, #4]
34809ff0:	e3c66003 	bic	r6, r6, #3
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
34809ff4:	e0605006 	rsb	r5, r0, r6
34809ff8:	e2855efe 	add	r5, r5, #4064	; 0xfe0
34809ffc:	e285500f 	add	r5, r5, #15
3480a000:	e3c55eff 	bic	r5, r5, #4080	; 0xff0
3480a004:	e3c5500f 	bic	r5, r5, #15
3480a008:	e2455a01 	sub	r5, r5, #4096	; 0x1000

  if (extra < (long)pagesz)  /* Not enough memory to release */
3480a00c:	e3550a01 	cmp	r5, #4096	; 0x1000
3480a010:	ba000020 	blt	3480a098 <malloc_trim+0xb8>
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
3480a014:	e3a00000 	mov	r0, #0
3480a018:	ebffffd1 	bl	34809f64 <sbrk>
    if (current_brk != (char*)(top) + top_size)
3480a01c:	e5943008 	ldr	r3, [r4, #8]
3480a020:	e0833006 	add	r3, r3, r6
3480a024:	e1500003 	cmp	r0, r3
3480a028:	1a00001a 	bne	3480a098 <malloc_trim+0xb8>
      return 0;     /* Apparently we don't own memory; must fail */

    else
    {
      new_brk = (char*)(MORECORE (-extra));
3480a02c:	e2650000 	rsb	r0, r5, #0
3480a030:	ebffffcb 	bl	34809f64 <sbrk>

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
3480a034:	e3700001 	cmn	r0, #1
3480a038:	1a00000c 	bne	3480a070 <malloc_trim+0x90>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
3480a03c:	e2800001 	add	r0, r0, #1
3480a040:	ebffffc7 	bl	34809f64 <sbrk>
	top_size = current_brk - (char*)top;
3480a044:	e5943008 	ldr	r3, [r4, #8]
3480a048:	e0632000 	rsb	r2, r3, r0
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
3480a04c:	e352000f 	cmp	r2, #15
3480a050:	da000012 	ble	3480a0a0 <malloc_trim+0xc0>
	{
	  sbrked_mem = current_brk - sbrk_base;
3480a054:	e5941408 	ldr	r1, [r4, #1032]	; 0x408
	  set_head(top, top_size | PREV_INUSE);
3480a058:	e3822001 	orr	r2, r2, #1
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
3480a05c:	e0610000 	rsb	r0, r1, r0
3480a060:	e59f1044 	ldr	r1, [pc, #68]	; 3480a0ac <malloc_trim+0xcc>
	  set_head(top, top_size | PREV_INUSE);
3480a064:	e5832004 	str	r2, [r3, #4]
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
3480a068:	e581000c 	str	r0, [r1, #12]
3480a06c:	ea000009 	b	3480a098 <malloc_trim+0xb8>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
3480a070:	e5943008 	ldr	r3, [r4, #8]
3480a074:	e0656006 	rsb	r6, r5, r6
3480a078:	e3866001 	orr	r6, r6, #1
3480a07c:	e5836004 	str	r6, [r3, #4]
	sbrked_mem -= extra;
3480a080:	e59f3024 	ldr	r3, [pc, #36]	; 3480a0ac <malloc_trim+0xcc>
	check_chunk(top);
	return 1;
3480a084:	e3a00001 	mov	r0, #1

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
	sbrked_mem -= extra;
3480a088:	e593200c 	ldr	r2, [r3, #12]
3480a08c:	e0655002 	rsb	r5, r5, r2
3480a090:	e583500c 	str	r5, [r3, #12]
	check_chunk(top);
	return 1;
3480a094:	e8bd8070 	pop	{r4, r5, r6, pc}
  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
    if (current_brk != (char*)(top) + top_size)
      return 0;     /* Apparently we don't own memory; must fail */
3480a098:	e3a00000 	mov	r0, #0
3480a09c:	e8bd8070 	pop	{r4, r5, r6, pc}
	{
	  sbrked_mem = current_brk - sbrk_base;
	  set_head(top, top_size | PREV_INUSE);
	}
	check_chunk(top);
	return 0;
3480a0a0:	e3a00000 	mov	r0, #0
	check_chunk(top);
	return 1;
      }
    }
  }
}
3480a0a4:	e8bd8070 	pop	{r4, r5, r6, pc}
3480a0a8:	3482885c 	.word	0x3482885c
3480a0ac:	3482a028 	.word	0x3482a028

3480a0b0 <free>:
#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
3480a0b0:	e92d4070 	push	{r4, r5, r6, lr}
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
3480a0b4:	e2504000 	subs	r4, r0, #0
3480a0b8:	08bd8070 	popeq	{r4, r5, r6, pc}
    return;

  p = mem2chunk(mem);
  hd = p->size;
3480a0bc:	e5140004 	ldr	r0, [r4, #-4]

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
3480a0c0:	e59f51fc 	ldr	r5, [pc, #508]	; 3480a2c4 <free+0x214>
  }
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
3480a0c4:	e3c02001 	bic	r2, r0, #1
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  p = mem2chunk(mem);
3480a0c8:	e2443008 	sub	r3, r4, #8
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
3480a0cc:	e0831002 	add	r1, r3, r2
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
3480a0d0:	e5956008 	ldr	r6, [r5, #8]

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
3480a0d4:	e591c004 	ldr	ip, [r1, #4]

  if (next == top)                            /* merge with top */
3480a0d8:	e1510006 	cmp	r1, r6

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
3480a0dc:	e3ccc003 	bic	ip, ip, #3
3480a0e0:	e2000001 	and	r0, r0, #1

  if (next == top)                            /* merge with top */
3480a0e4:	1a000014 	bne	3480a13c <free+0x8c>
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480a0e8:	e3500000 	cmp	r0, #0
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
3480a0ec:	e08c2002 	add	r2, ip, r2

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480a0f0:	1a000006 	bne	3480a110 <free+0x60>
    {
      prevsz = p->prev_size;
3480a0f4:	e5141008 	ldr	r1, [r4, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
3480a0f8:	e0613003 	rsb	r3, r1, r3
      sz += prevsz;
      unlink(p, bck, fwd);
3480a0fc:	e5930008 	ldr	r0, [r3, #8]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
3480a100:	e0822001 	add	r2, r2, r1
      unlink(p, bck, fwd);
3480a104:	e593100c 	ldr	r1, [r3, #12]
3480a108:	e580100c 	str	r1, [r0, #12]
3480a10c:	e5810008 	str	r0, [r1, #8]
    }

    set_head(p, sz | PREV_INUSE);
3480a110:	e3821001 	orr	r1, r2, #1
3480a114:	e5831004 	str	r1, [r3, #4]
    top = p;
3480a118:	e59f11a4 	ldr	r1, [pc, #420]	; 3480a2c4 <free+0x214>
3480a11c:	e5813008 	str	r3, [r1, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
3480a120:	e591340c 	ldr	r3, [r1, #1036]	; 0x40c
3480a124:	e1520003 	cmp	r2, r3
3480a128:	38bd8070 	popcc	{r4, r5, r6, pc}
      malloc_trim(top_pad);
3480a12c:	e59f3194 	ldr	r3, [pc, #404]	; 3480a2c8 <free+0x218>
3480a130:	e5930034 	ldr	r0, [r3, #52]	; 0x34

  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);
}
3480a134:	e8bd4070 	pop	{r4, r5, r6, lr}
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
3480a138:	eaffffa8 	b	34809fe0 <malloc_trim>

  set_head(next, nextsz);                    /* clear inuse bit */

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480a13c:	e3500000 	cmp	r0, #0
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
3480a140:	e581c004 	str	ip, [r1, #4]

  islr = 0;
3480a144:	13a00000 	movne	r0, #0

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480a148:	1a000009 	bne	3480a174 <free+0xc4>
  {
    prevsz = p->prev_size;
3480a14c:	e5144008 	ldr	r4, [r4, #-8]
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
3480a150:	e2855008 	add	r5, r5, #8
  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
3480a154:	e0643003 	rsb	r3, r4, r3
    sz += prevsz;
3480a158:	e0822004 	add	r2, r2, r4

    if (p->fd == last_remainder)             /* keep as last_remainder */
3480a15c:	e5934008 	ldr	r4, [r3, #8]
3480a160:	e1540005 	cmp	r4, r5
      islr = 1;
    else
      unlink(p, bck, fwd);
3480a164:	1593500c 	ldrne	r5, [r3, #12]
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
      islr = 1;
3480a168:	03a00001 	moveq	r0, #1
    else
      unlink(p, bck, fwd);
3480a16c:	1584500c 	strne	r5, [r4, #12]
3480a170:	15854008 	strne	r4, [r5, #8]
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
3480a174:	e081400c 	add	r4, r1, ip
3480a178:	e5944004 	ldr	r4, [r4, #4]
3480a17c:	e3140001 	tst	r4, #1
3480a180:	1a000010 	bne	3480a1c8 <free+0x118>
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
3480a184:	e3500000 	cmp	r0, #0
      unlink(p, bck, fwd);
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
3480a188:	e082200c 	add	r2, r2, ip

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
3480a18c:	1a000009 	bne	3480a1b8 <free+0x108>
3480a190:	e591c008 	ldr	ip, [r1, #8]
3480a194:	e59f4130 	ldr	r4, [pc, #304]	; 3480a2cc <free+0x21c>
3480a198:	e15c0004 	cmp	ip, r4
3480a19c:	1a000005 	bne	3480a1b8 <free+0x108>
    {
      islr = 1;
      link_last_remainder(p);
3480a1a0:	e58c300c 	str	r3, [ip, #12]
3480a1a4:	e58c3008 	str	r3, [ip, #8]
3480a1a8:	e583c00c 	str	ip, [r3, #12]
3480a1ac:	e583c008 	str	ip, [r3, #8]
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
3480a1b0:	e2800001 	add	r0, r0, #1
      link_last_remainder(p);
3480a1b4:	ea000003 	b	3480a1c8 <free+0x118>
    }
    else
      unlink(next, bck, fwd);
3480a1b8:	e591c00c 	ldr	ip, [r1, #12]
3480a1bc:	e5911008 	ldr	r1, [r1, #8]
3480a1c0:	e581c00c 	str	ip, [r1, #12]
3480a1c4:	e58c1008 	str	r1, [ip, #8]
  }


  set_head(p, sz | PREV_INUSE);
3480a1c8:	e3821001 	orr	r1, r2, #1
  set_foot(p, sz);
  if (!islr)
3480a1cc:	e3500000 	cmp	r0, #0
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
3480a1d0:	e5831004 	str	r1, [r3, #4]
  set_foot(p, sz);
3480a1d4:	e7832002 	str	r2, [r3, r2]
  if (!islr)
3480a1d8:	18bd8070 	popne	{r4, r5, r6, pc}
    frontlink(p, sz, idx, bck, fwd);
3480a1dc:	e3520c02 	cmp	r2, #512	; 0x200
3480a1e0:	2a000009 	bcs	3480a20c <free+0x15c>
3480a1e4:	e59f10d8 	ldr	r1, [pc, #216]	; 3480a2c4 <free+0x214>
3480a1e8:	e1a021a2 	lsr	r2, r2, #3
3480a1ec:	e591c004 	ldr	ip, [r1, #4]
3480a1f0:	e1a00142 	asr	r0, r2, #2
3480a1f4:	e3a04001 	mov	r4, #1
3480a1f8:	e18c0014 	orr	r0, ip, r4, lsl r0
3480a1fc:	e0812182 	add	r2, r1, r2, lsl #3
3480a200:	e5810004 	str	r0, [r1, #4]
3480a204:	e5921008 	ldr	r1, [r2, #8]
3480a208:	ea000028 	b	3480a2b0 <free+0x200>
3480a20c:	e1a004a2 	lsr	r0, r2, #9
3480a210:	e3500004 	cmp	r0, #4
3480a214:	91a00322 	lsrls	r0, r2, #6
3480a218:	92800038 	addls	r0, r0, #56	; 0x38
3480a21c:	9a00000f 	bls	3480a260 <free+0x1b0>
3480a220:	e3500014 	cmp	r0, #20
3480a224:	9280005b 	addls	r0, r0, #91	; 0x5b
3480a228:	9a00000c 	bls	3480a260 <free+0x1b0>
3480a22c:	e3500054 	cmp	r0, #84	; 0x54
3480a230:	91a00622 	lsrls	r0, r2, #12
3480a234:	9280006e 	addls	r0, r0, #110	; 0x6e
3480a238:	9a000008 	bls	3480a260 <free+0x1b0>
3480a23c:	e3500f55 	cmp	r0, #340	; 0x154
3480a240:	91a007a2 	lsrls	r0, r2, #15
3480a244:	92800077 	addls	r0, r0, #119	; 0x77
3480a248:	9a000004 	bls	3480a260 <free+0x1b0>
3480a24c:	e3001554 	movw	r1, #1364	; 0x554
3480a250:	e1500001 	cmp	r0, r1
3480a254:	91a00922 	lsrls	r0, r2, #18
3480a258:	9280007c 	addls	r0, r0, #124	; 0x7c
3480a25c:	83a0007e 	movhi	r0, #126	; 0x7e
3480a260:	e59fc05c 	ldr	ip, [pc, #92]	; 3480a2c4 <free+0x214>
3480a264:	e08c4180 	add	r4, ip, r0, lsl #3
3480a268:	e5941008 	ldr	r1, [r4, #8]
3480a26c:	e1510004 	cmp	r1, r4
3480a270:	1a000009 	bne	3480a29c <free+0x1ec>
3480a274:	e59c2004 	ldr	r2, [ip, #4]
3480a278:	e1a00140 	asr	r0, r0, #2
3480a27c:	e3a04001 	mov	r4, #1
3480a280:	e1820014 	orr	r0, r2, r4, lsl r0
3480a284:	e1a02001 	mov	r2, r1
3480a288:	e58c0004 	str	r0, [ip, #4]
3480a28c:	ea000007 	b	3480a2b0 <free+0x200>
3480a290:	e5911008 	ldr	r1, [r1, #8]
3480a294:	e1510004 	cmp	r1, r4
3480a298:	0a000003 	beq	3480a2ac <free+0x1fc>
3480a29c:	e5910004 	ldr	r0, [r1, #4]
3480a2a0:	e3c00003 	bic	r0, r0, #3
3480a2a4:	e1520000 	cmp	r2, r0
3480a2a8:	3afffff8 	bcc	3480a290 <free+0x1e0>
3480a2ac:	e591200c 	ldr	r2, [r1, #12]
3480a2b0:	e583200c 	str	r2, [r3, #12]
3480a2b4:	e5831008 	str	r1, [r3, #8]
3480a2b8:	e5823008 	str	r3, [r2, #8]
3480a2bc:	e581300c 	str	r3, [r1, #12]
3480a2c0:	e8bd8070 	pop	{r4, r5, r6, pc}
3480a2c4:	3482885c 	.word	0x3482885c
3480a2c8:	3482a028 	.word	0x3482a028
3480a2cc:	34828864 	.word	0x34828864

3480a2d0 <cfree>:
void cfree(Void_t *mem)
#else
void cfree(mem) Void_t *mem;
#endif
{
  fREe(mem);
3480a2d0:	eaffff76 	b	3480a0b0 <free>

3480a2d4 <malloc>:
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
3480a2d4:	e59f35a0 	ldr	r3, [pc, #1440]	; 3480a87c <malloc+0x5a8>
#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
3480a2d8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
3480a2dc:	e5932004 	ldr	r2, [r3, #4]
3480a2e0:	e3520000 	cmp	r2, #0
3480a2e4:	1a000003 	bne	3480a2f8 <malloc+0x24>
3480a2e8:	e5933008 	ldr	r3, [r3, #8]
3480a2ec:	e3530000 	cmp	r3, #0
    /* not initialized yet */
    return 0;
3480a2f0:	01a00003 	moveq	r0, r3
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
3480a2f4:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
    /* not initialized yet */
    return 0;
  }

  if ((long)bytes < 0) return 0;
3480a2f8:	e3500000 	cmp	r0, #0
3480a2fc:	b3a00000 	movlt	r0, #0
3480a300:	b8bd8ef0 	poplt	{r4, r5, r6, r7, r9, sl, fp, pc}

  nb = request2size(bytes);  /* padded request size; */
3480a304:	e280400b 	add	r4, r0, #11
3480a308:	e3540016 	cmp	r4, #22
3480a30c:	d3a04010 	movle	r4, #16
3480a310:	da000002 	ble	3480a320 <malloc+0x4c>
3480a314:	e3c44007 	bic	r4, r4, #7

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
3480a318:	e3540f7e 	cmp	r4, #504	; 0x1f8
3480a31c:	2a00000d 	bcs	3480a358 <malloc+0x84>
  {
    idx = smallbin_index(nb);

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
3480a320:	e59f3558 	ldr	r3, [pc, #1368]	; 3480a880 <malloc+0x5ac>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
  {
    idx = smallbin_index(nb);
3480a324:	e1a011a4 	lsr	r1, r4, #3

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
3480a328:	e0833181 	add	r3, r3, r1, lsl #3
    victim = last(q);
3480a32c:	e593000c 	ldr	r0, [r3, #12]

    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
3480a330:	e1500003 	cmp	r0, r3
3480a334:	1a000004 	bne	3480a34c <malloc+0x78>
    {
      q = next_bin(q);
3480a338:	e2803008 	add	r3, r0, #8
      victim = last(q);
3480a33c:	e593000c 	ldr	r0, [r3, #12]
    }
    if (victim != q)
3480a340:	e1500003 	cmp	r0, r3
      set_inuse_bit_at_offset(victim, victim_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
3480a344:	02811002 	addeq	r1, r1, #2
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
    }
    if (victim != q)
3480a348:	0a00002e 	beq	3480a408 <malloc+0x134>
    {
      victim_size = chunksize(victim);
3480a34c:	e5903004 	ldr	r3, [r0, #4]
3480a350:	e3c33003 	bic	r3, r3, #3
3480a354:	ea000022 	b	3480a3e4 <malloc+0x110>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
3480a358:	e1b014a4 	lsrs	r1, r4, #9
3480a35c:	01a011a4 	lsreq	r1, r4, #3
3480a360:	0a000013 	beq	3480a3b4 <malloc+0xe0>
3480a364:	e3510004 	cmp	r1, #4
3480a368:	91a01324 	lsrls	r1, r4, #6
3480a36c:	92811038 	addls	r1, r1, #56	; 0x38
3480a370:	9a00000f 	bls	3480a3b4 <malloc+0xe0>
3480a374:	e3510014 	cmp	r1, #20
3480a378:	9281105b 	addls	r1, r1, #91	; 0x5b
3480a37c:	9a00000c 	bls	3480a3b4 <malloc+0xe0>
3480a380:	e3510054 	cmp	r1, #84	; 0x54
3480a384:	91a01624 	lsrls	r1, r4, #12
3480a388:	9281106e 	addls	r1, r1, #110	; 0x6e
3480a38c:	9a000008 	bls	3480a3b4 <malloc+0xe0>
3480a390:	e3510f55 	cmp	r1, #340	; 0x154
3480a394:	91a017a4 	lsrls	r1, r4, #15
3480a398:	92811077 	addls	r1, r1, #119	; 0x77
3480a39c:	9a000004 	bls	3480a3b4 <malloc+0xe0>
3480a3a0:	e3003554 	movw	r3, #1364	; 0x554
3480a3a4:	e1510003 	cmp	r1, r3
3480a3a8:	91a01924 	lsrls	r1, r4, #18
3480a3ac:	9281107c 	addls	r1, r1, #124	; 0x7c
3480a3b0:	83a0107e 	movhi	r1, #126	; 0x7e
    bin = bin_at(idx);
3480a3b4:	e59f24c4 	ldr	r2, [pc, #1220]	; 3480a880 <malloc+0x5ac>
3480a3b8:	e0822181 	add	r2, r2, r1, lsl #3

    for (victim = last(bin); victim != bin; victim = victim->bk)
3480a3bc:	e592000c 	ldr	r0, [r2, #12]
3480a3c0:	ea00000d 	b	3480a3fc <malloc+0x128>
    {
      victim_size = chunksize(victim);
3480a3c4:	e5903004 	ldr	r3, [r0, #4]
3480a3c8:	e3c33003 	bic	r3, r3, #3
      remainder_size = victim_size - nb;
3480a3cc:	e064c003 	rsb	ip, r4, r3

      if (remainder_size >= (long)MINSIZE) /* too big */
3480a3d0:	e35c000f 	cmp	ip, #15
      {
	--idx; /* adjust to rescan below after checking last remainder */
3480a3d4:	c2411001 	subgt	r1, r1, #1
	break;
3480a3d8:	ca000009 	bgt	3480a404 <malloc+0x130>
      }

      else if (remainder_size >= 0) /* exact fit */
3480a3dc:	e35c0000 	cmp	ip, #0
3480a3e0:	ba000004 	blt	3480a3f8 <malloc+0x124>
      {
	unlink(victim, bck, fwd);
3480a3e4:	e590200c 	ldr	r2, [r0, #12]
3480a3e8:	e5901008 	ldr	r1, [r0, #8]
3480a3ec:	e581200c 	str	r2, [r1, #12]
3480a3f0:	e5821008 	str	r1, [r2, #8]
3480a3f4:	ea00001c 	b	3480a46c <malloc+0x198>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
3480a3f8:	e590000c 	ldr	r0, [r0, #12]
3480a3fc:	e1500002 	cmp	r0, r2
3480a400:	1affffef 	bne	3480a3c4 <malloc+0xf0>
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
    }

    ++idx;
3480a404:	e2811001 	add	r1, r1, #1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
3480a408:	e59f5470 	ldr	r5, [pc, #1136]	; 3480a880 <malloc+0x5ac>
3480a40c:	e2852008 	add	r2, r5, #8
3480a410:	e5920008 	ldr	r0, [r2, #8]
3480a414:	e1500002 	cmp	r0, r2
3480a418:	0a000050 	beq	3480a560 <malloc+0x28c>
  {
    victim_size = chunksize(victim);
3480a41c:	e5903004 	ldr	r3, [r0, #4]
3480a420:	e3c33003 	bic	r3, r3, #3
    remainder_size = victim_size - nb;
3480a424:	e064c003 	rsb	ip, r4, r3

    if (remainder_size >= (long)MINSIZE) /* re-split */
3480a428:	e35c000f 	cmp	ip, #15
3480a42c:	da00000a 	ble	3480a45c <malloc+0x188>
    {
      remainder = chunk_at_offset(victim, nb);
3480a430:	e0803004 	add	r3, r0, r4
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
3480a434:	e582300c 	str	r3, [r2, #12]
3480a438:	e5823008 	str	r3, [r2, #8]
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
3480a43c:	e3844001 	orr	r4, r4, #1
      link_last_remainder(remainder);
3480a440:	e583200c 	str	r2, [r3, #12]
3480a444:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
3480a448:	e38c2001 	orr	r2, ip, #1
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
3480a44c:	e5804004 	str	r4, [r0, #4]
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
3480a450:	e783c00c 	str	ip, [r3, ip]
    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
3480a454:	e5832004 	str	r2, [r3, #4]
3480a458:	ea000103 	b	3480a86c <malloc+0x598>
      return chunk2mem(victim);
    }

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
3480a45c:	e35c0000 	cmp	ip, #0
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    clear_last_remainder;
3480a460:	e582200c 	str	r2, [r2, #12]
3480a464:	e5822008 	str	r2, [r2, #8]

    if (remainder_size >= 0)  /* exhaust */
3480a468:	ba000004 	blt	3480a480 <malloc+0x1ac>
    {
      set_inuse_bit_at_offset(victim, victim_size);
3480a46c:	e0803003 	add	r3, r0, r3
3480a470:	e5932004 	ldr	r2, [r3, #4]
3480a474:	e3822001 	orr	r2, r2, #1
3480a478:	e5832004 	str	r2, [r3, #4]
3480a47c:	ea0000fa 	b	3480a86c <malloc+0x598>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
3480a480:	e3530c02 	cmp	r3, #512	; 0x200
3480a484:	2a000008 	bcs	3480a4ac <malloc+0x1d8>
3480a488:	e1a031a3 	lsr	r3, r3, #3
3480a48c:	e5956004 	ldr	r6, [r5, #4]
3480a490:	e1a0c143 	asr	ip, r3, #2
3480a494:	e3a07001 	mov	r7, #1
3480a498:	e186cc17 	orr	ip, r6, r7, lsl ip
3480a49c:	e0853183 	add	r3, r5, r3, lsl #3
3480a4a0:	e585c004 	str	ip, [r5, #4]
3480a4a4:	e593c008 	ldr	ip, [r3, #8]
3480a4a8:	ea000028 	b	3480a550 <malloc+0x27c>
3480a4ac:	e1a064a3 	lsr	r6, r3, #9
3480a4b0:	e3560004 	cmp	r6, #4
3480a4b4:	91a06323 	lsrls	r6, r3, #6
3480a4b8:	92866038 	addls	r6, r6, #56	; 0x38
3480a4bc:	9a00000f 	bls	3480a500 <malloc+0x22c>
3480a4c0:	e3560014 	cmp	r6, #20
3480a4c4:	9286605b 	addls	r6, r6, #91	; 0x5b
3480a4c8:	9a00000c 	bls	3480a500 <malloc+0x22c>
3480a4cc:	e3560054 	cmp	r6, #84	; 0x54
3480a4d0:	91a06623 	lsrls	r6, r3, #12
3480a4d4:	9286606e 	addls	r6, r6, #110	; 0x6e
3480a4d8:	9a000008 	bls	3480a500 <malloc+0x22c>
3480a4dc:	e3560f55 	cmp	r6, #340	; 0x154
3480a4e0:	91a067a3 	lsrls	r6, r3, #15
3480a4e4:	92866077 	addls	r6, r6, #119	; 0x77
3480a4e8:	9a000004 	bls	3480a500 <malloc+0x22c>
3480a4ec:	e300c554 	movw	ip, #1364	; 0x554
3480a4f0:	e156000c 	cmp	r6, ip
3480a4f4:	91a06923 	lsrls	r6, r3, #18
3480a4f8:	9286607c 	addls	r6, r6, #124	; 0x7c
3480a4fc:	83a0607e 	movhi	r6, #126	; 0x7e
3480a500:	e0857186 	add	r7, r5, r6, lsl #3
3480a504:	e597c008 	ldr	ip, [r7, #8]
3480a508:	e15c0007 	cmp	ip, r7
3480a50c:	1a00000a 	bne	3480a53c <malloc+0x268>
3480a510:	e59f3368 	ldr	r3, [pc, #872]	; 3480a880 <malloc+0x5ac>
3480a514:	e1a06146 	asr	r6, r6, #2
3480a518:	e5937004 	ldr	r7, [r3, #4]
3480a51c:	e3a0a001 	mov	sl, #1
3480a520:	e187661a 	orr	r6, r7, sl, lsl r6
3480a524:	e5836004 	str	r6, [r3, #4]
3480a528:	e1a0300c 	mov	r3, ip
3480a52c:	ea000007 	b	3480a550 <malloc+0x27c>
3480a530:	e59cc008 	ldr	ip, [ip, #8]
3480a534:	e15c0007 	cmp	ip, r7
3480a538:	0a000003 	beq	3480a54c <malloc+0x278>
3480a53c:	e59c6004 	ldr	r6, [ip, #4]
3480a540:	e3c66003 	bic	r6, r6, #3
3480a544:	e1530006 	cmp	r3, r6
3480a548:	3afffff8 	bcc	3480a530 <malloc+0x25c>
3480a54c:	e59c300c 	ldr	r3, [ip, #12]
3480a550:	e580300c 	str	r3, [r0, #12]
3480a554:	e580c008 	str	ip, [r0, #8]
3480a558:	e5830008 	str	r0, [r3, #8]
3480a55c:	e58c000c 	str	r0, [ip, #12]
  /*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks_r)
3480a560:	e3a00001 	mov	r0, #1
3480a564:	e1a03141 	asr	r3, r1, #2
3480a568:	e1a03310 	lsl	r3, r0, r3
3480a56c:	e59f030c 	ldr	r0, [pc, #780]	; 3480a880 <malloc+0x5ac>
3480a570:	e5900004 	ldr	r0, [r0, #4]
3480a574:	e1530000 	cmp	r3, r0
3480a578:	8a00004a 	bhi	3480a6a8 <malloc+0x3d4>
  {

    /* Get to the first marked block */

    if ( (block & binblocks_r) == 0)
3480a57c:	e1130000 	tst	r3, r0
3480a580:	1a000004 	bne	3480a598 <malloc+0x2c4>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
3480a584:	e3c11003 	bic	r1, r1, #3
      block <<= 1;
      while ((block & binblocks_r) == 0)
      {
	idx += BINBLOCKWIDTH;
	block <<= 1;
3480a588:	e1a03083 	lsl	r3, r3, #1
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
3480a58c:	e1130000 	tst	r3, r0
      {
	idx += BINBLOCKWIDTH;
3480a590:	e2811004 	add	r1, r1, #4
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
3480a594:	0afffffb 	beq	3480a588 <malloc+0x2b4>

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
3480a598:	e59fa2e0 	ldr	sl, [pc, #736]	; 3480a880 <malloc+0x5ac>

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
3480a59c:	e0859181 	add	r9, r5, r1, lsl #3
3480a5a0:	e1a07009 	mov	r7, r9
3480a5a4:	e1a06001 	mov	r6, r1
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
3480a5a8:	e597000c 	ldr	r0, [r7, #12]
3480a5ac:	ea000020 	b	3480a634 <malloc+0x360>
	{
	  victim_size = chunksize(victim);
3480a5b0:	e590b004 	ldr	fp, [r0, #4]
3480a5b4:	e3cbb003 	bic	fp, fp, #3
	  remainder_size = victim_size - nb;
3480a5b8:	e064c00b 	rsb	ip, r4, fp

	  if (remainder_size >= (long)MINSIZE) /* split */
3480a5bc:	e35c000f 	cmp	ip, #15
3480a5c0:	da00000f 	ble	3480a604 <malloc+0x330>
	  {
	    remainder = chunk_at_offset(victim, nb);
3480a5c4:	e0803004 	add	r3, r0, r4
	    set_head(victim, nb | PREV_INUSE);
3480a5c8:	e3844001 	orr	r4, r4, #1
	    unlink(victim, bck, fwd);
3480a5cc:	e590100c 	ldr	r1, [r0, #12]
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
3480a5d0:	e5804004 	str	r4, [r0, #4]
	    unlink(victim, bck, fwd);
3480a5d4:	e5b04008 	ldr	r4, [r0, #8]!
	    link_last_remainder(remainder);
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
3480a5d8:	e783c00c 	str	ip, [r3, ip]

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
3480a5dc:	e584100c 	str	r1, [r4, #12]
3480a5e0:	e5814008 	str	r4, [r1, #8]
	    link_last_remainder(remainder);
3480a5e4:	e582300c 	str	r3, [r2, #12]
3480a5e8:	e5823008 	str	r3, [r2, #8]
3480a5ec:	e59f2290 	ldr	r2, [pc, #656]	; 3480a884 <malloc+0x5b0>
3480a5f0:	e583200c 	str	r2, [r3, #12]
3480a5f4:	e5832008 	str	r2, [r3, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
3480a5f8:	e38c2001 	orr	r2, ip, #1
3480a5fc:	e5832004 	str	r2, [r3, #4]
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
3480a600:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	  }

	  else if (remainder_size >= 0)  /* take */
3480a604:	e35c0000 	cmp	ip, #0
3480a608:	ba000008 	blt	3480a630 <malloc+0x35c>
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
3480a60c:	e080b00b 	add	fp, r0, fp
3480a610:	e59b3004 	ldr	r3, [fp, #4]
3480a614:	e3833001 	orr	r3, r3, #1
3480a618:	e58b3004 	str	r3, [fp, #4]
	    unlink(victim, bck, fwd);
3480a61c:	e590300c 	ldr	r3, [r0, #12]
3480a620:	e5b02008 	ldr	r2, [r0, #8]!
3480a624:	e582300c 	str	r3, [r2, #12]
3480a628:	e5832008 	str	r2, [r3, #8]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
3480a62c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
3480a630:	e590000c 	ldr	r0, [r0, #12]
3480a634:	e1500007 	cmp	r0, r7
3480a638:	1affffdc 	bne	3480a5b0 <malloc+0x2dc>

	}

       bin = next_bin(bin);

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
3480a63c:	e2866001 	add	r6, r6, #1
3480a640:	e3160003 	tst	r6, #3
	    return chunk2mem(victim);
	  }

	}

       bin = next_bin(bin);
3480a644:	12877008 	addne	r7, r7, #8
3480a648:	1affffd6 	bne	3480a5a8 <malloc+0x2d4>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
3480a64c:	e3110003 	tst	r1, #3
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
3480a650:	059a1004 	ldreq	r1, [sl, #4]
3480a654:	01c11003 	biceq	r1, r1, r3
3480a658:	058a1004 	streq	r1, [sl, #4]
	  break;
3480a65c:	0a000004 	beq	3480a674 <malloc+0x3a0>
	}
	--startidx;
       q = prev_bin(q);
3480a660:	e1a00009 	mov	r0, r9
      } while (first(q) == q);
3480a664:	e4109008 	ldr	r9, [r0], #-8
3480a668:	e1590000 	cmp	r9, r0
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
	  break;
	}
	--startidx;
3480a66c:	02411001 	subeq	r1, r1, #1
3480a670:	0afffff5 	beq	3480a64c <malloc+0x378>
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
3480a674:	e59a0004 	ldr	r0, [sl, #4]
3480a678:	e1a03083 	lsl	r3, r3, #1
3480a67c:	e1530000 	cmp	r3, r0
3480a680:	8a000008 	bhi	3480a6a8 <malloc+0x3d4>
3480a684:	e3530000 	cmp	r3, #0
3480a688:	0a000006 	beq	3480a6a8 <malloc+0x3d4>
3480a68c:	e1a01006 	mov	r1, r6
3480a690:	ea000001 	b	3480a69c <malloc+0x3c8>
      {
	while ((block & binblocks_r) == 0)
	{
	  idx += BINBLOCKWIDTH;
3480a694:	e2811004 	add	r1, r1, #4
	  block <<= 1;
3480a698:	e1a03083 	lsl	r3, r3, #1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
      {
	while ((block & binblocks_r) == 0)
3480a69c:	e1130000 	tst	r3, r0
3480a6a0:	1affffbd 	bne	3480a59c <malloc+0x2c8>
3480a6a4:	eafffffa 	b	3480a694 <malloc+0x3c0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
3480a6a8:	e59f21d0 	ldr	r2, [pc, #464]	; 3480a880 <malloc+0x5ac>
3480a6ac:	e5927008 	ldr	r7, [r2, #8]
3480a6b0:	e5979004 	ldr	r9, [r7, #4]
3480a6b4:	e3c99003 	bic	r9, r9, #3
3480a6b8:	e0643009 	rsb	r3, r4, r9
3480a6bc:	e353000f 	cmp	r3, #15
3480a6c0:	ca000061 	bgt	3480a84c <malloc+0x578>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a6c4:	e59f31b0 	ldr	r3, [pc, #432]	; 3480a87c <malloc+0x5a8>
3480a6c8:	e593a034 	ldr	sl, [r3, #52]	; 0x34

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
3480a6cc:	e5923408 	ldr	r3, [r2, #1032]	; 0x408
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a6d0:	e28aa010 	add	sl, sl, #16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
3480a6d4:	e3730001 	cmn	r3, #1
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
3480a6d8:	e08aa004 	add	sl, sl, r4
  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
3480a6dc:	128aaeff 	addne	sl, sl, #4080	; 0xff0
3480a6e0:	128aa00f 	addne	sl, sl, #15
3480a6e4:	13caaeff 	bicne	sl, sl, #4080	; 0xff0
3480a6e8:	13caa00f 	bicne	sl, sl, #15

  brk = (char*)(MORECORE (sbrk_size));
3480a6ec:	e1a0000a 	mov	r0, sl
3480a6f0:	ebfffe1b 	bl	34809f64 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a6f4:	e3700001 	cmn	r0, #1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
3480a6f8:	e1a06000 	mov	r6, r0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a6fc:	0a00004b 	beq	3480a830 <malloc+0x55c>
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
3480a700:	e0872009 	add	r2, r7, r9
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
3480a704:	e1500002 	cmp	r0, r2
3480a708:	2a000001 	bcs	3480a714 <malloc+0x440>
      (brk < old_end && old_top != initial_top))
3480a70c:	e1570005 	cmp	r7, r5
3480a710:	1a000046 	bne	3480a830 <malloc+0x55c>
    return;

  sbrked_mem += sbrk_size;
3480a714:	e59f3160 	ldr	r3, [pc, #352]	; 3480a87c <malloc+0x5a8>

  if (brk == old_end) /* can just add bytes to current top */
3480a718:	e1560002 	cmp	r6, r2
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
3480a71c:	e593000c 	ldr	r0, [r3, #12]
3480a720:	e59f1158 	ldr	r1, [pc, #344]	; 3480a880 <malloc+0x5ac>
3480a724:	e08a0000 	add	r0, sl, r0
3480a728:	e583000c 	str	r0, [r3, #12]

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
3480a72c:	05913008 	ldreq	r3, [r1, #8]

  sbrked_mem += sbrk_size;

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
3480a730:	008aa009 	addeq	sl, sl, r9
    set_head(top, top_size | PREV_INUSE);
3480a734:	038aa001 	orreq	sl, sl, #1
3480a738:	0583a004 	streq	sl, [r3, #4]
3480a73c:	0a000032 	beq	3480a80c <malloc+0x538>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
3480a740:	e591c408 	ldr	ip, [r1, #1032]	; 0x408
3480a744:	e37c0001 	cmn	ip, #1
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
3480a748:	10860000 	addne	r0, r6, r0
3480a74c:	10622000 	rsbne	r2, r2, r0
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
3480a750:	05816408 	streq	r6, [r1, #1032]	; 0x408
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
3480a754:	1583200c 	strne	r2, [r3, #12]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    if (front_misalign > 0)
3480a758:	e2163007 	ands	r3, r6, #7
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
3480a75c:	12633008 	rsbne	r3, r3, #8
      brk += correction;
3480a760:	10866003 	addne	r6, r6, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
3480a764:	e086a00a 	add	sl, r6, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));
3480a768:	e06a3003 	rsb	r3, sl, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
3480a76c:	e28aaeff 	add	sl, sl, #4080	; 0xff0
3480a770:	e28aa00f 	add	sl, sl, #15
3480a774:	e3caaeff 	bic	sl, sl, #4080	; 0xff0
3480a778:	e3caa00f 	bic	sl, sl, #15
3480a77c:	e083a00a 	add	sl, r3, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
3480a780:	e1a0000a 	mov	r0, sl
3480a784:	ebfffdf6 	bl	34809f64 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
3480a788:	e3700001 	cmn	r0, #1
3480a78c:	0a000027 	beq	3480a830 <malloc+0x55c>

    sbrked_mem += correction;
3480a790:	e59f30e4 	ldr	r3, [pc, #228]	; 3480a87c <malloc+0x5a8>

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
3480a794:	e0660000 	rsb	r0, r6, r0

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
3480a798:	e593200c 	ldr	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
3480a79c:	e1570005 	cmp	r7, r5

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
3480a7a0:	e08a2002 	add	r2, sl, r2
3480a7a4:	e583200c 	str	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
3480a7a8:	e08aa000 	add	sl, sl, r0
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
3480a7ac:	e59f30cc 	ldr	r3, [pc, #204]	; 3480a880 <malloc+0x5ac>
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
3480a7b0:	e38aa001 	orr	sl, sl, #1
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
3480a7b4:	e5836008 	str	r6, [r3, #8]
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
3480a7b8:	e586a004 	str	sl, [r6, #4]

    if (old_top != initial_top)
3480a7bc:	0a000012 	beq	3480a80c <malloc+0x538>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
3480a7c0:	e359000f 	cmp	r9, #15
      {
	set_head(top, PREV_INUSE); /* will force null return from malloc */
3480a7c4:	95933008 	ldrls	r3, [r3, #8]
3480a7c8:	93a02001 	movls	r2, #1
3480a7cc:	95832004 	strls	r2, [r3, #4]

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
3480a7d0:	9a000016 	bls	3480a830 <malloc+0x55c>
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
3480a7d4:	e5973004 	ldr	r3, [r7, #4]
	set_head(top, PREV_INUSE); /* will force null return from malloc */
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
3480a7d8:	e249900c 	sub	r9, r9, #12
3480a7dc:	e3c99007 	bic	r9, r9, #7
      set_head_size(old_top, old_top_size);
3480a7e0:	e2033001 	and	r3, r3, #1
3480a7e4:	e1893003 	orr	r3, r9, r3
3480a7e8:	e5873004 	str	r3, [r7, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
3480a7ec:	e3a02005 	mov	r2, #5
3480a7f0:	e0873009 	add	r3, r7, r9
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
3480a7f4:	e359000f 	cmp	r9, #15
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
      chunk_at_offset(old_top, old_top_size          )->size =
3480a7f8:	e5832004 	str	r2, [r3, #4]
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
3480a7fc:	e5832008 	str	r2, [r3, #8]
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
3480a800:	9a000001 	bls	3480a80c <malloc+0x538>
	fREe(chunk2mem(old_top));
3480a804:	e2870008 	add	r0, r7, #8
3480a808:	ebfffe28 	bl	3480a0b0 <free>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
3480a80c:	e59f2068 	ldr	r2, [pc, #104]	; 3480a87c <malloc+0x5a8>
3480a810:	e592300c 	ldr	r3, [r2, #12]
3480a814:	e5921038 	ldr	r1, [r2, #56]	; 0x38
3480a818:	e1530001 	cmp	r3, r1
    max_sbrked_mem = sbrked_mem;
3480a81c:	85823038 	strhi	r3, [r2, #56]	; 0x38
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
3480a820:	e59f2054 	ldr	r2, [pc, #84]	; 3480a87c <malloc+0x5a8>
3480a824:	e592103c 	ldr	r1, [r2, #60]	; 0x3c
3480a828:	e1530001 	cmp	r3, r1
    max_total_mem = mmapped_mem + sbrked_mem;
3480a82c:	8582303c 	strhi	r3, [r2, #60]	; 0x3c
      return chunk2mem(victim);
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
3480a830:	e59f3048 	ldr	r3, [pc, #72]	; 3480a880 <malloc+0x5ac>
3480a834:	e5933008 	ldr	r3, [r3, #8]
3480a838:	e5933004 	ldr	r3, [r3, #4]
3480a83c:	e3c33003 	bic	r3, r3, #3
3480a840:	e0643003 	rsb	r3, r4, r3
3480a844:	e353000f 	cmp	r3, #15
3480a848:	da000009 	ble	3480a874 <malloc+0x5a0>
      return 0; /* propagate failure */
  }

  victim = top;
3480a84c:	e59f202c 	ldr	r2, [pc, #44]	; 3480a880 <malloc+0x5ac>
  set_head(victim, nb | PREV_INUSE);
3480a850:	e3841001 	orr	r1, r4, #1
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
3480a854:	e5920008 	ldr	r0, [r2, #8]
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
3480a858:	e3833001 	orr	r3, r3, #1
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
3480a85c:	e0804004 	add	r4, r0, r4
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
3480a860:	e5801004 	str	r1, [r0, #4]
  top = chunk_at_offset(victim, nb);
3480a864:	e5824008 	str	r4, [r2, #8]
  set_head(top, remainder_size | PREV_INUSE);
3480a868:	e5843004 	str	r3, [r4, #4]
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);
3480a86c:	e2800008 	add	r0, r0, #8
3480a870:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
3480a874:	e3a00000 	mov	r0, #0
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);

}
3480a878:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480a87c:	3482a028 	.word	0x3482a028
3480a880:	3482885c 	.word	0x3482885c
3480a884:	34828864 	.word	0x34828864

3480a888 <calloc>:
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
3480a888:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
3480a88c:	e59f30d0 	ldr	r3, [pc, #208]	; 3480a964 <calloc+0xdc>
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
3480a890:	e1a06000 	mov	r6, r0
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
3480a894:	e5935008 	ldr	r5, [r3, #8]
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
3480a898:	e0000190 	mul	r0, r0, r1


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
3480a89c:	e5957004 	ldr	r7, [r5, #4]
#endif
  Void_t* mem = mALLOc (sz);
3480a8a0:	ebfffe8b 	bl	3480a2d4 <malloc>

  if ((long)n < 0) return 0;
3480a8a4:	e3560000 	cmp	r6, #0
  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
3480a8a8:	e1a04000 	mov	r4, r0

  if ((long)n < 0) return 0;
3480a8ac:	b3a04000 	movlt	r4, #0
3480a8b0:	ba000029 	blt	3480a95c <calloc+0xd4>

  if (mem == 0)
3480a8b4:	e3540000 	cmp	r4, #0
3480a8b8:	0a000027 	beq	3480a95c <calloc+0xd4>

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
3480a8bc:	e5142004 	ldr	r2, [r4, #-4]


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
3480a8c0:	e3c77003 	bic	r7, r7, #3

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
3480a8c4:	e3c22003 	bic	r2, r2, #3

  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
3480a8c8:	e2443008 	sub	r3, r4, #8
#endif

    csz = chunksize(p);

#if MORECORE_CLEARS
    if (p == oldtop && csz > oldtopsize)
3480a8cc:	e1530005 	cmp	r3, r5
3480a8d0:	13a05000 	movne	r5, #0
3480a8d4:	03a05001 	moveq	r5, #1
3480a8d8:	e1520007 	cmp	r2, r7
3480a8dc:	93a05000 	movls	r5, #0
3480a8e0:	e3550000 	cmp	r5, #0
3480a8e4:	11a02007 	movne	r2, r7
      /* clear only the bytes from non-freshly-sbrked memory */
      csz = oldtopsize;
    }
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
3480a8e8:	e2422004 	sub	r2, r2, #4
3480a8ec:	e3520024 	cmp	r2, #36	; 0x24
3480a8f0:	8a000017 	bhi	3480a954 <calloc+0xcc>
3480a8f4:	e3520013 	cmp	r2, #19
3480a8f8:	e1a03004 	mov	r3, r4
3480a8fc:	9a00000e 	bls	3480a93c <calloc+0xb4>
3480a900:	e3a01000 	mov	r1, #0
3480a904:	e1a00004 	mov	r0, r4
3480a908:	e4801004 	str	r1, [r0], #4
3480a90c:	e352001b 	cmp	r2, #27
3480a910:	e5841004 	str	r1, [r4, #4]
3480a914:	e2803004 	add	r3, r0, #4
3480a918:	9a000007 	bls	3480a93c <calloc+0xb4>
3480a91c:	e5801004 	str	r1, [r0, #4]
3480a920:	e2830004 	add	r0, r3, #4
3480a924:	e5831004 	str	r1, [r3, #4]
3480a928:	e3520024 	cmp	r2, #36	; 0x24
3480a92c:	e2803004 	add	r3, r0, #4
3480a930:	05801004 	streq	r1, [r0, #4]
3480a934:	05831004 	streq	r1, [r3, #4]
3480a938:	02833008 	addeq	r3, r3, #8
3480a93c:	e3a01000 	mov	r1, #0
3480a940:	e1a02003 	mov	r2, r3
3480a944:	e4821004 	str	r1, [r2], #4
3480a948:	e5831004 	str	r1, [r3, #4]
3480a94c:	e5821004 	str	r1, [r2, #4]
3480a950:	ea000001 	b	3480a95c <calloc+0xd4>
3480a954:	e3a01000 	mov	r1, #0
3480a958:	eb0047e7 	bl	3481c8fc <memset>
    return mem;
  }
}
3480a95c:	e1a00004 	mov	r0, r4
3480a960:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480a964:	3482885c 	.word	0x3482885c

3480a968 <memalign>:
#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
{
3480a968:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480a96c:	e1a04000 	mov	r4, r0
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return 0;
3480a970:	e2510000 	subs	r0, r1, #0
3480a974:	b3a00000 	movlt	r0, #0
3480a978:	b8bd84f0 	poplt	{r4, r5, r6, r7, sl, pc}

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
3480a97c:	e3540008 	cmp	r4, #8
3480a980:	8a000001 	bhi	3480a98c <memalign+0x24>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
3480a984:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}

  if ((long)bytes < 0) return 0;

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
3480a988:	eafffe51 	b	3480a2d4 <malloc>

  if (alignment <  MINSIZE) alignment = MINSIZE;

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
3480a98c:	e280700b 	add	r7, r0, #11

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);

  /* Otherwise, ensure that it is at least a minimum chunk size */

  if (alignment <  MINSIZE) alignment = MINSIZE;
3480a990:	e354000f 	cmp	r4, #15
3480a994:	93a04010 	movls	r4, #16

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
3480a998:	e3570016 	cmp	r7, #22
3480a99c:	c3c77007 	bicgt	r7, r7, #7
3480a9a0:	d3a07010 	movle	r7, #16
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
3480a9a4:	e2840010 	add	r0, r4, #16
3480a9a8:	e0800007 	add	r0, r0, r7
3480a9ac:	ebfffe48 	bl	3480a2d4 <malloc>

  if (m == 0) return 0; /* propagate failure */
3480a9b0:	e2506000 	subs	r6, r0, #0
3480a9b4:	0a00002d 	beq	3480aa70 <memalign+0x108>

  p = mem2chunk(m);

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
3480a9b8:	e1a01004 	mov	r1, r4
3480a9bc:	eb0055b5 	bl	34820098 <__aeabi_uidivmod>
3480a9c0:	e3510000 	cmp	r1, #0
  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */

  p = mem2chunk(m);
3480a9c4:	e2465008 	sub	r5, r6, #8

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
3480a9c8:	0a000018 	beq	3480aa30 <memalign+0xc8>
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
3480a9cc:	e244a001 	sub	sl, r4, #1
3480a9d0:	e2643000 	rsb	r3, r4, #0
3480a9d4:	e086a00a 	add	sl, r6, sl
3480a9d8:	e00aa003 	and	sl, sl, r3
3480a9dc:	e24aa008 	sub	sl, sl, #8
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
3480a9e0:	e065300a 	rsb	r3, r5, sl
3480a9e4:	e353000f 	cmp	r3, #15

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
    newsize = chunksize(p) - leadsize;
3480a9e8:	e5163004 	ldr	r3, [r6, #-4]
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
3480a9ec:	908aa004 	addls	sl, sl, r4

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
3480a9f0:	e065500a 	rsb	r5, r5, sl
    newsize = chunksize(p) - leadsize;
3480a9f4:	e3c33003 	bic	r3, r3, #3
3480a9f8:	e0653003 	rsb	r3, r5, r3
    }
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
3480a9fc:	e3832001 	orr	r2, r3, #1
3480aa00:	e58a2004 	str	r2, [sl, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480aa04:	e08a3003 	add	r3, sl, r3
3480aa08:	e5932004 	ldr	r2, [r3, #4]
    set_head_size(p, leadsize);
    fREe(chunk2mem(p));
3480aa0c:	e1a00006 	mov	r0, r6
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
    set_inuse_bit_at_offset(newp, newsize);
3480aa10:	e3822001 	orr	r2, r2, #1
3480aa14:	e5832004 	str	r2, [r3, #4]
    set_head_size(p, leadsize);
3480aa18:	e5163004 	ldr	r3, [r6, #-4]
3480aa1c:	e2033001 	and	r3, r3, #1
3480aa20:	e1855003 	orr	r5, r5, r3
3480aa24:	e5065004 	str	r5, [r6, #-4]
    fREe(chunk2mem(p));
3480aa28:	ebfffda0 	bl	3480a0b0 <free>
3480aa2c:	e1a0500a 	mov	r5, sl
    assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */

  remainder_size = chunksize(p) - nb;
3480aa30:	e5953004 	ldr	r3, [r5, #4]
3480aa34:	e3c33003 	bic	r3, r3, #3
3480aa38:	e0673003 	rsb	r3, r7, r3

  if (remainder_size >= (long)MINSIZE)
3480aa3c:	e353000f 	cmp	r3, #15
3480aa40:	da000008 	ble	3480aa68 <memalign+0x100>
  {
    remainder = chunk_at_offset(p, nb);
3480aa44:	e0850007 	add	r0, r5, r7
    set_head(remainder, remainder_size | PREV_INUSE);
3480aa48:	e3833001 	orr	r3, r3, #1
3480aa4c:	e5803004 	str	r3, [r0, #4]
    set_head_size(p, nb);
3480aa50:	e5953004 	ldr	r3, [r5, #4]
    fREe(chunk2mem(remainder));
3480aa54:	e2800008 	add	r0, r0, #8

  if (remainder_size >= (long)MINSIZE)
  {
    remainder = chunk_at_offset(p, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_head_size(p, nb);
3480aa58:	e2033001 	and	r3, r3, #1
3480aa5c:	e1877003 	orr	r7, r7, r3
3480aa60:	e5857004 	str	r7, [r5, #4]
    fREe(chunk2mem(remainder));
3480aa64:	ebfffd91 	bl	3480a0b0 <free>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);
3480aa68:	e2850008 	add	r0, r5, #8
3480aa6c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */
3480aa70:	e1a00006 	mov	r0, r6
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
3480aa74:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3480aa78 <pvalloc>:
#else
Void_t* pvALLOc(bytes) size_t bytes;
#endif
{
  size_t pagesize = malloc_getpagesize;
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
3480aa78:	e2801eff 	add	r1, r0, #4080	; 0xff0
3480aa7c:	e281100f 	add	r1, r1, #15
3480aa80:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
3480aa84:	e3a00a01 	mov	r0, #4096	; 0x1000
3480aa88:	e3c1100f 	bic	r1, r1, #15
3480aa8c:	eaffffb5 	b	3480a968 <memalign>

3480aa90 <valloc>:
#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
3480aa90:	e1a01000 	mov	r1, r0
  return mEMALIGn (malloc_getpagesize, bytes);
3480aa94:	e3a00a01 	mov	r0, #4096	; 0x1000
3480aa98:	eaffffb2 	b	3480a968 <memalign>

3480aa9c <realloc>:
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
3480aa9c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480aaa0:	e1a05000 	mov	r5, r0

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
3480aaa4:	e2510000 	subs	r0, r1, #0
3480aaa8:	ba00010b 	blt	3480aedc <realloc+0x440>

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
3480aaac:	e3550000 	cmp	r5, #0
3480aab0:	1a000001 	bne	3480aabc <realloc+0x20>
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
3480aab4:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
#endif

  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
3480aab8:	eafffe05 	b	3480a2d4 <malloc>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
3480aabc:	e280600b 	add	r6, r0, #11

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
3480aac0:	e5151004 	ldr	r1, [r5, #-4]


  nb = request2size(bytes);
3480aac4:	e3560016 	cmp	r6, #22

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
3480aac8:	e3c19003 	bic	r9, r1, #3


  nb = request2size(bytes);
3480aacc:	c3c66007 	bicgt	r6, r6, #7
3480aad0:	d3a06010 	movle	r6, #16
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480aad4:	e1590006 	cmp	r9, r6
  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
3480aad8:	e245b008 	sub	fp, r5, #8
  newsize = oldsize = chunksize(oldp);
3480aadc:	a1a0a009 	movge	sl, r9
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480aae0:	aa0000e2 	bge	3480ae70 <realloc+0x3d4>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
3480aae4:	e59f23fc 	ldr	r2, [pc, #1020]	; 3480aee8 <realloc+0x44c>
  if ((long)(oldsize) < (long)(nb))
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
3480aae8:	e08b3009 	add	r3, fp, r9
    if (next == top || !inuse(next))
3480aaec:	e592c008 	ldr	ip, [r2, #8]
3480aaf0:	e153000c 	cmp	r3, ip
3480aaf4:	0a000007 	beq	3480ab18 <realloc+0x7c>
3480aaf8:	e5932004 	ldr	r2, [r3, #4]
3480aafc:	e3c22001 	bic	r2, r2, #1
3480ab00:	e0832002 	add	r2, r3, r2
3480ab04:	e5922004 	ldr	r2, [r2, #4]
3480ab08:	e3120001 	tst	r2, #1
      }
    }
    else
    {
      next = 0;
      nextsize = 0;
3480ab0c:	13a02000 	movne	r2, #0
	goto split;
      }
    }
    else
    {
      next = 0;
3480ab10:	11a03002 	movne	r3, r2
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
3480ab14:	1a000019 	bne	3480ab80 <realloc+0xe4>
    {
      nextsize = chunksize(next);
3480ab18:	e5932004 	ldr	r2, [r3, #4]

      /* Forward into top only if a remainder */
      if (next == top)
3480ab1c:	e153000c 	cmp	r3, ip
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
    {
      nextsize = chunksize(next);
3480ab20:	e3c22003 	bic	r2, r2, #3
3480ab24:	e082a009 	add	sl, r2, r9

      /* Forward into top only if a remainder */
      if (next == top)
3480ab28:	1a00000e 	bne	3480ab68 <realloc+0xcc>
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
3480ab2c:	e2864010 	add	r4, r6, #16
3480ab30:	e15a0004 	cmp	sl, r4
3480ab34:	ba000011 	blt	3480ab80 <realloc+0xe4>
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480ab38:	e59f33a8 	ldr	r3, [pc, #936]	; 3480aee8 <realloc+0x44c>
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480ab3c:	e066a00a 	rsb	sl, r6, sl
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480ab40:	e08bb006 	add	fp, fp, r6
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480ab44:	e38aa001 	orr	sl, sl, #1
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480ab48:	e583b008 	str	fp, [r3, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480ab4c:	e58ba004 	str	sl, [fp, #4]
	  set_head_size(oldp, nb);
3480ab50:	e5153004 	ldr	r3, [r5, #-4]
	  return chunk2mem(oldp);
3480ab54:	e1a07005 	mov	r7, r5
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
	  set_head(top, (newsize - nb) | PREV_INUSE);
	  set_head_size(oldp, nb);
3480ab58:	e2033001 	and	r3, r3, #1
3480ab5c:	e1866003 	orr	r6, r6, r3
3480ab60:	e5056004 	str	r6, [r5, #-4]
	  return chunk2mem(oldp);
3480ab64:	ea0000dd 	b	3480aee0 <realloc+0x444>
	}
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
3480ab68:	e15a0006 	cmp	sl, r6
      {
	unlink(next, bck, fwd);
3480ab6c:	a593200c 	ldrge	r2, [r3, #12]
3480ab70:	a5933008 	ldrge	r3, [r3, #8]
3480ab74:	a583200c 	strge	r2, [r3, #12]
3480ab78:	a5823008 	strge	r3, [r2, #8]
3480ab7c:	aa0000bb 	bge	3480ae70 <realloc+0x3d4>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
3480ab80:	e3110001 	tst	r1, #1
3480ab84:	1a00007e 	bne	3480ad84 <realloc+0x2e8>
    {
      prev = prev_chunk(oldp);
3480ab88:	e5154008 	ldr	r4, [r5, #-8]
      prevsize = chunksize(prev);

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
3480ab8c:	e3530000 	cmp	r3, #0

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
3480ab90:	e064400b 	rsb	r4, r4, fp
      prevsize = chunksize(prev);
3480ab94:	e5941004 	ldr	r1, [r4, #4]
3480ab98:	e3c11003 	bic	r1, r1, #3

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
3480ab9c:	0a000047 	beq	3480acc0 <realloc+0x224>
      {
	/* into top */
	if (next == top)
3480aba0:	e153000c 	cmp	r3, ip
3480aba4:	e081a009 	add	sl, r1, r9
3480aba8:	1a00003d 	bne	3480aca4 <realloc+0x208>
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
3480abac:	e08aa002 	add	sl, sl, r2
3480abb0:	e2863010 	add	r3, r6, #16
3480abb4:	e15a0003 	cmp	sl, r3
3480abb8:	ba000040 	blt	3480acc0 <realloc+0x224>
	  {
	    unlink(prev, bck, fwd);
3480abbc:	e1a07004 	mov	r7, r4
3480abc0:	e5b72008 	ldr	r2, [r7, #8]!
3480abc4:	e594300c 	ldr	r3, [r4, #12]
3480abc8:	e582300c 	str	r3, [r2, #12]
3480abcc:	e5832008 	str	r2, [r3, #8]
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480abd0:	e2492004 	sub	r2, r9, #4
3480abd4:	e3520024 	cmp	r2, #36	; 0x24
3480abd8:	8a000023 	bhi	3480ac6c <realloc+0x1d0>
3480abdc:	e3520013 	cmp	r2, #19
3480abe0:	e1a03007 	mov	r3, r7
3480abe4:	9a000017 	bls	3480ac48 <realloc+0x1ac>
3480abe8:	e1a01005 	mov	r1, r5
3480abec:	e4913004 	ldr	r3, [r1], #4
3480abf0:	e352001b 	cmp	r2, #27
3480abf4:	e5843008 	str	r3, [r4, #8]
3480abf8:	e5953004 	ldr	r3, [r5, #4]
3480abfc:	e2815004 	add	r5, r1, #4
3480ac00:	e584300c 	str	r3, [r4, #12]
3480ac04:	e2843010 	add	r3, r4, #16
3480ac08:	9a00000e 	bls	3480ac48 <realloc+0x1ac>
3480ac0c:	e5913004 	ldr	r3, [r1, #4]
3480ac10:	e3520024 	cmp	r2, #36	; 0x24
3480ac14:	e5843010 	str	r3, [r4, #16]
3480ac18:	e5953004 	ldr	r3, [r5, #4]
3480ac1c:	e2851004 	add	r1, r5, #4
3480ac20:	e5843014 	str	r3, [r4, #20]
3480ac24:	e2815004 	add	r5, r1, #4
3480ac28:	e2843018 	add	r3, r4, #24
3480ac2c:	1a000005 	bne	3480ac48 <realloc+0x1ac>
3480ac30:	e5913004 	ldr	r3, [r1, #4]
3480ac34:	e5843018 	str	r3, [r4, #24]
3480ac38:	e5953004 	ldr	r3, [r5, #4]
3480ac3c:	e2855008 	add	r5, r5, #8
3480ac40:	e584301c 	str	r3, [r4, #28]
3480ac44:	e2843020 	add	r3, r4, #32
3480ac48:	e1a01005 	mov	r1, r5
3480ac4c:	e4910004 	ldr	r0, [r1], #4
3480ac50:	e1a02003 	mov	r2, r3
3480ac54:	e4820004 	str	r0, [r2], #4
3480ac58:	e5950004 	ldr	r0, [r5, #4]
3480ac5c:	e5830004 	str	r0, [r3, #4]
3480ac60:	e5913004 	ldr	r3, [r1, #4]
3480ac64:	e5823004 	str	r3, [r2, #4]
3480ac68:	ea000002 	b	3480ac78 <realloc+0x1dc>
3480ac6c:	e1a00007 	mov	r0, r7
3480ac70:	e1a01005 	mov	r1, r5
3480ac74:	eb004744 	bl	3481c98c <memcpy>
	    top = chunk_at_offset(newp, nb);
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480ac78:	e066a00a 	rsb	sl, r6, sl
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480ac7c:	e59f2264 	ldr	r2, [pc, #612]	; 3480aee8 <realloc+0x44c>
3480ac80:	e0843006 	add	r3, r4, r6
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480ac84:	e38aa001 	orr	sl, sl, #1
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480ac88:	e5823008 	str	r3, [r2, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480ac8c:	e583a004 	str	sl, [r3, #4]
	    set_head_size(newp, nb);
3480ac90:	e5943004 	ldr	r3, [r4, #4]
3480ac94:	e2033001 	and	r3, r3, #1
3480ac98:	e1866003 	orr	r6, r6, r3
3480ac9c:	e5846004 	str	r6, [r4, #4]
	    return newmem;
3480aca0:	ea00008e 	b	3480aee0 <realloc+0x444>
	  }
	}

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
3480aca4:	e08aa002 	add	sl, sl, r2
3480aca8:	e15a0006 	cmp	sl, r6
	{
	  unlink(next, bck, fwd);
3480acac:	a593200c 	ldrge	r2, [r3, #12]
3480acb0:	a5933008 	ldrge	r3, [r3, #8]
3480acb4:	a583200c 	strge	r2, [r3, #12]
3480acb8:	a5823008 	strge	r3, [r2, #8]
3480acbc:	aa000002 	bge	3480accc <realloc+0x230>
	  goto split;
	}
      }

      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
3480acc0:	e081a009 	add	sl, r1, r9
3480acc4:	e15a0006 	cmp	sl, r6
3480acc8:	ba00002d 	blt	3480ad84 <realloc+0x2e8>
      {
	unlink(prev, bck, fwd);
3480accc:	e1a00004 	mov	r0, r4
3480acd0:	e5b02008 	ldr	r2, [r0, #8]!
3480acd4:	e594300c 	ldr	r3, [r4, #12]
3480acd8:	e582300c 	str	r3, [r2, #12]
3480acdc:	e5832008 	str	r2, [r3, #8]
	newp = prev;
	newsize += prevsize;
	newmem = chunk2mem(newp);
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480ace0:	e2492004 	sub	r2, r9, #4
3480ace4:	e3520024 	cmp	r2, #36	; 0x24
3480ace8:	8a000022 	bhi	3480ad78 <realloc+0x2dc>
3480acec:	e3520013 	cmp	r2, #19
3480acf0:	9a000017 	bls	3480ad54 <realloc+0x2b8>
3480acf4:	e1a03005 	mov	r3, r5
3480acf8:	e4931004 	ldr	r1, [r3], #4
3480acfc:	e352001b 	cmp	r2, #27
3480ad00:	e5841008 	str	r1, [r4, #8]
3480ad04:	e5951004 	ldr	r1, [r5, #4]
3480ad08:	e2840010 	add	r0, r4, #16
3480ad0c:	e584100c 	str	r1, [r4, #12]
3480ad10:	e2835004 	add	r5, r3, #4
3480ad14:	9a00000e 	bls	3480ad54 <realloc+0x2b8>
3480ad18:	e5933004 	ldr	r3, [r3, #4]
3480ad1c:	e3520024 	cmp	r2, #36	; 0x24
3480ad20:	e5843010 	str	r3, [r4, #16]
3480ad24:	e5951004 	ldr	r1, [r5, #4]
3480ad28:	e2853004 	add	r3, r5, #4
3480ad2c:	e5841014 	str	r1, [r4, #20]
3480ad30:	e2840018 	add	r0, r4, #24
3480ad34:	e2835004 	add	r5, r3, #4
3480ad38:	1a000005 	bne	3480ad54 <realloc+0x2b8>
3480ad3c:	e5933004 	ldr	r3, [r3, #4]
3480ad40:	e2840020 	add	r0, r4, #32
3480ad44:	e5843018 	str	r3, [r4, #24]
3480ad48:	e5953004 	ldr	r3, [r5, #4]
3480ad4c:	e2855008 	add	r5, r5, #8
3480ad50:	e584301c 	str	r3, [r4, #28]
3480ad54:	e1a02005 	mov	r2, r5
3480ad58:	e4921004 	ldr	r1, [r2], #4
3480ad5c:	e1a03000 	mov	r3, r0
3480ad60:	e4831004 	str	r1, [r3], #4
3480ad64:	e5951004 	ldr	r1, [r5, #4]
3480ad68:	e5801004 	str	r1, [r0, #4]
3480ad6c:	e5922004 	ldr	r2, [r2, #4]
3480ad70:	e5832004 	str	r2, [r3, #4]
3480ad74:	ea00003e 	b	3480ae74 <realloc+0x3d8>
3480ad78:	e1a01005 	mov	r1, r5
3480ad7c:	eb004702 	bl	3481c98c <memcpy>
3480ad80:	ea00003b 	b	3480ae74 <realloc+0x3d8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (bytes);
3480ad84:	ebfffd52 	bl	3480a2d4 <malloc>

    if (newmem == 0)  /* propagate failure */
3480ad88:	e2507000 	subs	r7, r0, #0
3480ad8c:	0a000053 	beq	3480aee0 <realloc+0x444>
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480ad90:	e5153004 	ldr	r3, [r5, #-4]
3480ad94:	e2472008 	sub	r2, r7, #8
3480ad98:	e3c33001 	bic	r3, r3, #1
3480ad9c:	e08b3003 	add	r3, fp, r3
3480ada0:	e1520003 	cmp	r2, r3
    {
      newsize += chunksize(newp);
3480ada4:	0517a004 	ldreq	sl, [r7, #-4]
3480ada8:	03caa003 	biceq	sl, sl, #3
3480adac:	008aa009 	addeq	sl, sl, r9
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480adb0:	0a00002e 	beq	3480ae70 <realloc+0x3d4>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480adb4:	e2492004 	sub	r2, r9, #4
3480adb8:	e3520024 	cmp	r2, #36	; 0x24
3480adbc:	8a000026 	bhi	3480ae5c <realloc+0x3c0>
3480adc0:	e3520013 	cmp	r2, #19
3480adc4:	e1a01005 	mov	r1, r5
3480adc8:	e1a03007 	mov	r3, r7
3480adcc:	9a000019 	bls	3480ae38 <realloc+0x39c>
3480add0:	e1a0c005 	mov	ip, r5
3480add4:	e49c3004 	ldr	r3, [ip], #4
3480add8:	e1a00007 	mov	r0, r7
3480addc:	e4803004 	str	r3, [r0], #4
3480ade0:	e5953004 	ldr	r3, [r5, #4]
3480ade4:	e352001b 	cmp	r2, #27
3480ade8:	e5873004 	str	r3, [r7, #4]
3480adec:	e28c1004 	add	r1, ip, #4
3480adf0:	e2803004 	add	r3, r0, #4
3480adf4:	9a00000f 	bls	3480ae38 <realloc+0x39c>
3480adf8:	e59cc004 	ldr	ip, [ip, #4]
3480adfc:	e3520024 	cmp	r2, #36	; 0x24
3480ae00:	e580c004 	str	ip, [r0, #4]
3480ae04:	e281c004 	add	ip, r1, #4
3480ae08:	e5911004 	ldr	r1, [r1, #4]
3480ae0c:	e2830004 	add	r0, r3, #4
3480ae10:	e5831004 	str	r1, [r3, #4]
3480ae14:	e2803004 	add	r3, r0, #4
3480ae18:	e28c1004 	add	r1, ip, #4
3480ae1c:	1a000005 	bne	3480ae38 <realloc+0x39c>
3480ae20:	e59c2004 	ldr	r2, [ip, #4]
3480ae24:	e5802004 	str	r2, [r0, #4]
3480ae28:	e5912004 	ldr	r2, [r1, #4]
3480ae2c:	e2811008 	add	r1, r1, #8
3480ae30:	e5832004 	str	r2, [r3, #4]
3480ae34:	e2833008 	add	r3, r3, #8
3480ae38:	e1a00001 	mov	r0, r1
3480ae3c:	e490c004 	ldr	ip, [r0], #4
3480ae40:	e1a02003 	mov	r2, r3
3480ae44:	e482c004 	str	ip, [r2], #4
3480ae48:	e5911004 	ldr	r1, [r1, #4]
3480ae4c:	e5831004 	str	r1, [r3, #4]
3480ae50:	e5903004 	ldr	r3, [r0, #4]
3480ae54:	e5823004 	str	r3, [r2, #4]
3480ae58:	ea000001 	b	3480ae64 <realloc+0x3c8>
3480ae5c:	e1a01005 	mov	r1, r5
3480ae60:	eb0046c9 	bl	3481c98c <memcpy>
    fREe(oldmem);
3480ae64:	e1a00005 	mov	r0, r5
3480ae68:	ebfffc90 	bl	3480a0b0 <free>
    return newmem;
3480ae6c:	ea00001b 	b	3480aee0 <realloc+0x444>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480ae70:	e1a0400b 	mov	r4, fp
  }


 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
3480ae74:	e066300a 	rsb	r3, r6, sl
3480ae78:	e353000f 	cmp	r3, #15
3480ae7c:	e5942004 	ldr	r2, [r4, #4]
3480ae80:	9a00000c 	bls	3480aeb8 <realloc+0x41c>
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480ae84:	e2022001 	and	r2, r2, #1

 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
3480ae88:	e0840006 	add	r0, r4, r6
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480ae8c:	e1866002 	orr	r6, r6, r2
    set_head(remainder, remainder_size | PREV_INUSE);
3480ae90:	e3832001 	orr	r2, r3, #1

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480ae94:	e5846004 	str	r6, [r4, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480ae98:	e0803003 	add	r3, r0, r3
  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
3480ae9c:	e5802004 	str	r2, [r0, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
3480aea0:	e5932004 	ldr	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480aea4:	e2800008 	add	r0, r0, #8
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480aea8:	e3822001 	orr	r2, r2, #1
3480aeac:	e5832004 	str	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480aeb0:	ebfffc7e 	bl	3480a0b0 <free>
3480aeb4:	ea000006 	b	3480aed4 <realloc+0x438>
  }
  else
  {
    set_head_size(newp, newsize);
3480aeb8:	e2022001 	and	r2, r2, #1
3480aebc:	e18a2002 	orr	r2, sl, r2
3480aec0:	e5842004 	str	r2, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480aec4:	e084a00a 	add	sl, r4, sl
3480aec8:	e59a3004 	ldr	r3, [sl, #4]
3480aecc:	e3833001 	orr	r3, r3, #1
3480aed0:	e58a3004 	str	r3, [sl, #4]
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
3480aed4:	e2847008 	add	r7, r4, #8
3480aed8:	ea000000 	b	3480aee0 <realloc+0x444>

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
3480aedc:	e3a07000 	mov	r7, #0
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
3480aee0:	e1a00007 	mov	r0, r7
3480aee4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480aee8:	3482885c 	.word	0x3482885c

3480aeec <malloc_usable_size>:
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == 0)
3480aeec:	e3500000 	cmp	r0, #0
3480aef0:	012fff1e 	bxeq	lr
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
3480aef4:	e5103004 	ldr	r3, [r0, #-4]
  mchunkptr p;
  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
3480aef8:	e2401008 	sub	r1, r0, #8
    if(!chunk_is_mmapped(p))
3480aefc:	e3130002 	tst	r3, #2
3480af00:	1a000006 	bne	3480af20 <malloc_usable_size+0x34>
    {
      if (!inuse(p)) return 0;
3480af04:	e3c32001 	bic	r2, r3, #1
3480af08:	e0812002 	add	r2, r1, r2
3480af0c:	e5920004 	ldr	r0, [r2, #4]
3480af10:	e2100001 	ands	r0, r0, #1
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
3480af14:	13c30003 	bicne	r0, r3, #3
3480af18:	12400004 	subne	r0, r0, #4
3480af1c:	e12fff1e 	bx	lr
    }
    return chunksize(p) - 2*SIZE_SZ;
3480af20:	e3c30003 	bic	r0, r3, #3
3480af24:	e2400008 	sub	r0, r0, #8
  }
}
3480af28:	e12fff1e 	bx	lr

3480af2c <mallopt>:
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  switch(param_number)
3480af2c:	e2800004 	add	r0, r0, #4
3480af30:	e3500003 	cmp	r0, #3
3480af34:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
3480af38:	ea000012 	b	3480af88 <mallopt+0x5c>
3480af3c:	3480af70 	.word	0x3480af70
3480af40:	3480af64 	.word	0x3480af64
3480af44:	3480af58 	.word	0x3480af58
3480af48:	3480af4c 	.word	0x3480af4c
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
3480af4c:	e59f3044 	ldr	r3, [pc, #68]	; 3480af98 <mallopt+0x6c>
3480af50:	e583140c 	str	r1, [r3, #1036]	; 0x40c
3480af54:	ea000009 	b	3480af80 <mallopt+0x54>
    case M_TOP_PAD:
      top_pad = value; return 1;
3480af58:	e59f303c 	ldr	r3, [pc, #60]	; 3480af9c <mallopt+0x70>
3480af5c:	e5831034 	str	r1, [r3, #52]	; 0x34
3480af60:	ea000006 	b	3480af80 <mallopt+0x54>
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
3480af64:	e59f302c 	ldr	r3, [pc, #44]	; 3480af98 <mallopt+0x6c>
3480af68:	e5831410 	str	r1, [r3, #1040]	; 0x410
3480af6c:	ea000003 	b	3480af80 <mallopt+0x54>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480af70:	e3510000 	cmp	r1, #0
3480af74:	1a000005 	bne	3480af90 <mallopt+0x64>
3480af78:	e59f301c 	ldr	r3, [pc, #28]	; 3480af9c <mallopt+0x70>
3480af7c:	e5831040 	str	r1, [r3, #64]	; 0x40
3480af80:	e3a00001 	mov	r0, #1
3480af84:	e12fff1e 	bx	lr
#endif

    default:
      return 0;
3480af88:	e3a00000 	mov	r0, #0
3480af8c:	e12fff1e 	bx	lr
      mmap_threshold = value; return 1;
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480af90:	e3a00000 	mov	r0, #0
#endif

    default:
      return 0;
  }
}
3480af94:	e12fff1e 	bx	lr
3480af98:	3482885c 	.word	0x3482885c
3480af9c:	3482a028 	.word	0x3482a028

3480afa0 <env_get_char_spec>:
	.apply = env_check_apply,
};

static uchar __env_get_char_spec(int index)
{
	return *((uchar *)(gd->env_addr + index));
3480afa0:	e5983010 	ldr	r3, [r8, #16]
}
3480afa4:	e7d00003 	ldrb	r0, [r0, r3]
3480afa8:	e12fff1e 	bx	lr

3480afac <env_get_addr>:
		return env_get_char_init(index);
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
3480afac:	e5982014 	ldr	r2, [r8, #20]
3480afb0:	e1a03008 	mov	r3, r8
3480afb4:	e3520000 	cmp	r2, #0
		return (uchar *)(gd->env_addr + index);
3480afb8:	15983010 	ldrne	r3, [r8, #16]
	else
		return &default_environment[index];
3480afbc:	059f3008 	ldreq	r3, [pc, #8]	; 3480afcc <env_get_addr+0x20>
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
		return (uchar *)(gd->env_addr + index);
3480afc0:	10800003 	addne	r0, r0, r3
	else
		return &default_environment[index];
3480afc4:	00830000 	addeq	r0, r3, r0
}
3480afc8:	e12fff1e 	bx	lr
3480afcc:	348205c4 	.word	0x348205c4

3480afd0 <env_get_char_memory>:
	else
		return default_environment[index];
}

uchar env_get_char_memory(int index)
{
3480afd0:	e92d4008 	push	{r3, lr}
	return *env_get_addr(index);
3480afd4:	ebfffff4 	bl	3480afac <env_get_addr>
}
3480afd8:	e5d00000 	ldrb	r0, [r0]
3480afdc:	e8bd8008 	pop	{r3, pc}

3480afe0 <env_get_char>:

uchar env_get_char(int index)
{
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
3480afe0:	e5981004 	ldr	r1, [r8, #4]
3480afe4:	e3110001 	tst	r1, #1
3480afe8:	0a000000 	beq	3480aff0 <env_get_char+0x10>
		return env_get_char_memory(index);
3480afec:	eafffff7 	b	3480afd0 <env_get_char_memory>
	__attribute__((weak, alias("__env_get_char_spec")));

static uchar env_get_char_init(int index)
{
	/* if crc was bad, use the default environment */
	if (gd->env_valid)
3480aff0:	e5983014 	ldr	r3, [r8, #20]
3480aff4:	e3530000 	cmp	r3, #0
3480aff8:	0a000000 	beq	3480b000 <env_get_char+0x20>
		return env_get_char_spec(index);
3480affc:	eaffffe7 	b	3480afa0 <env_get_char_spec>
	else
		return default_environment[index];
3480b000:	e59f3008 	ldr	r3, [pc, #8]	; 3480b010 <env_get_char+0x30>
3480b004:	e0832000 	add	r2, r3, r0
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
		return env_get_char_memory(index);
	else
		return env_get_char_init(index);
}
3480b008:	e5d206f9 	ldrb	r0, [r2, #1785]	; 0x6f9
3480b00c:	e12fff1e 	bx	lr
3480b010:	348205c4 	.word	0x348205c4

3480b014 <set_default_env>:
	else
		return &default_environment[index];
}

void set_default_env(const char *s)
{
3480b014:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	if (sizeof(default_environment) > ENV_SIZE) {
		puts("*** Error - default environment is too large\n\n");
		return;
	}

	if (s) {
3480b018:	e2504000 	subs	r4, r0, #0
3480b01c:	0a00000a 	beq	3480b04c <set_default_env+0x38>
		if (*s == '!') {
3480b020:	e5d43000 	ldrb	r3, [r4]
3480b024:	e3530021 	cmp	r3, #33	; 0x21
3480b028:	1a000004 	bne	3480b040 <set_default_env+0x2c>
			printf("*** Warning - %s, "
3480b02c:	e2841001 	add	r1, r4, #1
3480b030:	e59f0078 	ldr	r0, [pc, #120]	; 3480b0b0 <set_default_env+0x9c>
3480b034:	ebfffadf 	bl	34809bb8 <printf>
{
	/*
	 * By default, do not apply changes as they will eventually
	 * be applied by someone else
	 */
	int do_apply = 0;
3480b038:	e3a04000 	mov	r4, #0
3480b03c:	ea000004 	b	3480b054 <set_default_env+0x40>
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
			puts(s);
3480b040:	ebfffad2 	bl	34809b90 <puts>
			 * by the user, as opposed to being a recovery
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
3480b044:	e3a04001 	mov	r4, #1
3480b048:	ea000001 	b	3480b054 <set_default_env+0x40>
			puts(s);
		}
	} else {
		puts("Using default environment\n\n");
3480b04c:	e59f0060 	ldr	r0, [pc, #96]	; 3480b0b4 <set_default_env+0xa0>
3480b050:	ebffface 	bl	34809b90 <puts>
	}

	if (himport_r(&env_htab, (char *)default_environment,
3480b054:	e3a03000 	mov	r3, #0
3480b058:	e59f0058 	ldr	r0, [pc, #88]	; 3480b0b8 <set_default_env+0xa4>
3480b05c:	e59f1058 	ldr	r1, [pc, #88]	; 3480b0bc <set_default_env+0xa8>
3480b060:	e30026f9 	movw	r2, #1785	; 0x6f9
3480b064:	e58d3000 	str	r3, [sp]
3480b068:	e58d3004 	str	r3, [sp, #4]
3480b06c:	e58d3008 	str	r3, [sp, #8]
3480b070:	e58d400c 	str	r4, [sp, #12]
3480b074:	eb004285 	bl	3481ba90 <himport_r>
3480b078:	e3500000 	cmp	r0, #0
3480b07c:	1a000007 	bne	3480b0a0 <set_default_env+0x8c>
			sizeof(default_environment), '\0', 0,
			0, NULL, do_apply) == 0)
		error("Environment import failed: errno = %d\n", errno);
3480b080:	e59f3038 	ldr	r3, [pc, #56]	; 3480b0c0 <set_default_env+0xac>
3480b084:	e59f0038 	ldr	r0, [pc, #56]	; 3480b0c4 <set_default_env+0xb0>
3480b088:	e58d3000 	str	r3, [sp]
3480b08c:	e59f3034 	ldr	r3, [pc, #52]	; 3480b0c8 <set_default_env+0xb4>
3480b090:	e59f2034 	ldr	r2, [pc, #52]	; 3480b0cc <set_default_env+0xb8>
3480b094:	e5931000 	ldr	r1, [r3]
3480b098:	e3a030d8 	mov	r3, #216	; 0xd8
3480b09c:	ebfffac5 	bl	34809bb8 <printf>

	gd->flags |= GD_FLG_ENV_READY;
3480b0a0:	e5982004 	ldr	r2, [r8, #4]
3480b0a4:	e3822080 	orr	r2, r2, #128	; 0x80
3480b0a8:	e5882004 	str	r2, [r8, #4]
}
3480b0ac:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
3480b0b0:	3482632a 	.word	0x3482632a
3480b0b4:	34826358 	.word	0x34826358
3480b0b8:	34828c70 	.word	0x34828c70
3480b0bc:	348205c4 	.word	0x348205c4
3480b0c0:	348213b8 	.word	0x348213b8
3480b0c4:	34825443 	.word	0x34825443
3480b0c8:	3482bee8 	.word	0x3482bee8
3480b0cc:	34826374 	.word	0x34826374

3480b0d0 <set_default_vars>:


/* [re]set individual variables to their value in the default environment */
int set_default_vars(int nvars, char * const vars[])
{
3480b0d0:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	/*
	 * Special use-case: import from default environment
	 * (and use \0 as a separator)
	 */
	return himport_r(&env_htab, (const char *)default_environment,
3480b0d4:	e3a03001 	mov	r3, #1
3480b0d8:	e58d3000 	str	r3, [sp]
3480b0dc:	e98d000b 	stmib	sp, {r0, r1, r3}
3480b0e0:	e59f1014 	ldr	r1, [pc, #20]	; 3480b0fc <set_default_vars+0x2c>
3480b0e4:	e30026f9 	movw	r2, #1785	; 0x6f9
3480b0e8:	e3a03000 	mov	r3, #0
3480b0ec:	e59f000c 	ldr	r0, [pc, #12]	; 3480b100 <set_default_vars+0x30>
3480b0f0:	eb004266 	bl	3481ba90 <himport_r>
				sizeof(default_environment), '\0', H_NOCLEAR,
				nvars, vars, 1 /* do_apply */);
}
3480b0f4:	e28dd014 	add	sp, sp, #20
3480b0f8:	e8bd8000 	pop	{pc}
3480b0fc:	348205c4 	.word	0x348205c4
3480b100:	34828c70 	.word	0x34828c70

3480b104 <env_import>:
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480b104:	e92d4010 	push	{r4, lr}
	env_t *ep = (env_t *)buf;

	if (check) {
3480b108:	e3510000 	cmp	r1, #0
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480b10c:	e24dd018 	sub	sp, sp, #24
3480b110:	e1a04000 	mov	r4, r0
	env_t *ep = (env_t *)buf;

	if (check) {
3480b114:	0a00000e 	beq	3480b154 <env_import+0x50>
		uint32_t crc;

		memcpy(&crc, &ep->crc, sizeof(crc));
3480b118:	e1a01004 	mov	r1, r4
3480b11c:	e3a02004 	mov	r2, #4
3480b120:	e28d0014 	add	r0, sp, #20
3480b124:	eb004618 	bl	3481c98c <memcpy>

		if (crc32(0, ep->data, ENV_SIZE) != crc) {
3480b128:	e3a00000 	mov	r0, #0
3480b12c:	e2841004 	add	r1, r4, #4
3480b130:	e59f208c 	ldr	r2, [pc, #140]	; 3480b1c4 <env_import+0xc0>
3480b134:	eb003e92 	bl	3481ab84 <crc32>
3480b138:	e59d3014 	ldr	r3, [sp, #20]
3480b13c:	e1500003 	cmp	r0, r3
3480b140:	0a000003 	beq	3480b154 <env_import+0x50>
			set_default_env("!bad CRC");
3480b144:	e59f007c 	ldr	r0, [pc, #124]	; 3480b1c8 <env_import+0xc4>
3480b148:	ebffffb1 	bl	3480b014 <set_default_env>
			return 0;
3480b14c:	e3a00000 	mov	r0, #0
3480b150:	ea000019 	b	3480b1bc <env_import+0xb8>
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
3480b154:	e3a03000 	mov	r3, #0
3480b158:	e2841004 	add	r1, r4, #4
3480b15c:	e59f0068 	ldr	r0, [pc, #104]	; 3480b1cc <env_import+0xc8>
3480b160:	e59f205c 	ldr	r2, [pc, #92]	; 3480b1c4 <env_import+0xc0>
3480b164:	e58d3000 	str	r3, [sp]
3480b168:	e58d3004 	str	r3, [sp, #4]
3480b16c:	e58d3008 	str	r3, [sp, #8]
3480b170:	e58d300c 	str	r3, [sp, #12]
3480b174:	eb004245 	bl	3481ba90 <himport_r>
3480b178:	e2504000 	subs	r4, r0, #0
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480b17c:	15982004 	ldrne	r2, [r8, #4]
		return 1;
3480b180:	13a00001 	movne	r0, #1
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480b184:	13822080 	orrne	r2, r2, #128	; 0x80
3480b188:	15882004 	strne	r2, [r8, #4]
		return 1;
3480b18c:	1a00000a 	bne	3480b1bc <env_import+0xb8>
	}

	error("Cannot import environment: errno = %d\n", errno);
3480b190:	e59f3038 	ldr	r3, [pc, #56]	; 3480b1d0 <env_import+0xcc>
3480b194:	e59f2038 	ldr	r2, [pc, #56]	; 3480b1d4 <env_import+0xd0>
3480b198:	e58d3000 	str	r3, [sp]
3480b19c:	e59f3034 	ldr	r3, [pc, #52]	; 3480b1d8 <env_import+0xd4>
3480b1a0:	e59f0034 	ldr	r0, [pc, #52]	; 3480b1dc <env_import+0xd8>
3480b1a4:	e5931000 	ldr	r1, [r3]
3480b1a8:	e3a03f41 	mov	r3, #260	; 0x104
3480b1ac:	ebfffa81 	bl	34809bb8 <printf>

	set_default_env("!import failed");
3480b1b0:	e59f0028 	ldr	r0, [pc, #40]	; 3480b1e0 <env_import+0xdc>
3480b1b4:	ebffff96 	bl	3480b014 <set_default_env>

	return 0;
3480b1b8:	e1a00004 	mov	r0, r4
}
3480b1bc:	e28dd018 	add	sp, sp, #24
3480b1c0:	e8bd8010 	pop	{r4, pc}
3480b1c4:	0003fffc 	.word	0x0003fffc
3480b1c8:	34826381 	.word	0x34826381
3480b1cc:	34828c70 	.word	0x34828c70
3480b1d0:	348213c8 	.word	0x348213c8
3480b1d4:	34826374 	.word	0x34826374
3480b1d8:	3482bee8 	.word	0x3482bee8
3480b1dc:	3482638a 	.word	0x3482638a
3480b1e0:	348263c7 	.word	0x348263c7

3480b1e4 <env_relocate>:
void env_relocate(void)
{
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
#endif
	if (gd->env_valid == 0) {
3480b1e4:	e5980014 	ldr	r0, [r8, #20]
3480b1e8:	e3500000 	cmp	r0, #0
3480b1ec:	1a000000 	bne	3480b1f4 <env_relocate+0x10>
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
3480b1f0:	eaffff87 	b	3480b014 <set_default_env>
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
#endif
	} else {
		env_relocate_spec();
3480b1f4:	eaffffff 	b	3480b1f8 <env_relocate_spec>

3480b1f8 <env_relocate_spec>:
#define ONENAND_ENV_SIZE(mtd)	(ONENAND_MAX_ENV_SIZE - ENV_HEADER_SIZE)

DECLARE_GLOBAL_DATA_PTR;

void env_relocate_spec(void)
{
3480b1f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480b1fc:	e59f006c 	ldr	r0, [pc, #108]	; 3480b270 <env_relocate_spec+0x78>
#define ONENAND_ENV_SIZE(mtd)	(ONENAND_MAX_ENV_SIZE - ENV_HEADER_SIZE)

DECLARE_GLOBAL_DATA_PTR;

void env_relocate_spec(void)
{
3480b200:	e24dd701 	sub	sp, sp, #262144	; 0x40000
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480b204:	e5903014 	ldr	r3, [r0, #20]
#define ONENAND_ENV_SIZE(mtd)	(ONENAND_MAX_ENV_SIZE - ENV_HEADER_SIZE)

DECLARE_GLOBAL_DATA_PTR;

void env_relocate_spec(void)
{
3480b208:	e24dd01c 	sub	sp, sp, #28
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480b20c:	e3530000 	cmp	r3, #0
		/* Ignore read fail */
		mtd->read(mtd, env_addr, ONENAND_MAX_ENV_SIZE,
				&retlen, (u_char *)buf);
	else
		mtd->writesize = MAX_ONENAND_PAGESIZE;
3480b210:	03a03d42 	moveq	r3, #4224	; 0x1080
3480b214:	05803014 	streq	r3, [r0, #20]
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480b218:	0a00000a 	beq	3480b248 <env_relocate_spec+0x50>
		/* Ignore read fail */
		mtd->read(mtd, env_addr, ONENAND_MAX_ENV_SIZE,
3480b21c:	e3a03701 	mov	r3, #262144	; 0x40000
3480b220:	e58d3000 	str	r3, [sp]
3480b224:	e28d3701 	add	r3, sp, #262144	; 0x40000
3480b228:	e2833014 	add	r3, r3, #20
3480b22c:	e58d3004 	str	r3, [sp, #4]
#ifdef ENV_IS_EMBEDDED
	char *buf = (char *)&environment;
#else
	loff_t env_addr = CONFIG_ENV_ADDR;
	char onenand_env[ONENAND_MAX_ENV_SIZE];
	char *buf = (char *)&onenand_env[0];
3480b230:	e28d3014 	add	r3, sp, #20
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
		/* Ignore read fail */
		mtd->read(mtd, env_addr, ONENAND_MAX_ENV_SIZE,
3480b234:	e58d3008 	str	r3, [sp, #8]
3480b238:	e5901040 	ldr	r1, [r0, #64]	; 0x40
3480b23c:	e3a02601 	mov	r2, #1048576	; 0x100000
3480b240:	e3a03000 	mov	r3, #0
3480b244:	e12fff31 	blx	r1
				&retlen, (u_char *)buf);
	else
		mtd->writesize = MAX_ONENAND_PAGESIZE;
#endif /* !ENV_IS_EMBEDDED */

	rc = env_import(buf, 1);
3480b248:	e28d0014 	add	r0, sp, #20
3480b24c:	e3a01001 	mov	r1, #1
3480b250:	ebffffab 	bl	3480b104 <env_import>
	if (rc)
3480b254:	e3500000 	cmp	r0, #0
		gd->env_valid = 1;
3480b258:	11a03008 	movne	r3, r8
3480b25c:	13a02001 	movne	r2, #1
3480b260:	15832014 	strne	r2, [r3, #20]
}
3480b264:	e28dd01c 	add	sp, sp, #28
3480b268:	e28dd701 	add	sp, sp, #262144	; 0x40000
3480b26c:	e8bd8000 	pop	{pc}
3480b270:	3482bd68 	.word	0x3482bd68

3480b274 <saveenv>:

int saveenv(void)
{
3480b274:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480b278:	e24dd701 	sub	sp, sp, #262144	; 0x40000
3480b27c:	e24dd060 	sub	sp, sp, #96	; 0x60
#ifdef CONFIG_ENV_ADDR_FLEX
	struct onenand_chip *this = &onenand_chip;
#endif
	loff_t	env_addr = CONFIG_ENV_ADDR;
	size_t	retlen;
	struct erase_info instr = {
3480b280:	e28d6701 	add	r6, sp, #262144	; 0x40000
3480b284:	e2866010 	add	r6, r6, #16
3480b288:	e3a01000 	mov	r1, #0
3480b28c:	e3a02048 	mov	r2, #72	; 0x48
3480b290:	e1a00006 	mov	r0, r6
3480b294:	eb004598 	bl	3481c8fc <memset>
		.callback	= NULL,
	};

	res = (char *)&env_new.data;
3480b298:	e28d7010 	add	r7, sp, #16
3480b29c:	e28d2701 	add	r2, sp, #262144	; 0x40000
	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, 0, NULL);
3480b2a0:	e3a04000 	mov	r4, #0
	size_t	retlen;
	struct erase_info instr = {
		.callback	= NULL,
	};

	res = (char *)&env_new.data;
3480b2a4:	e2822060 	add	r2, r2, #96	; 0x60
3480b2a8:	e2875004 	add	r5, r7, #4
3480b2ac:	e5225004 	str	r5, [r2, #-4]!
	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, 0, NULL);
3480b2b0:	e59f010c 	ldr	r0, [pc, #268]	; 3480b3c4 <saveenv+0x150>
3480b2b4:	e1a01004 	mov	r1, r4
3480b2b8:	e59f3108 	ldr	r3, [pc, #264]	; 3480b3c8 <saveenv+0x154>
3480b2bc:	e58d4000 	str	r4, [sp]
3480b2c0:	e58d4004 	str	r4, [sp, #4]
3480b2c4:	eb004146 	bl	3481b7e4 <hexport_r>
	if (len < 0) {
3480b2c8:	e1500004 	cmp	r0, r4
3480b2cc:	aa000008 	bge	3480b2f4 <saveenv+0x80>
		error("Cannot export environment: errno = %d\n", errno);
3480b2d0:	e59f30f4 	ldr	r3, [pc, #244]	; 3480b3cc <saveenv+0x158>
3480b2d4:	e59f20f4 	ldr	r2, [pc, #244]	; 3480b3d0 <saveenv+0x15c>
3480b2d8:	e58d3000 	str	r3, [sp]
3480b2dc:	e59f30f0 	ldr	r3, [pc, #240]	; 3480b3d4 <saveenv+0x160>
3480b2e0:	e59f00f0 	ldr	r0, [pc, #240]	; 3480b3d8 <saveenv+0x164>
3480b2e4:	e5931000 	ldr	r1, [r3]
3480b2e8:	e3a03064 	mov	r3, #100	; 0x64
3480b2ec:	ebfffa31 	bl	34809bb8 <printf>
3480b2f0:	ea00001c 	b	3480b368 <saveenv+0xf4>
		return 1;
	}
	env_new.crc = crc32(0, env_new.data, ENV_SIZE);
3480b2f4:	e1a01005 	mov	r1, r5
3480b2f8:	e1a00004 	mov	r0, r4
3480b2fc:	e59f20c4 	ldr	r2, [pc, #196]	; 3480b3c8 <saveenv+0x154>
3480b300:	eb003e1f 	bl	3481ab84 <crc32>
3480b304:	e59f30d0 	ldr	r3, [pc, #208]	; 3480b3dc <saveenv+0x168>
3480b308:	e28d1701 	add	r1, sp, #262144	; 0x40000
3480b30c:	e2811060 	add	r1, r1, #96	; 0x60
3480b310:	e7810003 	str	r0, [r1, r3]

	instr.len = CONFIG_ENV_SIZE;
3480b314:	e28d1701 	add	r1, sp, #262144	; 0x40000
3480b318:	e2811020 	add	r1, r1, #32
		instr.len <<= onenand_mtd.eraseregions[0].numblocks == 1 ?
				1 : 0;
	}
#endif
	instr.addr = env_addr;
	instr.mtd = mtd;
3480b31c:	e59fa0bc 	ldr	sl, [pc, #188]	; 3480b3e0 <saveenv+0x16c>
		error("Cannot export environment: errno = %d\n", errno);
		return 1;
	}
	env_new.crc = crc32(0, env_new.data, ENV_SIZE);

	instr.len = CONFIG_ENV_SIZE;
3480b320:	e3a02701 	mov	r2, #262144	; 0x40000
3480b324:	e3a03000 	mov	r3, #0
3480b328:	e1c120f0 	strd	r2, [r1]
		instr.len = CONFIG_ENV_SIZE_FLEX;
		instr.len <<= onenand_mtd.eraseregions[0].numblocks == 1 ?
				1 : 0;
	}
#endif
	instr.addr = env_addr;
3480b32c:	e3a04601 	mov	r4, #1048576	; 0x100000
	instr.mtd = mtd;
3480b330:	e28d2701 	add	r2, sp, #262144	; 0x40000
		instr.len = CONFIG_ENV_SIZE_FLEX;
		instr.len <<= onenand_mtd.eraseregions[0].numblocks == 1 ?
				1 : 0;
	}
#endif
	instr.addr = env_addr;
3480b334:	e3a05000 	mov	r5, #0
3480b338:	e14140f8 	strd	r4, [r1, #-8]
	instr.mtd = mtd;
3480b33c:	e582a010 	str	sl, [r2, #16]
	if (mtd->erase(mtd, &instr)) {
3480b340:	e59a3034 	ldr	r3, [sl, #52]	; 0x34
3480b344:	e1a0000a 	mov	r0, sl
3480b348:	e1a01006 	mov	r1, r6
3480b34c:	e12fff33 	blx	r3
3480b350:	e3500000 	cmp	r0, #0
3480b354:	0a000005 	beq	3480b370 <saveenv+0xfc>
		printf("OneNAND: erase failed at 0x%08llx\n", env_addr);
3480b358:	e59f0084 	ldr	r0, [pc, #132]	; 3480b3e4 <saveenv+0x170>
3480b35c:	e1a02004 	mov	r2, r4
3480b360:	e1a03005 	mov	r3, r5
3480b364:	ebfffa13 	bl	34809bb8 <printf>
		return 1;
3480b368:	e3a00001 	mov	r0, #1
3480b36c:	ea000011 	b	3480b3b8 <saveenv+0x144>
	}

	if (mtd->write(mtd, env_addr, ONENAND_MAX_ENV_SIZE, &retlen,
3480b370:	e3a03701 	mov	r3, #262144	; 0x40000
3480b374:	e58d3000 	str	r3, [sp]
3480b378:	e28d3701 	add	r3, sp, #262144	; 0x40000
3480b37c:	e2833058 	add	r3, r3, #88	; 0x58
3480b380:	e98d0088 	stmib	sp, {r3, r7}
3480b384:	e59a1044 	ldr	r1, [sl, #68]	; 0x44
3480b388:	e1a0000a 	mov	r0, sl
3480b38c:	e1a02004 	mov	r2, r4
3480b390:	e1a03005 	mov	r3, r5
3480b394:	e12fff31 	blx	r1
3480b398:	e3500000 	cmp	r0, #0
3480b39c:	0a000005 	beq	3480b3b8 <saveenv+0x144>
			(u_char *)&env_new)) {
		printf("OneNAND: write failed at 0x%llx\n", instr.addr);
3480b3a0:	e28d1701 	add	r1, sp, #262144	; 0x40000
3480b3a4:	e2811020 	add	r1, r1, #32
3480b3a8:	e59f0038 	ldr	r0, [pc, #56]	; 3480b3e8 <saveenv+0x174>
3480b3ac:	e14120d8 	ldrd	r2, [r1, #-8]
3480b3b0:	ebfffa00 	bl	34809bb8 <printf>
		return 2;
3480b3b4:	e3a00002 	mov	r0, #2
	}

	return 0;
}
3480b3b8:	e28dd060 	add	sp, sp, #96	; 0x60
3480b3bc:	e28dd701 	add	sp, sp, #262144	; 0x40000
3480b3c0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480b3c4:	34828c70 	.word	0x34828c70
3480b3c8:	0003fffc 	.word	0x0003fffc
3480b3cc:	348213d4 	.word	0x348213d4
3480b3d0:	348263d6 	.word	0x348263d6
3480b3d4:	3482bee8 	.word	0x3482bee8
3480b3d8:	34825622 	.word	0x34825622
3480b3dc:	fffbffb0 	.word	0xfffbffb0
3480b3e0:	3482bd68 	.word	0x3482bd68
3480b3e4:	348263e4 	.word	0x348263e4
3480b3e8:	34826407 	.word	0x34826407

3480b3ec <env_init>:

int env_init(void)
{
	/* use default */
	gd->env_addr = (ulong)&default_environment[0];
3480b3ec:	e59f2010 	ldr	r2, [pc, #16]	; 3480b404 <env_init+0x18>
	gd->env_valid = 1;

	return 0;
}
3480b3f0:	e3a00000 	mov	r0, #0
}

int env_init(void)
{
	/* use default */
	gd->env_addr = (ulong)&default_environment[0];
3480b3f4:	e5882010 	str	r2, [r8, #16]
	gd->env_valid = 1;
3480b3f8:	e3a02001 	mov	r2, #1
3480b3fc:	e5882014 	str	r2, [r8, #20]

	return 0;
}
3480b400:	e12fff1e 	bx	lr
3480b404:	348205c4 	.word	0x348205c4

3480b408 <dummy>:

DECLARE_GLOBAL_DATA_PTR;

__attribute__((unused)) static void dummy(void)
{
}
3480b408:	e12fff1e 	bx	lr

3480b40c <get_version>:

unsigned long get_version(void)
{
	return XF_VERSION;
}
3480b40c:	e3a00006 	mov	r0, #6
3480b410:	e12fff1e 	bx	lr

3480b414 <jumptable_init>:
# define spi_release_bus   dummy
# define spi_xfer          dummy
#endif

void jumptable_init(void)
{
3480b414:	e92d4010 	push	{r4, lr}
	gd->jt = malloc(XF_MAX * sizeof(void *));
3480b418:	e3a00070 	mov	r0, #112	; 0x70
3480b41c:	e1a04008 	mov	r4, r8
3480b420:	ebfffbab 	bl	3480a2d4 <malloc>
3480b424:	e5840054 	str	r0, [r4, #84]	; 0x54
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480b428:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b42c:	e59f1124 	ldr	r1, [pc, #292]	; 3480b558 <jumptable_init+0x144>
EXPORT_FUNC(putc)
EXPORT_FUNC(puts)
EXPORT_FUNC(printf)
EXPORT_FUNC(install_hdlr)
EXPORT_FUNC(free_hdlr)
EXPORT_FUNC(malloc)
3480b430:	e59f0124 	ldr	r0, [pc, #292]	; 3480b55c <jumptable_init+0x148>
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480b434:	e5821000 	str	r1, [r2]
EXPORT_FUNC(getc)
3480b438:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b43c:	e59f111c 	ldr	r1, [pc, #284]	; 3480b560 <jumptable_init+0x14c>
3480b440:	e5821004 	str	r1, [r2, #4]
EXPORT_FUNC(tstc)
3480b444:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b448:	e59f1114 	ldr	r1, [pc, #276]	; 3480b564 <jumptable_init+0x150>
3480b44c:	e5821008 	str	r1, [r2, #8]
EXPORT_FUNC(putc)
3480b450:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b454:	e59f110c 	ldr	r1, [pc, #268]	; 3480b568 <jumptable_init+0x154>
3480b458:	e582100c 	str	r1, [r2, #12]
EXPORT_FUNC(puts)
3480b45c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b460:	e59f1104 	ldr	r1, [pc, #260]	; 3480b56c <jumptable_init+0x158>
3480b464:	e5821010 	str	r1, [r2, #16]
EXPORT_FUNC(printf)
3480b468:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480b46c:	e59f10fc 	ldr	r1, [pc, #252]	; 3480b570 <jumptable_init+0x15c>
3480b470:	e5821014 	str	r1, [r2, #20]
EXPORT_FUNC(install_hdlr)
3480b474:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b478:	e59f20f4 	ldr	r2, [pc, #244]	; 3480b574 <jumptable_init+0x160>
3480b47c:	e5812018 	str	r2, [r1, #24]
EXPORT_FUNC(free_hdlr)
3480b480:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b484:	e581201c 	str	r2, [r1, #28]
EXPORT_FUNC(malloc)
3480b488:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b48c:	e5810020 	str	r0, [r1, #32]
EXPORT_FUNC(free)
3480b490:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b494:	e59f00dc 	ldr	r0, [pc, #220]	; 3480b578 <jumptable_init+0x164>
3480b498:	e5810024 	str	r0, [r1, #36]	; 0x24
EXPORT_FUNC(udelay)
3480b49c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4a0:	e59f00d4 	ldr	r0, [pc, #212]	; 3480b57c <jumptable_init+0x168>
3480b4a4:	e5810028 	str	r0, [r1, #40]	; 0x28
EXPORT_FUNC(get_timer)
3480b4a8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4ac:	e59f00cc 	ldr	r0, [pc, #204]	; 3480b580 <jumptable_init+0x16c>
3480b4b0:	e581002c 	str	r0, [r1, #44]	; 0x2c
EXPORT_FUNC(vprintf)
3480b4b4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4b8:	e59f00c4 	ldr	r0, [pc, #196]	; 3480b584 <jumptable_init+0x170>
3480b4bc:	e5810030 	str	r0, [r1, #48]	; 0x30
EXPORT_FUNC(do_reset)
3480b4c0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4c4:	e59f00bc 	ldr	r0, [pc, #188]	; 3480b588 <jumptable_init+0x174>
3480b4c8:	e5810034 	str	r0, [r1, #52]	; 0x34
EXPORT_FUNC(getenv)
3480b4cc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4d0:	e59f00b4 	ldr	r0, [pc, #180]	; 3480b58c <jumptable_init+0x178>
3480b4d4:	e5810038 	str	r0, [r1, #56]	; 0x38
EXPORT_FUNC(setenv)
3480b4d8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4dc:	e59f00ac 	ldr	r0, [pc, #172]	; 3480b590 <jumptable_init+0x17c>
3480b4e0:	e581003c 	str	r0, [r1, #60]	; 0x3c
EXPORT_FUNC(simple_strtoul)
3480b4e4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4e8:	e59f00a4 	ldr	r0, [pc, #164]	; 3480b594 <jumptable_init+0x180>
3480b4ec:	e5810040 	str	r0, [r1, #64]	; 0x40
EXPORT_FUNC(strict_strtoul)
3480b4f0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b4f4:	e59f009c 	ldr	r0, [pc, #156]	; 3480b598 <jumptable_init+0x184>
3480b4f8:	e5810044 	str	r0, [r1, #68]	; 0x44
EXPORT_FUNC(simple_strtol)
3480b4fc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b500:	e59f0094 	ldr	r0, [pc, #148]	; 3480b59c <jumptable_init+0x188>
3480b504:	e5810048 	str	r0, [r1, #72]	; 0x48
EXPORT_FUNC(strcmp)
3480b508:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b50c:	e59f008c 	ldr	r0, [pc, #140]	; 3480b5a0 <jumptable_init+0x18c>
3480b510:	e581004c 	str	r0, [r1, #76]	; 0x4c
EXPORT_FUNC(i2c_write)
3480b514:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b518:	e5812050 	str	r2, [r1, #80]	; 0x50
EXPORT_FUNC(i2c_read)
3480b51c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b520:	e5812054 	str	r2, [r1, #84]	; 0x54
EXPORT_FUNC(spi_init)
3480b524:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b528:	e5812058 	str	r2, [r1, #88]	; 0x58
EXPORT_FUNC(spi_setup_slave)
3480b52c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b530:	e581205c 	str	r2, [r1, #92]	; 0x5c
EXPORT_FUNC(spi_free_slave)
3480b534:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b538:	e5812060 	str	r2, [r1, #96]	; 0x60
EXPORT_FUNC(spi_claim_bus)
3480b53c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480b540:	e5812064 	str	r2, [r1, #100]	; 0x64
EXPORT_FUNC(spi_release_bus)
3480b544:	e5981054 	ldr	r1, [r8, #84]	; 0x54
EXPORT_FUNC(spi_xfer)
3480b548:	e5983054 	ldr	r3, [r8, #84]	; 0x54
EXPORT_FUNC(i2c_read)
EXPORT_FUNC(spi_init)
EXPORT_FUNC(spi_setup_slave)
EXPORT_FUNC(spi_free_slave)
EXPORT_FUNC(spi_claim_bus)
EXPORT_FUNC(spi_release_bus)
3480b54c:	e5812068 	str	r2, [r1, #104]	; 0x68
EXPORT_FUNC(spi_xfer)
3480b550:	e583206c 	str	r2, [r3, #108]	; 0x6c
#include <_exports.h>
}
3480b554:	e8bd8010 	pop	{r4, pc}
3480b558:	3480b40c 	.word	0x3480b40c
3480b55c:	3480a2d4 	.word	0x3480a2d4
3480b560:	34809b20 	.word	0x34809b20
3480b564:	34809b44 	.word	0x34809b44
3480b568:	34809b68 	.word	0x34809b68
3480b56c:	34809b90 	.word	0x34809b90
3480b570:	34809bb8 	.word	0x34809bb8
3480b574:	3480b408 	.word	0x3480b408
3480b578:	3480a0b0 	.word	0x3480a0b0
3480b57c:	3481cbb8 	.word	0x3481cbb8
3480b580:	3480139c 	.word	0x3480139c
3480b584:	34809c08 	.word	0x34809c08
3480b588:	3480223c 	.word	0x3480223c
3480b58c:	34808000 	.word	0x34808000
3480b590:	34807be0 	.word	0x34807be0
3480b594:	3481d4c8 	.word	0x3481d4c8
3480b598:	3481d574 	.word	0x3481d574
3480b59c:	3481d5ec 	.word	0x3481d5ec
3480b5a0:	3481c5ac 	.word	0x3481c5ac

3480b5a4 <static_get>:
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480b5a4:	e5903000 	ldr	r3, [r0]
3480b5a8:	e4d32001 	ldrb	r2, [r3], #1
	if (ch=='\0') return EOF;
3480b5ac:	e3520000 	cmp	r2, #0
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480b5b0:	e5803000 	str	r3, [r0]
	if (ch=='\0') return EOF;
	return ch;
}
3480b5b4:	11a00002 	movne	r0, r2
3480b5b8:	03e00000 	mvneq	r0, #0
3480b5bc:	e12fff1e 	bx	lr

3480b5c0 <static_peek>:

static int static_peek(struct in_str *i)
{
	return *i->p;
3480b5c0:	e5903000 	ldr	r3, [r0]
}
3480b5c4:	e5d30000 	ldrb	r0, [r3]
3480b5c8:	e12fff1e 	bx	lr

3480b5cc <file_peek>:
static int file_peek(struct in_str *i)
{
#ifndef __U_BOOT__
	if (i->p && *i->p) {
#endif
		return *i->p;
3480b5cc:	e5903000 	ldr	r3, [r0]
		i->p = i->peek_buf;
		debug_printf("b_peek: got a %d\n", *i->p);
		return *i->p;
	}
#endif
}
3480b5d0:	e5d30000 	ldrb	r0, [r3]
3480b5d4:	e12fff1e 	bx	lr

3480b5d8 <is_assignment>:
	}
}

static int is_assignment(const char *s)
{
	if (s == NULL)
3480b5d8:	e3500000 	cmp	r0, #0
3480b5dc:	012fff1e 	bxeq	lr
		return 0;

	if (!isalpha(*s)) return 0;
3480b5e0:	e59f3040 	ldr	r3, [pc, #64]	; 3480b628 <is_assignment+0x50>
3480b5e4:	e5d02000 	ldrb	r2, [r0]
3480b5e8:	e7d32002 	ldrb	r2, [r3, r2]
3480b5ec:	e2122003 	ands	r2, r2, #3
3480b5f0:	0a00000a 	beq	3480b620 <is_assignment+0x48>
	++s;
	while(isalnum(*s) || *s=='_') ++s;
3480b5f4:	e1a02003 	mov	r2, r3
3480b5f8:	e5f03001 	ldrb	r3, [r0, #1]!
3480b5fc:	e7d21003 	ldrb	r1, [r2, r3]
3480b600:	e3110007 	tst	r1, #7
3480b604:	1afffffb 	bne	3480b5f8 <is_assignment+0x20>
3480b608:	e353005f 	cmp	r3, #95	; 0x5f
3480b60c:	0afffff9 	beq	3480b5f8 <is_assignment+0x20>
	return *s=='=';
3480b610:	e353003d 	cmp	r3, #61	; 0x3d
3480b614:	13a00000 	movne	r0, #0
3480b618:	03a00001 	moveq	r0, #1
3480b61c:	e12fff1e 	bx	lr
static int is_assignment(const char *s)
{
	if (s == NULL)
		return 0;

	if (!isalpha(*s)) return 0;
3480b620:	e1a00002 	mov	r0, r2
	++s;
	while(isalnum(*s) || *s=='_') ++s;
	return *s=='=';
}
3480b624:	e12fff1e 	bx	lr
3480b628:	34821fe0 	.word	0x34821fe0

3480b62c <syntax_err>:
#endif
#define final_printf debug_printf

#ifdef __U_BOOT__
static void syntax_err(void) {
	 printf("syntax error\n");
3480b62c:	e59f0000 	ldr	r0, [pc, #0]	; 3480b634 <syntax_err+0x8>
3480b630:	eafff960 	b	34809bb8 <printf>
3480b634:	34826430 	.word	0x34826430

3480b638 <do_showvar>:
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480b638:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480b63c:	e3520001 	cmp	r2, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480b640:	059f30d0 	ldreq	r3, [pc, #208]	; 3480b718 <do_showvar+0xe0>
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480b644:	e58d2004 	str	r2, [sp, #4]
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480b648:	11a09003 	movne	r9, r3
3480b64c:	13a04000 	movne	r4, #0
3480b650:	13a06001 	movne	r6, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480b654:	05934000 	ldreq	r4, [r3]
{
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480b658:	1a000029 	bne	3480b704 <do_showvar+0xcc>
3480b65c:	ea000006 	b	3480b67c <do_showvar+0x44>
		for (cur = top_vars; cur; cur = cur->next) {
			printf ("%s=%s\n", cur->name, cur->value);
3480b660:	e8940006 	ldm	r4, {r1, r2}
3480b664:	e59f00b0 	ldr	r0, [pc, #176]	; 3480b71c <do_showvar+0xe4>
3480b668:	ebfff952 	bl	34809bb8 <printf>
			if (ctrlc ()) {
3480b66c:	ebfff976 	bl	34809c4c <ctrlc>
3480b670:	e3500000 	cmp	r0, #0
3480b674:	1a000014 	bne	3480b6cc <do_showvar+0x94>
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
		for (cur = top_vars; cur; cur = cur->next) {
3480b678:	e5944010 	ldr	r4, [r4, #16]
3480b67c:	e3540000 	cmp	r4, #0
3480b680:	1afffff6 	bne	3480b660 <do_showvar+0x28>
3480b684:	ea000021 	b	3480b710 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480b688:	e59f2088 	ldr	r2, [pc, #136]	; 3480b718 <do_showvar+0xe0>
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];
3480b68c:	e5b97004 	ldr	r7, [r9, #4]!

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480b690:	e5925000 	ldr	r5, [r2]
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
3480b694:	e3e0b000 	mvn	fp, #0
		for (cur = top_vars; cur; cur = cur->next) {
3480b698:	ea000010 	b	3480b6e0 <do_showvar+0xa8>
			if(strcmp (cur->name, name) == 0) {
3480b69c:	e5950000 	ldr	r0, [r5]
3480b6a0:	e1a01007 	mov	r1, r7
3480b6a4:	eb0043c0 	bl	3481c5ac <strcmp>
3480b6a8:	e250a000 	subs	sl, r0, #0
3480b6ac:	1a000003 	bne	3480b6c0 <do_showvar+0x88>
				k = 0;
				printf ("%s=%s\n", cur->name, cur->value);
3480b6b0:	e59f0064 	ldr	r0, [pc, #100]	; 3480b71c <do_showvar+0xe4>
3480b6b4:	e8950006 	ldm	r5, {r1, r2}
3480b6b8:	ebfff93e 	bl	34809bb8 <printf>
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
			if(strcmp (cur->name, name) == 0) {
				k = 0;
3480b6bc:	e1a0b00a 	mov	fp, sl
				printf ("%s=%s\n", cur->name, cur->value);
			}
			if (ctrlc ()) {
3480b6c0:	ebfff961 	bl	34809c4c <ctrlc>
3480b6c4:	e3500000 	cmp	r0, #0
3480b6c8:	0a000003 	beq	3480b6dc <do_showvar+0xa4>
				puts ("\n ** Abort\n");
3480b6cc:	e59f004c 	ldr	r0, [pc, #76]	; 3480b720 <do_showvar+0xe8>
3480b6d0:	ebfff92e 	bl	34809b90 <puts>
				return 1;
3480b6d4:	e3a04001 	mov	r4, #1
3480b6d8:	ea00000c 	b	3480b710 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480b6dc:	e5955010 	ldr	r5, [r5, #16]
3480b6e0:	e3550000 	cmp	r5, #0
3480b6e4:	1affffec 	bne	3480b69c <do_showvar+0x64>
			if (ctrlc ()) {
				puts ("\n ** Abort\n");
				return 1;
			}
		}
		if (k < 0) {
3480b6e8:	e37b0001 	cmn	fp, #1
3480b6ec:	1a000003 	bne	3480b700 <do_showvar+0xc8>
			printf ("## Error: \"%s\" not defined\n", name);
3480b6f0:	e59f002c 	ldr	r0, [pc, #44]	; 3480b724 <do_showvar+0xec>
3480b6f4:	e1a01007 	mov	r1, r7
3480b6f8:	ebfff92e 	bl	34809bb8 <printf>
			rcode ++;
3480b6fc:	e2844001 	add	r4, r4, #1
				return 1;
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
3480b700:	e2866001 	add	r6, r6, #1
3480b704:	e59d3004 	ldr	r3, [sp, #4]
3480b708:	e1560003 	cmp	r6, r3
3480b70c:	baffffdd 	blt	3480b688 <do_showvar+0x50>
			printf ("## Error: \"%s\" not defined\n", name);
			rcode ++;
		}
	}
	return rcode;
}
3480b710:	e1a00004 	mov	r0, r4
3480b714:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480b718:	3482a06c 	.word	0x3482a06c
3480b71c:	348254e1 	.word	0x348254e1
3480b720:	3482643e 	.word	0x3482643e
3480b724:	34825509 	.word	0x34825509

3480b728 <xmalloc>:
	}
	return 0;
}

static void *xmalloc(size_t size)
{
3480b728:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = malloc(size))) {
3480b72c:	ebfffae8 	bl	3480a2d4 <malloc>
3480b730:	e3500000 	cmp	r0, #0
3480b734:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480b738:	e59f0004 	ldr	r0, [pc, #4]	; 3480b744 <xmalloc+0x1c>
3480b73c:	ebfff91d 	bl	34809bb8 <printf>
3480b740:	eafffffe 	b	3480b740 <xmalloc+0x18>
3480b744:	3482644a 	.word	0x3482644a

3480b748 <file_get>:
{
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480b748:	e5903000 	ldr	r3, [r0]
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480b74c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480b750:	e3530000 	cmp	r3, #0
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480b754:	e1a04000 	mov	r4, r0
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480b758:	0a000047 	beq	3480b87c <file_get+0x134>
3480b75c:	e5d30000 	ldrb	r0, [r3]
3480b760:	e3500000 	cmp	r0, #0
3480b764:	0a000044 	beq	3480b87c <file_get+0x134>
3480b768:	ea000056 	b	3480b8c8 <file_get+0x180>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
	if (i->promptmode == 1) {
3480b76c:	e5943008 	ldr	r3, [r4, #8]
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480b770:	e3a02001 	mov	r2, #1
	if (i->promptmode == 1) {
3480b774:	e1530002 	cmp	r3, r2
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480b778:	e5842004 	str	r2, [r4, #4]
	if (i->promptmode == 1) {
		n = readline(CONFIG_SYS_PROMPT);
3480b77c:	059f0158 	ldreq	r0, [pc, #344]	; 3480b8dc <file_get+0x194>
	} else {
		n = readline(CONFIG_SYS_PROMPT_HUSH_PS2);
3480b780:	159f0158 	ldrne	r0, [pc, #344]	; 3480b8e0 <file_get+0x198>
3480b784:	eb000c3d 	bl	3480e880 <readline>
#  else
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
3480b788:	e3700001 	cmn	r0, #1
		flag_repeat = 0;
		i->__promptme = 0;
3480b78c:	05846004 	streq	r6, [r4, #4]
	}
	n = strlen(console_buffer);
3480b790:	e59f014c 	ldr	r0, [pc, #332]	; 3480b8e4 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480b794:	05856004 	streq	r6, [r5, #4]
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480b798:	eb0043b7 	bl	3481c67c <strlen>
	console_buffer[n] = '\n';
3480b79c:	e1a03007 	mov	r3, r7
3480b7a0:	e7e3a000 	strb	sl, [r3, r0]!
	console_buffer[n+1]= '\0';
3480b7a4:	e5c36001 	strb	r6, [r3, #1]
	if (had_ctrlc()) flag_repeat = 0;
3480b7a8:	ebfff940 	bl	34809cb0 <had_ctrlc>
3480b7ac:	e3500000 	cmp	r0, #0
3480b7b0:	15856004 	strne	r6, [r5, #4]
	clear_ctrlc();
3480b7b4:	ebfff941 	bl	34809cc0 <clear_ctrlc>
	do_repeat = 0;
	if (i->promptmode == 1) {
3480b7b8:	e5949008 	ldr	r9, [r4, #8]
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
3480b7bc:	e5856008 	str	r6, [r5, #8]
	if (i->promptmode == 1) {
3480b7c0:	e3590001 	cmp	r9, #1
3480b7c4:	1a000010 	bne	3480b80c <file_get+0xc4>
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480b7c8:	e5d73000 	ldrb	r3, [r7]
3480b7cc:	e353000a 	cmp	r3, #10
3480b7d0:	1a000007 	bne	3480b7f4 <file_get+0xac>
3480b7d4:	e5953004 	ldr	r3, [r5, #4]
3480b7d8:	e3530000 	cmp	r3, #0
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
				flag_repeat = 1;
			}
			else {
				do_repeat = 1;
3480b7dc:	15859008 	strne	r9, [r5, #8]
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
	if (i->promptmode == 1) {
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480b7e0:	1a000007 	bne	3480b804 <file_get+0xbc>
			strcpy(the_command,console_buffer);
3480b7e4:	e59f10f8 	ldr	r1, [pc, #248]	; 3480b8e4 <file_get+0x19c>
3480b7e8:	e59f00f8 	ldr	r0, [pc, #248]	; 3480b8e8 <file_get+0x1a0>
3480b7ec:	eb00433d 	bl	3481c4e8 <strcpy>
3480b7f0:	ea000003 	b	3480b804 <file_get+0xbc>
		}
		else {
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
3480b7f4:	e59f00ec 	ldr	r0, [pc, #236]	; 3480b8e8 <file_get+0x1a0>
3480b7f8:	e59f10e4 	ldr	r1, [pc, #228]	; 3480b8e4 <file_get+0x19c>
3480b7fc:	eb004339 	bl	3481c4e8 <strcpy>
				flag_repeat = 1;
3480b800:	e5859004 	str	r9, [r5, #4]
			}
			else {
				do_repeat = 1;
			}
		}
		i->p = the_command;
3480b804:	e584b000 	str	fp, [r4]
3480b808:	ea000020 	b	3480b890 <file_get+0x148>
	}
	else {
		if (console_buffer[0] != '\n') {
3480b80c:	e5d73000 	ldrb	r3, [r7]
3480b810:	e353000a 	cmp	r3, #10
3480b814:	0a000012 	beq	3480b864 <file_get+0x11c>
			if (strlen(the_command) + strlen(console_buffer)
3480b818:	e59f00c8 	ldr	r0, [pc, #200]	; 3480b8e8 <file_get+0x1a0>
3480b81c:	eb004396 	bl	3481c67c <strlen>
3480b820:	e1a09000 	mov	r9, r0
3480b824:	e59f00b8 	ldr	r0, [pc, #184]	; 3480b8e4 <file_get+0x19c>
3480b828:	eb004393 	bl	3481c67c <strlen>
3480b82c:	e0800009 	add	r0, r0, r9
3480b830:	e35000ff 	cmp	r0, #255	; 0xff
				n = strlen(the_command);
				the_command[n-1] = ' ';
				strcpy(&the_command[n],console_buffer);
			}
			else {
				the_command[0] = '\n';
3480b834:	85c5a00c 	strbhi	sl, [r5, #12]
				the_command[1] = '\0';
3480b838:	85c5600d 	strbhi	r6, [r5, #13]
				flag_repeat = 0;
3480b83c:	85856004 	strhi	r6, [r5, #4]
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480b840:	8a000007 	bhi	3480b864 <file_get+0x11c>
			    < CONFIG_SYS_CBSIZE) {
				n = strlen(the_command);
3480b844:	e59f009c 	ldr	r0, [pc, #156]	; 3480b8e8 <file_get+0x1a0>
3480b848:	eb00438b 	bl	3481c67c <strlen>
				the_command[n-1] = ' ';
3480b84c:	e3a02020 	mov	r2, #32
3480b850:	e0853000 	add	r3, r5, r0
3480b854:	e5c3200b 	strb	r2, [r3, #11]
				strcpy(&the_command[n],console_buffer);
3480b858:	e08b0000 	add	r0, fp, r0
3480b85c:	e59f1080 	ldr	r1, [pc, #128]	; 3480b8e4 <file_get+0x19c>
3480b860:	eb004320 	bl	3481c4e8 <strcpy>
				the_command[0] = '\n';
				the_command[1] = '\0';
				flag_repeat = 0;
			}
		}
		if (i->__promptme == 0) {
3480b864:	e5943004 	ldr	r3, [r4, #4]
3480b868:	e3530000 	cmp	r3, #0
			the_command[0] = '\n';
3480b86c:	05c5a00c 	strbeq	sl, [r5, #12]
			the_command[1] = '\0';
3480b870:	05c5300d 	strbeq	r3, [r5, #13]
		}
		i->p = console_buffer;
3480b874:	e5847000 	str	r7, [r4]
3480b878:	ea000004 	b	3480b890 <file_get+0x148>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480b87c:	e59f5068 	ldr	r5, [pc, #104]	; 3480b8ec <file_get+0x1a4>
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480b880:	e59f705c 	ldr	r7, [pc, #92]	; 3480b8e4 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480b884:	e3a06000 	mov	r6, #0
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
3480b888:	e3a0a00a 	mov	sl, #10
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480b88c:	e285b00c 	add	fp, r5, #12
		 * more complicated by now, like sourcing or substituting. */
#ifndef __U_BOOT__
		if (i->__promptme && interactive && i->file == stdin) {
			while(! i->p || (interactive && strlen(i->p)==0) ) {
#else
			while(! i->p  || strlen(i->p)==0 ) {
3480b890:	e5940000 	ldr	r0, [r4]
3480b894:	e3500000 	cmp	r0, #0
3480b898:	0affffb3 	beq	3480b76c <file_get+0x24>
3480b89c:	eb004376 	bl	3481c67c <strlen>
3480b8a0:	e3500000 	cmp	r0, #0
3480b8a4:	0affffb0 	beq	3480b76c <file_get+0x24>
#endif
				get_user_input(i);
			}
			i->promptmode=2;
3480b8a8:	e3a03002 	mov	r3, #2
3480b8ac:	e5843008 	str	r3, [r4, #8]
#ifndef __U_BOOT__
			i->__promptme = 0;
#endif
			if (i->p && *i->p) {
3480b8b0:	e5943000 	ldr	r3, [r4]
3480b8b4:	e3530000 	cmp	r3, #0
3480b8b8:	0a000005 	beq	3480b8d4 <file_get+0x18c>
3480b8bc:	e5d30000 	ldrb	r0, [r3]
3480b8c0:	e3500000 	cmp	r0, #0
3480b8c4:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
				ch = *i->p++;
3480b8c8:	e2833001 	add	r3, r3, #1
3480b8cc:	e5843000 	str	r3, [r4]
3480b8d0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
	int ch;

	ch = 0;
3480b8d4:	e1a00003 	mov	r0, r3
	}
#ifndef __U_BOOT__
	if (ch == '\n') i->__promptme=1;
#endif
	return ch;
}
3480b8d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480b8dc:	34826468 	.word	0x34826468
3480b8e0:	34826470 	.word	0x34826470
3480b8e4:	3482b720 	.word	0x3482b720
3480b8e8:	3482a078 	.word	0x3482a078
3480b8ec:	3482a06c 	.word	0x3482a06c

3480b8f0 <free_pipe_list>:
	pi->progs=NULL;
	return ret_code;
}

static int free_pipe_list(struct pipe *head, int indent)
{
3480b8f0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rcode=0;   /* if list has no members */
3480b8f4:	e3a05000 	mov	r5, #0
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480b8f8:	e1a04000 	mov	r4, r0
3480b8fc:	e1a06005 	mov	r6, r5
			child->argv=NULL;
		} else if (child->group) {
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480b900:	e2819003 	add	r9, r1, #3
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480b904:	ea000029 	b	3480b9b0 <free_pipe_list+0xc0>
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480b908:	e5943004 	ldr	r3, [r4, #4]
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480b90c:	e7932007 	ldr	r2, [r3, r7]
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480b910:	e083b007 	add	fp, r3, r7
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480b914:	e3520000 	cmp	r2, #0
3480b918:	0a000011 	beq	3480b964 <free_pipe_list+0x74>
			for (a=0,p=child->argv; *p; a++,p++) {
3480b91c:	e4923004 	ldr	r3, [r2], #4
3480b920:	e3530000 	cmp	r3, #0
3480b924:	1afffffc 	bne	3480b91c <free_pipe_list+0x2c>
3480b928:	ea000005 	b	3480b944 <free_pipe_list+0x54>
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
				free(child->argv[a]);
3480b92c:	e59b2000 	ldr	r2, [fp]
3480b930:	e7920103 	ldr	r0, [r2, r3, lsl #2]
3480b934:	e58d3004 	str	r3, [sp, #4]
3480b938:	ebfff9dc 	bl	3480a0b0 <free>
				final_printf("%s   argv[%d] = %s\n",ind,a,*p);
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
3480b93c:	e59d3004 	ldr	r3, [sp, #4]
3480b940:	e2833001 	add	r3, r3, #1
3480b944:	e59b2004 	ldr	r2, [fp, #4]
3480b948:	e1530002 	cmp	r3, r2
3480b94c:	bafffff6 	blt	3480b92c <free_pipe_list+0x3c>
				free(child->argv[a]);
			}
					free(child->argv);
3480b950:	e59b0000 	ldr	r0, [fp]
3480b954:	ebfff9d5 	bl	3480a0b0 <free>
			child->argc = 0;
3480b958:	e58b6004 	str	r6, [fp, #4]
#endif
			child->argv=NULL;
3480b95c:	e58b6000 	str	r6, [fp]
3480b960:	ea000005 	b	3480b97c <free_pipe_list+0x8c>
		} else if (child->group) {
3480b964:	e59b0008 	ldr	r0, [fp, #8]
3480b968:	e3500000 	cmp	r0, #0
3480b96c:	0a000002 	beq	3480b97c <free_pipe_list+0x8c>
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480b970:	e1a01009 	mov	r1, r9
3480b974:	ebffffdd 	bl	3480b8f0 <free_pipe_list>
3480b978:	e1a05000 	mov	r5, r0
#ifndef __U_BOOT__
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
3480b97c:	e28aa001 	add	sl, sl, #1
3480b980:	e2877014 	add	r7, r7, #20
3480b984:	e5943000 	ldr	r3, [r4]
3480b988:	e15a0003 	cmp	sl, r3
3480b98c:	baffffdd 	blt	3480b908 <free_pipe_list+0x18>
			free(r);
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
3480b990:	e5940004 	ldr	r0, [r4, #4]
3480b994:	ebfff9c5 	bl	3480a0b0 <free>
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
3480b998:	e5947008 	ldr	r7, [r4, #8]
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
	pi->progs=NULL;
3480b99c:	e5846004 	str	r6, [r4, #4]
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
		pi->next=NULL;
3480b9a0:	e5846008 	str	r6, [r4, #8]
		free(pi);
3480b9a4:	e1a00004 	mov	r0, r4
3480b9a8:	ebfff9c0 	bl	3480a0b0 <free>
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480b9ac:	e1a04007 	mov	r4, r7
3480b9b0:	e3540000 	cmp	r4, #0
3480b9b4:	13a05000 	movne	r5, #0
3480b9b8:	11a07005 	movne	r7, r5
3480b9bc:	11a0a005 	movne	sl, r5
3480b9c0:	1affffef 	bne	3480b984 <free_pipe_list+0x94>
		next=pi->next;
		pi->next=NULL;
		free(pi);
	}
	return rcode;
}
3480b9c4:	e1a00005 	mov	r0, r5
3480b9c8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480b9cc <xrealloc>:
	}
	return p;
}

static void *xrealloc(void *ptr, size_t size)
{
3480b9cc:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = realloc(ptr, size))) {
3480b9d0:	ebfffc31 	bl	3480aa9c <realloc>
3480b9d4:	e3500000 	cmp	r0, #0
3480b9d8:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480b9dc:	e59f0004 	ldr	r0, [pc, #4]	; 3480b9e8 <xrealloc+0x1c>
3480b9e0:	ebfff874 	bl	34809bb8 <printf>
3480b9e4:	eafffffe 	b	3480b9e4 <xrealloc+0x18>
3480b9e8:	3482644a 	.word	0x3482644a

3480b9ec <done_command>:
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;
3480b9ec:	e5903000 	ldr	r3, [r0]
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480b9f0:	e92d4070 	push	{r4, r5, r6, lr}
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480b9f4:	e3530000 	cmp	r3, #0
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480b9f8:	e1a05000 	mov	r5, r0
	/* The child is really already in the pipe structure, so
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
3480b9fc:	e5904008 	ldr	r4, [r0, #8]
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480ba00:	0a000008 	beq	3480ba28 <done_command+0x3c>
3480ba04:	e5932008 	ldr	r2, [r3, #8]
3480ba08:	e3520000 	cmp	r2, #0
3480ba0c:	1a000002 	bne	3480ba1c <done_command+0x30>
		 && prog->argv == NULL
3480ba10:	e5933000 	ldr	r3, [r3]
3480ba14:	e3530000 	cmp	r3, #0
3480ba18:	0a000013 	beq	3480ba6c <done_command+0x80>
										) {
#endif
		debug_printf("done_command: skipping null command\n");
		return 0;
	} else if (prog) {
		pi->num_progs++;
3480ba1c:	e5943000 	ldr	r3, [r4]
3480ba20:	e2833001 	add	r3, r3, #1
3480ba24:	e5843000 	str	r3, [r4]
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480ba28:	e5941000 	ldr	r1, [r4]
3480ba2c:	e3a06014 	mov	r6, #20
3480ba30:	e2811001 	add	r1, r1, #1
3480ba34:	e0010196 	mul	r1, r6, r1
3480ba38:	e5940004 	ldr	r0, [r4, #4]
3480ba3c:	ebffffe2 	bl	3480b9cc <xrealloc>

	prog = pi->progs + pi->num_progs;
3480ba40:	e5943000 	ldr	r3, [r4]
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480ba44:	e3a02000 	mov	r2, #0
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));

	prog = pi->progs + pi->num_progs;
3480ba48:	e0060396 	mul	r6, r6, r3
3480ba4c:	e0803006 	add	r3, r0, r6
		pi->num_progs++;
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480ba50:	e5840004 	str	r0, [r4, #4]

	prog = pi->progs + pi->num_progs;
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480ba54:	e7802006 	str	r2, [r0, r6]
#ifndef __U_BOOT__
	prog->is_stopped = 0;
#endif
	prog->group = NULL;
3480ba58:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
3480ba5c:	e583200c 	str	r2, [r3, #12]
	ctx->child = prog;
	prog->type = ctx->type;
3480ba60:	e5952018 	ldr	r2, [r5, #24]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
	ctx->child = prog;
3480ba64:	e5853000 	str	r3, [r5]
	prog->type = ctx->type;
3480ba68:	e5832010 	str	r2, [r3, #16]

	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}
3480ba6c:	e3a00000 	mov	r0, #0
3480ba70:	e8bd8070 	pop	{r4, r5, r6, pc}

3480ba74 <b_addchr>:
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480ba74:	e92d4070 	push	{r4, r5, r6, lr}

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480ba78:	e5903004 	ldr	r3, [r0, #4]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480ba7c:	e1a06001 	mov	r6, r1

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480ba80:	e5901008 	ldr	r1, [r0, #8]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480ba84:	e1a04000 	mov	r4, r0

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480ba88:	e1530001 	cmp	r3, r1
3480ba8c:	ba00000a 	blt	3480babc <b_addchr+0x48>
		char *old_data = o->data;
3480ba90:	e5905000 	ldr	r5, [r0]
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
3480ba94:	e2813064 	add	r3, r1, #100	; 0x64
3480ba98:	e5803008 	str	r3, [r0, #8]
		o->data = realloc(o->data, 1 + o->maxlen);
3480ba9c:	e2811065 	add	r1, r1, #101	; 0x65
3480baa0:	e1a00005 	mov	r0, r5
3480baa4:	ebfffbfc 	bl	3480aa9c <realloc>
		if (o->data == NULL) {
3480baa8:	e3500000 	cmp	r0, #0
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
		char *old_data = o->data;
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
		o->data = realloc(o->data, 1 + o->maxlen);
3480baac:	e5840000 	str	r0, [r4]
		if (o->data == NULL) {
3480bab0:	1a000001 	bne	3480babc <b_addchr+0x48>
			free(old_data);
3480bab4:	e1a00005 	mov	r0, r5
3480bab8:	ebfff97c 	bl	3480a0b0 <free>
		}
	}
	return o->data == NULL;
3480babc:	e5943000 	ldr	r3, [r4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480bac0:	e3530000 	cmp	r3, #0
	o->data[o->length] = ch;
3480bac4:	15942004 	ldrne	r2, [r4, #4]
	o->length++;
	o->data[o->length] = '\0';
3480bac8:	13a00000 	movne	r0, #0

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
3480bacc:	17c36002 	strbne	r6, [r3, r2]
	o->length++;
3480bad0:	15943004 	ldrne	r3, [r4, #4]
	o->data[o->length] = '\0';
3480bad4:	15942000 	ldrne	r2, [r4]
static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
	o->length++;
3480bad8:	12833001 	addne	r3, r3, #1
3480badc:	15843004 	strne	r3, [r4, #4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480bae0:	03a00001 	moveq	r0, #1
	o->data[o->length] = ch;
	o->length++;
	o->data[o->length] = '\0';
3480bae4:	17c20003 	strbne	r0, [r2, r3]
	return 0;
}
3480bae8:	e8bd8070 	pop	{r4, r5, r6, pc}

3480baec <b_addqchr>:
/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
	if (quote && strchr("*?[\\",ch)) {
3480baec:	e3520000 	cmp	r2, #0

/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
3480baf0:	e92d4070 	push	{r4, r5, r6, lr}
3480baf4:	e1a04000 	mov	r4, r0
3480baf8:	e1a05001 	mov	r5, r1
	if (quote && strchr("*?[\\",ch)) {
3480bafc:	0a000008 	beq	3480bb24 <b_addqchr+0x38>
3480bb00:	e59f002c 	ldr	r0, [pc, #44]	; 3480bb34 <b_addqchr+0x48>
3480bb04:	eb0042c6 	bl	3481c624 <strchr>
3480bb08:	e3500000 	cmp	r0, #0
3480bb0c:	0a000004 	beq	3480bb24 <b_addqchr+0x38>
		int rc;
		rc = b_addchr(o, '\\');
3480bb10:	e1a00004 	mov	r0, r4
3480bb14:	e3a0105c 	mov	r1, #92	; 0x5c
3480bb18:	ebffffd5 	bl	3480ba74 <b_addchr>
		if (rc) return rc;
3480bb1c:	e3500000 	cmp	r0, #0
3480bb20:	18bd8070 	popne	{r4, r5, r6, pc}
	}
	return b_addchr(o, ch);
3480bb24:	e1a00004 	mov	r0, r4
3480bb28:	e1a01005 	mov	r1, r5
}
3480bb2c:	e8bd4070 	pop	{r4, r5, r6, lr}
	if (quote && strchr("*?[\\",ch)) {
		int rc;
		rc = b_addchr(o, '\\');
		if (rc) return rc;
	}
	return b_addchr(o, ch);
3480bb30:	eaffffcf 	b	3480ba74 <b_addchr>
3480bb34:	34826473 	.word	0x34826473

3480bb38 <get_local_var>:
static char *get_dollar_var(char ch);
#endif

/* This is used to get/check local shell variables */
char *get_local_var(const char *s)
{
3480bb38:	e92d4038 	push	{r3, r4, r5, lr}
	struct variables *cur;

	if (!s)
3480bb3c:	e2505000 	subs	r5, r0, #0
3480bb40:	0a00001c 	beq	3480bbb8 <get_local_var+0x80>
		return NULL;

#ifdef __U_BOOT__
	if (*s == '$')
3480bb44:	e5d53000 	ldrb	r3, [r5]
3480bb48:	e59f4070 	ldr	r4, [pc, #112]	; 3480bbc0 <get_local_var+0x88>
3480bb4c:	e3530024 	cmp	r3, #36	; 0x24
3480bb50:	1a00000a 	bne	3480bb80 <get_local_var+0x48>
		return get_dollar_var(s[1]);
3480bb54:	e5d53001 	ldrb	r3, [r5, #1]
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480bb58:	e3a00000 	mov	r0, #0
	switch (ch) {
3480bb5c:	e353003f 	cmp	r3, #63	; 0x3f
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480bb60:	e5c4010c 	strb	r0, [r4, #268]	; 0x10c
	switch (ch) {
3480bb64:	18bd8038 	popne	{r3, r4, r5, pc}
		case '?':
			sprintf(buf, "%u", (unsigned int)last_return_code);
3480bb68:	e2840f43 	add	r0, r4, #268	; 0x10c
3480bb6c:	e59f1050 	ldr	r1, [pc, #80]	; 3480bbc4 <get_local_var+0x8c>
3480bb70:	e5942134 	ldr	r2, [r4, #308]	; 0x134
3480bb74:	eb0046f9 	bl	3481d760 <sprintf>
			break;
		default:
			return NULL;
	}
	return buf;
3480bb78:	e2840f43 	add	r0, r4, #268	; 0x10c
3480bb7c:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480bb80:	e5944000 	ldr	r4, [r4]
3480bb84:	ea000007 	b	3480bba8 <get_local_var+0x70>
		if(strcmp(cur->name, s)==0)
3480bb88:	e5940000 	ldr	r0, [r4]
3480bb8c:	e1a01005 	mov	r1, r5
3480bb90:	eb004285 	bl	3481c5ac <strcmp>
3480bb94:	e3500000 	cmp	r0, #0
3480bb98:	1a000001 	bne	3480bba4 <get_local_var+0x6c>
			return cur->value;
3480bb9c:	e5940004 	ldr	r0, [r4, #4]
3480bba0:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480bba4:	e5944010 	ldr	r4, [r4, #16]
3480bba8:	e3540000 	cmp	r4, #0
3480bbac:	1afffff5 	bne	3480bb88 <get_local_var+0x50>
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
3480bbb0:	e1a00004 	mov	r0, r4
3480bbb4:	e8bd8038 	pop	{r3, r4, r5, pc}
char *get_local_var(const char *s)
{
	struct variables *cur;

	if (!s)
		return NULL;
3480bbb8:	e1a00005 	mov	r0, r5

	for (cur = top_vars; cur; cur=cur->next)
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
}
3480bbbc:	e8bd8038 	pop	{r3, r4, r5, pc}
3480bbc0:	3482a06c 	.word	0x3482a06c
3480bbc4:	3482470f 	.word	0x3482470f

3480bbc8 <set_local_var>:
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480bbc8:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480bbcc:	e59f219c 	ldr	r2, [pc, #412]	; 3480bd70 <set_local_var+0x1a8>
3480bbd0:	e5d03000 	ldrb	r3, [r0]
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480bbd4:	e1a07001 	mov	r7, r1
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480bbd8:	e7d23003 	ldrb	r3, [r2, r3]
3480bbdc:	e3130003 	tst	r3, #3
3480bbe0:	0a00005a 	beq	3480bd50 <set_local_var+0x188>
		return -1;
#endif

	name=strdup(s);
3480bbe4:	eb0042d9 	bl	3481c750 <strdup>
3480bbe8:	e1a05000 	mov	r5, r0

#ifdef __U_BOOT__
	if (getenv(name) != NULL) {
3480bbec:	ebfff103 	bl	34808000 <getenv>
3480bbf0:	e2504000 	subs	r4, r0, #0
3480bbf4:	0a000004 	beq	3480bc0c <set_local_var+0x44>
		printf ("ERROR: "
3480bbf8:	e59f0174 	ldr	r0, [pc, #372]	; 3480bd74 <set_local_var+0x1ac>
3480bbfc:	ebfff7ed 	bl	34809bb8 <printf>
				"There is a global environment variable with the same name.\n");
		free(name);
3480bc00:	e1a00005 	mov	r0, r5
3480bc04:	ebfff929 	bl	3480a0b0 <free>
3480bc08:	ea000050 	b	3480bd50 <set_local_var+0x188>
	}
#endif
	/* Assume when we enter this function that we are already in
	 * NAME=VALUE format.  So the first order of business is to
	 * split 's' on the '=' into 'name' and 'value' */
	value = strchr(name, '=');
3480bc0c:	e1a00005 	mov	r0, r5
3480bc10:	e3a0103d 	mov	r1, #61	; 0x3d
3480bc14:	eb004282 	bl	3481c624 <strchr>
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480bc18:	e3500000 	cmp	r0, #0
3480bc1c:	11a06000 	movne	r6, r0
3480bc20:	03a06001 	moveq	r6, #1

	for(cur = top_vars; cur; cur = cur->next) {
3480bc24:	e59f314c 	ldr	r3, [pc, #332]	; 3480bd78 <set_local_var+0x1b0>
	value = strchr(name, '=');
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480bc28:	e4c64001 	strb	r4, [r6], #1

	for(cur = top_vars; cur; cur = cur->next) {
3480bc2c:	e5934000 	ldr	r4, [r3]
3480bc30:	ea000005 	b	3480bc4c <set_local_var+0x84>
		if(strcmp(cur->name, name)==0)
3480bc34:	e5940000 	ldr	r0, [r4]
3480bc38:	e1a01005 	mov	r1, r5
3480bc3c:	eb00425a 	bl	3481c5ac <strcmp>
3480bc40:	e3500000 	cmp	r0, #0
3480bc44:	0a000003 	beq	3480bc58 <set_local_var+0x90>
		free(name);
		return -1;
	}
	*value++ = 0;

	for(cur = top_vars; cur; cur = cur->next) {
3480bc48:	e5944010 	ldr	r4, [r4, #16]
3480bc4c:	e3540000 	cmp	r4, #0
3480bc50:	1afffff7 	bne	3480bc34 <set_local_var+0x6c>
3480bc54:	ea000040 	b	3480bd5c <set_local_var+0x194>
		if(strcmp(cur->name, name)==0)
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
3480bc58:	e5940004 	ldr	r0, [r4, #4]
3480bc5c:	e1a01006 	mov	r1, r6
3480bc60:	eb004251 	bl	3481c5ac <strcmp>
3480bc64:	e3500000 	cmp	r0, #0
3480bc68:	1a000007 	bne	3480bc8c <set_local_var+0xc4>
			if(flg_export>0 && cur->flg_export==0)
3480bc6c:	e3570000 	cmp	r7, #0
3480bc70:	da000030 	ble	3480bd38 <set_local_var+0x170>
3480bc74:	e5943008 	ldr	r3, [r4, #8]
3480bc78:	e3530000 	cmp	r3, #0
				cur->flg_export=flg_export;
3480bc7c:	05847008 	streq	r7, [r4, #8]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480bc80:	01a04003 	moveq	r4, r3
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
3480bc84:	0a00002e 	beq	3480bd44 <set_local_var+0x17c>
3480bc88:	ea00002a 	b	3480bd38 <set_local_var+0x170>
				cur->flg_export=flg_export;
			else
				result++;
		} else {
			if(cur->flg_read_only) {
3480bc8c:	e594300c 	ldr	r3, [r4, #12]
3480bc90:	e3530000 	cmp	r3, #0
3480bc94:	0a000003 	beq	3480bca8 <set_local_var+0xe0>
				error_msg("%s: readonly variable", name);
3480bc98:	e1a01005 	mov	r1, r5
3480bc9c:	e59f00d8 	ldr	r0, [pc, #216]	; 3480bd7c <set_local_var+0x1b4>
3480bca0:	ebfff7c4 	bl	34809bb8 <printf>
3480bca4:	ea000025 	b	3480bd40 <set_local_var+0x178>
				result = -1;
			} else {
				if(flg_export>0 || cur->flg_export>1)
3480bca8:	e3570000 	cmp	r7, #0
3480bcac:	ca000002 	bgt	3480bcbc <set_local_var+0xf4>
3480bcb0:	e5943008 	ldr	r3, [r4, #8]
3480bcb4:	e3530001 	cmp	r3, #1
3480bcb8:	da000001 	ble	3480bcc4 <set_local_var+0xfc>
					cur->flg_export=1;
3480bcbc:	e3a03001 	mov	r3, #1
3480bcc0:	e5843008 	str	r3, [r4, #8]
				free(cur->value);
3480bcc4:	e5940004 	ldr	r0, [r4, #4]
3480bcc8:	ebfff8f8 	bl	3480a0b0 <free>

				cur->value = strdup(value);
3480bccc:	e1a00006 	mov	r0, r6
3480bcd0:	eb00429e 	bl	3481c750 <strdup>
3480bcd4:	e5840004 	str	r0, [r4, #4]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480bcd8:	e3a04000 	mov	r4, #0
3480bcdc:	ea000018 	b	3480bd44 <set_local_var+0x17c>
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480bce0:	e1a00005 	mov	r0, r5
3480bce4:	eb004299 	bl	3481c750 <strdup>
			if(cur->name == 0) {
3480bce8:	e3500000 	cmp	r0, #0
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480bcec:	e58a0000 	str	r0, [sl]
			if(cur->name == 0) {
3480bcf0:	1a000002 	bne	3480bd00 <set_local_var+0x138>
				free(cur);
3480bcf4:	e1a0000a 	mov	r0, sl
3480bcf8:	ebfff8ec 	bl	3480a0b0 <free>
3480bcfc:	ea00000f 	b	3480bd40 <set_local_var+0x178>
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480bd00:	e59f3070 	ldr	r3, [pc, #112]	; 3480bd78 <set_local_var+0x1b0>
				cur->value = strdup(value);
3480bd04:	e1a00006 	mov	r0, r6
			cur->name = strdup(name);
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480bd08:	e5939000 	ldr	r9, [r3]
				cur->value = strdup(value);
3480bd0c:	eb00428f 	bl	3481c750 <strdup>
				cur->next = 0;
3480bd10:	e58a4010 	str	r4, [sl, #16]
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
				cur->value = strdup(value);
3480bd14:	e98a0081 	stmib	sl, {r0, r7}
				cur->next = 0;
				cur->flg_export = flg_export;
				cur->flg_read_only = 0;
3480bd18:	e58a400c 	str	r4, [sl, #12]
				while(bottom->next) bottom=bottom->next;
3480bd1c:	ea000000 	b	3480bd24 <set_local_var+0x15c>
3480bd20:	e1a09004 	mov	r9, r4
3480bd24:	e5994010 	ldr	r4, [r9, #16]
3480bd28:	e3540000 	cmp	r4, #0
3480bd2c:	1afffffb 	bne	3480bd20 <set_local_var+0x158>
				bottom->next = cur;
3480bd30:	e589a010 	str	sl, [r9, #16]
3480bd34:	ea000002 	b	3480bd44 <set_local_var+0x17c>
	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
				cur->flg_export=flg_export;
			else
				result++;
3480bd38:	e3a04001 	mov	r4, #1
3480bd3c:	ea000000 	b	3480bd44 <set_local_var+0x17c>
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
3480bd40:	e3e04000 	mvn	r4, #0
	if(result==0 && cur->flg_export==1) {
		*(value-1) = '=';
		result = putenv(name);
	} else {
#endif
		free(name);
3480bd44:	e1a00005 	mov	r0, r5
3480bd48:	ebfff8d8 	bl	3480a0b0 <free>
#ifndef __U_BOOT__
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
3480bd4c:	ea000000 	b	3480bd54 <set_local_var+0x18c>
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
		return -1;
3480bd50:	e3e04000 	mvn	r4, #0
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
}
3480bd54:	e1a00004 	mov	r0, r4
3480bd58:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

				cur->value = strdup(value);
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
3480bd5c:	e3a00014 	mov	r0, #20
3480bd60:	ebfff95b 	bl	3480a2d4 <malloc>
		if(!cur) {
3480bd64:	e250a000 	subs	sl, r0, #0
3480bd68:	1affffdc 	bne	3480bce0 <set_local_var+0x118>
3480bd6c:	eafffff3 	b	3480bd40 <set_local_var+0x178>
3480bd70:	34821fe0 	.word	0x34821fe0
3480bd74:	34826478 	.word	0x34826478
3480bd78:	3482a06c 	.word	0x3482a06c
3480bd7c:	348264bb 	.word	0x348264bb

3480bd80 <insert_var_value_sub>:
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480bd80:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;
3480bd84:	e3a04000 	mov	r4, #0
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480bd88:	e1a09000 	mov	r9, r0
3480bd8c:	e58d100c 	str	r1, [sp, #12]
	int res_str_len = 0;
	int len;
	int done = 0;
3480bd90:	e1a05004 	mov	r5, r4
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
	int res_str_len = 0;
3480bd94:	e1a07004 	mov	r7, r4
3480bd98:	e1a06004 	mov	r6, r4
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480bd9c:	ea00008a 	b	3480bfcc <insert_var_value_sub+0x24c>
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
3480bda0:	e15b0009 	cmp	fp, r9
3480bda4:	0a00000a 	beq	3480bdd4 <insert_var_value_sub+0x54>
			/* copy any charachters to the result string */
			len = p - inp;
3480bda8:	e069500b 	rsb	r5, r9, fp
			res_str = xrealloc(res_str, (res_str_len + len));
3480bdac:	e0854007 	add	r4, r5, r7
3480bdb0:	e1a00006 	mov	r0, r6
3480bdb4:	e1a01004 	mov	r1, r4
3480bdb8:	ebffff03 	bl	3480b9cc <xrealloc>
			strncpy((res_str + res_str_len), inp, len);
3480bdbc:	e1a01009 	mov	r1, r9
	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
			/* copy any charachters to the result string */
			len = p - inp;
			res_str = xrealloc(res_str, (res_str_len + len));
3480bdc0:	e1a06000 	mov	r6, r0
			strncpy((res_str + res_str_len), inp, len);
3480bdc4:	e1a02005 	mov	r2, r5
3480bdc8:	e0800007 	add	r0, r0, r7
3480bdcc:	eb0041cc 	bl	3481c504 <strncpy>
			res_str_len += len;
3480bdd0:	e1a07004 	mov	r7, r4
		}
		inp = ++p;
3480bdd4:	e28bb001 	add	fp, fp, #1
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480bdd8:	e1a0000b 	mov	r0, fp
3480bddc:	e3a01003 	mov	r1, #3
3480bde0:	eb00420f 	bl	3481c624 <strchr>
		*p = '\0';
3480bde4:	e3a03000 	mov	r3, #0
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480bde8:	e35b0000 	cmp	fp, #0
			strncpy((res_str + res_str_len), inp, len);
			res_str_len += len;
		}
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480bdec:	e1a09000 	mov	r9, r0
		*p = '\0';
3480bdf0:	e5c03000 	strb	r3, [r0]
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480bdf4:	0a000071 	beq	3480bfc0 <insert_var_value_sub+0x240>
		return NULL;

	sep = strchr(src, ':');
3480bdf8:	e1a0000b 	mov	r0, fp
3480bdfc:	e3a0103a 	mov	r1, #58	; 0x3a
3480be00:	eb004207 	bl	3481c624 <strchr>

	if (sep) {
3480be04:	e250a000 	subs	sl, r0, #0
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480be08:	01a0500a 	moveq	r5, sl
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
3480be0c:	01a0200a 	moveq	r2, sl
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480be10:	01a0400a 	moveq	r4, sl
	if (!src)
		return NULL;

	sep = strchr(src, ':');

	if (sep) {
3480be14:	0a000013 	beq	3480be68 <insert_var_value_sub+0xe8>
		*sep = '\0';
3480be18:	e3a03000 	mov	r3, #0
3480be1c:	e5ca3000 	strb	r3, [sl]
		if (*(sep + 1) == '-')
3480be20:	e5da3001 	ldrb	r3, [sl, #1]
3480be24:	e353002d 	cmp	r3, #45	; 0x2d
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480be28:	03a05000 	moveq	r5, #0
	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
3480be2c:	028a4002 	addeq	r4, sl, #2
3480be30:	01a02005 	moveq	r2, r5

	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
3480be34:	0a00000b 	beq	3480be68 <insert_var_value_sub+0xe8>
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480be38:	e353003d 	cmp	r3, #61	; 0x3d
			default_val = sep+2;
3480be3c:	028a4002 	addeq	r4, sl, #2
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480be40:	03a05000 	moveq	r5, #0
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
3480be44:	03a02001 	moveq	r2, #1

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480be48:	0a000006 	beq	3480be68 <insert_var_value_sub+0xe8>
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480be4c:	e353002b 	cmp	r3, #43	; 0x2b
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480be50:	13a05000 	movne	r5, #0
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480be54:	028a4002 	addeq	r4, sl, #2
			expand_empty = 1;
3480be58:	03a05001 	moveq	r5, #1
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480be5c:	03a02000 	moveq	r2, #0
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480be60:	11a02005 	movne	r2, r5
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480be64:	11a04005 	movne	r4, r5
			default_val = sep+2;
			expand_empty = 1;
		}
	}

	p = getenv(src);
3480be68:	e1a0000b 	mov	r0, fp
3480be6c:	e58d2004 	str	r2, [sp, #4]
3480be70:	ebfff062 	bl	34808000 <getenv>
	if (!p)
3480be74:	e2503000 	subs	r3, r0, #0
3480be78:	e59d2004 	ldr	r2, [sp, #4]
3480be7c:	1a000004 	bne	3480be94 <insert_var_value_sub+0x114>
		p = get_local_var(src);
3480be80:	e1a0000b 	mov	r0, fp
3480be84:	ebffff2b 	bl	3480bb38 <get_local_var>

	if (!p || strlen(p) == 0) {
3480be88:	e2503000 	subs	r3, r0, #0
3480be8c:	e59d2004 	ldr	r2, [sp, #4]
3480be90:	0a000005 	beq	3480beac <insert_var_value_sub+0x12c>
3480be94:	e1a00003 	mov	r0, r3
3480be98:	e98d000c 	stmib	sp, {r2, r3}
3480be9c:	eb0041f6 	bl	3481c67c <strlen>
3480bea0:	e3500000 	cmp	r0, #0
3480bea4:	e99d000c 	ldmib	sp, {r2, r3}
3480bea8:	1a000015 	bne	3480bf04 <insert_var_value_sub+0x184>
		p = default_val;
		if (assign) {
3480beac:	e3520000 	cmp	r2, #0
3480beb0:	0a00001b 	beq	3480bf24 <insert_var_value_sub+0x1a4>
			char *var = malloc(strlen(src)+strlen(default_val)+2);
3480beb4:	e1a0000b 	mov	r0, fp
3480beb8:	eb0041ef 	bl	3481c67c <strlen>
3480bebc:	e1a05000 	mov	r5, r0
3480bec0:	e1a00004 	mov	r0, r4
3480bec4:	eb0041ec 	bl	3481c67c <strlen>
3480bec8:	e0850000 	add	r0, r5, r0
3480becc:	e2800002 	add	r0, r0, #2
3480bed0:	ebfff8ff 	bl	3480a2d4 <malloc>
			if (var) {
3480bed4:	e2505000 	subs	r5, r0, #0
3480bed8:	0a000006 	beq	3480bef8 <insert_var_value_sub+0x178>
				sprintf(var, "%s=%s", src, default_val);
3480bedc:	e59f1164 	ldr	r1, [pc, #356]	; 3480c048 <insert_var_value_sub+0x2c8>
3480bee0:	e1a0200b 	mov	r2, fp
3480bee4:	e1a03004 	mov	r3, r4
3480bee8:	eb00461c 	bl	3481d760 <sprintf>
				set_local_var(var, 0);
3480beec:	e1a00005 	mov	r0, r5
3480bef0:	e3a01000 	mov	r1, #0
3480bef4:	ebffff33 	bl	3480bbc8 <set_local_var>
			}
			free(var);
3480bef8:	e1a00005 	mov	r0, r5
3480befc:	ebfff86b 	bl	3480a0b0 <free>
3480bf00:	ea000007 	b	3480bf24 <insert_var_value_sub+0x1a4>
		}
	} else if (expand_empty) {
3480bf04:	e3550000 	cmp	r5, #0
3480bf08:	01a04003 	moveq	r4, r3
3480bf0c:	0a000004 	beq	3480bf24 <insert_var_value_sub+0x1a4>
		p += strlen(p);
3480bf10:	e1a00003 	mov	r0, r3
3480bf14:	e58d3008 	str	r3, [sp, #8]
3480bf18:	eb0041d7 	bl	3481c67c <strlen>
3480bf1c:	e59d3008 	ldr	r3, [sp, #8]
3480bf20:	e0834000 	add	r4, r3, r0
	}

	if (sep)
3480bf24:	e35a0000 	cmp	sl, #0
		*sep = ':';
3480bf28:	13a0303a 	movne	r3, #58	; 0x3a
3480bf2c:	15ca3000 	strbne	r3, [sl]
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
		*p = '\0';
		/* look up the value to substitute */
		if ((p1 = lookup_param(inp))) {
3480bf30:	e3540000 	cmp	r4, #0
3480bf34:	0a000021 	beq	3480bfc0 <insert_var_value_sub+0x240>
			if (tag_subst)
3480bf38:	e59d300c 	ldr	r3, [sp, #12]
3480bf3c:	e3530000 	cmp	r3, #0
3480bf40:	0a000004 	beq	3480bf58 <insert_var_value_sub+0x1d8>
				len = res_str_len + strlen(p1) + 2;
3480bf44:	e1a00004 	mov	r0, r4
3480bf48:	eb0041cb 	bl	3481c67c <strlen>
3480bf4c:	e2875002 	add	r5, r7, #2
3480bf50:	e0855000 	add	r5, r5, r0
3480bf54:	ea000002 	b	3480bf64 <insert_var_value_sub+0x1e4>
			else
				len = res_str_len + strlen(p1);
3480bf58:	e1a00004 	mov	r0, r4
3480bf5c:	eb0041c6 	bl	3481c67c <strlen>
3480bf60:	e0805007 	add	r5, r0, r7
			res_str = xrealloc(res_str, (1 + len));
3480bf64:	e1a00006 	mov	r0, r6
3480bf68:	e2851001 	add	r1, r5, #1
3480bf6c:	ebfffe96 	bl	3480b9cc <xrealloc>
			if (tag_subst) {
3480bf70:	e59d300c 	ldr	r3, [sp, #12]
		if ((p1 = lookup_param(inp))) {
			if (tag_subst)
				len = res_str_len + strlen(p1) + 2;
			else
				len = res_str_len + strlen(p1);
			res_str = xrealloc(res_str, (1 + len));
3480bf74:	e1a06000 	mov	r6, r0
			if (tag_subst) {
3480bf78:	e3530000 	cmp	r3, #0
3480bf7c:	0a00000b 	beq	3480bfb0 <insert_var_value_sub+0x230>
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len + 1), p1);
3480bf80:	e287a001 	add	sl, r7, #1
3480bf84:	e080a00a 	add	sl, r0, sl
3480bf88:	e1a01004 	mov	r1, r4
3480bf8c:	e1a0000a 	mov	r0, sl
3480bf90:	eb004154 	bl	3481c4e8 <strcpy>

				/*
				 * mark the replaced text to be accepted as
				 * is
				 */
				res_str[res_str_len] = SUBSTED_VAR_SYMBOL;
3480bf94:	e3a03004 	mov	r3, #4
3480bf98:	e7c63007 	strb	r3, [r6, r7]
				res_str[res_str_len + 1 + strlen(p1)] =
3480bf9c:	e1a00004 	mov	r0, r4
3480bfa0:	eb0041b5 	bl	3481c67c <strlen>
3480bfa4:	e3a03004 	mov	r3, #4
3480bfa8:	e7ca3000 	strb	r3, [sl, r0]
3480bfac:	ea000002 	b	3480bfbc <insert_var_value_sub+0x23c>
			} else
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len), p1);
3480bfb0:	e0800007 	add	r0, r0, r7
3480bfb4:	e1a01004 	mov	r1, r4
3480bfb8:	eb00414a 	bl	3481c4e8 <strcpy>

			res_str_len = len;
3480bfbc:	e1a07005 	mov	r7, r5
		}
		*p = SPECIAL_VAR_SYMBOL;
3480bfc0:	e3a03003 	mov	r3, #3
3480bfc4:	e4c93001 	strb	r3, [r9], #1
		inp = ++p;
		done = 1;
3480bfc8:	e3a05001 	mov	r5, #1
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480bfcc:	e1a00009 	mov	r0, r9
3480bfd0:	e3a01003 	mov	r1, #3
3480bfd4:	eb004192 	bl	3481c624 <strchr>
3480bfd8:	e250b000 	subs	fp, r0, #0
3480bfdc:	1affff6f 	bne	3480bda0 <insert_var_value_sub+0x20>
		}
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
3480bfe0:	e3550000 	cmp	r5, #0
3480bfe4:	e1a04006 	mov	r4, r6
3480bfe8:	0a000011 	beq	3480c034 <insert_var_value_sub+0x2b4>
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480bfec:	e1a00009 	mov	r0, r9
3480bff0:	eb0041a1 	bl	3481c67c <strlen>
3480bff4:	e2871001 	add	r1, r7, #1
3480bff8:	e0811000 	add	r1, r1, r0
3480bffc:	e1a00006 	mov	r0, r6
3480c000:	ebfffe71 	bl	3480b9cc <xrealloc>
		strcpy((res_str + res_str_len), inp);
3480c004:	e1a01009 	mov	r1, r9
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480c008:	e1a04000 	mov	r4, r0
		strcpy((res_str + res_str_len), inp);
3480c00c:	e0800007 	add	r0, r0, r7
3480c010:	eb004134 	bl	3481c4e8 <strcpy>
		while ((p = strchr(res_str, '\n'))) {
			*p = ' ';
3480c014:	e3a05020 	mov	r5, #32
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480c018:	ea000000 	b	3480c020 <insert_var_value_sub+0x2a0>
			*p = ' ';
3480c01c:	e5c05000 	strb	r5, [r0]
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480c020:	e1a00004 	mov	r0, r4
3480c024:	e3a0100a 	mov	r1, #10
3480c028:	eb00417d 	bl	3481c624 <strchr>
3480c02c:	e3500000 	cmp	r0, #0
3480c030:	1afffff9 	bne	3480c01c <insert_var_value_sub+0x29c>
			*p = ' ';
		}
	}
	return (res_str == NULL) ? inp : res_str;
}
3480c034:	e3540000 	cmp	r4, #0
3480c038:	11a00004 	movne	r0, r4
3480c03c:	01a00009 	moveq	r0, r9
3480c040:	e28dd010 	add	sp, sp, #16
3480c044:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480c048:	348264d1 	.word	0x348264d1

3480c04c <unset_local_var>:
#endif
	return result;
}

void unset_local_var(const char *name)
{
3480c04c:	e92d4070 	push	{r4, r5, r6, lr}
	struct variables *cur;

	if (name) {
3480c050:	e2505000 	subs	r5, r0, #0
		for (cur = top_vars; cur; cur=cur->next) {
3480c054:	159f3088 	ldrne	r3, [pc, #136]	; 3480c0e4 <unset_local_var+0x98>
3480c058:	15934000 	ldrne	r4, [r3]

void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
3480c05c:	1a000006 	bne	3480c07c <unset_local_var+0x30>
3480c060:	e8bd8070 	pop	{r4, r5, r6, pc}
		for (cur = top_vars; cur; cur=cur->next) {
			if(strcmp(cur->name, name)==0)
3480c064:	e5940000 	ldr	r0, [r4]
3480c068:	e1a01005 	mov	r1, r5
3480c06c:	eb00414e 	bl	3481c5ac <strcmp>
3480c070:	e3500000 	cmp	r0, #0
3480c074:	0a000003 	beq	3480c088 <unset_local_var+0x3c>
void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
		for (cur = top_vars; cur; cur=cur->next) {
3480c078:	e5944010 	ldr	r4, [r4, #16]
3480c07c:	e3540000 	cmp	r4, #0
3480c080:	1afffff7 	bne	3480c064 <unset_local_var+0x18>
3480c084:	e8bd8070 	pop	{r4, r5, r6, pc}
			if(strcmp(cur->name, name)==0)
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
3480c088:	e59f3054 	ldr	r3, [pc, #84]	; 3480c0e4 <unset_local_var+0x98>
3480c08c:	e5936000 	ldr	r6, [r3]
			if(cur->flg_read_only) {
3480c090:	e594300c 	ldr	r3, [r4, #12]
3480c094:	e3530000 	cmp	r3, #0
3480c098:	0a000003 	beq	3480c0ac <unset_local_var+0x60>
				error_msg("%s: readonly variable", name);
3480c09c:	e59f0044 	ldr	r0, [pc, #68]	; 3480c0e8 <unset_local_var+0x9c>
3480c0a0:	e1a01005 	mov	r1, r5
				next->next = cur->next;
			}
			free(cur);
		}
	}
}
3480c0a4:	e8bd4070 	pop	{r4, r5, r6, lr}
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
			if(cur->flg_read_only) {
				error_msg("%s: readonly variable", name);
3480c0a8:	eafff6c2 	b	34809bb8 <printf>
			} else {
#ifndef __U_BOOT__
				if(cur->flg_export)
					unsetenv(cur->name);
#endif
				free(cur->name);
3480c0ac:	e5940000 	ldr	r0, [r4]
3480c0b0:	ebfff7fe 	bl	3480a0b0 <free>
				free(cur->value);
3480c0b4:	e5940004 	ldr	r0, [r4, #4]
3480c0b8:	ebfff7fc 	bl	3480a0b0 <free>
				while (next->next != cur)
3480c0bc:	ea000000 	b	3480c0c4 <unset_local_var+0x78>
3480c0c0:	e1a06003 	mov	r6, r3
3480c0c4:	e5963010 	ldr	r3, [r6, #16]
3480c0c8:	e1530004 	cmp	r3, r4
3480c0cc:	1afffffb 	bne	3480c0c0 <unset_local_var+0x74>
					next = next->next;
				next->next = cur->next;
3480c0d0:	e5943010 	ldr	r3, [r4, #16]
			}
			free(cur);
3480c0d4:	e1a00004 	mov	r0, r4
#endif
				free(cur->name);
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
3480c0d8:	e5863010 	str	r3, [r6, #16]
			}
			free(cur);
		}
	}
}
3480c0dc:	e8bd4070 	pop	{r4, r5, r6, lr}
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
			}
			free(cur);
3480c0e0:	eafff7f2 	b	3480a0b0 <free>
3480c0e4:	3482a06c 	.word	0x3482a06c
3480c0e8:	348264bb 	.word	0x348264bb

3480c0ec <new_pipe>:
	}
	return 0;
}
#endif

struct pipe *new_pipe(void) {
3480c0ec:	e92d4008 	push	{r3, lr}
	struct pipe *pi;
	pi = xmalloc(sizeof(struct pipe));
3480c0f0:	e3a00014 	mov	r0, #20
3480c0f4:	ebfffd8b 	bl	3480b728 <xmalloc>
	pi->num_progs = 0;
3480c0f8:	e3a02000 	mov	r2, #0
3480c0fc:	e5802000 	str	r2, [r0]
	pi->progs = NULL;
3480c100:	e5802004 	str	r2, [r0, #4]
	pi->next = NULL;
3480c104:	e5802008 	str	r2, [r0, #8]
	pi->followup = 0;  /* invalid */
3480c108:	e580200c 	str	r2, [r0, #12]
	pi->r_mode = RES_NONE;
3480c10c:	e5802010 	str	r2, [r0, #16]
	return pi;
}
3480c110:	e8bd8008 	pop	{r3, pc}

3480c114 <done_pipe>:
	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}

static int done_pipe(struct p_context *ctx, pipe_style type)
{
3480c114:	e92d4038 	push	{r3, r4, r5, lr}
3480c118:	e1a04000 	mov	r4, r0
3480c11c:	e1a05001 	mov	r5, r1
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
3480c120:	ebfffe31 	bl	3480b9ec <done_command>
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480c124:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe->r_mode = ctx->w;
3480c128:	e594200c 	ldr	r2, [r4, #12]
static int done_pipe(struct p_context *ctx, pipe_style type)
{
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480c12c:	e583500c 	str	r5, [r3, #12]
	ctx->pipe->r_mode = ctx->w;
3480c130:	e5832010 	str	r2, [r3, #16]
	new_p=new_pipe();
3480c134:	ebffffec 	bl	3480c0ec <new_pipe>
	ctx->pipe->next = new_p;
3480c138:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe = new_p;
	ctx->child = NULL;
3480c13c:	e3a05000 	mov	r5, #0
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
	ctx->pipe->r_mode = ctx->w;
	new_p=new_pipe();
	ctx->pipe->next = new_p;
3480c140:	e5830008 	str	r0, [r3, #8]
	ctx->pipe = new_p;
3480c144:	e5840008 	str	r0, [r4, #8]
	ctx->child = NULL;
3480c148:	e5845000 	str	r5, [r4]
	done_command(ctx);  /* set up new pipe to accept commands */
3480c14c:	e1a00004 	mov	r0, r4
3480c150:	ebfffe25 	bl	3480b9ec <done_command>
	return 0;
}
3480c154:	e1a00005 	mov	r0, r5
3480c158:	e8bd8038 	pop	{r3, r4, r5, pc}

3480c15c <reserved_word>:
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480c15c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	{ "do",    RES_DO,    FLAG_DONE },
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
3480c160:	e59f719c 	ldr	r7, [pc, #412]	; 3480c304 <reserved_word+0x1a8>
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480c164:	e59f619c 	ldr	r6, [pc, #412]	; 3480c308 <reserved_word+0x1ac>
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480c168:	e1a05000 	mov	r5, r0
3480c16c:	e1a04001 	mov	r4, r1
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
3480c170:	e5950000 	ldr	r0, [r5]
3480c174:	e5961000 	ldr	r1, [r6]
3480c178:	eb00410b 	bl	3481c5ac <strcmp>
3480c17c:	e2509000 	subs	r9, r0, #0
3480c180:	1a000056 	bne	3480c2e0 <reserved_word+0x184>
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
3480c184:	e5963008 	ldr	r3, [r6, #8]
3480c188:	e3130b02 	tst	r3, #2048	; 0x800
3480c18c:	0a000025 	beq	3480c228 <reserved_word+0xcc>
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480c190:	e280001c 	add	r0, r0, #28
3480c194:	ebfffd63 	bl	3480b728 <xmalloc>
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480c198:	e594700c 	ldr	r7, [r4, #12]
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480c19c:	e1a0a000 	mov	sl, r0
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480c1a0:	e357000c 	cmp	r7, #12
3480c1a4:	13570006 	cmpne	r7, #6
3480c1a8:	13a07000 	movne	r7, #0
3480c1ac:	03a07001 	moveq	r7, #1
3480c1b0:	1a00000a 	bne	3480c1e0 <reserved_word+0x84>
					syntax();
3480c1b4:	ebfffd1c 	bl	3480b62c <syntax_err>
					free(new);
3480c1b8:	e1a0000a 	mov	r0, sl
3480c1bc:	ebfff7bb 	bl	3480a0b0 <free>
					ctx->w = RES_SNTX;
3480c1c0:	e3a0300d 	mov	r3, #13
3480c1c4:	e584300c 	str	r3, [r4, #12]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c1c8:	e5953000 	ldr	r3, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c1cc:	e5859004 	str	r9, [r5, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c1d0:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480c1d4:	e5859010 	str	r9, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480c1d8:	15c39000 	strbne	r9, [r3]
3480c1dc:	ea000044 	b	3480c2f4 <reserved_word+0x198>
					free(new);
					ctx->w = RES_SNTX;
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
3480c1e0:	e1a0c004 	mov	ip, r4
3480c1e4:	e1a0e00a 	mov	lr, sl
3480c1e8:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
3480c1ec:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
3480c1f0:	e89c0007 	ldm	ip, {r0, r1, r2}
3480c1f4:	e88e0007 	stm	lr, {r0, r1, r2}
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480c1f8:	e5847008 	str	r7, [r4, #8]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480c1fc:	e5847000 	str	r7, [r4]
	ctx->list_head=new_pipe();
3480c200:	ebffffb9 	bl	3480c0ec <new_pipe>
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480c204:	e584700c 	str	r7, [r4, #12]
	ctx->pipe=NULL;
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
3480c208:	e5840004 	str	r0, [r4, #4]
	ctx->pipe=ctx->list_head;
3480c20c:	e5840008 	str	r0, [r4, #8]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
3480c210:	e5847014 	str	r7, [r4, #20]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480c214:	e5847010 	str	r7, [r4, #16]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480c218:	e1a00004 	mov	r0, r4
3480c21c:	ebfffdf2 	bl	3480b9ec <done_command>
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
3480c220:	e584a014 	str	sl, [r4, #20]
3480c224:	ea000011 	b	3480c270 <reserved_word+0x114>
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
3480c228:	e594300c 	ldr	r3, [r4, #12]
3480c22c:	e3530000 	cmp	r3, #0
3480c230:	0a000004 	beq	3480c248 <reserved_word+0xec>
3480c234:	e5942010 	ldr	r2, [r4, #16]
3480c238:	e5963004 	ldr	r3, [r6, #4]
3480c23c:	e1a03352 	asr	r3, r2, r3
3480c240:	e3130001 	tst	r3, #1
3480c244:	1a000009 	bne	3480c270 <reserved_word+0x114>
				syntax();
3480c248:	ebfffcf7 	bl	3480b62c <syntax_err>
				ctx->w = RES_SNTX;
3480c24c:	e3a0300d 	mov	r3, #13

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c250:	e5952000 	ldr	r2, [r5]
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
3480c254:	e584300c 	str	r3, [r4, #12]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c258:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c25c:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c260:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480c264:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480c268:	1a00001a 	bne	3480c2d8 <reserved_word+0x17c>
3480c26c:	ea000020 	b	3480c2f4 <reserved_word+0x198>
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
3480c270:	e5963004 	ldr	r3, [r6, #4]
3480c274:	e584300c 	str	r3, [r4, #12]
			ctx->old_flag = r->flag;
3480c278:	e5963008 	ldr	r3, [r6, #8]
			if (ctx->old_flag & FLAG_END) {
3480c27c:	e3130001 	tst	r3, #1
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
			ctx->old_flag = r->flag;
3480c280:	e5843010 	str	r3, [r4, #16]
			if (ctx->old_flag & FLAG_END) {
3480c284:	0a00000d 	beq	3480c2c0 <reserved_word+0x164>
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
3480c288:	e1a00004 	mov	r0, r4
3480c28c:	e3a01001 	mov	r1, #1
3480c290:	ebffff9f 	bl	3480c114 <done_pipe>
				old = ctx->stack;
3480c294:	e594c014 	ldr	ip, [r4, #20]
				old->child->group = ctx->list_head;
3480c298:	e5942004 	ldr	r2, [r4, #4]
3480c29c:	e59c3000 	ldr	r3, [ip]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480c2a0:	e1a0e00c 	mov	lr, ip
			if (ctx->old_flag & FLAG_END) {
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
				old = ctx->stack;
				old->child->group = ctx->list_head;
3480c2a4:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480c2a8:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
3480c2ac:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
3480c2b0:	e89e0007 	ldm	lr, {r0, r1, r2}
3480c2b4:	e8840007 	stm	r4, {r0, r1, r2}
				free(old);
3480c2b8:	e1a0000c 	mov	r0, ip
3480c2bc:	ebfff77b 	bl	3480a0b0 <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c2c0:	e5952000 	ldr	r2, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c2c4:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c2c8:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c2cc:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480c2d0:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480c2d4:	0a000008 	beq	3480c2fc <reserved_word+0x1a0>
3480c2d8:	e5c23000 	strb	r3, [r2]
3480c2dc:	ea000004 	b	3480c2f4 <reserved_word+0x198>

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
3480c2e0:	e286600c 	add	r6, r6, #12
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480c2e4:	e1560007 	cmp	r6, r7
3480c2e8:	1affffa0 	bne	3480c170 <reserved_word+0x14>
			}
			b_reset (dest);
			return 1;
		}
	}
	return 0;
3480c2ec:	e3a00000 	mov	r0, #0
3480c2f0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
3480c2f4:	e3a00001 	mov	r0, #1
3480c2f8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
				*ctx = *old;   /* physical copy */
				free(old);
			}
			b_reset (dest);
			return 1;
3480c2fc:	e3a00001 	mov	r0, #1
		}
	}
	return 0;
}
3480c300:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480c304:	34828d08 	.word	0x34828d08
3480c308:	34828c84 	.word	0x34828c84

3480c30c <done_word>:

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480c30c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480c310:	e5903004 	ldr	r3, [r0, #4]
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480c314:	e1a04000 	mov	r4, r0
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480c318:	e3530000 	cmp	r3, #0
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480c31c:	e1a05001 	mov	r5, r1
	struct child_prog *child=ctx->child;
3480c320:	e5916000 	ldr	r6, [r1]
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480c324:	1a000002 	bne	3480c334 <done_word+0x28>
3480c328:	e5900010 	ldr	r0, [r0, #16]
3480c32c:	e3500000 	cmp	r0, #0
3480c330:	08bd86f8 	popeq	{r3, r4, r5, r6, r7, r9, sl, pc}
#ifndef __U_BOOT__
	if (ctx->pending_redirect) {
		glob_target = &ctx->pending_redirect->word;
	} else {
#endif
		if (child->group) {
3480c334:	e5963008 	ldr	r3, [r6, #8]
3480c338:	e3530000 	cmp	r3, #0
3480c33c:	0a000001 	beq	3480c348 <done_word+0x3c>
			syntax();
3480c340:	ebfffcb9 	bl	3480b62c <syntax_err>
3480c344:	ea00004a 	b	3480c474 <done_word+0x168>
			return 1;  /* syntax error, groups and arglists don't mix */
		}
		if (!child->argv && (ctx->type & FLAG_PARSE_SEMICOLON)) {
3480c348:	e5963000 	ldr	r3, [r6]
3480c34c:	e3530000 	cmp	r3, #0
3480c350:	1a00000c 	bne	3480c388 <done_word+0x7c>
3480c354:	e5953018 	ldr	r3, [r5, #24]
3480c358:	e3130002 	tst	r3, #2
3480c35c:	0a000009 	beq	3480c388 <done_word+0x7c>
			debug_printf("checking %s for reserved-ness\n",dest->data);
			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
3480c360:	e1a00004 	mov	r0, r4
3480c364:	e1a01005 	mov	r1, r5
3480c368:	ebffff7b 	bl	3480c15c <reserved_word>
3480c36c:	e3500000 	cmp	r0, #0
3480c370:	0a000004 	beq	3480c388 <done_word+0x7c>
3480c374:	e595000c 	ldr	r0, [r5, #12]
3480c378:	e350000d 	cmp	r0, #13
3480c37c:	13a00000 	movne	r0, #0
3480c380:	03a00001 	moveq	r0, #1
3480c384:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480c388:	e5943000 	ldr	r3, [r4]
3480c38c:	e3a00001 	mov	r0, #1
3480c390:	ea000003 	b	3480c3a4 <done_word+0x98>
			if (*s == '\\') s++;
3480c394:	e352005c 	cmp	r2, #92	; 0x5c
3480c398:	02833001 	addeq	r3, r3, #1
			cnt++;
3480c39c:	e2800001 	add	r0, r0, #1
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480c3a0:	e2833001 	add	r3, r3, #1
3480c3a4:	e3530000 	cmp	r3, #0
3480c3a8:	0a000002 	beq	3480c3b8 <done_word+0xac>
3480c3ac:	e5d32000 	ldrb	r2, [r3]
3480c3b0:	e3520000 	cmp	r2, #0
3480c3b4:	1afffff6 	bne	3480c394 <done_word+0x88>
			if (*s == '\\') s++;
			cnt++;
		}
		str = malloc(cnt);
3480c3b8:	ebfff7c5 	bl	3480a2d4 <malloc>
		if (!str) return 1;
3480c3bc:	e2507000 	subs	r7, r0, #0
3480c3c0:	0a00002b 	beq	3480c474 <done_word+0x168>
		if ( child->argv == NULL) {
3480c3c4:	e5960000 	ldr	r0, [r6]
3480c3c8:	e3500000 	cmp	r0, #0
			child->argc=0;
3480c3cc:	05860004 	streq	r0, [r6, #4]
		}
		argc = ++child->argc;
3480c3d0:	e5969004 	ldr	r9, [r6, #4]
3480c3d4:	e289a001 	add	sl, r9, #1
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480c3d8:	e28a1001 	add	r1, sl, #1
		str = malloc(cnt);
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
3480c3dc:	e586a004 	str	sl, [r6, #4]
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480c3e0:	e1a01101 	lsl	r1, r1, #2
3480c3e4:	ebfff9ac 	bl	3480aa9c <realloc>
		if (child->argv == NULL) return 1;
3480c3e8:	e3500000 	cmp	r0, #0
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480c3ec:	e5860000 	str	r0, [r6]
		if (child->argv == NULL) return 1;
3480c3f0:	0a00001f 	beq	3480c474 <done_word+0x168>
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
3480c3f4:	e3a03000 	mov	r3, #0
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
3480c3f8:	e7807109 	str	r7, [r0, r9, lsl #2]
		child->argv[argc]=NULL;
3480c3fc:	e780310a 	str	r3, [r0, sl, lsl #2]
		for (s = dest->data; s && *s; s++,str++) {
3480c400:	e5943000 	ldr	r3, [r4]
3480c404:	ea000003 	b	3480c418 <done_word+0x10c>
			if (*s == '\\') s++;
3480c408:	e352005c 	cmp	r2, #92	; 0x5c
3480c40c:	02833001 	addeq	r3, r3, #1
			*str = *s;
3480c410:	e4d32001 	ldrb	r2, [r3], #1
3480c414:	e4c72001 	strb	r2, [r7], #1
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
		for (s = dest->data; s && *s; s++,str++) {
3480c418:	e3530000 	cmp	r3, #0
3480c41c:	0a000002 	beq	3480c42c <done_word+0x120>
3480c420:	e5d32000 	ldrb	r2, [r3]
3480c424:	e3520000 	cmp	r2, #0
3480c428:	1afffff6 	bne	3480c408 <done_word+0xfc>
			if (*s == '\\') s++;
			*str = *s;
		}
		*str = '\0';
3480c42c:	e3a03000 	mov	r3, #0
3480c430:	e5c73000 	strb	r3, [r7]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c434:	e5942000 	ldr	r2, [r4]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c438:	e5843004 	str	r3, [r4, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c43c:	e1520003 	cmp	r2, r3
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480c440:	e5843010 	str	r3, [r4, #16]
	if (o->data != NULL) *o->data = '\0';
3480c444:	15c23000 	strbne	r3, [r2]
		}
	} else {
		child->argv = glob_target->gl_pathv;
	}
#endif
	if (ctx->w == RES_FOR) {
3480c448:	e595300c 	ldr	r3, [r5, #12]
3480c44c:	e3530006 	cmp	r3, #6
3480c450:	1a000009 	bne	3480c47c <done_word+0x170>
		done_word(dest,ctx);
3480c454:	e1a01005 	mov	r1, r5
3480c458:	e1a00004 	mov	r0, r4
3480c45c:	ebffffaa 	bl	3480c30c <done_word>
		done_pipe(ctx,PIPE_SEQ);
3480c460:	e1a00005 	mov	r0, r5
3480c464:	e3a01001 	mov	r1, #1
3480c468:	ebffff29 	bl	3480c114 <done_pipe>
	}
	return 0;
3480c46c:	e3a00000 	mov	r0, #0
3480c470:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
3480c474:	e3a00001 	mov	r0, #1
3480c478:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
	if (ctx->w == RES_FOR) {
		done_word(dest,ctx);
		done_pipe(ctx,PIPE_SEQ);
	}
	return 0;
3480c47c:	e3a00000 	mov	r0, #0
}
3480c480:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

3480c484 <mapset>:
}

void mapset(const unsigned char *set, int code)
{
	const unsigned char *s;
	for (s=set; *s; s++) map[*s] = code;
3480c484:	e59f2018 	ldr	r2, [pc, #24]	; 3480c4a4 <mapset+0x20>
3480c488:	ea000001 	b	3480c494 <mapset+0x10>
3480c48c:	e0823003 	add	r3, r2, r3
3480c490:	e5c31138 	strb	r1, [r3, #312]	; 0x138
3480c494:	e4d03001 	ldrb	r3, [r0], #1
3480c498:	e3530000 	cmp	r3, #0
3480c49c:	1afffffa 	bne	3480c48c <mapset+0x8>
}
3480c4a0:	e12fff1e 	bx	lr
3480c4a4:	3482a06c 	.word	0x3482a06c

3480c4a8 <update_ifs_map>:

void update_ifs_map(void)
{
3480c4a8:	e92d4013 	push	{r0, r1, r4, lr}
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480c4ac:	e59f006c 	ldr	r0, [pc, #108]	; 3480c520 <update_ifs_map+0x78>
3480c4b0:	ebffeed2 	bl	34808000 <getenv>
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480c4b4:	e3500000 	cmp	r0, #0
3480c4b8:	059f2064 	ldreq	r2, [pc, #100]	; 3480c524 <update_ifs_map+0x7c>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480c4bc:	e59f3064 	ldr	r3, [pc, #100]	; 3480c528 <update_ifs_map+0x80>
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480c4c0:	e59f4060 	ldr	r4, [pc, #96]	; 3480c528 <update_ifs_map+0x80>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480c4c4:	e5830238 	str	r0, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480c4c8:	e3a01000 	mov	r1, #0

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480c4cc:	05832238 	streq	r2, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480c4d0:	e2840f4e 	add	r0, r4, #312	; 0x138
3480c4d4:	e3a02c01 	mov	r2, #256	; 0x100
3480c4d8:	eb004107 	bl	3481c8fc <memset>
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480c4dc:	e3a03004 	mov	r3, #4
3480c4e0:	e5cd3004 	strb	r3, [sp, #4]
		mapset(subst, 3);       /* never flow through */
3480c4e4:	e28d0004 	add	r0, sp, #4
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480c4e8:	e3a03000 	mov	r3, #0
		mapset(subst, 3);       /* never flow through */
3480c4ec:	e3a01003 	mov	r1, #3
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480c4f0:	e5cd3005 	strb	r3, [sp, #5]
		mapset(subst, 3);       /* never flow through */
3480c4f4:	ebffffe2 	bl	3480c484 <mapset>
	}
	mapset((uchar *)"\\$'\"", 3);       /* never flow through */
3480c4f8:	e59f002c 	ldr	r0, [pc, #44]	; 3480c52c <update_ifs_map+0x84>
3480c4fc:	e3a01003 	mov	r1, #3
3480c500:	ebffffdf 	bl	3480c484 <mapset>
	mapset((uchar *)";&|#", 1);         /* flow through if quoted */
3480c504:	e59f0024 	ldr	r0, [pc, #36]	; 3480c530 <update_ifs_map+0x88>
3480c508:	e3a01001 	mov	r1, #1
3480c50c:	ebffffdc 	bl	3480c484 <mapset>
#endif
	mapset(ifs, 2);            /* also flow through if quoted */
3480c510:	e5940238 	ldr	r0, [r4, #568]	; 0x238
3480c514:	e3a01002 	mov	r1, #2
3480c518:	ebffffd9 	bl	3480c484 <mapset>
}
3480c51c:	e8bd801c 	pop	{r2, r3, r4, pc}
3480c520:	348264d7 	.word	0x348264d7
3480c524:	348264db 	.word	0x348264db
3480c528:	3482a06c 	.word	0x3482a06c
3480c52c:	348264df 	.word	0x348264df
3480c530:	348264e4 	.word	0x348264e4

3480c534 <parse_string_outer>:
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480c534:	e92d4070 	push	{r4, r5, r6, lr}
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480c538:	e2504000 	subs	r4, r0, #0
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480c53c:	e24dd018 	sub	sp, sp, #24
3480c540:	e1a06001 	mov	r6, r1
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480c544:	0a00002f 	beq	3480c608 <parse_string_outer+0xd4>
3480c548:	e5d43000 	ldrb	r3, [r4]
3480c54c:	e3530000 	cmp	r3, #0
3480c550:	0a00002c 	beq	3480c608 <parse_string_outer+0xd4>
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
3480c554:	e3a0100a 	mov	r1, #10
3480c558:	eb004031 	bl	3481c624 <strchr>
3480c55c:	e3500000 	cmp	r0, #0
3480c560:	0a000002 	beq	3480c570 <parse_string_outer+0x3c>
3480c564:	e5d03001 	ldrb	r3, [r0, #1]
3480c568:	e3530000 	cmp	r3, #0
3480c56c:	0a000018 	beq	3480c5d4 <parse_string_outer+0xa0>
		p = xmalloc(strlen(s) + 2);
3480c570:	e1a00004 	mov	r0, r4
3480c574:	eb004040 	bl	3481c67c <strlen>
3480c578:	e2800002 	add	r0, r0, #2
3480c57c:	ebfffc69 	bl	3480b728 <xmalloc>
		strcpy(p, s);
3480c580:	e1a01004 	mov	r1, r4
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
3480c584:	e1a05000 	mov	r5, r0
		strcpy(p, s);
3480c588:	eb003fd6 	bl	3481c4e8 <strcpy>
		strcat(p, "\n");
3480c58c:	e1a00005 	mov	r0, r5
3480c590:	e59f1080 	ldr	r1, [pc, #128]	; 3480c618 <parse_string_outer+0xe4>
3480c594:	eb003fe4 	bl	3481c52c <strcat>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c598:	e59f307c 	ldr	r3, [pc, #124]	; 3480c61c <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c59c:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c5a0:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480c5a4:	e59f3074 	ldr	r3, [pc, #116]	; 3480c620 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c5a8:	e5205014 	str	r5, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480c5ac:	e58d3010 	str	r3, [sp, #16]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480c5b0:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480c5b4:	e3a03001 	mov	r3, #1
3480c5b8:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480c5bc:	e58d300c 	str	r3, [sp, #12]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480c5c0:	eb000210 	bl	3480ce08 <parse_stream_outer>
3480c5c4:	e1a04000 	mov	r4, r0
		free(p);
3480c5c8:	e1a00005 	mov	r0, r5
3480c5cc:	ebfff6b7 	bl	3480a0b0 <free>
		return rcode;
3480c5d0:	ea00000d 	b	3480c60c <parse_string_outer+0xd8>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c5d4:	e59f3040 	ldr	r3, [pc, #64]	; 3480c61c <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c5d8:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480c5dc:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480c5e0:	e59f3038 	ldr	r3, [pc, #56]	; 3480c620 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480c5e4:	e5204014 	str	r4, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480c5e8:	e58d3010 	str	r3, [sp, #16]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480c5ec:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480c5f0:	e3a03001 	mov	r3, #1
3480c5f4:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480c5f8:	e58d300c 	str	r3, [sp, #12]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480c5fc:	eb000201 	bl	3480ce08 <parse_stream_outer>
3480c600:	e1a04000 	mov	r4, r0
3480c604:	ea000000 	b	3480c60c <parse_string_outer+0xd8>
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
3480c608:	e3a04001 	mov	r4, #1
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
#ifdef __U_BOOT__
	}
#endif
}
3480c60c:	e1a00004 	mov	r0, r4
3480c610:	e28dd018 	add	sp, sp, #24
3480c614:	e8bd8070 	pop	{r4, r5, r6, pc}
3480c618:	348264dd 	.word	0x348264dd
3480c61c:	3480b5c0 	.word	0x3480b5c0
3480c620:	3480b5a4 	.word	0x3480b5a4

3480c624 <run_list_real>:
#endif
	return -1;
}

static int run_list_real(struct pipe *pi)
{
3480c624:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480c628:	e1a04000 	mov	r4, r0
3480c62c:	e24dd038 	sub	sp, sp, #56	; 0x38
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c630:	e1a05000 	mov	r5, r0
3480c634:	ea000023 	b	3480c6c8 <run_list_real+0xa4>
		if ((rpipe->r_mode == RES_IN ||
3480c638:	e5953010 	ldr	r3, [r5, #16]
3480c63c:	e353000c 	cmp	r3, #12
3480c640:	13a02000 	movne	r2, #0
3480c644:	03a02001 	moveq	r2, #1
3480c648:	e3530006 	cmp	r3, #6
3480c64c:	13a03000 	movne	r3, #0
3480c650:	03a03001 	moveq	r3, #1
3480c654:	e1930002 	orrs	r0, r3, r2
3480c658:	0a000019 	beq	3480c6c4 <run_list_real+0xa0>
		    rpipe->r_mode == RES_FOR) &&
		    (rpipe->next == NULL)) {
3480c65c:	e5956008 	ldr	r6, [r5, #8]
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
		if ((rpipe->r_mode == RES_IN ||
		    rpipe->r_mode == RES_FOR) &&
3480c660:	e3560000 	cmp	r6, #0
3480c664:	1a000003 	bne	3480c678 <run_list_real+0x54>
		    (rpipe->next == NULL)) {
				syntax();
3480c668:	ebfffbef 	bl	3480b62c <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480c66c:	e59f377c 	ldr	r3, [pc, #1916]	; 3480cdf0 <run_list_real+0x7cc>
3480c670:	e5836004 	str	r6, [r3, #4]
3480c674:	ea0001d7 	b	3480cdd8 <run_list_real+0x7b4>
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
3480c678:	e3520000 	cmp	r2, #0
3480c67c:	0a000006 	beq	3480c69c <run_list_real+0x78>
3480c680:	e5963010 	ldr	r3, [r6, #16]
3480c684:	e353000c 	cmp	r3, #12
3480c688:	1a00000d 	bne	3480c6c4 <run_list_real+0xa0>
			(rpipe->next->r_mode == RES_IN &&
			rpipe->next->progs->argv != NULL))||
3480c68c:	e5963004 	ldr	r3, [r6, #4]
				flag_repeat = 0;
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
			(rpipe->next->r_mode == RES_IN &&
3480c690:	e5933000 	ldr	r3, [r3]
3480c694:	e3530000 	cmp	r3, #0
3480c698:	ea000003 	b	3480c6ac <run_list_real+0x88>
			rpipe->next->progs->argv != NULL))||
3480c69c:	e3530000 	cmp	r3, #0
3480c6a0:	0a000007 	beq	3480c6c4 <run_list_real+0xa0>
			(rpipe->r_mode == RES_FOR &&
3480c6a4:	e5963010 	ldr	r3, [r6, #16]
3480c6a8:	e353000c 	cmp	r3, #12
3480c6ac:	0a000004 	beq	3480c6c4 <run_list_real+0xa0>
			rpipe->next->r_mode != RES_IN)) {
				syntax();
3480c6b0:	ebfffbdd 	bl	3480b62c <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480c6b4:	e59f3734 	ldr	r3, [pc, #1844]	; 3480cdf0 <run_list_real+0x7cc>
3480c6b8:	e3a02000 	mov	r2, #0
3480c6bc:	e5832004 	str	r2, [r3, #4]
3480c6c0:	ea0001c4 	b	3480cdd8 <run_list_real+0x7b4>
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480c6c4:	e5955008 	ldr	r5, [r5, #8]
3480c6c8:	e3550000 	cmp	r5, #0
3480c6cc:	1affffd9 	bne	3480c638 <run_list_real+0x14>
3480c6d0:	e3a09001 	mov	r9, #1
3480c6d4:	e1a07009 	mov	r7, r9
3480c6d8:	e3a0300b 	mov	r3, #11
3480c6dc:	e58d5028 	str	r5, [sp, #40]	; 0x28
3480c6e0:	e58d5018 	str	r5, [sp, #24]
3480c6e4:	e58d5014 	str	r5, [sp, #20]
3480c6e8:	e1a0a005 	mov	sl, r5
3480c6ec:	e1a0b005 	mov	fp, r5
3480c6f0:	e58d5020 	str	r5, [sp, #32]
3480c6f4:	e1a06005 	mov	r6, r5
3480c6f8:	e58d501c 	str	r5, [sp, #28]
3480c6fc:	e1a09005 	mov	r9, r5
3480c700:	ea0001b1 	b	3480cdcc <run_list_real+0x7a8>
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
		if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||
3480c704:	e5942010 	ldr	r2, [r4, #16]
3480c708:	e2422006 	sub	r2, r2, #6
3480c70c:	e3520002 	cmp	r2, #2
3480c710:	8a00000a 	bhi	3480c740 <run_list_real+0x11c>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
3480c714:	e58d3008 	str	r3, [sp, #8]
3480c718:	ebfff54b 	bl	34809c4c <ctrlc>
				if ((had_ctrlc())) {
3480c71c:	ebfff563 	bl	34809cb0 <had_ctrlc>
3480c720:	e3500000 	cmp	r0, #0
3480c724:	e59d3008 	ldr	r3, [sp, #8]
3480c728:	1a0001aa 	bne	3480cdd8 <run_list_real+0x7b4>
					return 1;
				}
#endif
				flag_restore = 0;
				if (!rpipe) {
3480c72c:	e3590000 	cmp	r9, #0
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480c730:	158d0014 	strne	r0, [sp, #20]
				if (!rpipe) {
3480c734:	01a09004 	moveq	r9, r4
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480c738:	058d0014 	streq	r0, [sp, #20]
				if (!rpipe) {
					flag_rep = 0;
3480c73c:	01a0b000 	moveq	fp, r0
					rpipe = pi;
				}
		}
		rmode = pi->r_mode;
3480c740:	e5945010 	ldr	r5, [r4, #16]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
3480c744:	e1550003 	cmp	r5, r3
3480c748:	13a07000 	movne	r7, #0
3480c74c:	02077001 	andeq	r7, r7, #1
3480c750:	e3570000 	cmp	r7, #0
3480c754:	0a000003 	beq	3480c768 <run_list_real+0x144>
			if (pi->followup == PIPE_SEQ) flag_skip=0;
3480c758:	e594700c 	ldr	r7, [r4, #12]
3480c75c:	e2577001 	subs	r7, r7, #1
3480c760:	13a07001 	movne	r7, #1
3480c764:	ea000194 	b	3480cdbc <run_list_real+0x798>
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480c768:	e3550002 	cmp	r5, #2
3480c76c:	13a02000 	movne	r2, #0
3480c770:	03a02001 	moveq	r2, #1
3480c774:	e3550004 	cmp	r5, #4
3480c778:	13a03000 	movne	r3, #0
3480c77c:	03a03001 	moveq	r3, #1
3480c780:	e1931002 	orrs	r1, r3, r2
3480c784:	e59d0018 	ldr	r0, [sp, #24]
3480c788:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480c78c:	11a00001 	movne	r0, r1
		if (rmode == RES_THEN &&  if_code) continue;
3480c790:	e3500000 	cmp	r0, #0
3480c794:	03a02000 	moveq	r2, #0
3480c798:	12022001 	andne	r2, r2, #1
3480c79c:	e3520000 	cmp	r2, #0
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480c7a0:	e58d0018 	str	r0, [sp, #24]
		if (rmode == RES_THEN &&  if_code) continue;
3480c7a4:	1a000182 	bne	3480cdb4 <run_list_real+0x790>
		if (rmode == RES_ELSE && !if_code) continue;
3480c7a8:	e2707001 	rsbs	r7, r0, #1
3480c7ac:	33a07000 	movcc	r7, #0
3480c7b0:	e1170003 	tst	r7, r3
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480c7b4:	13a0300b 	movne	r3, #11
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
		if (rmode == RES_THEN &&  if_code) continue;
		if (rmode == RES_ELSE && !if_code) continue;
3480c7b8:	158d2018 	strne	r2, [sp, #24]
3480c7bc:	1a00017d 	bne	3480cdb8 <run_list_real+0x794>
		if (rmode == RES_ELIF && !if_code) break;
3480c7c0:	e3550003 	cmp	r5, #3
3480c7c4:	13a02000 	movne	r2, #0
3480c7c8:	03a02001 	moveq	r2, #1
3480c7cc:	e0177002 	ands	r7, r7, r2
3480c7d0:	e58d202c 	str	r2, [sp, #44]	; 0x2c
3480c7d4:	1a000180 	bne	3480cddc <run_list_real+0x7b8>
		if (rmode == RES_FOR && pi->num_progs) {
3480c7d8:	e3550006 	cmp	r5, #6
3480c7dc:	1a000082 	bne	3480c9ec <run_list_real+0x3c8>
3480c7e0:	e5943000 	ldr	r3, [r4]
3480c7e4:	e3530000 	cmp	r3, #0
3480c7e8:	0a00008d 	beq	3480ca24 <run_list_real+0x400>
			if (!list) {
3480c7ec:	e3560000 	cmp	r6, #0
3480c7f0:	1a00005f 	bne	3480c974 <run_list_real+0x350>
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
3480c7f4:	e5943008 	ldr	r3, [r4, #8]
3480c7f8:	e5933004 	ldr	r3, [r3, #4]
3480c7fc:	e5933000 	ldr	r3, [r3]
3480c800:	e3530000 	cmp	r3, #0
3480c804:	0a00016a 	beq	3480cdb4 <run_list_real+0x790>
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
3480c808:	e5942004 	ldr	r2, [r4, #4]
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480c80c:	e5922000 	ldr	r2, [r2]
3480c810:	e5922000 	ldr	r2, [r2]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480c814:	e58d3008 	str	r3, [sp, #8]
3480c818:	e1a00002 	mov	r0, r2
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480c81c:	e58d2010 	str	r2, [sp, #16]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480c820:	eb003f95 	bl	3481c67c <strlen>
3480c824:	e58d001c 	str	r0, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480c828:	e3a00004 	mov	r0, #4
3480c82c:	ebfffbbd 	bl	3480b728 <xmalloc>
3480c830:	e59d3008 	ldr	r3, [sp, #8]
3480c834:	e58d9024 	str	r9, [sp, #36]	; 0x24
3480c838:	e58d300c 	str	r3, [sp, #12]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480c83c:	e59d301c 	ldr	r3, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480c840:	e1a06000 	mov	r6, r0
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480c844:	e2833002 	add	r3, r3, #2
3480c848:	e58d3020 	str	r3, [sp, #32]
3480c84c:	e58da030 	str	sl, [sp, #48]	; 0x30
3480c850:	e58d5034 	str	r5, [sp, #52]	; 0x34
3480c854:	e1a09004 	mov	r9, r4
3480c858:	ea000034 	b	3480c930 <run_list_real+0x30c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480c85c:	e3a01000 	mov	r1, #0
3480c860:	ebfffd46 	bl	3480bd80 <insert_var_value_sub>
3480c864:	e1a0b000 	mov	fp, r0
3480c868:	e1a0a000 	mov	sl, r0
3480c86c:	ea000026 	b	3480c90c <run_list_real+0x2e8>
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480c870:	e3530020 	cmp	r3, #32
				p1++;
3480c874:	028bb001 	addeq	fp, fp, #1
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480c878:	0a000023 	beq	3480c90c <run_list_real+0x2e8>
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480c87c:	e1a0000b 	mov	r0, fp
3480c880:	e3a01020 	mov	r1, #32
3480c884:	eb003f66 	bl	3481c624 <strchr>
3480c888:	e2505000 	subs	r5, r0, #0
				len = p2 - p1;
3480c88c:	106b4005 	rsbne	r4, fp, r5
		while (*p1) {
			if ((*p1 == ' ')) {
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480c890:	1a000003 	bne	3480c8a4 <run_list_real+0x280>
				len = p2 - p1;
			} else {
				len = strlen(p1);
3480c894:	e1a0000b 	mov	r0, fp
3480c898:	eb003f77 	bl	3481c67c <strlen>
3480c89c:	e1a04000 	mov	r4, r0
				p2 = p1 + len;
3480c8a0:	e08b5000 	add	r5, fp, r0
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480c8a4:	e2871002 	add	r1, r7, #2
3480c8a8:	e1a00006 	mov	r0, r6
3480c8ac:	e1a01101 	lsl	r1, r1, #2
3480c8b0:	ebfffc45 	bl	3480b9cc <xrealloc>
			list[n] = xmalloc(2 + name_len + len);
3480c8b4:	e59d1020 	ldr	r1, [sp, #32]
				len = strlen(p1);
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480c8b8:	e1a06000 	mov	r6, r0
			list[n] = xmalloc(2 + name_len + len);
3480c8bc:	e0810004 	add	r0, r1, r4
3480c8c0:	ebfffb98 	bl	3480b728 <xmalloc>
			strcpy(list[n], name);
3480c8c4:	e59d1010 	ldr	r1, [sp, #16]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480c8c8:	e7860107 	str	r0, [r6, r7, lsl #2]
			strcpy(list[n], name);
3480c8cc:	eb003f05 	bl	3481c4e8 <strcpy>
			strcat(list[n], "=");
3480c8d0:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480c8d4:	e59f1518 	ldr	r1, [pc, #1304]	; 3480cdf4 <run_list_real+0x7d0>
3480c8d8:	eb003f13 	bl	3481c52c <strcat>
			strncat(list[n], p1, len);
3480c8dc:	e1a02004 	mov	r2, r4
3480c8e0:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480c8e4:	e1a0100b 	mov	r1, fp
3480c8e8:	eb003f1b 	bl	3481c55c <strncat>
			list[n++][name_len + len + 1] = '\0';
3480c8ec:	e7963107 	ldr	r3, [r6, r7, lsl #2]
3480c8f0:	e59d201c 	ldr	r2, [sp, #28]
3480c8f4:	e2877001 	add	r7, r7, #1
3480c8f8:	e0833002 	add	r3, r3, r2
3480c8fc:	e0834004 	add	r4, r3, r4
3480c900:	e3a03000 	mov	r3, #0
3480c904:	e5c43001 	strb	r3, [r4, #1]
			p1 = p2;
3480c908:	e1a0b005 	mov	fp, r5
	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
3480c90c:	e5db3000 	ldrb	r3, [fp]
3480c910:	e3530000 	cmp	r3, #0
3480c914:	1affffd5 	bne	3480c870 <run_list_real+0x24c>
			strcat(list[n], "=");
			strncat(list[n], p1, len);
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
3480c918:	e59d000c 	ldr	r0, [sp, #12]
3480c91c:	e5103004 	ldr	r3, [r0, #-4]
3480c920:	e15a0003 	cmp	sl, r3
3480c924:	0a000001 	beq	3480c930 <run_list_real+0x30c>
3480c928:	e1a0000a 	mov	r0, sl
3480c92c:	ebfff5df 	bl	3480a0b0 <free>
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
3480c930:	e59d100c 	ldr	r1, [sp, #12]
3480c934:	e4910004 	ldr	r0, [r1], #4
3480c938:	e3500000 	cmp	r0, #0
3480c93c:	e58d100c 	str	r1, [sp, #12]
3480c940:	1affffc5 	bne	3480c85c <run_list_real+0x238>
3480c944:	e1a04009 	mov	r4, r9
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480c948:	e5943004 	ldr	r3, [r4, #4]
3480c94c:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480c950:	e5933000 	ldr	r3, [r3]
3480c954:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
3480c958:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
	}
	list[n] = NULL;
3480c95c:	e7860107 	str	r0, [r6, r7, lsl #2]
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480c960:	e5932000 	ldr	r2, [r3]
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
3480c964:	e3a0b001 	mov	fp, #1
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480c968:	e58d201c 	str	r2, [sp, #28]
				pi->progs->argv[0] = NULL;
3480c96c:	e5830000 	str	r0, [r3]
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
3480c970:	e58d6020 	str	r6, [sp, #32]
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
3480c974:	e5962000 	ldr	r2, [r6]
3480c978:	e5943004 	ldr	r3, [r4, #4]
3480c97c:	e3520000 	cmp	r2, #0
3480c980:	1a00000f 	bne	3480c9c4 <run_list_real+0x3a0>
				free(pi->progs->argv[0]);
3480c984:	e5933000 	ldr	r3, [r3]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480c988:	e3a07001 	mov	r7, #1
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
3480c98c:	e5930000 	ldr	r0, [r3]
3480c990:	e58d2008 	str	r2, [sp, #8]
3480c994:	ebfff5c5 	bl	3480a0b0 <free>
				free(save_list);
3480c998:	e59d0020 	ldr	r0, [sp, #32]
3480c99c:	ebfff5c3 	bl	3480a0b0 <free>
				list = NULL;
				flag_rep = 0;
				pi->progs->argv[0] = save_name;
3480c9a0:	e5943004 	ldr	r3, [r4, #4]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480c9a4:	e59d2008 	ldr	r2, [sp, #8]
				pi->progs->argv[0] = save_name;
3480c9a8:	e5933000 	ldr	r3, [r3]
3480c9ac:	e59d001c 	ldr	r0, [sp, #28]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480c9b0:	e1a0b002 	mov	fp, r2
				pi->progs->argv[0] = save_name;
3480c9b4:	e5830000 	str	r0, [r3]
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
3480c9b8:	e1a06002 	mov	r6, r2
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480c9bc:	e3a0300b 	mov	r3, #11
				pi->progs->argv[0] = save_name;
#ifndef __U_BOOT__
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
				continue;
3480c9c0:	ea0000fd 	b	3480cdbc <run_list_real+0x798>
			} else {
				/* insert new value from list for variable */
				if (pi->progs->argv[0])
3480c9c4:	e5933000 	ldr	r3, [r3]
3480c9c8:	e5930000 	ldr	r0, [r3]
3480c9cc:	e3500000 	cmp	r0, #0
3480c9d0:	0a000000 	beq	3480c9d8 <run_list_real+0x3b4>
					free(pi->progs->argv[0]);
3480c9d4:	ebfff5b5 	bl	3480a0b0 <free>
				pi->progs->argv[0] = *list++;
3480c9d8:	e5943004 	ldr	r3, [r4, #4]
3480c9dc:	e4962004 	ldr	r2, [r6], #4
3480c9e0:	e5933000 	ldr	r3, [r3]
3480c9e4:	e5832000 	str	r2, [r3]
3480c9e8:	ea00000d 	b	3480ca24 <run_list_real+0x400>
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
			}
		}
		if (rmode == RES_IN) continue;
3480c9ec:	e355000c 	cmp	r5, #12
3480c9f0:	0a0000ef 	beq	3480cdb4 <run_list_real+0x790>
		if (rmode == RES_DO) {
3480c9f4:	e3550009 	cmp	r5, #9
3480c9f8:	1a000002 	bne	3480ca08 <run_list_real+0x3e4>
			if (!flag_rep) continue;
3480c9fc:	e35b0000 	cmp	fp, #0
3480ca00:	0a0000eb 	beq	3480cdb4 <run_list_real+0x790>
3480ca04:	ea000006 	b	3480ca24 <run_list_real+0x400>
		}
		if ((rmode == RES_DONE)) {
3480ca08:	e355000a 	cmp	r5, #10
3480ca0c:	1a000004 	bne	3480ca24 <run_list_real+0x400>
			if (flag_rep) {
				flag_restore = 1;
3480ca10:	e59d1014 	ldr	r1, [sp, #20]
3480ca14:	e35b0000 	cmp	fp, #0
3480ca18:	13a01001 	movne	r1, #1
3480ca1c:	e58d1014 	str	r1, [sp, #20]
3480ca20:	03a09000 	moveq	r9, #0
			} else {
				rpipe = NULL;
			}
		}
		if (pi->num_progs == 0) continue;
3480ca24:	e5943000 	ldr	r3, [r4]
3480ca28:	e3530000 	cmp	r3, #0
3480ca2c:	0a0000e0 	beq	3480cdb4 <run_list_real+0x790>
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480ca30:	e59f23b8 	ldr	r2, [pc, #952]	; 3480cdf0 <run_list_real+0x7cc>

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480ca34:	e3530001 	cmp	r3, #1
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480ca38:	e5922008 	ldr	r2, [r2, #8]
3480ca3c:	e58d2010 	str	r2, [sp, #16]

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480ca40:	1a0000e8 	bne	3480cde8 <run_list_real+0x7c4>
3480ca44:	e5947004 	ldr	r7, [r4, #4]
		/* XXX could we merge code with following builtin case,
		 * by creating a pseudo builtin that calls run_list_real? */
		rcode = run_list_real(child->group);
		restore_redirects(squirrel);
#else
		if (pi->num_progs == 1 && child->group) {
3480ca48:	e5970008 	ldr	r0, [r7, #8]
3480ca4c:	e3500000 	cmp	r0, #0
3480ca50:	0a000001 	beq	3480ca5c <run_list_real+0x438>
		int rcode;
		debug_printf("non-subshell grouping\n");
		rcode = run_list_real(child->group);
3480ca54:	ebfffef2 	bl	3480c624 <run_list_real>
3480ca58:	ea0000b3 	b	3480cd2c <run_list_real+0x708>
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
3480ca5c:	e5972000 	ldr	r2, [r7]
3480ca60:	e3520000 	cmp	r2, #0
3480ca64:	0a0000df 	beq	3480cde8 <run_list_real+0x7c4>
3480ca68:	e1a01007 	mov	r1, r7
3480ca6c:	e1a0c004 	mov	ip, r4
3480ca70:	e1a0a000 	mov	sl, r0
3480ca74:	e1a07005 	mov	r7, r5
3480ca78:	e1a04002 	mov	r4, r2
3480ca7c:	ea000000 	b	3480ca84 <run_list_real+0x460>
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
3480ca80:	e28aa001 	add	sl, sl, #1
3480ca84:	e4945004 	ldr	r5, [r4], #4
3480ca88:	e58d1008 	str	r1, [sp, #8]
3480ca8c:	e1a00005 	mov	r0, r5
3480ca90:	e58dc004 	str	ip, [sp, #4]
3480ca94:	ebfffacf 	bl	3480b5d8 <is_assignment>
3480ca98:	e3500000 	cmp	r0, #0
3480ca9c:	e59d1008 	ldr	r1, [sp, #8]
3480caa0:	e59dc004 	ldr	ip, [sp, #4]
3480caa4:	1afffff5 	bne	3480ca80 <run_list_real+0x45c>
		if (i!=0 && child->argv[i]==NULL) {
3480caa8:	e35a0000 	cmp	sl, #0
3480caac:	e1a03005 	mov	r3, r5
3480cab0:	e1a0400c 	mov	r4, ip
3480cab4:	e1a05007 	mov	r5, r7
3480cab8:	e1a07001 	mov	r7, r1
3480cabc:	0a000035 	beq	3480cb98 <run_list_real+0x574>
3480cac0:	e3530000 	cmp	r3, #0
3480cac4:	01a0a003 	moveq	sl, r3
3480cac8:	1a000031 	bne	3480cb94 <run_list_real+0x570>
3480cacc:	ea000018 	b	3480cb34 <run_list_real+0x510>
				 * not exported, we need only set this as a local variable.
				 * This junk is all to decide whether or not to export this
				 * variable. */
				int export_me=0;
				char *name, *value;
				name = xstrdup(child->argv[i]);
3480cad0:	eb003f1e 	bl	3481c750 <strdup>
				debug_printf("Local environment set: %s\n", name);
				value = strchr(name, '=');
3480cad4:	e3a0103d 	mov	r1, #61	; 0x3d
3480cad8:	e58d0008 	str	r0, [sp, #8]
3480cadc:	eb003ed0 	bl	3481c624 <strchr>
				if (value)
3480cae0:	e59d3008 	ldr	r3, [sp, #8]
3480cae4:	e3500000 	cmp	r0, #0
					*value=0;
3480cae8:	13a01000 	movne	r1, #0
3480caec:	15c01000 	strbne	r1, [r0]
#ifndef __U_BOOT__
				if ( get_local_var(name)) {
					export_me=1;
				}
#endif
				free(name);
3480caf0:	e1a00003 	mov	r0, r3
3480caf4:	ebfff56d 	bl	3480a0b0 <free>
				p = insert_var_value(child->argv[i]);
3480caf8:	e5973000 	ldr	r3, [r7]
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480cafc:	e3a01000 	mov	r1, #0
3480cb00:	e793000a 	ldr	r0, [r3, sl]
3480cb04:	ebfffc9d 	bl	3480bd80 <insert_var_value_sub>
					export_me=1;
				}
#endif
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
3480cb08:	e3a01000 	mov	r1, #0
3480cb0c:	e58d0008 	str	r0, [sp, #8]
3480cb10:	ebfffc2c 	bl	3480bbc8 <set_local_var>
				if (p != child->argv[i]) free(p);
3480cb14:	e5972000 	ldr	r2, [r7]
3480cb18:	e59d3008 	ldr	r3, [sp, #8]
3480cb1c:	e792200a 	ldr	r2, [r2, sl]
3480cb20:	e1530002 	cmp	r3, r2
3480cb24:	0a000001 	beq	3480cb30 <run_list_real+0x50c>
3480cb28:	e1a00003 	mov	r0, r3
3480cb2c:	ebfff55f 	bl	3480a0b0 <free>
3480cb30:	e28aa004 	add	sl, sl, #4
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
			/* assignments, but no command: set the local environment */
			for (i=0; child->argv[i]!=NULL; i++) {
3480cb34:	e5973000 	ldr	r3, [r7]
3480cb38:	e793000a 	ldr	r0, [r3, sl]
3480cb3c:	e3500000 	cmp	r0, #0
3480cb40:	1affffe2 	bne	3480cad0 <run_list_real+0x4ac>
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
3480cb44:	e1a0a000 	mov	sl, r0
3480cb48:	ea000080 	b	3480cd50 <run_list_real+0x72c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480cb4c:	e1a00003 	mov	r0, r3
3480cb50:	e3a01000 	mov	r1, #0
3480cb54:	ebfffc89 	bl	3480bd80 <insert_var_value_sub>
		for (i = 0; is_assignment(child->argv[i]); i++) {
			p = insert_var_value(child->argv[i]);
#ifndef __U_BOOT__
			putenv(strdup(p));
#else
			set_local_var(p, 0);
3480cb58:	e3a01000 	mov	r1, #0
3480cb5c:	e58d0008 	str	r0, [sp, #8]
3480cb60:	ebfffc18 	bl	3480bbc8 <set_local_var>
#endif
			if (p != child->argv[i]) {
3480cb64:	e5972000 	ldr	r2, [r7]
3480cb68:	e59d3008 	ldr	r3, [sp, #8]
3480cb6c:	e792200a 	ldr	r2, [r2, sl]
3480cb70:	e1530002 	cmp	r3, r2
3480cb74:	0a000004 	beq	3480cb8c <run_list_real+0x568>
				child->sp--;
3480cb78:	e597200c 	ldr	r2, [r7, #12]
				free(p);
3480cb7c:	e1a00003 	mov	r0, r3
			putenv(strdup(p));
#else
			set_local_var(p, 0);
#endif
			if (p != child->argv[i]) {
				child->sp--;
3480cb80:	e2422001 	sub	r2, r2, #1
3480cb84:	e587200c 	str	r2, [r7, #12]
				free(p);
3480cb88:	ebfff548 	bl	3480a0b0 <free>
3480cb8c:	e28aa004 	add	sl, sl, #4
3480cb90:	ea000000 	b	3480cb98 <run_list_real+0x574>
		rcode = run_list_real(child->group);
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
3480cb94:	e1a0a000 	mov	sl, r0
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
		}
		for (i = 0; is_assignment(child->argv[i]); i++) {
3480cb98:	e5973000 	ldr	r3, [r7]
3480cb9c:	e083200a 	add	r2, r3, sl
3480cba0:	e793300a 	ldr	r3, [r3, sl]
3480cba4:	e58d200c 	str	r2, [sp, #12]
3480cba8:	e1a00003 	mov	r0, r3
3480cbac:	e58d3008 	str	r3, [sp, #8]
3480cbb0:	ebfffa88 	bl	3480b5d8 <is_assignment>
3480cbb4:	e2502000 	subs	r2, r0, #0
3480cbb8:	e59d3008 	ldr	r3, [sp, #8]
3480cbbc:	1affffe2 	bne	3480cb4c <run_list_real+0x528>
			if (p != child->argv[i]) {
				child->sp--;
				free(p);
			}
		}
		if (child->sp) {
3480cbc0:	e597100c 	ldr	r1, [r7, #12]
3480cbc4:	e3510000 	cmp	r1, #0
3480cbc8:	0a000046 	beq	3480cce8 <run_list_real+0x6c4>
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
3480cbcc:	e59f0224 	ldr	r0, [pc, #548]	; 3480cdf8 <run_list_real+0x7d4>
3480cbd0:	e58d2008 	str	r2, [sp, #8]
3480cbd4:	ebfffbd7 	bl	3480bb38 <get_local_var>
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480cbd8:	e3500000 	cmp	r0, #0
3480cbdc:	e59d2008 	ldr	r2, [sp, #8]
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480cbe0:	058d0010 	streq	r0, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480cbe4:	0a000006 	beq	3480cc04 <run_list_real+0x5e0>
3480cbe8:	e5d03000 	ldrb	r3, [r0]
3480cbec:	e3530030 	cmp	r3, #48	; 0x30
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480cbf0:	058d2010 	streq	r2, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480cbf4:	0a000002 	beq	3480cc04 <run_list_real+0x5e0>
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480cbf8:	e2533000 	subs	r3, r3, #0
3480cbfc:	13a03001 	movne	r3, #1
3480cc00:	e58d3010 	str	r3, [sp, #16]
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480cc04:	e3a03002 	mov	r3, #2
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480cc08:	e3a0a000 	mov	sl, #0
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480cc0c:	e58d3024 	str	r3, [sp, #36]	; 0x24

/* Make new string for parser */
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
3480cc10:	e1a0700a 	mov	r7, sl
3480cc14:	e58d6030 	str	r6, [sp, #48]	; 0x30
3480cc18:	ea00001c 	b	3480cc90 <run_list_real+0x66c>

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
3480cc1c:	e1a00003 	mov	r0, r3
3480cc20:	e59d1010 	ldr	r1, [sp, #16]
3480cc24:	ebfffc55 	bl	3480bd80 <insert_var_value_sub>
3480cc28:	e1a06000 	mov	r6, r0
		str = xrealloc(str, (len + strlen(p)));
3480cc2c:	eb003e92 	bl	3481c67c <strlen>
3480cc30:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3480cc34:	e0801002 	add	r1, r0, r2
3480cc38:	e1a00007 	mov	r0, r7
3480cc3c:	ebfffb62 	bl	3480b9cc <xrealloc>
		if (n) {
3480cc40:	e35a0000 	cmp	sl, #0
	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
3480cc44:	e1a07000 	mov	r7, r0
		if (n) {
			strcat(str, " ");
		} else {
			*str = '\0';
3480cc48:	05c0a000 	strbeq	sl, [r0]
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
		if (n) {
3480cc4c:	0a000001 	beq	3480cc58 <run_list_real+0x634>
			strcat(str, " ");
3480cc50:	e59f11a4 	ldr	r1, [pc, #420]	; 3480cdfc <run_list_real+0x7d8>
3480cc54:	eb003e34 	bl	3481c52c <strcat>
		} else {
			*str = '\0';
		}
		strcat(str, p);
3480cc58:	e1a01006 	mov	r1, r6
3480cc5c:	e1a00007 	mov	r0, r7
3480cc60:	eb003e31 	bl	3481c52c <strcat>
		len = strlen(str) + 3;
3480cc64:	e1a00007 	mov	r0, r7
3480cc68:	eb003e83 	bl	3481c67c <strlen>
3480cc6c:	e2800003 	add	r0, r0, #3
3480cc70:	e58d0024 	str	r0, [sp, #36]	; 0x24
		if (p != inp[n]) free(p);
3480cc74:	e59d000c 	ldr	r0, [sp, #12]
3480cc78:	e5103004 	ldr	r3, [r0, #-4]
3480cc7c:	e1560003 	cmp	r6, r3
3480cc80:	0a000001 	beq	3480cc8c <run_list_real+0x668>
3480cc84:	e1a00006 	mov	r0, r6
3480cc88:	ebfff508 	bl	3480a0b0 <free>
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480cc8c:	e28aa001 	add	sl, sl, #1
3480cc90:	e59d100c 	ldr	r1, [sp, #12]
3480cc94:	e4913004 	ldr	r3, [r1], #4
3480cc98:	e3530000 	cmp	r3, #0
3480cc9c:	e58d100c 	str	r1, [sp, #12]
3480cca0:	1affffdd 	bne	3480cc1c <run_list_real+0x5f8>
		}
		strcat(str, p);
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
3480cca4:	e1a00007 	mov	r0, r7
3480cca8:	e58d3008 	str	r3, [sp, #8]
3480ccac:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3480ccb0:	eb003e71 	bl	3481c67c <strlen>
	*(str + len) = '\n';
3480ccb4:	e1a02007 	mov	r2, r7
3480ccb8:	e3a0100a 	mov	r1, #10
3480ccbc:	e7e21000 	strb	r1, [r2, r0]!
	*(str + len + 1) = '\0';
3480ccc0:	e59d3008 	ldr	r3, [sp, #8]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480ccc4:	e3a01005 	mov	r1, #5
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
	*(str + len) = '\n';
	*(str + len + 1) = '\0';
3480ccc8:	e5c23001 	strb	r3, [r2, #1]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480cccc:	e1a00007 	mov	r0, r7
3480ccd0:	ebfffe17 	bl	3480c534 <parse_string_outer>
			free(str);
3480ccd4:	e1a00007 	mov	r0, r7
3480ccd8:	ebfff4f4 	bl	3480a0b0 <free>
			return last_return_code;
3480ccdc:	e59f210c 	ldr	r2, [pc, #268]	; 3480cdf0 <run_list_real+0x7cc>
3480cce0:	e592a134 	ldr	sl, [r2, #308]	; 0x134
3480cce4:	ea000011 	b	3480cd30 <run_list_real+0x70c>
		}
#else
		/* check ";", because ,example , argv consist from
		 * "help;flinfo" must not execute
		 */
		if (strchr(child->argv[i], ';')) {
3480cce8:	e1a00003 	mov	r0, r3
3480ccec:	e3a0103b 	mov	r1, #59	; 0x3b
3480ccf0:	eb003e4b 	bl	3481c624 <strchr>
3480ccf4:	e3500000 	cmp	r0, #0
3480ccf8:	0a000004 	beq	3480cd10 <run_list_real+0x6ec>
			printf("Unknown command '%s' - try 'help' or use "
3480ccfc:	e5973000 	ldr	r3, [r7]
3480cd00:	e59f00f8 	ldr	r0, [pc, #248]	; 3480ce00 <run_list_real+0x7dc>
3480cd04:	e793100a 	ldr	r1, [r3, sl]
3480cd08:	ebfff3aa 	bl	34809bb8 <printf>
3480cd0c:	ea000035 	b	3480cde8 <run_list_real+0x7c4>
					"'run' command\n", child->argv[i]);
			return -1;
		}
		/* Process the command */
		return cmd_process(flag, child->argc, child->argv,
3480cd10:	e59d3010 	ldr	r3, [sp, #16]
3480cd14:	e5971004 	ldr	r1, [r7, #4]
3480cd18:	e2530000 	subs	r0, r3, #0
3480cd1c:	13a00001 	movne	r0, #1
3480cd20:	e5972000 	ldr	r2, [r7]
3480cd24:	e59f30d8 	ldr	r3, [pc, #216]	; 3480ce04 <run_list_real+0x7e0>
3480cd28:	ebfff2d8 	bl	34809890 <cmd_process>
3480cd2c:	e1a0a000 	mov	sl, r0
			}
			debug_printf("checkjobs returned %d\n",rcode);
		}
		last_return_code=rcode;
#else
		if (rcode < -1) {
3480cd30:	e37a0001 	cmn	sl, #1
3480cd34:	aa000005 	bge	3480cd50 <run_list_real+0x72c>
			last_return_code = -rcode - 2;
3480cd38:	e3e03001 	mvn	r3, #1
3480cd3c:	e59f20ac 	ldr	r2, [pc, #172]	; 3480cdf0 <run_list_real+0x7cc>
3480cd40:	e06a3003 	rsb	r3, sl, r3
3480cd44:	e5823134 	str	r3, [r2, #308]	; 0x134
			return -2;	/* exit */
3480cd48:	e3e0a001 	mvn	sl, #1
3480cd4c:	ea000022 	b	3480cddc <run_list_real+0x7b8>
		last_return_code=(rcode == 0) ? 0 : 1;
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480cd50:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480cd54:	e25a3000 	subs	r3, sl, #0
3480cd58:	13a03001 	movne	r3, #1
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480cd5c:	e3550001 	cmp	r5, #1
3480cd60:	03822001 	orreq	r2, r2, #1
3480cd64:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480cd68:	e3520000 	cmp	r2, #0
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480cd6c:	e59f007c 	ldr	r0, [pc, #124]	; 3480cdf0 <run_list_real+0x7cc>
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480cd70:	11a0100a 	movne	r1, sl
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480cd74:	e3550007 	cmp	r5, #7
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480cd78:	e5803134 	str	r3, [r0, #308]	; 0x134
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480cd7c:	e58d1028 	str	r1, [sp, #40]	; 0x28
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
			flag_rep = !last_return_code;
3480cd80:	0223b001 	eoreq	fp, r3, #1
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480cd84:	0a000001 	beq	3480cd90 <run_list_real+0x76c>
			flag_rep = !last_return_code;
		if (rmode == RES_UNTIL)
			flag_rep = last_return_code;
3480cd88:	e3550008 	cmp	r5, #8
3480cd8c:	01a0b003 	moveq	fp, r3
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480cd90:	e35a0000 	cmp	sl, #0
3480cd94:	e594300c 	ldr	r3, [r4, #12]
3480cd98:	1a000001 	bne	3480cda4 <run_list_real+0x780>
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480cd9c:	e3530003 	cmp	r3, #3
3480cda0:	ea000000 	b	3480cda8 <run_list_real+0x784>
3480cda4:	e3530002 	cmp	r3, #2
3480cda8:	01a03005 	moveq	r3, r5
3480cdac:	13a0300b 	movne	r3, #11
3480cdb0:	ea000000 	b	3480cdb8 <run_list_real+0x794>
3480cdb4:	e3a0300b 	mov	r3, #11
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480cdb8:	e3a07001 	mov	r7, #1
				flag_repeat = 0;
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
3480cdbc:	e59d2014 	ldr	r2, [sp, #20]
3480cdc0:	e3520000 	cmp	r2, #0
3480cdc4:	05944008 	ldreq	r4, [r4, #8]
3480cdc8:	11a04009 	movne	r4, r9
3480cdcc:	e3540000 	cmp	r4, #0
3480cdd0:	1afffe4b 	bne	3480c704 <run_list_real+0xe0>
3480cdd4:	ea000000 	b	3480cddc <run_list_real+0x7b8>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
3480cdd8:	e3a0a001 	mov	sl, #1
#ifndef __U_BOOT__
		checkjobs(NULL);
#endif
	}
	return rcode;
}
3480cddc:	e1a0000a 	mov	r0, sl
3480cde0:	e28dd038 	add	sp, sp, #56	; 0x38
3480cde4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		/* If there isn't another process, nextin is garbage
		   but it doesn't matter */
		nextin = pipefds[0];
	}
#endif
	return -1;
3480cde8:	e3e0a000 	mvn	sl, #0
3480cdec:	eaffffd7 	b	3480cd50 <run_list_real+0x72c>
3480cdf0:	3482a06c 	.word	0x3482a06c
3480cdf4:	34823c2a 	.word	0x34823c2a
3480cdf8:	348264e9 	.word	0x348264e9
3480cdfc:	348266f2 	.word	0x348266f2
3480ce00:	348264f6 	.word	0x348264f6
3480ce04:	3482a070 	.word	0x3482a070

3480ce08 <parse_stream_outer>:
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480ce08:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480ce0c:	e24dd038 	sub	sp, sp, #56	; 0x38

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480ce10:	e28d5024 	add	r5, sp, #36	; 0x24
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480ce14:	e58d1004 	str	r1, [sp, #4]
3480ce18:	e1a04000 	mov	r4, r0

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480ce1c:	e3a01000 	mov	r1, #0
3480ce20:	e1a00005 	mov	r0, r5
3480ce24:	e3a02014 	mov	r2, #20
3480ce28:	eb003eb3 	bl	3481c8fc <memset>
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
3480ce2c:	e3a07000 	mov	r7, #0
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
3480ce30:	e28d6008 	add	r6, sp, #8
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480ce34:	e59d2004 	ldr	r2, [sp, #4]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480ce38:	e3a0a000 	mov	sl, #0
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480ce3c:	e58d2020 	str	r2, [sp, #32]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480ce40:	e58da010 	str	sl, [sp, #16]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480ce44:	e58da008 	str	sl, [sp, #8]
	ctx->list_head=new_pipe();
3480ce48:	ebfffca7 	bl	3480c0ec <new_pipe>
3480ce4c:	e58d000c 	str	r0, [sp, #12]
	ctx->pipe=ctx->list_head;
3480ce50:	e58d0010 	str	r0, [sp, #16]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
#ifdef __U_BOOT__
	ctx->old_flag=0;
#endif
	done_command(ctx);   /* creates the memory for working child */
3480ce54:	e1a00006 	mov	r0, r6
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480ce58:	e58da014 	str	sl, [sp, #20]
	ctx->stack=NULL;
3480ce5c:	e58da01c 	str	sl, [sp, #28]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480ce60:	e58da018 	str	sl, [sp, #24]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480ce64:	ebfffae0 	bl	3480b9ec <done_command>
	int code = 0;
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
		update_ifs_map();
3480ce68:	ebfffd8e 	bl	3480c4a8 <update_ifs_map>
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
3480ce6c:	e59d2004 	ldr	r2, [sp, #4]
3480ce70:	e2023006 	and	r3, r2, #6
3480ce74:	e3530002 	cmp	r3, #2
3480ce78:	0a000002 	beq	3480ce88 <parse_stream_outer+0x80>
3480ce7c:	e59f05e0 	ldr	r0, [pc, #1504]	; 3480d464 <parse_stream_outer+0x65c>
3480ce80:	e1a0100a 	mov	r1, sl
3480ce84:	ebfffd7e 	bl	3480c484 <mapset>
		inp->promptmode=1;
3480ce88:	e3a03001 	mov	r3, #1
3480ce8c:	e5843008 	str	r3, [r4, #8]
3480ce90:	ea00010a 	b	3480d2c0 <parse_stream_outer+0x4b8>
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
		m = map[ch];
3480ce94:	e59f25cc 	ldr	r2, [pc, #1484]	; 3480d468 <parse_stream_outer+0x660>
3480ce98:	e082300a 	add	r3, r2, sl
3480ce9c:	e5d3b138 	ldrb	fp, [r3, #312]	; 0x138
#ifdef __U_BOOT__
		if (input->__promptme == 0) return 1;
3480cea0:	e5943004 	ldr	r3, [r4, #4]
3480cea4:	e3530000 	cmp	r3, #0
3480cea8:	0a00010b 	beq	3480d2dc <parse_stream_outer+0x4d4>
#endif
		next = (ch == '\n') ? 0 : b_peek(input);
3480ceac:	e35a000a 	cmp	sl, #10
3480ceb0:	03a09000 	moveq	r9, #0
3480ceb4:	0a000003 	beq	3480cec8 <parse_stream_outer+0xc0>
3480ceb8:	e5943010 	ldr	r3, [r4, #16]
3480cebc:	e1a00004 	mov	r0, r4
3480cec0:	e12fff33 	blx	r3
3480cec4:	e1a09000 	mov	r9, r0

		debug_printf("parse_stream: ch=%c (%d) m=%d quote=%d - %c\n",
			ch >= ' ' ? ch : '.', ch, m,
			dest->quote, ctx->stack == NULL ? '*' : '.');

		if (m==0 || ((m==1 || m==2) && dest->quote)) {
3480cec8:	e35b0000 	cmp	fp, #0
3480cecc:	0a000005 	beq	3480cee8 <parse_stream_outer+0xe0>
3480ced0:	e24b3001 	sub	r3, fp, #1
3480ced4:	e3530001 	cmp	r3, #1
3480ced8:	8a000012 	bhi	3480cf28 <parse_stream_outer+0x120>
3480cedc:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480cee0:	e3530000 	cmp	r3, #0
3480cee4:	0a000002 	beq	3480cef4 <parse_stream_outer+0xec>
			b_addqchr(dest, ch, dest->quote);
3480cee8:	e1a00005 	mov	r0, r5
3480ceec:	e1a0100a 	mov	r1, sl
3480cef0:	ea000042 	b	3480d000 <parse_stream_outer+0x1f8>
		} else {
			if (m==2) {  /* unquoted IFS */
3480cef4:	e35b0002 	cmp	fp, #2
3480cef8:	1a00000a 	bne	3480cf28 <parse_stream_outer+0x120>
				if (done_word(dest, ctx)) {
3480cefc:	e1a00005 	mov	r0, r5
3480cf00:	e1a01006 	mov	r1, r6
3480cf04:	ebfffd00 	bl	3480c30c <done_word>
3480cf08:	e3500000 	cmp	r0, #0
3480cf0c:	1a0000f2 	bne	3480d2dc <parse_stream_outer+0x4d4>
					return 1;
				}
				/* If we aren't performing a substitution, treat a newline as a
				 * command separator.  */
				if (end_trigger != '\0' && ch=='\n')
3480cf10:	e35a000a 	cmp	sl, #10
3480cf14:	1a0000e9 	bne	3480d2c0 <parse_stream_outer+0x4b8>
					done_pipe(ctx,PIPE_SEQ);
3480cf18:	e1a00006 	mov	r0, r6
3480cf1c:	e3a01001 	mov	r1, #1
3480cf20:	ebfffc7b 	bl	3480c114 <done_pipe>
3480cf24:	ea000001 	b	3480cf30 <parse_stream_outer+0x128>
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
3480cf28:	e35a000a 	cmp	sl, #10
3480cf2c:	1a000005 	bne	3480cf48 <parse_stream_outer+0x140>
3480cf30:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480cf34:	e3530000 	cmp	r3, #0
3480cf38:	1a000002 	bne	3480cf48 <parse_stream_outer+0x140>
3480cf3c:	e59d3014 	ldr	r3, [sp, #20]
3480cf40:	e3530000 	cmp	r3, #0
3480cf44:	0a000141 	beq	3480d450 <parse_stream_outer+0x648>
				done_pipe(ctx,PIPE_SEQ);
				run_list(ctx->list_head);
				initialize_context(ctx);
			}
#endif
			if (m!=2) switch (ch) {
3480cf48:	e35b0002 	cmp	fp, #2
3480cf4c:	0a0000db 	beq	3480d2c0 <parse_stream_outer+0x4b8>
3480cf50:	e35a0026 	cmp	sl, #38	; 0x26
3480cf54:	0a0000af 	beq	3480d218 <parse_stream_outer+0x410>
3480cf58:	8a00000a 	bhi	3480cf88 <parse_stream_outer+0x180>
3480cf5c:	e35a0022 	cmp	sl, #34	; 0x22
3480cf60:	0a00009f 	beq	3480d1e4 <parse_stream_outer+0x3dc>
3480cf64:	8a000002 	bhi	3480cf74 <parse_stream_outer+0x16c>
3480cf68:	e35a0004 	cmp	sl, #4
3480cf6c:	1a0000d1 	bne	3480d2b8 <parse_stream_outer+0x4b0>
3480cf70:	ea0000bf 	b	3480d274 <parse_stream_outer+0x46c>
3480cf74:	e35a0023 	cmp	sl, #35	; 0x23
3480cf78:	0a00000d 	beq	3480cfb4 <parse_stream_outer+0x1ac>
3480cf7c:	e35a0024 	cmp	sl, #36	; 0x24
3480cf80:	1a0000cc 	bne	3480d2b8 <parse_stream_outer+0x4b0>
3480cf84:	ea00002c 	b	3480d03c <parse_stream_outer+0x234>
3480cf88:	e35a003b 	cmp	sl, #59	; 0x3b
3480cf8c:	0a00009b 	beq	3480d200 <parse_stream_outer+0x3f8>
3480cf90:	8a000002 	bhi	3480cfa0 <parse_stream_outer+0x198>
3480cf94:	e35a0027 	cmp	sl, #39	; 0x27
3480cf98:	1a0000c6 	bne	3480d2b8 <parse_stream_outer+0x4b0>
3480cf9c:	ea000080 	b	3480d1a4 <parse_stream_outer+0x39c>
3480cfa0:	e35a005c 	cmp	sl, #92	; 0x5c
3480cfa4:	0a000018 	beq	3480d00c <parse_stream_outer+0x204>
3480cfa8:	e35a007c 	cmp	sl, #124	; 0x7c
3480cfac:	1a0000c1 	bne	3480d2b8 <parse_stream_outer+0x4b0>
3480cfb0:	ea0000a3 	b	3480d244 <parse_stream_outer+0x43c>
		case '#':
			if (dest->length == 0 && !dest->quote) {
3480cfb4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3480cfb8:	e3530000 	cmp	r3, #0
3480cfbc:	1a00000d 	bne	3480cff8 <parse_stream_outer+0x1f0>
3480cfc0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480cfc4:	e3530000 	cmp	r3, #0
3480cfc8:	0a000003 	beq	3480cfdc <parse_stream_outer+0x1d4>
3480cfcc:	ea000009 	b	3480cff8 <parse_stream_outer+0x1f0>
				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
3480cfd0:	e594300c 	ldr	r3, [r4, #12]
3480cfd4:	e1a00004 	mov	r0, r4
3480cfd8:	e12fff33 	blx	r3
3480cfdc:	e5943010 	ldr	r3, [r4, #16]
3480cfe0:	e1a00004 	mov	r0, r4
3480cfe4:	e12fff33 	blx	r3
3480cfe8:	e350000a 	cmp	r0, #10
3480cfec:	13700001 	cmnne	r0, #1
3480cff0:	1afffff6 	bne	3480cfd0 <parse_stream_outer+0x1c8>
3480cff4:	ea0000b1 	b	3480d2c0 <parse_stream_outer+0x4b8>
			} else {
				b_addqchr(dest, ch, dest->quote);
3480cff8:	e1a00005 	mov	r0, r5
3480cffc:	e3a01023 	mov	r1, #35	; 0x23
3480d000:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480d004:	ebfffab8 	bl	3480baec <b_addqchr>
3480d008:	ea0000ac 	b	3480d2c0 <parse_stream_outer+0x4b8>
			}
			break;
		case '\\':
			if (next == EOF) {
3480d00c:	e3790001 	cmn	r9, #1
3480d010:	0a0000a8 	beq	3480d2b8 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addqchr(dest, '\\', dest->quote);
3480d014:	e1a0100a 	mov	r1, sl
3480d018:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480d01c:	e1a00005 	mov	r0, r5
3480d020:	ebfffab1 	bl	3480baec <b_addqchr>
			b_addqchr(dest, b_getch(input), dest->quote);
3480d024:	e594300c 	ldr	r3, [r4, #12]
3480d028:	e1a00004 	mov	r0, r4
3480d02c:	e12fff33 	blx	r3
3480d030:	e1a01000 	mov	r1, r0
3480d034:	e1a00005 	mov	r0, r5
3480d038:	eafffff0 	b	3480d000 <parse_stream_outer+0x1f8>
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480d03c:	e5943010 	ldr	r3, [r4, #16]
3480d040:	e1a00004 	mov	r0, r4
3480d044:	e12fff33 	blx	r3
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480d048:	e59f241c 	ldr	r2, [pc, #1052]	; 3480d46c <parse_stream_outer+0x664>
3480d04c:	e6ef3070 	uxtb	r3, r0
3480d050:	e7d23003 	ldrb	r3, [r2, r3]
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480d054:	e1a09000 	mov	r9, r0
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480d058:	e3130003 	tst	r3, #3
3480d05c:	0a00001b 	beq	3480d0d0 <parse_stream_outer+0x2c8>
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480d060:	e1a00005 	mov	r0, r5
3480d064:	e3a01003 	mov	r1, #3
3480d068:	ebfffa81 	bl	3480ba74 <b_addchr>
		ctx->child->sp++;
3480d06c:	e59d3008 	ldr	r3, [sp, #8]
3480d070:	e593200c 	ldr	r2, [r3, #12]
3480d074:	e2822001 	add	r2, r2, #1
3480d078:	e583200c 	str	r2, [r3, #12]
3480d07c:	ea000005 	b	3480d098 <parse_stream_outer+0x290>
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
			b_getch(input);
3480d080:	e594300c 	ldr	r3, [r4, #12]
3480d084:	e1a00004 	mov	r0, r4
3480d088:	e12fff33 	blx	r3
			b_addchr(dest,ch);
3480d08c:	e1a00005 	mov	r0, r5
3480d090:	e1a0100a 	mov	r1, sl
3480d094:	ebfffa76 	bl	3480ba74 <b_addchr>
	int ch = input->peek(input);  /* first character after the $ */
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
		ctx->child->sp++;
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
3480d098:	e5943010 	ldr	r3, [r4, #16]
3480d09c:	e1a00004 	mov	r0, r4
3480d0a0:	e12fff33 	blx	r3
3480d0a4:	e59f23c0 	ldr	r2, [pc, #960]	; 3480d46c <parse_stream_outer+0x664>
3480d0a8:	e6ef3070 	uxtb	r3, r0
3480d0ac:	e7d23003 	ldrb	r3, [r2, r3]
3480d0b0:	e1a0a000 	mov	sl, r0
3480d0b4:	e2133007 	ands	r3, r3, #7
3480d0b8:	13a03001 	movne	r3, #1
3480d0bc:	e350005f 	cmp	r0, #95	; 0x5f
3480d0c0:	03833001 	orreq	r3, r3, #1
3480d0c4:	e3530000 	cmp	r3, #0
3480d0c8:	1affffec 	bne	3480d080 <parse_stream_outer+0x278>
3480d0cc:	ea000030 	b	3480d194 <parse_stream_outer+0x38c>
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480d0d0:	e350003f 	cmp	r0, #63	; 0x3f
3480d0d4:	0a000004 	beq	3480d0ec <parse_stream_outer+0x2e4>
3480d0d8:	e350007b 	cmp	r0, #123	; 0x7b
			error_msg("unhandled syntax: $%c",ch);
			return 1;
			break;
#endif
		default:
			b_addqchr(dest,'$',dest->quote);
3480d0dc:	11a00005 	movne	r0, r5
3480d0e0:	13a01024 	movne	r1, #36	; 0x24
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480d0e4:	1affffc5 	bne	3480d000 <parse_stream_outer+0x1f8>
3480d0e8:	ea000013 	b	3480d13c <parse_stream_outer+0x334>
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480d0ec:	e59d3008 	ldr	r3, [sp, #8]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480d0f0:	e1a00005 	mov	r0, r5
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480d0f4:	e593200c 	ldr	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480d0f8:	e3a01003 	mov	r1, #3
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480d0fc:	e2822001 	add	r2, r2, #1
3480d100:	e583200c 	str	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480d104:	ebfffa5a 	bl	3480ba74 <b_addchr>
			b_addchr(dest, '$');
3480d108:	e1a0100a 	mov	r1, sl
3480d10c:	e1a00005 	mov	r0, r5
3480d110:	ebfffa57 	bl	3480ba74 <b_addchr>
			b_addchr(dest, '?');
3480d114:	e1a01009 	mov	r1, r9
3480d118:	e1a00005 	mov	r0, r5
3480d11c:	ebfffa54 	bl	3480ba74 <b_addchr>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480d120:	e1a00005 	mov	r0, r5
3480d124:	e3a01003 	mov	r1, #3
3480d128:	ebfffa51 	bl	3480ba74 <b_addchr>
	/* Eat the character if the flag was set.  If the compiler
	 * is smart enough, we could substitute "b_getch(input);"
	 * for all the "advance = 1;" above, and also end up with
	 * a nice size-optimized program.  Hah!  That'll be the day.
	 */
	if (advance) b_getch(input);
3480d12c:	e594300c 	ldr	r3, [r4, #12]
3480d130:	e1a00004 	mov	r0, r4
3480d134:	e12fff33 	blx	r3
3480d138:	ea000060 	b	3480d2c0 <parse_stream_outer+0x4b8>
			b_adduint(dest,global_argc ? global_argc-1 : 0);
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480d13c:	e1a00005 	mov	r0, r5
3480d140:	e3a01003 	mov	r1, #3
3480d144:	ebfffa4a 	bl	3480ba74 <b_addchr>
			ctx->child->sp++;
3480d148:	e59d3008 	ldr	r3, [sp, #8]
			b_getch(input);
3480d14c:	e1a00004 	mov	r0, r4
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
3480d150:	e593200c 	ldr	r2, [r3, #12]
3480d154:	e2822001 	add	r2, r2, #1
3480d158:	e583200c 	str	r2, [r3, #12]
			b_getch(input);
3480d15c:	e594300c 	ldr	r3, [r4, #12]
3480d160:	e12fff33 	blx	r3
3480d164:	ea000001 	b	3480d170 <parse_stream_outer+0x368>
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
				b_addchr(dest,ch);
3480d168:	e1a00005 	mov	r0, r5
3480d16c:	ebfffa40 	bl	3480ba74 <b_addchr>
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
			b_getch(input);
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
3480d170:	e594300c 	ldr	r3, [r4, #12]
3480d174:	e1a00004 	mov	r0, r4
3480d178:	e12fff33 	blx	r3
3480d17c:	e350007d 	cmp	r0, #125	; 0x7d
3480d180:	13700001 	cmnne	r0, #1
3480d184:	e1a01000 	mov	r1, r0
3480d188:	1afffff6 	bne	3480d168 <parse_stream_outer+0x360>
				b_addchr(dest,ch);
			}
			if (ch != '}') {
3480d18c:	e350007d 	cmp	r0, #125	; 0x7d
3480d190:	1a000048 	bne	3480d2b8 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480d194:	e1a00005 	mov	r0, r5
3480d198:	e3a01003 	mov	r1, #3
3480d19c:	ebfffa34 	bl	3480ba74 <b_addchr>
3480d1a0:	ea000046 	b	3480d2c0 <parse_stream_outer+0x4b8>
			break;
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
3480d1a4:	e3a03001 	mov	r3, #1
3480d1a8:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d1ac:	ea000004 	b	3480d1c4 <parse_stream_outer+0x3bc>
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
#ifdef __U_BOOT__
				if(input->__promptme == 0) return 1;
3480d1b0:	e5943004 	ldr	r3, [r4, #4]
3480d1b4:	e3530000 	cmp	r3, #0
3480d1b8:	0a000047 	beq	3480d2dc <parse_stream_outer+0x4d4>
#endif
				b_addchr(dest,ch);
3480d1bc:	e1a00005 	mov	r0, r5
3480d1c0:	ebfffa2b 	bl	3480ba74 <b_addchr>
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
3480d1c4:	e594300c 	ldr	r3, [r4, #12]
3480d1c8:	e1a00004 	mov	r0, r4
3480d1cc:	e12fff33 	blx	r3
3480d1d0:	e3500027 	cmp	r0, #39	; 0x27
3480d1d4:	13700001 	cmnne	r0, #1
3480d1d8:	e1a01000 	mov	r1, r0
3480d1dc:	1afffff3 	bne	3480d1b0 <parse_stream_outer+0x3a8>
3480d1e0:	ea000032 	b	3480d2b0 <parse_stream_outer+0x4a8>
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
			dest->quote = !dest->quote;
3480d1e4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480d1e8:	e3a02001 	mov	r2, #1
			dest->quote = !dest->quote;
3480d1ec:	e2733001 	rsbs	r3, r3, #1
3480d1f0:	33a03000 	movcc	r3, #0
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480d1f4:	e58d2034 	str	r2, [sp, #52]	; 0x34
			dest->quote = !dest->quote;
3480d1f8:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d1fc:	ea00002f 	b	3480d2c0 <parse_stream_outer+0x4b8>
			}
			setup_redirect(ctx, redir_fd, redir_style, input);
			break;
#endif
		case ';':
			done_word(dest, ctx);
3480d200:	e1a01006 	mov	r1, r6
3480d204:	e1a00005 	mov	r0, r5
3480d208:	ebfffc3f 	bl	3480c30c <done_word>
			done_pipe(ctx,PIPE_SEQ);
3480d20c:	e1a00006 	mov	r0, r6
3480d210:	e3a01001 	mov	r1, #1
3480d214:	ea000014 	b	3480d26c <parse_stream_outer+0x464>
			break;
		case '&':
			done_word(dest, ctx);
3480d218:	e1a00005 	mov	r0, r5
3480d21c:	e1a01006 	mov	r1, r6
3480d220:	ebfffc39 	bl	3480c30c <done_word>
			if (next=='&') {
3480d224:	e3590026 	cmp	r9, #38	; 0x26
3480d228:	1a000022 	bne	3480d2b8 <parse_stream_outer+0x4b0>
				b_getch(input);
3480d22c:	e594300c 	ldr	r3, [r4, #12]
3480d230:	e1a00004 	mov	r0, r4
3480d234:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_AND);
3480d238:	e1a00006 	mov	r0, r6
3480d23c:	e3a01002 	mov	r1, #2
3480d240:	ea000009 	b	3480d26c <parse_stream_outer+0x464>
				return 1;
#endif
			}
			break;
		case '|':
			done_word(dest, ctx);
3480d244:	e1a00005 	mov	r0, r5
3480d248:	e1a01006 	mov	r1, r6
3480d24c:	ebfffc2e 	bl	3480c30c <done_word>
			if (next=='|') {
3480d250:	e359007c 	cmp	r9, #124	; 0x7c
3480d254:	1a000017 	bne	3480d2b8 <parse_stream_outer+0x4b0>
				b_getch(input);
3480d258:	e594300c 	ldr	r3, [r4, #12]
3480d25c:	e1a00004 	mov	r0, r4
3480d260:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_OR);
3480d264:	e1a00006 	mov	r0, r6
3480d268:	e3a01003 	mov	r1, #3
3480d26c:	ebfffba8 	bl	3480c114 <done_pipe>
3480d270:	ea000012 	b	3480d2c0 <parse_stream_outer+0x4b8>
			syntax();   /* Proper use of this character caught by end_trigger */
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
3480d274:	e3a03001 	mov	r3, #1
3480d278:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d27c:	ea000004 	b	3480d294 <parse_stream_outer+0x48c>
			while (ch = b_getch(input), ch != EOF &&
			    ch != SUBSTED_VAR_SYMBOL) {
				debug_printf("subst, pass=%d\n", ch);
				if (input->__promptme == 0)
3480d280:	e5943004 	ldr	r3, [r4, #4]
3480d284:	e3530000 	cmp	r3, #0
3480d288:	0a000013 	beq	3480d2dc <parse_stream_outer+0x4d4>
					return 1;
				b_addchr(dest, ch);
3480d28c:	e1a00005 	mov	r0, r5
3480d290:	ebfff9f7 	bl	3480ba74 <b_addchr>
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
			while (ch = b_getch(input), ch != EOF &&
3480d294:	e594300c 	ldr	r3, [r4, #12]
3480d298:	e1a00004 	mov	r0, r4
3480d29c:	e12fff33 	blx	r3
3480d2a0:	e3500004 	cmp	r0, #4
3480d2a4:	13700001 	cmnne	r0, #1
3480d2a8:	e1a01000 	mov	r1, r0
3480d2ac:	1afffff3 	bne	3480d280 <parse_stream_outer+0x478>
				if (input->__promptme == 0)
					return 1;
				b_addchr(dest, ch);
			}
			debug_printf("subst, term=%d\n", ch);
			if (ch == EOF) {
3480d2b0:	e3710001 	cmn	r1, #1
3480d2b4:	1a000001 	bne	3480d2c0 <parse_stream_outer+0x4b8>
				syntax();
				return 1;
			}
			break;
		default:
			syntax();   /* this is really an internal logic error */
3480d2b8:	ebfff8db 	bl	3480b62c <syntax_err>
3480d2bc:	ea000006 	b	3480d2dc <parse_stream_outer+0x4d4>
	/* Only double-quote state is handled in the state variable dest->quote.
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
3480d2c0:	e594300c 	ldr	r3, [r4, #12]
3480d2c4:	e1a00004 	mov	r0, r4
3480d2c8:	e12fff33 	blx	r3
3480d2cc:	e3700001 	cmn	r0, #1
3480d2d0:	e1a0a000 	mov	sl, r0
3480d2d4:	1afffeee 	bne	3480ce94 <parse_stream_outer+0x8c>
3480d2d8:	ea00005d 	b	3480d454 <parse_stream_outer+0x64c>
		update_ifs_map();
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
3480d2dc:	e59f2184 	ldr	r2, [pc, #388]	; 3480d468 <parse_stream_outer+0x660>
3480d2e0:	e3a03000 	mov	r3, #0
3480d2e4:	e5823004 	str	r3, [r2, #4]
3480d2e8:	e3a0a001 	mov	sl, #1
3480d2ec:	ea000028 	b	3480d394 <parse_stream_outer+0x58c>
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
			syntax();
3480d2f0:	ebfff8cd 	bl	3480b62c <syntax_err>
#ifdef __U_BOOT__
			flag_repeat = 0;
3480d2f4:	e59f216c 	ldr	r2, [pc, #364]	; 3480d468 <parse_stream_outer+0x660>
3480d2f8:	e3a03000 	mov	r3, #0
3480d2fc:	e5823004 	str	r3, [r2, #4]
3480d300:	ea00004e 	b	3480d440 <parse_stream_outer+0x638>
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
			done_word(&temp, &ctx);
3480d304:	e1a01006 	mov	r1, r6
3480d308:	e1a00005 	mov	r0, r5
3480d30c:	ebfffbfe 	bl	3480c30c <done_word>
			done_pipe(&ctx,PIPE_SEQ);
3480d310:	e3a01001 	mov	r1, #1
3480d314:	e1a00006 	mov	r0, r6
3480d318:	ebfffb7d 	bl	3480c114 <done_pipe>
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
3480d31c:	e59db00c 	ldr	fp, [sp, #12]
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480d320:	e1a0000b 	mov	r0, fp
3480d324:	ebfffcbe 	bl	3480c624 <run_list_real>
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480d328:	e1a01009 	mov	r1, r9
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480d32c:	e1a07000 	mov	r7, r0
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480d330:	e1a0000b 	mov	r0, fp
3480d334:	ebfff96d 	bl	3480b8f0 <free_pipe_list>
			done_pipe(&ctx,PIPE_SEQ);
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
3480d338:	e3770002 	cmn	r7, #2
3480d33c:	1a000010 	bne	3480d384 <parse_stream_outer+0x57c>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d340:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d344:	e58d9028 	str	r9, [sp, #40]	; 0x28
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d348:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480d34c:	e58d9034 	str	r9, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480d350:	15c39000 	strbne	r9, [r3]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480d354:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480d358:	ebfff354 	bl	3480a0b0 <free>
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480d35c:	e5943010 	ldr	r3, [r4, #16]
3480d360:	e59f2108 	ldr	r2, [pc, #264]	; 3480d470 <parse_stream_outer+0x668>

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480d364:	e3a07000 	mov	r7, #0
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480d368:	e1530002 	cmp	r3, r2

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480d36c:	e58d7024 	str	r7, [sp, #36]	; 0x24
	o->maxlen = 0;
3480d370:	e58d702c 	str	r7, [sp, #44]	; 0x2c
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480d374:	1a00002d 	bne	3480d430 <parse_stream_outer+0x628>
					printf("exit not allowed from main input shell.\n");
3480d378:	e59f00f4 	ldr	r0, [pc, #244]	; 3480d474 <parse_stream_outer+0x66c>
3480d37c:	ebfff20d 	bl	34809bb8 <printf>
					continue;
3480d380:	ea000025 	b	3480d41c <parse_stream_outer+0x614>
				}
				break;
			}
			if (code == -1)
3480d384:	e3770001 	cmn	r7, #1
			    flag_repeat = 0;
3480d388:	059f30d8 	ldreq	r3, [pc, #216]	; 3480d468 <parse_stream_outer+0x660>
3480d38c:	05839004 	streq	r9, [r3, #4]
3480d390:	ea000016 	b	3480d3f0 <parse_stream_outer+0x5e8>
#endif
		} else {
			if (ctx.old_flag != 0) {
3480d394:	e59d3018 	ldr	r3, [sp, #24]
3480d398:	e3530000 	cmp	r3, #0
3480d39c:	0a000007 	beq	3480d3c0 <parse_stream_outer+0x5b8>
				free(ctx.stack);
3480d3a0:	e59d001c 	ldr	r0, [sp, #28]
3480d3a4:	ebfff341 	bl	3480a0b0 <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d3a8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d3ac:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d3b0:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d3b4:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480d3b8:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480d3bc:	15c23000 	strbne	r3, [r2]
			if (ctx.old_flag != 0) {
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
3480d3c0:	e5943004 	ldr	r3, [r4, #4]
3480d3c4:	e3530000 	cmp	r3, #0
3480d3c8:	1a000001 	bne	3480d3d4 <parse_stream_outer+0x5cc>
3480d3cc:	e59f00a4 	ldr	r0, [pc, #164]	; 3480d478 <parse_stream_outer+0x670>
3480d3d0:	ebfff1f8 	bl	34809bb8 <printf>
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480d3d4:	e3a01000 	mov	r1, #0
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
3480d3d8:	e3a03001 	mov	r3, #1
3480d3dc:	e884000a 	stm	r4, {r1, r3}
#endif
			temp.nonnull = 0;
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480d3e0:	e59d000c 	ldr	r0, [sp, #12]
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480d3e4:	e58d1034 	str	r1, [sp, #52]	; 0x34
			temp.quote = 0;
3480d3e8:	e58d1030 	str	r1, [sp, #48]	; 0x30
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480d3ec:	ebfff93f 	bl	3480b8f0 <free_pipe_list>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d3f0:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d3f4:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480d3f8:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480d3fc:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480d400:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480d404:	15c23000 	strbne	r3, [r2]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480d408:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480d40c:	ebfff327 	bl	3480a0b0 <free>
	o->data = NULL;
3480d410:	e3a03000 	mov	r3, #0
3480d414:	e58d3024 	str	r3, [sp, #36]	; 0x24
	o->maxlen = 0;
3480d418:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
		}
		b_free(&temp);
	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP));   /* loop on syntax errors, return on EOF */
3480d41c:	e37a0001 	cmn	sl, #1
3480d420:	0a000002 	beq	3480d430 <parse_stream_outer+0x628>
3480d424:	e59d2004 	ldr	r2, [sp, #4]
3480d428:	e3120001 	tst	r2, #1
3480d42c:	0afffe80 	beq	3480ce34 <parse_stream_outer+0x2c>
#ifndef __U_BOOT__
	return 0;
#else
	return (code != 0) ? 1 : 0;
#endif /* __U_BOOT__ */
}
3480d430:	e2570000 	subs	r0, r7, #0
3480d434:	13a00001 	movne	r0, #1
3480d438:	e28dd038 	add	sp, sp, #56	; 0x38
3480d43c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			syntax();
#ifdef __U_BOOT__
			flag_repeat = 0;
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
3480d440:	e59d9018 	ldr	r9, [sp, #24]
3480d444:	e3590000 	cmp	r9, #0
3480d448:	1affffd1 	bne	3480d394 <parse_stream_outer+0x58c>
3480d44c:	eaffffac 	b	3480d304 <parse_stream_outer+0x4fc>
				if (end_trigger != '\0' && ch=='\n')
					done_pipe(ctx,PIPE_SEQ);
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
				debug_printf("leaving parse_stream (triggered)\n");
				return 0;
3480d450:	e1a0a003 	mov	sl, r3
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
3480d454:	e59d3018 	ldr	r3, [sp, #24]
3480d458:	e3530000 	cmp	r3, #0
3480d45c:	0afffff7 	beq	3480d440 <parse_stream_outer+0x638>
3480d460:	eaffffa2 	b	3480d2f0 <parse_stream_outer+0x4e8>
3480d464:	3482652e 	.word	0x3482652e
3480d468:	3482a06c 	.word	0x3482a06c
3480d46c:	34821fe0 	.word	0x34821fe0
3480d470:	3480b5cc 	.word	0x3480b5cc
3480d474:	34826533 	.word	0x34826533
3480d478:	3482655c 	.word	0x3482655c

3480d47c <parse_file_outer>:
#ifndef __U_BOOT__
static int parse_file_outer(FILE *f)
#else
int parse_file_outer(void)
#endif
{
3480d47c:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480d480:	e59f3030 	ldr	r3, [pc, #48]	; 3480d4b8 <parse_file_outer+0x3c>
	i->__promptme=1;
	i->promptmode=1;
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480d484:	e28d0018 	add	r0, sp, #24
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480d488:	e58d3014 	str	r3, [sp, #20]
	i->get = file_get;
3480d48c:	e59f3028 	ldr	r3, [pc, #40]	; 3480d4bc <parse_file_outer+0x40>
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480d490:	e3a01002 	mov	r1, #2
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
	i->get = file_get;
3480d494:	e58d3010 	str	r3, [sp, #16]
	i->__promptme=1;
3480d498:	e3a03001 	mov	r3, #1
3480d49c:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480d4a0:	e58d300c 	str	r3, [sp, #12]
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480d4a4:	e3a03000 	mov	r3, #0
3480d4a8:	e5203014 	str	r3, [r0, #-20]!
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480d4ac:	ebfffe55 	bl	3480ce08 <parse_stream_outer>
	return rcode;
}
3480d4b0:	e28dd01c 	add	sp, sp, #28
3480d4b4:	e8bd8000 	pop	{pc}
3480d4b8:	3480b5cc 	.word	0x3480b5cc
3480d4bc:	3480b748 	.word	0x3480b748

3480d4c0 <u_boot_hush_start>:
	}
}
#endif

int u_boot_hush_start(void)
{
3480d4c0:	e92d4038 	push	{r3, r4, r5, lr}
	if (top_vars == NULL) {
3480d4c4:	e59f503c 	ldr	r5, [pc, #60]	; 3480d508 <u_boot_hush_start+0x48>
3480d4c8:	e5954000 	ldr	r4, [r5]
3480d4cc:	e3540000 	cmp	r4, #0
3480d4d0:	1a00000a 	bne	3480d500 <u_boot_hush_start+0x40>
		top_vars = malloc(sizeof(struct variables));
3480d4d4:	e3a00014 	mov	r0, #20
3480d4d8:	ebfff37d 	bl	3480a2d4 <malloc>
		top_vars->name = "HUSH_VERSION";
3480d4dc:	e59f3028 	ldr	r3, [pc, #40]	; 3480d50c <u_boot_hush_start+0x4c>
#endif

int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
3480d4e0:	e5850000 	str	r0, [r5]
		top_vars->name = "HUSH_VERSION";
3480d4e4:	e5803000 	str	r3, [r0]
		top_vars->value = "0.01";
3480d4e8:	e59f3020 	ldr	r3, [pc, #32]	; 3480d510 <u_boot_hush_start+0x50>
		top_vars->next = 0;
3480d4ec:	e5804010 	str	r4, [r0, #16]
int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
3480d4f0:	e5803004 	str	r3, [r0, #4]
		top_vars->next = 0;
		top_vars->flg_export = 0;
		top_vars->flg_read_only = 1;
3480d4f4:	e3a03001 	mov	r3, #1
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
		top_vars->next = 0;
		top_vars->flg_export = 0;
3480d4f8:	e5804008 	str	r4, [r0, #8]
		top_vars->flg_read_only = 1;
3480d4fc:	e580300c 	str	r3, [r0, #12]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		u_boot_hush_reloc();
#endif
	}
	return 0;
}
3480d500:	e3a00000 	mov	r0, #0
3480d504:	e8bd8038 	pop	{r3, r4, r5, pc}
3480d508:	3482a06c 	.word	0x3482a06c
3480d50c:	34826569 	.word	0x34826569
3480d510:	34826576 	.word	0x34826576

3480d514 <__fswab32>:
3480d514:	e6bf0f30 	rev	r0, r0
3480d518:	e12fff1e 	bx	lr

3480d51c <image_check_magic.clone.8>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
3480d51c:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
3480d520:	ebfffffb 	bl	3480d514 <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
3480d524:	e59f300c 	ldr	r3, [pc, #12]	; 3480d538 <image_check_magic.clone.8+0x1c>
3480d528:	e1500003 	cmp	r0, r3
3480d52c:	13a00000 	movne	r0, #0
3480d530:	03a00001 	moveq	r0, #1
3480d534:	e8bd8008 	pop	{r3, pc}
3480d538:	27051956 	.word	0x27051956

3480d53c <image_get_data_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
3480d53c:	eafffff4 	b	3480d514 <__fswab32>

3480d540 <image_check_hcrc>:

/*****************************************************************************/
/* Legacy format routines */
/*****************************************************************************/
int image_check_hcrc(const image_header_t *hdr)
{
3480d540:	e92d4030 	push	{r4, r5, lr}
3480d544:	e1a04000 	mov	r4, r0
3480d548:	e24dd044 	sub	sp, sp, #68	; 0x44
	ulong hcrc;
	ulong len = image_get_header_size();
	image_header_t header;

	/* Copy header so we can blank CRC field for re-calculation */
	memmove(&header, (char *)hdr, image_get_header_size());
3480d54c:	e1a01004 	mov	r1, r4
3480d550:	e1a0000d 	mov	r0, sp
3480d554:	e3a02040 	mov	r2, #64	; 0x40
3480d558:	eb003d28 	bl	3481ca00 <memmove>
	image_set_hcrc(&header, 0);

	hcrc = crc32(0, (unsigned char *)&header, len);
3480d55c:	e1a0100d 	mov	r1, sp
3480d560:	e3a02040 	mov	r2, #64	; 0x40
	static inline void image_set_##f(image_header_t *hdr, uint32_t val) \
	{ \
		hdr->ih_##f = cpu_to_uimage(val); \
	}
image_set_hdr_l(magic)		/* image_set_magic */
image_set_hdr_l(hcrc)		/* image_set_hcrc */
3480d564:	e3a00000 	mov	r0, #0
3480d568:	e58d0004 	str	r0, [sp, #4]
3480d56c:	eb003584 	bl	3481ab84 <crc32>
3480d570:	e1a05000 	mov	r5, r0
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
3480d574:	e5940004 	ldr	r0, [r4, #4]
3480d578:	ebffffe5 	bl	3480d514 <__fswab32>

	return (hcrc == image_get_hcrc(hdr));
}
3480d57c:	e1550000 	cmp	r5, r0
3480d580:	13a00000 	movne	r0, #0
3480d584:	03a00001 	moveq	r0, #1
3480d588:	e28dd044 	add	sp, sp, #68	; 0x44
3480d58c:	e8bd8030 	pop	{r4, r5, pc}

3480d590 <image_check_dcrc>:

int image_check_dcrc(const image_header_t *hdr)
{
3480d590:	e92d4038 	push	{r3, r4, r5, lr}
3480d594:	e1a04000 	mov	r4, r0
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480d598:	e590000c 	ldr	r0, [r0, #12]
3480d59c:	ebffffe6 	bl	3480d53c <image_get_data_size.clone.10>
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480d5a0:	e2841040 	add	r1, r4, #64	; 0x40
}

int image_check_dcrc(const image_header_t *hdr)
{
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480d5a4:	e1a02000 	mov	r2, r0
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480d5a8:	e3a03801 	mov	r3, #65536	; 0x10000
3480d5ac:	e3a00000 	mov	r0, #0
3480d5b0:	eb003578 	bl	3481ab98 <crc32_wd>
3480d5b4:	e1a05000 	mov	r5, r0
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
image_get_hdr_l(ep)		/* image_get_ep */
image_get_hdr_l(dcrc)		/* image_get_dcrc */
3480d5b8:	e5940018 	ldr	r0, [r4, #24]
3480d5bc:	ebffffd4 	bl	3480d514 <__fswab32>

	return (dcrc == image_get_dcrc(hdr));
}
3480d5c0:	e1550000 	cmp	r5, r0
3480d5c4:	13a00000 	movne	r0, #0
3480d5c8:	03a00001 	moveq	r0, #1
3480d5cc:	e8bd8038 	pop	{r3, r4, r5, pc}

3480d5d0 <image_multi_count>:
	/* get start of the image payload, which in case of multi
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* count non empty slots */
	for (i = 0; size[i]; ++i)
3480d5d0:	e280303c 	add	r3, r0, #60	; 0x3c
3480d5d4:	e3a00000 	mov	r0, #0
3480d5d8:	ea000000 	b	3480d5e0 <image_multi_count+0x10>
3480d5dc:	e2800001 	add	r0, r0, #1
3480d5e0:	e5b32004 	ldr	r2, [r3, #4]!
3480d5e4:	e3520000 	cmp	r2, #0
3480d5e8:	1afffffb 	bne	3480d5dc <image_multi_count+0xc>
		count++;

	return count;
}
3480d5ec:	e12fff1e 	bx	lr

3480d5f0 <image_multi_getimg>:
 *     data address and size of the component, if idx is valid
 *     0 in data and len, if idx is out of range
 */
void image_multi_getimg(const image_header_t *hdr, ulong idx,
			ulong *data, ulong *len)
{
3480d5f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480d5f4:	e1a0a003 	mov	sl, r3
3480d5f8:	e1a05001 	mov	r5, r1
3480d5fc:	e1a06002 	mov	r6, r2
3480d600:	e1a04000 	mov	r4, r0
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480d604:	ebfffff1 	bl	3480d5d0 <image_multi_count>

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480d608:	e1550000 	cmp	r5, r0
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
3480d60c:	23a03000 	movcs	r3, #0
3480d610:	258a3000 	strcs	r3, [sl]
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480d614:	e1a0b000 	mov	fp, r0

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
		*data = 0;
3480d618:	25863000 	strcs	r3, [r6]

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480d61c:	28bd8ef0 	popcs	{r4, r5, r6, r7, r9, sl, fp, pc}
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480d620:	e2849040 	add	r9, r4, #64	; 0x40
		*len = uimage_to_cpu(size[idx]);
3480d624:	e7990105 	ldr	r0, [r9, r5, lsl #2]
3480d628:	ebffffb9 	bl	3480d514 <__fswab32>
		offset = 0;
3480d62c:	e3a07000 	mov	r7, #0
	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
3480d630:	e58a0000 	str	r0, [sl]
3480d634:	e284403c 	add	r4, r4, #60	; 0x3c
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480d638:	e1a0a007 	mov	sl, r7
3480d63c:	ea000005 	b	3480d658 <image_multi_getimg+0x68>
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
3480d640:	e5b40004 	ldr	r0, [r4, #4]!
3480d644:	ebffffb2 	bl	3480d514 <__fswab32>
3480d648:	e2800003 	add	r0, r0, #3
3480d64c:	e3c00003 	bic	r0, r0, #3
3480d650:	e0877000 	add	r7, r7, r0
	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480d654:	e28aa001 	add	sl, sl, #1
3480d658:	e15a0005 	cmp	sl, r5
3480d65c:	1afffff7 	bne	3480d640 <image_multi_getimg+0x50>
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);
3480d660:	e28bb001 	add	fp, fp, #1
3480d664:	e089910b 	add	r9, r9, fp, lsl #2
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
3480d668:	e0897007 	add	r7, r9, r7
3480d66c:	e5867000 	str	r7, [r6]
3480d670:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480d674 <getenv_yesno>:
/*****************************************************************************/
/* Shared dual-format routines */
/*****************************************************************************/
#ifndef USE_HOSTCC
int getenv_yesno(char *var)
{
3480d674:	e92d4008 	push	{r3, lr}
	char *s = getenv(var);
3480d678:	ebffea60 	bl	34808000 <getenv>
	return (s && (*s == 'n')) ? 0 : 1;
3480d67c:	e3500000 	cmp	r0, #0
3480d680:	0a000003 	beq	3480d694 <getenv_yesno+0x20>
3480d684:	e5d00000 	ldrb	r0, [r0]
3480d688:	e250006e 	subs	r0, r0, #110	; 0x6e
3480d68c:	13a00001 	movne	r0, #1
3480d690:	e8bd8008 	pop	{r3, pc}
3480d694:	e3a00001 	mov	r0, #1
}
3480d698:	e8bd8008 	pop	{r3, pc}

3480d69c <getenv_bootm_low>:

ulong getenv_bootm_low(void)
{
3480d69c:	e92d4010 	push	{r4, lr}
	char *s = getenv("bootm_low");
3480d6a0:	e59f0020 	ldr	r0, [pc, #32]	; 3480d6c8 <getenv_bootm_low+0x2c>
3480d6a4:	ebffea55 	bl	34808000 <getenv>
	if (s) {
3480d6a8:	e3500000 	cmp	r0, #0
3480d6ac:	0a000003 	beq	3480d6c0 <getenv_bootm_low+0x24>
		ulong tmp = simple_strtoul(s, NULL, 16);
3480d6b0:	e3a01000 	mov	r1, #0
3480d6b4:	e3a02010 	mov	r2, #16
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480d6b8:	e8bd4010 	pop	{r4, lr}

ulong getenv_bootm_low(void)
{
	char *s = getenv("bootm_low");
	if (s) {
		ulong tmp = simple_strtoul(s, NULL, 16);
3480d6bc:	ea003f81 	b	3481d4c8 <simple_strtoul>
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480d6c0:	e3a00202 	mov	r0, #536870912	; 0x20000000
3480d6c4:	e8bd8010 	pop	{r4, pc}
3480d6c8:	3482663c 	.word	0x3482663c

3480d6cc <getenv_bootm_size>:

phys_size_t getenv_bootm_size(void)
{
3480d6cc:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_size");
3480d6d0:	e59f0048 	ldr	r0, [pc, #72]	; 3480d720 <getenv_bootm_size+0x54>
3480d6d4:	ebffea49 	bl	34808000 <getenv>
	if (s) {
3480d6d8:	e2504000 	subs	r4, r0, #0
3480d6dc:	0a000003 	beq	3480d6f0 <getenv_bootm_size+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d6e0:	e3a02010 	mov	r2, #16
3480d6e4:	e3a01000 	mov	r1, #0
3480d6e8:	eb003fe6 	bl	3481d688 <simple_strtoull>
		return tmp;
3480d6ec:	e8bd8010 	pop	{r4, pc}
	}
	s = getenv("bootm_low");
3480d6f0:	e59f002c 	ldr	r0, [pc, #44]	; 3480d724 <getenv_bootm_size+0x58>
3480d6f4:	ebffea41 	bl	34808000 <getenv>
	if (s)
3480d6f8:	e2503000 	subs	r3, r0, #0
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
	else
		tmp = 0;
3480d6fc:	01a00003 	moveq	r0, r3
	if (s) {
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
		return tmp;
	}
	s = getenv("bootm_low");
	if (s)
3480d700:	0a000002 	beq	3480d710 <getenv_bootm_size+0x44>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d704:	e1a01004 	mov	r1, r4
3480d708:	e3a02010 	mov	r2, #16
3480d70c:	eb003fdd 	bl	3481d688 <simple_strtoull>
	else
		tmp = 0;


#if defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].size - tmp;
3480d710:	e5983000 	ldr	r3, [r8]
3480d714:	e593301c 	ldr	r3, [r3, #28]
3480d718:	e0600003 	rsb	r0, r0, r3
#else
	return gd->bd->bi_memsize - tmp;
#endif
}
3480d71c:	e8bd8010 	pop	{r4, pc}
3480d720:	34826646 	.word	0x34826646
3480d724:	3482663c 	.word	0x3482663c

3480d728 <getenv_bootm_mapsize>:

phys_size_t getenv_bootm_mapsize(void)
{
3480d728:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_mapsize");
3480d72c:	e59f0020 	ldr	r0, [pc, #32]	; 3480d754 <getenv_bootm_mapsize+0x2c>
3480d730:	ebffea32 	bl	34808000 <getenv>
	if (s) {
3480d734:	e3500000 	cmp	r0, #0
3480d738:	0a000003 	beq	3480d74c <getenv_bootm_mapsize+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480d73c:	e3a02010 	mov	r2, #16
3480d740:	e3a01000 	mov	r1, #0
3480d744:	eb003fcf 	bl	3481d688 <simple_strtoull>
#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
#endif
}
3480d748:	e8bd8010 	pop	{r4, pc}
3480d74c:	e8bd4010 	pop	{r4, lr}
	}

#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
3480d750:	eaffffdd 	b	3480d6cc <getenv_bootm_size>
3480d754:	34826651 	.word	0x34826651

3480d758 <memmove_wd>:
#endif
}

void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
{
	if (to == from)
3480d758:	e1510000 	cmp	r1, r0
3480d75c:	012fff1e 	bxeq	lr
		to += tail;
		from += tail;
		len -= tail;
	}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
	memmove(to, from, len);
3480d760:	ea003ca6 	b	3481ca00 <memmove>

3480d764 <genimg_print_size>:
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
}
#endif /* !USE_HOSTCC */

void genimg_print_size(uint32_t size)
{
3480d764:	e92d4010 	push	{r4, lr}
3480d768:	e1a04000 	mov	r4, r0
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
3480d76c:	e1a01004 	mov	r1, r4
3480d770:	e59f0014 	ldr	r0, [pc, #20]	; 3480d78c <genimg_print_size+0x28>
3480d774:	ebfff10f 	bl	34809bb8 <printf>
	print_size(size, "\n");
3480d778:	e59f2010 	ldr	r2, [pc, #16]	; 3480d790 <genimg_print_size+0x2c>
3480d77c:	e1a00004 	mov	r0, r4
3480d780:	e3a01000 	mov	r1, #0
#else
	printf("%d Bytes = %.2f kB = %.2f MB\n",
			size, (double)size / 1.024e3,
			(double)size / 1.048576e6);
#endif
}
3480d784:	e8bd4010 	pop	{r4, lr}

void genimg_print_size(uint32_t size)
{
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
	print_size(size, "\n");
3480d788:	ea003515 	b	3481abe4 <print_size>
3480d78c:	3482665f 	.word	0x3482665f
3480d790:	348264dd 	.word	0x348264dd

3480d794 <get_table_entry_name>:
 * returns:
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
3480d794:	e1a03000 	mov	r3, r0
	for (; table->id >= 0; ++table) {
3480d798:	ea000003 	b	3480d7ac <get_table_entry_name+0x18>
		if (table->id == id)
3480d79c:	e1500002 	cmp	r0, r2
#if defined(USE_HOSTCC) || !defined(CONFIG_NEEDS_MANUAL_RELOC)
			return table->lname;
3480d7a0:	05931008 	ldreq	r1, [r3, #8]
3480d7a4:	0a000003 	beq	3480d7b8 <get_table_entry_name+0x24>
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
	for (; table->id >= 0; ++table) {
3480d7a8:	e283300c 	add	r3, r3, #12
3480d7ac:	e5930000 	ldr	r0, [r3]
3480d7b0:	e3500000 	cmp	r0, #0
3480d7b4:	aafffff8 	bge	3480d79c <get_table_entry_name+0x8>
#else
			return table->lname + gd->reloc_off;
#endif
	}
	return (msg);
}
3480d7b8:	e1a00001 	mov	r0, r1
3480d7bc:	e12fff1e 	bx	lr

3480d7c0 <genimg_get_os_name>:

const char *genimg_get_os_name(uint8_t os)
{
3480d7c0:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_os, "Unknown OS", os));
3480d7c4:	e59f1004 	ldr	r1, [pc, #4]	; 3480d7d0 <genimg_get_os_name+0x10>
3480d7c8:	e59f0004 	ldr	r0, [pc, #4]	; 3480d7d4 <genimg_get_os_name+0x14>
3480d7cc:	eafffff0 	b	3480d794 <get_table_entry_name>
3480d7d0:	3482666b 	.word	0x3482666b
3480d7d4:	348213dc 	.word	0x348213dc

3480d7d8 <genimg_get_arch_name>:
}

const char *genimg_get_arch_name(uint8_t arch)
{
3480d7d8:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_arch, "Unknown Architecture",
3480d7dc:	e59f1004 	ldr	r1, [pc, #4]	; 3480d7e8 <genimg_get_arch_name+0x10>
3480d7e0:	e59f0004 	ldr	r0, [pc, #4]	; 3480d7ec <genimg_get_arch_name+0x14>
3480d7e4:	eaffffea 	b	3480d794 <get_table_entry_name>
3480d7e8:	34826676 	.word	0x34826676
3480d7ec:	34821430 	.word	0x34821430

3480d7f0 <genimg_get_type_name>:
					arch));
}

const char *genimg_get_type_name(uint8_t type)
{
3480d7f0:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_type, "Unknown Image", type));
3480d7f4:	e59f1004 	ldr	r1, [pc, #4]	; 3480d800 <genimg_get_type_name+0x10>
3480d7f8:	e59f0004 	ldr	r0, [pc, #4]	; 3480d804 <genimg_get_type_name+0x14>
3480d7fc:	eaffffe4 	b	3480d794 <get_table_entry_name>
3480d800:	3482668b 	.word	0x3482668b
3480d804:	3482152c 	.word	0x3482152c

3480d808 <genimg_get_comp_name>:
}

const char *genimg_get_comp_name(uint8_t comp)
{
3480d808:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_comp, "Unknown Compression",
3480d80c:	e59f1004 	ldr	r1, [pc, #4]	; 3480d818 <genimg_get_comp_name+0x10>
3480d810:	e59f0004 	ldr	r0, [pc, #4]	; 3480d81c <genimg_get_comp_name+0x14>
3480d814:	eaffffde 	b	3480d794 <get_table_entry_name>
3480d818:	34826699 	.word	0x34826699
3480d81c:	348215f8 	.word	0x348215f8

3480d820 <image_print_contents>:
 *
 * returns:
 *     no returned results
 */
void image_print_contents(const void *ptr)
{
3480d820:	e92d44ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, sl, lr}
3480d824:	e1a04000 	mov	r4, r0
	p = "";
#else
	p = "   ";
#endif

	printf("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name(hdr));
3480d828:	e3a02020 	mov	r2, #32
3480d82c:	e0843002 	add	r3, r4, r2
3480d830:	e59f1138 	ldr	r1, [pc, #312]	; 3480d970 <image_print_contents+0x150>
3480d834:	e59f0138 	ldr	r0, [pc, #312]	; 3480d974 <image_print_contents+0x154>
3480d838:	ebfff0de 	bl	34809bb8 <printf>
#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
3480d83c:	e59f112c 	ldr	r1, [pc, #300]	; 3480d970 <image_print_contents+0x150>
3480d840:	e59f0130 	ldr	r0, [pc, #304]	; 3480d978 <image_print_contents+0x158>
3480d844:	ebfff0db 	bl	34809bb8 <printf>

static void image_print_type(const image_header_t *hdr)
{
	const char *os, *arch, *type, *comp;

	os = genimg_get_os_name(image_get_os(hdr));
3480d848:	e5d4001c 	ldrb	r0, [r4, #28]
3480d84c:	ebffffdb 	bl	3480d7c0 <genimg_get_os_name>
3480d850:	e1a06000 	mov	r6, r0
	arch = genimg_get_arch_name(image_get_arch(hdr));
3480d854:	e5d4001d 	ldrb	r0, [r4, #29]
3480d858:	ebffffde 	bl	3480d7d8 <genimg_get_arch_name>
3480d85c:	e1a07000 	mov	r7, r0
	type = genimg_get_type_name(image_get_type(hdr));
3480d860:	e5d4001e 	ldrb	r0, [r4, #30]
3480d864:	ebffffe1 	bl	3480d7f0 <genimg_get_type_name>
3480d868:	e1a05000 	mov	r5, r0
	comp = genimg_get_comp_name(image_get_comp(hdr));
3480d86c:	e5d4001f 	ldrb	r0, [r4, #31]
3480d870:	ebffffe4 	bl	3480d808 <genimg_get_comp_name>

	printf("%s %s %s (%s)\n", arch, os, type, comp);
3480d874:	e1a03005 	mov	r3, r5
3480d878:	e1a02006 	mov	r2, r6
3480d87c:	e58d0000 	str	r0, [sp]
3480d880:	e1a01007 	mov	r1, r7
3480d884:	e59f00f0 	ldr	r0, [pc, #240]	; 3480d97c <image_print_contents+0x15c>
3480d888:	ebfff0ca 	bl	34809bb8 <printf>
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
3480d88c:	e59f10dc 	ldr	r1, [pc, #220]	; 3480d970 <image_print_contents+0x150>
3480d890:	e59f00e8 	ldr	r0, [pc, #232]	; 3480d980 <image_print_contents+0x160>
3480d894:	ebfff0c7 	bl	34809bb8 <printf>
	genimg_print_size(image_get_data_size(hdr));
3480d898:	e594000c 	ldr	r0, [r4, #12]
3480d89c:	ebffff26 	bl	3480d53c <image_get_data_size.clone.10>
3480d8a0:	ebffffaf 	bl	3480d764 <genimg_print_size>
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
3480d8a4:	e5940010 	ldr	r0, [r4, #16]
3480d8a8:	ebffff19 	bl	3480d514 <__fswab32>
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
3480d8ac:	e59f10bc 	ldr	r1, [pc, #188]	; 3480d970 <image_print_contents+0x150>
3480d8b0:	e1a02000 	mov	r2, r0
3480d8b4:	e59f00c8 	ldr	r0, [pc, #200]	; 3480d984 <image_print_contents+0x164>
3480d8b8:	ebfff0be 	bl	34809bb8 <printf>
image_get_hdr_l(ep)		/* image_get_ep */
3480d8bc:	e5940014 	ldr	r0, [r4, #20]
3480d8c0:	ebffff13 	bl	3480d514 <__fswab32>
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));
3480d8c4:	e59f10a4 	ldr	r1, [pc, #164]	; 3480d970 <image_print_contents+0x150>
3480d8c8:	e1a02000 	mov	r2, r0
3480d8cc:	e59f00b4 	ldr	r0, [pc, #180]	; 3480d988 <image_print_contents+0x168>
3480d8d0:	ebfff0b8 	bl	34809bb8 <printf>

	return 0;

error:
	return -1;
}
3480d8d4:	e5d4301e 	ldrb	r3, [r4, #30]
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
3480d8d8:	e3530004 	cmp	r3, #4
3480d8dc:	0a000001 	beq	3480d8e8 <image_print_contents+0xc8>
3480d8e0:	e3530006 	cmp	r3, #6
3480d8e4:	1a000020 	bne	3480d96c <image_print_contents+0x14c>
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480d8e8:	e1a00004 	mov	r0, r4
3480d8ec:	ebffff37 	bl	3480d5d0 <image_multi_count>

		printf("%sContents:\n", p);
3480d8f0:	e59f1078 	ldr	r1, [pc, #120]	; 3480d970 <image_print_contents+0x150>

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480d8f4:	e1a06000 	mov	r6, r0

		printf("%sContents:\n", p);
3480d8f8:	e59f008c 	ldr	r0, [pc, #140]	; 3480d98c <image_print_contents+0x16c>
3480d8fc:	ebfff0ad 	bl	34809bb8 <printf>
		for (i = 0; i < count; i++) {
3480d900:	e3a05000 	mov	r5, #0
			image_multi_getimg(hdr, i, &data, &len);
3480d904:	e28d700c 	add	r7, sp, #12
3480d908:	e28da008 	add	sl, sp, #8
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480d90c:	ea000014 	b	3480d964 <image_print_contents+0x144>
			image_multi_getimg(hdr, i, &data, &len);
3480d910:	e1a0300a 	mov	r3, sl
3480d914:	e1a00004 	mov	r0, r4
3480d918:	e1a01005 	mov	r1, r5
3480d91c:	e1a02007 	mov	r2, r7
3480d920:	ebffff32 	bl	3480d5f0 <image_multi_getimg>

			printf("%s   Image %d: ", p, i);
3480d924:	e59f1044 	ldr	r1, [pc, #68]	; 3480d970 <image_print_contents+0x150>
3480d928:	e1a02005 	mov	r2, r5
3480d92c:	e59f005c 	ldr	r0, [pc, #92]	; 3480d990 <image_print_contents+0x170>
3480d930:	ebfff0a0 	bl	34809bb8 <printf>
			genimg_print_size(len);
3480d934:	e59d0008 	ldr	r0, [sp, #8]
3480d938:	ebffff89 	bl	3480d764 <genimg_print_size>

			if (image_check_type(hdr, IH_TYPE_SCRIPT) && i > 0) {
3480d93c:	e5d4301e 	ldrb	r3, [r4, #30]
3480d940:	e3530006 	cmp	r3, #6
3480d944:	1a000005 	bne	3480d960 <image_print_contents+0x140>
3480d948:	e3550000 	cmp	r5, #0
3480d94c:	0a000003 	beq	3480d960 <image_print_contents+0x140>
				/*
				 * the user may need to know offsets
				 * if planning to do something with
				 * multiple files
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
3480d950:	e59f003c 	ldr	r0, [pc, #60]	; 3480d994 <image_print_contents+0x174>
3480d954:	e59f1014 	ldr	r1, [pc, #20]	; 3480d970 <image_print_contents+0x150>
3480d958:	e59d200c 	ldr	r2, [sp, #12]
3480d95c:	ebfff095 	bl	34809bb8 <printf>
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480d960:	e2855001 	add	r5, r5, #1
3480d964:	e1550006 	cmp	r5, r6
3480d968:	3affffe8 	bcc	3480d910 <image_print_contents+0xf0>
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
			}
		}
	}
}
3480d96c:	e8bd84ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, sl, pc}
3480d970:	348266f0 	.word	0x348266f0
3480d974:	348266ad 	.word	0x348266ad
3480d978:	348266c3 	.word	0x348266c3
3480d97c:	348266d4 	.word	0x348266d4
3480d980:	348266e3 	.word	0x348266e3
3480d984:	348266f4 	.word	0x348266f4
3480d988:	3482670a 	.word	0x3482670a
3480d98c:	34826720 	.word	0x34826720
3480d990:	3482672d 	.word	0x3482672d
3480d994:	3482673d 	.word	0x3482673d

3480d998 <get_table_entry_id>:
 *     entry id if translation succeeds
 *     -1 otherwise
 */
int get_table_entry_id(const table_entry_t *table,
		const char *table_name, const char *name)
{
3480d998:	e92d4038 	push	{r3, r4, r5, lr}
3480d99c:	e1a05002 	mov	r5, r2
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480d9a0:	e1a04000 	mov	r4, r0
3480d9a4:	ea000009 	b	3480d9d0 <get_table_entry_id+0x38>
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		if (t->sname && strcmp(t->sname + gd->reloc_off, name) == 0)
#else
		if (t->sname && strcmp(t->sname, name) == 0)
3480d9a8:	e5940004 	ldr	r0, [r4, #4]
3480d9ac:	e3500000 	cmp	r0, #0
3480d9b0:	0a000005 	beq	3480d9cc <get_table_entry_id+0x34>
3480d9b4:	e1a01005 	mov	r1, r5
3480d9b8:	eb003afb 	bl	3481c5ac <strcmp>
3480d9bc:	e3500000 	cmp	r0, #0
3480d9c0:	1a000001 	bne	3480d9cc <get_table_entry_id+0x34>
#endif
			return (t->id);
3480d9c4:	e5940000 	ldr	r0, [r4]
3480d9c8:	e8bd8038 	pop	{r3, r4, r5, pc}
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480d9cc:	e284400c 	add	r4, r4, #12
3480d9d0:	e5943000 	ldr	r3, [r4]
3480d9d4:	e3530000 	cmp	r3, #0
3480d9d8:	aafffff2 	bge	3480d9a8 <get_table_entry_id+0x10>
#endif
			return (t->id);
	}
	debug("Invalid %s Type: %s\n", table_name, name);
#endif /* USE_HOSTCC */
	return (-1);
3480d9dc:	e3e00000 	mvn	r0, #0
}
3480d9e0:	e8bd8038 	pop	{r3, r4, r5, pc}

3480d9e4 <genimg_get_os_id>:

int genimg_get_os_id(const char *name)
{
3480d9e4:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_os, "OS", name));
3480d9e8:	e59f1004 	ldr	r1, [pc, #4]	; 3480d9f4 <genimg_get_os_id+0x10>
3480d9ec:	e59f0004 	ldr	r0, [pc, #4]	; 3480d9f8 <genimg_get_os_id+0x14>
3480d9f0:	eaffffe8 	b	3480d998 <get_table_entry_id>
3480d9f4:	34826b6e 	.word	0x34826b6e
3480d9f8:	348213dc 	.word	0x348213dc

3480d9fc <genimg_get_arch_id>:
}

int genimg_get_arch_id(const char *name)
{
3480d9fc:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_arch, "CPU", name));
3480da00:	e59f1004 	ldr	r1, [pc, #4]	; 3480da0c <genimg_get_arch_id+0x10>
3480da04:	e59f0004 	ldr	r0, [pc, #4]	; 3480da10 <genimg_get_arch_id+0x14>
3480da08:	eaffffe2 	b	3480d998 <get_table_entry_id>
3480da0c:	34823079 	.word	0x34823079
3480da10:	34821430 	.word	0x34821430

3480da14 <genimg_get_type_id>:
}

int genimg_get_type_id(const char *name)
{
3480da14:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_type, "Image", name));
3480da18:	e59f1004 	ldr	r1, [pc, #4]	; 3480da24 <genimg_get_type_id+0x10>
3480da1c:	e59f0004 	ldr	r0, [pc, #4]	; 3480da28 <genimg_get_type_id+0x14>
3480da20:	eaffffdc 	b	3480d998 <get_table_entry_id>
3480da24:	348269b1 	.word	0x348269b1
3480da28:	3482152c 	.word	0x3482152c

3480da2c <genimg_get_comp_id>:
}

int genimg_get_comp_id(const char *name)
{
3480da2c:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_comp, "Compression", name));
3480da30:	e59f1004 	ldr	r1, [pc, #4]	; 3480da3c <genimg_get_comp_id+0x10>
3480da34:	e59f0004 	ldr	r0, [pc, #4]	; 3480da40 <genimg_get_comp_id+0x14>
3480da38:	eaffffd6 	b	3480d998 <get_table_entry_id>
3480da3c:	348266a1 	.word	0x348266a1
3480da40:	348215f8 	.word	0x348215f8

3480da44 <genimg_get_format>:
 *
 * returns:
 *     image format type or IMAGE_FORMAT_INVALID if no image is present
 */
int genimg_get_format(void *img_addr)
{
3480da44:	e92d4008 	push	{r3, lr}
#if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
	char *fit_hdr;
#endif

	hdr = (const image_header_t *)img_addr;
	if (image_check_magic(hdr))
3480da48:	e5900000 	ldr	r0, [r0]
3480da4c:	ebfffeb2 	bl	3480d51c <image_check_magic.clone.8>
			format = IMAGE_FORMAT_FIT;
	}
#endif

	return format;
}
3480da50:	e2500000 	subs	r0, r0, #0
3480da54:	13a00001 	movne	r0, #1
3480da58:	e8bd8008 	pop	{r3, pc}

3480da5c <genimg_get_image>:

	}
#endif /* CONFIG_HAS_DATAFLASH */

	return ram_addr;
}
3480da5c:	e12fff1e 	bx	lr

3480da60 <genimg_has_config>:
#if defined(CONFIG_FIT)
	if (images->fit_uname_cfg)
		return 1;
#endif
	return 0;
}
3480da60:	e3a00000 	mov	r0, #0
3480da64:	e12fff1e 	bx	lr

3480da68 <boot_get_ramdisk>:
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480da68:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3480da6c:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
3480da70:	e59d502c 	ldr	r5, [sp, #44]	; 0x2c
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480da74:	e3a09000 	mov	r9, #0

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480da78:	e3500002 	cmp	r0, #2
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480da7c:	e5879000 	str	r9, [r7]
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480da80:	e1a06001 	mov	r6, r1
3480da84:	e1a04002 	mov	r4, r2
3480da88:	e1a0a003 	mov	sl, r3
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
	*rd_end = 0;
3480da8c:	e5859000 	str	r9, [r5]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480da90:	da000006 	ble	3480dab0 <boot_get_ramdisk+0x48>
3480da94:	e5910008 	ldr	r0, [r1, #8]
3480da98:	e59f11d0 	ldr	r1, [pc, #464]	; 3480dc70 <boot_get_ramdisk+0x208>
3480da9c:	eb003ac2 	bl	3481c5ac <strcmp>
3480daa0:	e3500000 	cmp	r0, #0
		debug("## Skipping init Ramdisk\n");
		rd_len = rd_data = 0;
3480daa4:	058d0004 	streq	r0, [sp, #4]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480daa8:	0a000044 	beq	3480dbc0 <boot_get_ramdisk+0x158>
3480daac:	ea000065 	b	3480dc48 <boot_get_ramdisk+0x1e0>
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480dab0:	e5923044 	ldr	r3, [r2, #68]	; 0x44
3480dab4:	e3530000 	cmp	r3, #0
3480dab8:	1a000046 	bne	3480dbd8 <boot_get_ramdisk+0x170>
3480dabc:	ea000053 	b	3480dc10 <boot_get_ramdisk+0x1a8>
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
3480dac0:	e1a01006 	mov	r1, r6
3480dac4:	e59f01a8 	ldr	r0, [pc, #424]	; 3480dc74 <boot_get_ramdisk+0x20c>
3480dac8:	ebfff03a 	bl	34809bb8 <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480dacc:	e3a00009 	mov	r0, #9
3480dad0:	eb00012c 	bl	3480df88 <__show_boot_progress>
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480dad4:	e5960000 	ldr	r0, [r6]
3480dad8:	ebfffe8f 	bl	3480d51c <image_check_magic.clone.8>
3480dadc:	e3500000 	cmp	r0, #0
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
					"Image at %08lx ...\n", rd_addr);

			bootstage_mark(BOOTSTAGE_ID_CHECK_RAMDISK);
			rd_hdr = image_get_ramdisk(rd_addr, arch,
3480dae0:	e5944084 	ldr	r4, [r4, #132]	; 0x84
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480dae4:	1a000003 	bne	3480daf8 <boot_get_ramdisk+0x90>
		puts("Bad Magic Number\n");
3480dae8:	e59f0188 	ldr	r0, [pc, #392]	; 3480dc78 <boot_get_ramdisk+0x210>
3480daec:	ebfff027 	bl	34809b90 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480daf0:	e3e00009 	mvn	r0, #9
3480daf4:	ea000006 	b	3480db14 <boot_get_ramdisk+0xac>
		bootstage_error(BOOTSTAGE_ID_RD_MAGIC);
		return NULL;
	}

	if (!image_check_hcrc(rd_hdr)) {
3480daf8:	e1a00006 	mov	r0, r6
3480dafc:	ebfffe8f 	bl	3480d540 <image_check_hcrc>
3480db00:	e3500000 	cmp	r0, #0
3480db04:	1a000004 	bne	3480db1c <boot_get_ramdisk+0xb4>
		puts("Bad Header Checksum\n");
3480db08:	e59f016c 	ldr	r0, [pc, #364]	; 3480dc7c <boot_get_ramdisk+0x214>
3480db0c:	ebfff01f 	bl	34809b90 <puts>
3480db10:	e3e0000a 	mvn	r0, #10
3480db14:	eb00011b 	bl	3480df88 <__show_boot_progress>
3480db18:	ea000048 	b	3480dc40 <boot_get_ramdisk+0x1d8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480db1c:	e3a0000a 	mov	r0, #10
3480db20:	eb000118 	bl	3480df88 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_RD_HDR_CHECKSUM);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_RD_MAGIC);
	image_print_contents(rd_hdr);
3480db24:	e1a00006 	mov	r0, r6
3480db28:	ebffff3c 	bl	3480d820 <image_print_contents>

	if (verify) {
3480db2c:	e3540000 	cmp	r4, #0
3480db30:	0a00000b 	beq	3480db64 <boot_get_ramdisk+0xfc>
		puts("   Verifying Checksum ... ");
3480db34:	e59f0144 	ldr	r0, [pc, #324]	; 3480dc80 <boot_get_ramdisk+0x218>
3480db38:	ebfff014 	bl	34809b90 <puts>
		if (!image_check_dcrc(rd_hdr)) {
3480db3c:	e1a00006 	mov	r0, r6
3480db40:	ebfffe92 	bl	3480d590 <image_check_dcrc>
3480db44:	e3500000 	cmp	r0, #0
3480db48:	1a000003 	bne	3480db5c <boot_get_ramdisk+0xf4>
			puts("Bad Data CRC\n");
3480db4c:	e59f0130 	ldr	r0, [pc, #304]	; 3480dc84 <boot_get_ramdisk+0x21c>
3480db50:	ebfff00e 	bl	34809b90 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480db54:	e3e0000b 	mvn	r0, #11
3480db58:	eaffffed 	b	3480db14 <boot_get_ramdisk+0xac>
			bootstage_error(BOOTSTAGE_ID_RD_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
3480db5c:	e59f0124 	ldr	r0, [pc, #292]	; 3480dc88 <boot_get_ramdisk+0x220>
3480db60:	ebfff00a 	bl	34809b90 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480db64:	e3a0000b 	mov	r0, #11
3480db68:	eb000106 	bl	3480df88 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_RD_HDR_CHECKSUM);

	if (!image_check_os(rd_hdr, IH_OS_LINUX) ||
3480db6c:	e5d6301c 	ldrb	r3, [r6, #28]
3480db70:	e3530005 	cmp	r3, #5
3480db74:	1a000005 	bne	3480db90 <boot_get_ramdisk+0x128>
3480db78:	e5d6301d 	ldrb	r3, [r6, #29]
3480db7c:	e153000a 	cmp	r3, sl
3480db80:	1a000002 	bne	3480db90 <boot_get_ramdisk+0x128>
	    !image_check_arch(rd_hdr, arch) ||
3480db84:	e5d6301e 	ldrb	r3, [r6, #30]
3480db88:	e3530003 	cmp	r3, #3
3480db8c:	0a000007 	beq	3480dbb0 <boot_get_ramdisk+0x148>
	    !image_check_type(rd_hdr, IH_TYPE_RAMDISK)) {
		printf("No Linux %s Ramdisk Image\n",
3480db90:	e1a0000a 	mov	r0, sl
3480db94:	ebffff0f 	bl	3480d7d8 <genimg_get_arch_name>
3480db98:	e1a01000 	mov	r1, r0
3480db9c:	e59f00e8 	ldr	r0, [pc, #232]	; 3480dc8c <boot_get_ramdisk+0x224>
3480dba0:	ebfff004 	bl	34809bb8 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480dba4:	e3e0000c 	mvn	r0, #12
3480dba8:	eb0000f6 	bl	3480df88 <__show_boot_progress>
3480dbac:	ea000007 	b	3480dbd0 <boot_get_ramdisk+0x168>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480dbb0:	e2863040 	add	r3, r6, #64	; 0x40

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
			rd_len = image_get_data_size(rd_hdr);
3480dbb4:	e596000c 	ldr	r0, [r6, #12]
							images->verify);

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
3480dbb8:	e58d3004 	str	r3, [sp, #4]
			rd_len = image_get_data_size(rd_hdr);
3480dbbc:	ebfffe5e 	bl	3480d53c <image_get_data_size.clone.10>
3480dbc0:	e58d0000 	str	r0, [sp]
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480dbc4:	ea000016 	b	3480dc24 <boot_get_ramdisk+0x1bc>
				rd_len = simple_strtoul(++end, NULL, 16);
				rd_data = rd_addr;
			} else
#endif
			{
				puts("Wrong Ramdisk Image Format\n");
3480dbc8:	e59f00c0 	ldr	r0, [pc, #192]	; 3480dc90 <boot_get_ramdisk+0x228>
3480dbcc:	ebffefef 	bl	34809b90 <puts>
				rd_data = rd_len = rd_load = 0;
				return 1;
3480dbd0:	e3a09001 	mov	r9, #1
3480dbd4:	ea000019 	b	3480dc40 <boot_get_ramdisk+0x1d8>
			}
		}
	} else if (images->legacy_hdr_valid &&
3480dbd8:	e5d23022 	ldrb	r3, [r2, #34]	; 0x22
3480dbdc:	e3530004 	cmp	r3, #4
3480dbe0:	1a00000a 	bne	3480dc10 <boot_get_ramdisk+0x1a8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480dbe4:	e3a0000d 	mov	r0, #13
3480dbe8:	eb0000e6 	bl	3480df88 <__show_boot_progress>
		/*
		 * Now check if we have a legacy mult-component image,
		 * get second entry data start address and len.
		 */
		bootstage_mark(BOOTSTAGE_ID_RAMDISK);
		printf("## Loading init Ramdisk from multi component "
3480dbec:	e5941000 	ldr	r1, [r4]
3480dbf0:	e59f009c 	ldr	r0, [pc, #156]	; 3480dc94 <boot_get_ramdisk+0x22c>
3480dbf4:	ebffefef 	bl	34809bb8 <printf>
				"Legacy Image at %08lx ...\n",
				(ulong)images->legacy_hdr_os);

		image_multi_getimg(images->legacy_hdr_os, 1, &rd_data, &rd_len);
3480dbf8:	e5940000 	ldr	r0, [r4]
3480dbfc:	e3a01001 	mov	r1, #1
3480dc00:	e28d2004 	add	r2, sp, #4
3480dc04:	e1a0300d 	mov	r3, sp
3480dc08:	ebfffe78 	bl	3480d5f0 <image_multi_getimg>
3480dc0c:	ea000004 	b	3480dc24 <boot_get_ramdisk+0x1bc>
3480dc10:	e3a0000e 	mov	r0, #14
3480dc14:	eb0000db 	bl	3480df88 <__show_boot_progress>
	} else {
		/*
		 * no initrd image
		 */
		bootstage_mark(BOOTSTAGE_ID_NO_RAMDISK);
		rd_len = rd_data = 0;
3480dc18:	e3a03000 	mov	r3, #0
3480dc1c:	e58d3004 	str	r3, [sp, #4]
3480dc20:	e58d3000 	str	r3, [sp]
	}

	if (!rd_data) {
3480dc24:	e59d9004 	ldr	r9, [sp, #4]
3480dc28:	e3590000 	cmp	r9, #0
		debug("## No init Ramdisk\n");
	} else {
		*rd_start = rd_data;
3480dc2c:	15879000 	strne	r9, [r7]
		*rd_end = rd_data + rd_len;
3480dc30:	159d3000 	ldrne	r3, [sp]
3480dc34:	10839009 	addne	r9, r3, r9
3480dc38:	15859000 	strne	r9, [r5]
	}
	debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
			*rd_start, *rd_end);

	return 0;
3480dc3c:	13a09000 	movne	r9, #0
}
3480dc40:	e1a00009 	mov	r0, r9
3480dc44:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
						"0x%08lx\n",
						fit_uname_ramdisk, rd_addr);
			} else
#endif
			{
				rd_addr = simple_strtoul(argv[2], NULL, 16);
3480dc48:	e1a01009 	mov	r1, r9
3480dc4c:	e5960008 	ldr	r0, [r6, #8]
3480dc50:	e3a02010 	mov	r2, #16
3480dc54:	eb003e1b 	bl	3481d4c8 <simple_strtoul>
3480dc58:	e1a06000 	mov	r6, r0
		/*
		 * Check if there is an initrd image at the
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
3480dc5c:	ebffff78 	bl	3480da44 <genimg_get_format>
3480dc60:	e3500001 	cmp	r0, #1
3480dc64:	e1a09000 	mov	r9, r0
3480dc68:	1affffd6 	bne	3480dbc8 <boot_get_ramdisk+0x160>
3480dc6c:	eaffff93 	b	3480dac0 <boot_get_ramdisk+0x58>
3480dc70:	3482774a 	.word	0x3482774a
3480dc74:	34826755 	.word	0x34826755
3480dc78:	34823142 	.word	0x34823142
3480dc7c:	34823157 	.word	0x34823157
3480dc80:	3482316c 	.word	0x3482316c
3480dc84:	3482318a 	.word	0x3482318a
3480dc88:	34823198 	.word	0x34823198
3480dc8c:	3482678d 	.word	0x3482678d
3480dc90:	348267a8 	.word	0x348267a8
3480dc94:	348267c4 	.word	0x348267c4

3480dc98 <boot_ramdisk_high>:
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480dc98:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3480dc9c:	e1a0a000 	mov	sl, r0
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480dca0:	e59f010c 	ldr	r0, [pc, #268]	; 3480ddb4 <boot_ramdisk_high+0x11c>
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480dca4:	e1a05003 	mov	r5, r3
3480dca8:	e1a04001 	mov	r4, r1
3480dcac:	e1a06002 	mov	r6, r2
3480dcb0:	e59d9020 	ldr	r9, [sp, #32]
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480dcb4:	ebffe8d1 	bl	34808000 <getenv>
3480dcb8:	e3500000 	cmp	r0, #0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480dcbc:	03a07001 	moveq	r7, #1
		initrd_high = simple_strtoul(s, NULL, 16);
		if (initrd_high == ~0)
			initrd_copy_to_ram = 0;
	} else {
		/* not set, no restrictions to load high */
		initrd_high = ~0;
3480dcc0:	03e03000 	mvneq	r3, #0
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480dcc4:	0a000005 	beq	3480dce0 <boot_ramdisk_high+0x48>
		/* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 */
		initrd_high = simple_strtoul(s, NULL, 16);
3480dcc8:	e3a01000 	mov	r1, #0
3480dccc:	e3a02010 	mov	r2, #16
3480dcd0:	eb003dfc 	bl	3481d4c8 <simple_strtoul>
3480dcd4:	e1a03000 	mov	r3, r0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480dcd8:	e2907001 	adds	r7, r0, #1
3480dcdc:	13a07001 	movne	r7, #1
#endif

	debug("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
3480dce0:	e3540000 	cmp	r4, #0
3480dce4:	0a00002e 	beq	3480dda4 <boot_ramdisk_high+0x10c>
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
3480dce8:	e3570000 	cmp	r7, #0
3480dcec:	1a000008 	bne	3480dd14 <boot_ramdisk_high+0x7c>
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480dcf0:	e0863004 	add	r3, r6, r4
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
3480dcf4:	e5854000 	str	r4, [r5]
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
3480dcf8:	e1a0000a 	mov	r0, sl

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480dcfc:	e5893000 	str	r3, [r9]
			lmb_reserve(lmb, rd_data, rd_len);
3480dd00:	e1a01004 	mov	r1, r4
3480dd04:	e1a02006 	mov	r2, r6
3480dd08:	eb003912 	bl	3481c158 <lmb_reserve>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480dd0c:	e1a00007 	mov	r0, r7
3480dd10:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
		} else {
			if (initrd_high)
3480dd14:	e3530000 	cmp	r3, #0
3480dd18:	0a000004 	beq	3480dd30 <boot_ramdisk_high+0x98>
				*initrd_start = (ulong)lmb_alloc_base(lmb,
3480dd1c:	e1a0000a 	mov	r0, sl
3480dd20:	e1a01006 	mov	r1, r6
3480dd24:	e3a02a01 	mov	r2, #4096	; 0x1000
3480dd28:	eb00396d 	bl	3481c2e4 <lmb_alloc_base>
3480dd2c:	ea000003 	b	3480dd40 <boot_ramdisk_high+0xa8>
						rd_len, 0x1000, initrd_high);
			else
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
3480dd30:	e1a0000a 	mov	r0, sl
3480dd34:	e1a01006 	mov	r1, r6
3480dd38:	e3a02a01 	mov	r2, #4096	; 0x1000
3480dd3c:	eb003975 	bl	3481c318 <lmb_alloc>
3480dd40:	e5850000 	str	r0, [r5]
								 0x1000);

			if (*initrd_start == 0) {
3480dd44:	e5953000 	ldr	r3, [r5]
3480dd48:	e3530000 	cmp	r3, #0
3480dd4c:	1a000003 	bne	3480dd60 <boot_ramdisk_high+0xc8>
				puts("ramdisk - allocation error\n");
3480dd50:	e59f0060 	ldr	r0, [pc, #96]	; 3480ddb8 <boot_ramdisk_high+0x120>
3480dd54:	ebffef8d 	bl	34809b90 <puts>
			*initrd_start, *initrd_end);

	return 0;

error:
	return -1;
3480dd58:	e3e00000 	mvn	r0, #0
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
								 0x1000);

			if (*initrd_start == 0) {
				puts("ramdisk - allocation error\n");
				goto error;
3480dd5c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480dd60:	e3a0000c 	mov	r0, #12
3480dd64:	eb000087 	bl	3480df88 <__show_boot_progress>
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480dd68:	e5952000 	ldr	r2, [r5]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480dd6c:	e59f0048 	ldr	r0, [pc, #72]	; 3480ddbc <boot_ramdisk_high+0x124>
				puts("ramdisk - allocation error\n");
				goto error;
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480dd70:	e0862002 	add	r2, r6, r2
3480dd74:	e5892000 	str	r2, [r9]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480dd78:	e5951000 	ldr	r1, [r5]
3480dd7c:	ebffef8d 	bl	34809bb8 <printf>
					*initrd_start, *initrd_end);

			memmove_wd((void *)*initrd_start,
3480dd80:	e5950000 	ldr	r0, [r5]
3480dd84:	e1a01004 	mov	r1, r4
3480dd88:	e1a02006 	mov	r2, r6
3480dd8c:	e3a03801 	mov	r3, #65536	; 0x10000
3480dd90:	ebfffe70 	bl	3480d758 <memmove_wd>
			 * AMP boot scenarios in which we might not be
			 * HW cache coherent
			 */
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
3480dd94:	e59f0024 	ldr	r0, [pc, #36]	; 3480ddc0 <boot_ramdisk_high+0x128>
3480dd98:	ebffef7c 	bl	34809b90 <puts>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480dd9c:	e3a00000 	mov	r0, #0
3480dda0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
3480dda4:	e5854000 	str	r4, [r5]
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480dda8:	e1a00004 	mov	r0, r4
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
		*initrd_end = 0;
3480ddac:	e5894000 	str	r4, [r9]

	return 0;

error:
	return -1;
}
3480ddb0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480ddb4:	3482680c 	.word	0x3482680c
3480ddb8:	34826818 	.word	0x34826818
3480ddbc:	34826834 	.word	0x34826834
3480ddc0:	34823198 	.word	0x34823198

3480ddc4 <delete_char>:
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480ddc4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480ddc8:	e1a07003 	mov	r7, r3
	char *s;

	if (*np == 0) {
3480ddcc:	e5933000 	ldr	r3, [r3]
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480ddd0:	e1a04000 	mov	r4, r0
	char *s;

	if (*np == 0) {
3480ddd4:	e3530000 	cmp	r3, #0
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480ddd8:	e1a05001 	mov	r5, r1
3480dddc:	e1a06002 	mov	r6, r2
3480dde0:	e59da018 	ldr	sl, [sp, #24]
	char *s;

	if (*np == 0) {
3480dde4:	0a000028 	beq	3480de8c <delete_char+0xc8>
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
3480dde8:	e5753001 	ldrb	r3, [r5, #-1]!
3480ddec:	e3530009 	cmp	r3, #9
3480ddf0:	1a00001d 	bne	3480de6c <delete_char+0xa8>
3480ddf4:	ea000004 	b	3480de0c <delete_char+0x48>
		while (*colp > plen) {
			puts (erase_seq);
3480ddf8:	e59f0094 	ldr	r0, [pc, #148]	; 3480de94 <delete_char+0xd0>
3480ddfc:	ebffef63 	bl	34809b90 <puts>
			(*colp)--;
3480de00:	e5963000 	ldr	r3, [r6]
3480de04:	e2433001 	sub	r3, r3, #1
3480de08:	e5863000 	str	r3, [r6]
	if (*np == 0) {
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
3480de0c:	e5963000 	ldr	r3, [r6]
3480de10:	e153000a 	cmp	r3, sl
3480de14:	cafffff7 	bgt	3480ddf8 <delete_char+0x34>
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
				puts (tab_seq+((*colp) & 07));
3480de18:	e59fa078 	ldr	sl, [pc, #120]	; 3480de98 <delete_char+0xd4>
3480de1c:	ea00000f 	b	3480de60 <delete_char+0x9c>
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
3480de20:	e4d43001 	ldrb	r3, [r4], #1
3480de24:	e5960000 	ldr	r0, [r6]
3480de28:	e3530009 	cmp	r3, #9
3480de2c:	1a000007 	bne	3480de50 <delete_char+0x8c>
				puts (tab_seq+((*colp) & 07));
3480de30:	e2000007 	and	r0, r0, #7
3480de34:	e08a0000 	add	r0, sl, r0
3480de38:	ebffef54 	bl	34809b90 <puts>
				*colp += 8 - ((*colp) & 07);
3480de3c:	e5963000 	ldr	r3, [r6]
3480de40:	e3c33007 	bic	r3, r3, #7
3480de44:	e2833008 	add	r3, r3, #8
3480de48:	e5863000 	str	r3, [r6]
3480de4c:	ea000003 	b	3480de60 <delete_char+0x9c>
			} else {
				++(*colp);
3480de50:	e2800001 	add	r0, r0, #1
3480de54:	e5860000 	str	r0, [r6]
				putc (*s);
3480de58:	e5540001 	ldrb	r0, [r4, #-1]
3480de5c:	ebffef41 	bl	34809b68 <putc>
	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
3480de60:	e1550004 	cmp	r5, r4
3480de64:	8affffed 	bhi	3480de20 <delete_char+0x5c>
3480de68:	ea000004 	b	3480de80 <delete_char+0xbc>
				++(*colp);
				putc (*s);
			}
		}
	} else {
		puts (erase_seq);
3480de6c:	e59f0020 	ldr	r0, [pc, #32]	; 3480de94 <delete_char+0xd0>
3480de70:	ebffef46 	bl	34809b90 <puts>
		(*colp)--;
3480de74:	e5963000 	ldr	r3, [r6]
3480de78:	e2433001 	sub	r3, r3, #1
3480de7c:	e5863000 	str	r3, [r6]
	}
	(*np)--;
3480de80:	e5973000 	ldr	r3, [r7]
3480de84:	e2433001 	sub	r3, r3, #1
3480de88:	e5873000 	str	r3, [r7]
	return (p);
}
3480de8c:	e1a00005 	mov	r0, r5
3480de90:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480de94:	34821640 	.word	0x34821640
3480de98:	34821644 	.word	0x34821644

3480de9c <cread_add_char>:
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480de9c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480dea0:	e3510000 	cmp	r1, #0
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480dea4:	e1a04002 	mov	r4, r2
3480dea8:	e1a05000 	mov	r5, r0
3480deac:	e59d6018 	ldr	r6, [sp, #24]
3480deb0:	e59d201c 	ldr	r2, [sp, #28]
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480deb4:	1a000003 	bne	3480dec8 <cread_add_char+0x2c>
3480deb8:	e594c000 	ldr	ip, [r4]
3480debc:	e5930000 	ldr	r0, [r3]
3480dec0:	e15c0000 	cmp	ip, r0
3480dec4:	1a000023 	bne	3480df58 <cread_add_char+0xbc>
		if (*eol_num > len - 1) {
3480dec8:	e5937000 	ldr	r7, [r3]
3480decc:	e2422001 	sub	r2, r2, #1
3480ded0:	e1570002 	cmp	r7, r2
3480ded4:	9a000002 	bls	3480dee4 <cread_add_char+0x48>
			getcmd_cbeep();
3480ded8:	e3a00007 	mov	r0, #7
		wlen = 1;
		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
	}
}
3480dedc:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
3480dee0:	eaffef20 	b	34809b68 <putc>
			return;
		}
		(*eol_num)++;
3480dee4:	e2877001 	add	r7, r7, #1
	}

	if (insert) {
3480dee8:	e3510000 	cmp	r1, #0
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
			return;
		}
		(*eol_num)++;
3480deec:	e5837000 	str	r7, [r3]
	}

	if (insert) {
3480def0:	0a000018 	beq	3480df58 <cread_add_char+0xbc>
		wlen = *eol_num - *num;
3480def4:	e5941000 	ldr	r1, [r4]
3480def8:	e0617007 	rsb	r7, r1, r7
		if (wlen > 1) {
3480defc:	e3570001 	cmp	r7, #1
3480df00:	9a000004 	bls	3480df18 <cread_add_char+0x7c>
			memmove(&buf[*num+1], &buf[*num], wlen-1);
3480df04:	e2810001 	add	r0, r1, #1
3480df08:	e0860000 	add	r0, r6, r0
3480df0c:	e0861001 	add	r1, r6, r1
3480df10:	e2472001 	sub	r2, r7, #1
3480df14:	eb003ab9 	bl	3481ca00 <memmove>
		}

		buf[*num] = ichar;
3480df18:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480df1c:	e59f0060 	ldr	r0, [pc, #96]	; 3480df84 <cread_add_char+0xe8>
		wlen = *eol_num - *num;
		if (wlen > 1) {
			memmove(&buf[*num+1], &buf[*num], wlen-1);
		}

		buf[*num] = ichar;
3480df20:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480df24:	e5942000 	ldr	r2, [r4]
3480df28:	e1a01007 	mov	r1, r7
3480df2c:	e0862002 	add	r2, r6, r2
3480df30:	ebffef20 	bl	34809bb8 <printf>
		(*num)++;
3480df34:	e5943000 	ldr	r3, [r4]
3480df38:	e2833001 	add	r3, r3, #1
3480df3c:	e5843000 	str	r3, [r4]
		while (--wlen) {
3480df40:	ea000001 	b	3480df4c <cread_add_char+0xb0>
			getcmd_putch(CTL_BACKSPACE);
3480df44:	e3a00008 	mov	r0, #8
3480df48:	ebffef06 	bl	34809b68 <putc>
		}

		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
		while (--wlen) {
3480df4c:	e2577001 	subs	r7, r7, #1
3480df50:	1afffffb 	bne	3480df44 <cread_add_char+0xa8>
3480df54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480df58:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480df5c:	e59f0020 	ldr	r0, [pc, #32]	; 3480df84 <cread_add_char+0xe8>
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480df60:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480df64:	e5942000 	ldr	r2, [r4]
3480df68:	e3a01001 	mov	r1, #1
3480df6c:	e0862002 	add	r2, r6, r2
3480df70:	ebffef10 	bl	34809bb8 <printf>
		(*num)++;
3480df74:	e5943000 	ldr	r3, [r4]
3480df78:	e2833001 	add	r3, r3, #1
3480df7c:	e5843000 	str	r3, [r4]
3480df80:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
3480df84:	34826bb2 	.word	0x34826bb2

3480df88 <__show_boot_progress>:
#endif

/*
 * Board-specific Platform code can reimplement show_boot_progress () if needed
 */
void inline __show_boot_progress (int val) {}
3480df88:	e12fff1e 	bx	lr

3480df8c <readline_into_buffer>:
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480df8c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480df90:	e5983004 	ldr	r3, [r8, #4]
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480df94:	e24dd040 	sub	sp, sp, #64	; 0x40
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480df98:	e2133001 	ands	r3, r3, #1
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480df9c:	e1a06000 	mov	r6, r0
3480dfa0:	e1a04001 	mov	r4, r1
3480dfa4:	e58d201c 	str	r2, [sp, #28]
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480dfa8:	0a0001b7 	beq	3480e68c <readline_into_buffer+0x700>
		if (!initted) {
3480dfac:	e59f28a0 	ldr	r2, [pc, #2208]	; 3480e854 <readline_into_buffer+0x8c8>
3480dfb0:	e5923000 	ldr	r3, [r2]
3480dfb4:	e3530000 	cmp	r3, #0
3480dfb8:	1a000010 	bne	3480e000 <readline_into_buffer+0x74>
{
	int i;

	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
3480dfbc:	e59f1894 	ldr	r1, [pc, #2196]	; 3480e858 <readline_into_buffer+0x8cc>
3480dfc0:	e3e00000 	mvn	r0, #0
3480dfc4:	e5810000 	str	r0, [r1]
	hist_num = 0;
3480dfc8:	e59f188c 	ldr	r1, [pc, #2188]	; 3480e85c <readline_into_buffer+0x8d0>

	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
3480dfcc:	e59f088c 	ldr	r0, [pc, #2188]	; 3480e860 <readline_into_buffer+0x8d4>

static void hist_init(void)
{
	int i;

	hist_max = 0;
3480dfd0:	e5823004 	str	r3, [r2, #4]
	hist_add_idx = 0;
3480dfd4:	e5823008 	str	r3, [r2, #8]
	hist_cur = -1;
	hist_num = 0;
3480dfd8:	e582300c 	str	r3, [r2, #12]

	for (i = 0; i < HIST_MAX; i++) {
		hist_list[i] = hist_lines[i];
3480dfdc:	e2822010 	add	r2, r2, #16
3480dfe0:	e5a12004 	str	r2, [r1, #4]!
		hist_list[i][0] = '\0';
3480dfe4:	e4c23100 	strb	r3, [r2], #256	; 0x100
3480dfe8:	e2822001 	add	r2, r2, #1
	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
	hist_num = 0;

	for (i = 0; i < HIST_MAX; i++) {
3480dfec:	e1520000 	cmp	r2, r0
3480dff0:	1afffffa 	bne	3480dfe0 <readline_into_buffer+0x54>
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
		if (!initted) {
			hist_init();
			initted = 1;
3480dff4:	e59f3858 	ldr	r3, [pc, #2136]	; 3480e854 <readline_into_buffer+0x8c8>
3480dff8:	e3a02001 	mov	r2, #1
3480dffc:	e5832000 	str	r2, [r3]
		}

		if (prompt)
3480e000:	e3560000 	cmp	r6, #0
3480e004:	0a000001 	beq	3480e010 <readline_into_buffer+0x84>
			puts (prompt);
3480e008:	e1a00006 	mov	r0, r6
3480e00c:	ebffeedf 	bl	34809b90 <puts>
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480e010:	e3a03000 	mov	r3, #0
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480e014:	e1a00004 	mov	r0, r4
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480e018:	e58d3034 	str	r3, [sp, #52]	; 0x34
	unsigned long eol_num = 0;
3480e01c:	e58d3030 	str	r3, [sp, #48]	; 0x30
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480e020:	eb003995 	bl	3481c67c <strlen>
	int first = 1;

	if (init_len)
3480e024:	e2505000 	subs	r5, r0, #0
3480e028:	1a000011 	bne	3480e074 <readline_into_buffer+0xe8>
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480e02c:	e59d101c 	ldr	r1, [sp, #28]
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480e030:	e3a0b001 	mov	fp, #1
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480e034:	e1a00001 	mov	r0, r1
3480e038:	e1a01fc0 	asr	r1, r0, #31
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480e03c:	e3a0a000 	mov	sl, #0
3480e040:	e1a0700b 	mov	r7, fp
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480e044:	e1cd02f0 	strd	r0, [sp, #32]

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480e048:	e59f5808 	ldr	r5, [pc, #2056]	; 3480e858 <readline_into_buffer+0x8cc>
		return NULL;

	if (hist_cur == hist_add_idx)
3480e04c:	e59f6800 	ldr	r6, [pc, #2048]	; 3480e854 <readline_into_buffer+0x8c8>
3480e050:	ea00000f 	b	3480e094 <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480e054:	e4d60001 	ldrb	r0, [r6], #1
3480e058:	e3a01001 	mov	r1, #1
3480e05c:	e1a02007 	mov	r2, r7
3480e060:	e1a0300a 	mov	r3, sl
3480e064:	e88d0210 	stm	sp, {r4, r9}
		str++;
3480e068:	e2455001 	sub	r5, r5, #1

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480e06c:	ebffff8a 	bl	3480de9c <cread_add_char>
3480e070:	ea000003 	b	3480e084 <readline_into_buffer+0xf8>
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
	int first = 1;

	if (init_len)
3480e074:	e1a06004 	mov	r6, r4
		cread_add_str(buf, init_len, 1, &num, &eol_num, buf, *len);
3480e078:	e28d7034 	add	r7, sp, #52	; 0x34
3480e07c:	e28da030 	add	sl, sp, #48	; 0x30

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480e080:	e3a09c01 	mov	r9, #256	; 0x100
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480e084:	e3550000 	cmp	r5, #0
3480e088:	1afffff1 	bne	3480e054 <readline_into_buffer+0xc8>
3480e08c:	eaffffe6 	b	3480e02c <readline_into_buffer+0xa0>
		case CTL_CH('p'):
		case CTL_CH('n'):
		{
			char * hline;

			esc_len = 0;
3480e090:	e3a0a000 	mov	sl, #0
			if (retry_time >= 0 && get_ticks() > endtime)
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
3480e094:	e59d201c 	ldr	r2, [sp, #28]
3480e098:	e3520000 	cmp	r2, #0
3480e09c:	03a03000 	moveq	r3, #0
3480e0a0:	120b3001 	andne	r3, fp, #1
3480e0a4:	e3530000 	cmp	r3, #0
3480e0a8:	0a000017 	beq	3480e10c <readline_into_buffer+0x180>
			uint64_t etime = endtick(timeout);
3480e0ac:	ebffccde 	bl	3480142c <get_ticks>
3480e0b0:	e1cd01f0 	strd	r0, [sp, #16]
3480e0b4:	ebffcce0 	bl	3480143c <get_tbclk>
3480e0b8:	e59d101c 	ldr	r1, [sp, #28]
3480e0bc:	e0832190 	umull	r2, r3, r0, r1
3480e0c0:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3480e0c4:	e0233190 	mla	r3, r0, r1, r3
3480e0c8:	e1cd01d0 	ldrd	r0, [sp, #16]
3480e0cc:	e0900002 	adds	r0, r0, r2
3480e0d0:	e0a11003 	adc	r1, r1, r3
3480e0d4:	e1cd01f0 	strd	r0, [sp, #16]
3480e0d8:	ea000007 	b	3480e0fc <readline_into_buffer+0x170>

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
3480e0dc:	ebffccd2 	bl	3480142c <get_ticks>
3480e0e0:	e59d2014 	ldr	r2, [sp, #20]
3480e0e4:	e1520001 	cmp	r2, r1
3480e0e8:	8a000003 	bhi	3480e0fc <readline_into_buffer+0x170>
3480e0ec:	1a000164 	bne	3480e684 <readline_into_buffer+0x6f8>
3480e0f0:	e59d3010 	ldr	r3, [sp, #16]
3480e0f4:	e1530000 	cmp	r3, r0
3480e0f8:	9a000161 	bls	3480e684 <readline_into_buffer+0x6f8>
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
3480e0fc:	ebffee90 	bl	34809b44 <tstc>
3480e100:	e3500000 	cmp	r0, #0
3480e104:	0afffff4 	beq	3480e0dc <readline_into_buffer+0x150>
				if (get_ticks() >= etime)
					return -2;	/* timed out */
				WATCHDOG_RESET();
			}
			first = 0;
3480e108:	e3a0b000 	mov	fp, #0
		}

		ichar = getcmd_getch();
3480e10c:	ebffee83 	bl	34809b20 <getc>
3480e110:	e6ef0070 	uxtb	r0, r0

		if ((ichar == '\n') || (ichar == '\r')) {
3480e114:	e350000a 	cmp	r0, #10
3480e118:	1350000d 	cmpne	r0, #13
3480e11c:	13a09000 	movne	r9, #0
3480e120:	03a09001 	moveq	r9, #1
3480e124:	1a000009 	bne	3480e150 <readline_into_buffer+0x1c4>
			putc('\n');
3480e128:	e3a0000a 	mov	r0, #10
3480e12c:	ebffee8d 	bl	34809b68 <putc>
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
			break;
		}
	}
	*len = eol_num;
3480e130:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
	buf[eol_num] = '\0';	/* lose the newline */
3480e134:	e3a03000 	mov	r3, #0
3480e138:	e7c43006 	strb	r3, [r4, r6]

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
3480e13c:	e5d43000 	ldrb	r3, [r4]
3480e140:	e3530021 	cmp	r3, #33	; 0x21
3480e144:	13530000 	cmpne	r3, #0
3480e148:	0a000147 	beq	3480e66c <readline_into_buffer+0x6e0>
3480e14c:	ea000134 	b	3480e624 <readline_into_buffer+0x698>
		}

		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
3480e150:	e35a0000 	cmp	sl, #0
3480e154:	0a000032 	beq	3480e224 <readline_into_buffer+0x298>
			if (esc_len == 1) {
3480e158:	e35a0001 	cmp	sl, #1
3480e15c:	1a00000d 	bne	3480e198 <readline_into_buffer+0x20c>
				if (ichar == '[') {
3480e160:	e350005b 	cmp	r0, #91	; 0x5b
					esc_save[esc_len] = ichar;
3480e164:	05cd0029 	strbeq	r0, [sp, #41]	; 0x29
					esc_len = 2;
3480e168:	03a0a002 	moveq	sl, #2
		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
			if (esc_len == 1) {
				if (ichar == '[') {
3480e16c:	0affffc8 	beq	3480e094 <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480e170:	e3a03c01 	mov	r3, #256	; 0x100
3480e174:	e58d3004 	str	r3, [sp, #4]
3480e178:	e5dd0028 	ldrb	r0, [sp, #40]	; 0x28
3480e17c:	e1a01007 	mov	r1, r7
3480e180:	e28d2034 	add	r2, sp, #52	; 0x34
3480e184:	e28d3030 	add	r3, sp, #48	; 0x30
3480e188:	e58d4000 	str	r4, [sp]
					esc_save[esc_len] = ichar;
					esc_len = 2;
				} else {
					cread_add_str(esc_save, esc_len, insert,
						      &num, &eol_num, buf, *len);
					esc_len = 0;
3480e18c:	e1a0a009 	mov	sl, r9

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480e190:	ebffff41 	bl	3480de9c <cread_add_char>
3480e194:	eaffffbe 	b	3480e094 <readline_into_buffer+0x108>
					esc_len = 0;
				}
				continue;
			}

			switch (ichar) {
3480e198:	e2403041 	sub	r3, r0, #65	; 0x41
3480e19c:	e3530007 	cmp	r3, #7
3480e1a0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480e1a4:	ea000007 	b	3480e1c8 <readline_into_buffer+0x23c>
3480e1a8:	3480e4bc 	.word	0x3480e4bc
3480e1ac:	3480e500 	.word	0x3480e500
3480e1b0:	3480e218 	.word	0x3480e218
3480e1b4:	3480e318 	.word	0x3480e318
3480e1b8:	3480e1c8 	.word	0x3480e1c8
3480e1bc:	3480e1c8 	.word	0x3480e1c8
3480e1c0:	3480e1c8 	.word	0x3480e1c8
3480e1c4:	3480e2e4 	.word	0x3480e2e4
			case 'B':	/* down arrow */
				ichar = CTL_CH('n');
				esc_len = 0;
				break;	/* pass off to ^N handler */
			default:
				esc_save[esc_len++] = ichar;
3480e1c8:	e28d1040 	add	r1, sp, #64	; 0x40
3480e1cc:	e081300a 	add	r3, r1, sl
3480e1d0:	e5430018 	strb	r0, [r3, #-24]
3480e1d4:	e28aa001 	add	sl, sl, #1
				cread_add_str(esc_save, esc_len, insert,
3480e1d8:	e28d9028 	add	r9, sp, #40	; 0x28

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480e1dc:	e3a0cc01 	mov	ip, #256	; 0x100
3480e1e0:	ea000009 	b	3480e20c <readline_into_buffer+0x280>
3480e1e4:	e4d90001 	ldrb	r0, [r9], #1
3480e1e8:	e1a01007 	mov	r1, r7
3480e1ec:	e28d2034 	add	r2, sp, #52	; 0x34
3480e1f0:	e28d3030 	add	r3, sp, #48	; 0x30
3480e1f4:	e58dc004 	str	ip, [sp, #4]
3480e1f8:	e58dc00c 	str	ip, [sp, #12]
3480e1fc:	e58d4000 	str	r4, [sp]
3480e200:	ebffff25 	bl	3480de9c <cread_add_char>
		str++;
3480e204:	e59dc00c 	ldr	ip, [sp, #12]
3480e208:	e24aa001 	sub	sl, sl, #1
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480e20c:	e35a0000 	cmp	sl, #0
3480e210:	1afffff3 	bne	3480e1e4 <readline_into_buffer+0x258>
3480e214:	eaffff9e 	b	3480e094 <readline_into_buffer+0x108>
			case 'D':	/* <- key */
				ichar = CTL_CH('b');
				esc_len = 0;
				break;
			case 'C':	/* -> key */
				ichar = CTL_CH('f');
3480e218:	e3a00006 	mov	r0, #6
3480e21c:	e350000b 	cmp	r0, #11
3480e220:	ea000001 	b	3480e22c <readline_into_buffer+0x2a0>
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480e224:	e350000b 	cmp	r0, #11
3480e228:	0a00005e 	beq	3480e3a8 <readline_into_buffer+0x41c>
3480e22c:	8a00000f 	bhi	3480e270 <readline_into_buffer+0x2e4>
3480e230:	e3500004 	cmp	r0, #4
3480e234:	0a00003f 	beq	3480e338 <readline_into_buffer+0x3ac>
3480e238:	8a000005 	bhi	3480e254 <readline_into_buffer+0x2c8>
3480e23c:	e3500002 	cmp	r0, #2
3480e240:	0a000034 	beq	3480e318 <readline_into_buffer+0x38c>
3480e244:	8a00013e 	bhi	3480e744 <readline_into_buffer+0x7b8>
3480e248:	e3500001 	cmp	r0, #1
3480e24c:	1a0000ec 	bne	3480e604 <readline_into_buffer+0x678>
3480e250:	ea000023 	b	3480e2e4 <readline_into_buffer+0x358>
3480e254:	e3500006 	cmp	r0, #6
3480e258:	0a000025 	beq	3480e2f4 <readline_into_buffer+0x368>
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
3480e25c:	359d2034 	ldrcc	r2, [sp, #52]	; 0x34
3480e260:	359d1030 	ldrcc	r1, [sp, #48]	; 0x30
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480e264:	3a0000dd 	bcc	3480e5e0 <readline_into_buffer+0x654>
3480e268:	e3500008 	cmp	r0, #8
3480e26c:	ea000015 	b	3480e2c8 <readline_into_buffer+0x33c>
3480e270:	e3500015 	cmp	r0, #21
3480e274:	0a000061 	beq	3480e400 <readline_into_buffer+0x474>
3480e278:	8a000007 	bhi	3480e29c <readline_into_buffer+0x310>
3480e27c:	e350000f 	cmp	r0, #15
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
			break;
		case CTL_CH('o'):
			insert = !insert;
3480e280:	02277001 	eoreq	r7, r7, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480e284:	0affff81 	beq	3480e090 <readline_into_buffer+0x104>
3480e288:	e3500010 	cmp	r0, #16
3480e28c:	0a00008a 	beq	3480e4bc <readline_into_buffer+0x530>
3480e290:	e350000e 	cmp	r0, #14
3480e294:	1a0000da 	bne	3480e604 <readline_into_buffer+0x678>
3480e298:	ea000098 	b	3480e500 <readline_into_buffer+0x574>
3480e29c:	e350001b 	cmp	r0, #27
		case 0x1b:
			if (esc_len == 0) {
				esc_save[esc_len] = ichar;
3480e2a0:	05cd0028 	strbeq	r0, [sp, #40]	; 0x28
				esc_len = 1;
3480e2a4:	03a0a001 	moveq	sl, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480e2a8:	0affff79 	beq	3480e094 <readline_into_buffer+0x108>
3480e2ac:	8a000002 	bhi	3480e2bc <readline_into_buffer+0x330>
3480e2b0:	e3500018 	cmp	r0, #24
3480e2b4:	1a0000d2 	bne	3480e604 <readline_into_buffer+0x678>
3480e2b8:	ea000050 	b	3480e400 <readline_into_buffer+0x474>
3480e2bc:	e350007f 	cmp	r0, #127	; 0x7f
3480e2c0:	0a000061 	beq	3480e44c <readline_into_buffer+0x4c0>
3480e2c4:	e35000ff 	cmp	r0, #255	; 0xff
3480e2c8:	1a0000cd 	bne	3480e604 <readline_into_buffer+0x678>
3480e2cc:	ea00005e 	b	3480e44c <readline_into_buffer+0x4c0>
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480e2d0:	e3a00008 	mov	r0, #8
3480e2d4:	ebffee23 	bl	34809b68 <putc>
3480e2d8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e2dc:	e2433001 	sub	r3, r3, #1
3480e2e0:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e2e4:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480e2e8:	e35a0000 	cmp	sl, #0
3480e2ec:	1afffff7 	bne	3480e2d0 <readline_into_buffer+0x344>
3480e2f0:	eaffff67 	b	3480e094 <readline_into_buffer+0x108>
			break;
		case CTL_CH('c'):	/* ^C - break */
			*buf = '\0';	/* discard input */
			return (-1);
		case CTL_CH('f'):
			if (num < eol_num) {
3480e2f4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e2f8:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480e2fc:	e1530002 	cmp	r3, r2
3480e300:	2affff62 	bcs	3480e090 <readline_into_buffer+0x104>
				getcmd_putch(buf[num]);
3480e304:	e7d40003 	ldrb	r0, [r4, r3]
3480e308:	ebffee16 	bl	34809b68 <putc>
				num++;
3480e30c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e310:	e2833001 	add	r3, r3, #1
3480e314:	ea0000b8 	b	3480e5fc <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('b'):
			if (num) {
3480e318:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480e31c:	e35a0000 	cmp	sl, #0
3480e320:	0affff5b 	beq	3480e094 <readline_into_buffer+0x108>
				getcmd_putch(CTL_BACKSPACE);
3480e324:	e3a00008 	mov	r0, #8
3480e328:	ebffee0e 	bl	34809b68 <putc>
				num--;
3480e32c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e330:	e2433001 	sub	r3, r3, #1
3480e334:	ea0000b0 	b	3480e5fc <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('d'):
			if (num < eol_num) {
3480e338:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3480e33c:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480e340:	e150000a 	cmp	r0, sl
3480e344:	2affff51 	bcs	3480e090 <readline_into_buffer+0x104>
				wlen = eol_num - num - 1;
3480e348:	e24aa001 	sub	sl, sl, #1
				if (wlen) {
3480e34c:	e05aa000 	subs	sl, sl, r0
3480e350:	0a000009 	beq	3480e37c <readline_into_buffer+0x3f0>
					memmove(&buf[num], &buf[num+1], wlen);
3480e354:	e2801001 	add	r1, r0, #1
3480e358:	e0841001 	add	r1, r4, r1
3480e35c:	e1a0200a 	mov	r2, sl
3480e360:	e0840000 	add	r0, r4, r0
3480e364:	eb0039a5 	bl	3481ca00 <memmove>
					putnstr(buf + num, wlen);
3480e368:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e36c:	e59f04f0 	ldr	r0, [pc, #1264]	; 3480e864 <readline_into_buffer+0x8d8>
3480e370:	e1a0100a 	mov	r1, sl
3480e374:	e0842002 	add	r2, r4, r2
3480e378:	ebffee0e 	bl	34809bb8 <printf>
				}

				getcmd_putch(' ');
3480e37c:	e3a00020 	mov	r0, #32
3480e380:	ebffedf8 	bl	34809b68 <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480e384:	e3a00008 	mov	r0, #8
3480e388:	ebffedf6 	bl	34809b68 <putc>
				} while (wlen--);
3480e38c:	e25aa001 	subs	sl, sl, #1
3480e390:	2afffffb 	bcs	3480e384 <readline_into_buffer+0x3f8>
				eol_num--;
3480e394:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e398:	e28aa001 	add	sl, sl, #1
3480e39c:	e2433001 	sub	r3, r3, #1
3480e3a0:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e3a4:	eaffff3a 	b	3480e094 <readline_into_buffer+0x108>
			}
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
3480e3a8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e3ac:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480e3b0:	e1530001 	cmp	r3, r1
3480e3b4:	2affff36 	bcs	3480e094 <readline_into_buffer+0x108>
3480e3b8:	e59f04a8 	ldr	r0, [pc, #1192]	; 3480e868 <readline_into_buffer+0x8dc>
3480e3bc:	e0631001 	rsb	r1, r3, r1
3480e3c0:	e59f24a4 	ldr	r2, [pc, #1188]	; 3480e86c <readline_into_buffer+0x8e0>
3480e3c4:	ebffedfb 	bl	34809bb8 <printf>
3480e3c8:	e3a00008 	mov	r0, #8
3480e3cc:	ebffede5 	bl	34809b68 <putc>
3480e3d0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e3d4:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e3d8:	e2433001 	sub	r3, r3, #1
3480e3dc:	e1530002 	cmp	r3, r2
3480e3e0:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e3e4:	8afffff7 	bhi	3480e3c8 <readline_into_buffer+0x43c>
3480e3e8:	eaffff28 	b	3480e090 <readline_into_buffer+0x104>
		case CTL_CH('o'):
			insert = !insert;
			break;
		case CTL_CH('x'):
		case CTL_CH('u'):
			BEGINNING_OF_LINE();
3480e3ec:	e3a00008 	mov	r0, #8
3480e3f0:	ebffeddc 	bl	34809b68 <putc>
3480e3f4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e3f8:	e2433001 	sub	r3, r3, #1
3480e3fc:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e400:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e404:	e3530000 	cmp	r3, #0
3480e408:	1afffff7 	bne	3480e3ec <readline_into_buffer+0x460>
			ERASE_TO_EOL();
3480e40c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480e410:	e3510000 	cmp	r1, #0
3480e414:	01a0a001 	moveq	sl, r1
3480e418:	0affff1d 	beq	3480e094 <readline_into_buffer+0x108>
3480e41c:	e59f0444 	ldr	r0, [pc, #1092]	; 3480e868 <readline_into_buffer+0x8dc>
3480e420:	e59f2444 	ldr	r2, [pc, #1092]	; 3480e86c <readline_into_buffer+0x8e0>
3480e424:	ebffede3 	bl	34809bb8 <printf>
3480e428:	e3a00008 	mov	r0, #8
3480e42c:	ebffedcd 	bl	34809b68 <putc>
3480e430:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e434:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e438:	e2433001 	sub	r3, r3, #1
3480e43c:	e1530002 	cmp	r3, r2
3480e440:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e444:	8afffff7 	bhi	3480e428 <readline_into_buffer+0x49c>
3480e448:	eaffff10 	b	3480e090 <readline_into_buffer+0x104>
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
3480e44c:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480e450:	e35a0000 	cmp	sl, #0
3480e454:	0affff0e 	beq	3480e094 <readline_into_buffer+0x108>
				wlen = eol_num - num;
3480e458:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
				num--;
3480e45c:	e24a0001 	sub	r0, sl, #1
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
3480e460:	e06a9009 	rsb	r9, sl, r9
				num--;
				memmove(&buf[num], &buf[num+1], wlen);
3480e464:	e084100a 	add	r1, r4, sl
3480e468:	e1a02009 	mov	r2, r9
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
				num--;
3480e46c:	e58d0034 	str	r0, [sp, #52]	; 0x34
				memmove(&buf[num], &buf[num+1], wlen);
3480e470:	e0840000 	add	r0, r4, r0
3480e474:	eb003961 	bl	3481ca00 <memmove>
				getcmd_putch(CTL_BACKSPACE);
3480e478:	e3a00008 	mov	r0, #8
3480e47c:	ebffedb9 	bl	34809b68 <putc>
				putnstr(buf + num, wlen);
3480e480:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e484:	e59f03d8 	ldr	r0, [pc, #984]	; 3480e864 <readline_into_buffer+0x8d8>
3480e488:	e1a01009 	mov	r1, r9
3480e48c:	e0842002 	add	r2, r4, r2
3480e490:	ebffedc8 	bl	34809bb8 <printf>
				getcmd_putch(' ');
3480e494:	e3a00020 	mov	r0, #32
3480e498:	ebffedb2 	bl	34809b68 <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480e49c:	e3a00008 	mov	r0, #8
3480e4a0:	ebffedb0 	bl	34809b68 <putc>
				} while (wlen--);
3480e4a4:	e2599001 	subs	r9, r9, #1
3480e4a8:	2afffffb 	bcs	3480e49c <readline_into_buffer+0x510>
				eol_num--;
3480e4ac:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e4b0:	e2433001 	sub	r3, r3, #1
3480e4b4:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e4b8:	eafffef4 	b	3480e090 <readline_into_buffer+0x104>
static char* hist_prev(void)
{
	char *ret;
	int old_cur;

	if (hist_cur < 0)
3480e4bc:	e5953000 	ldr	r3, [r5]
3480e4c0:	e3530000 	cmp	r3, #0
3480e4c4:	ba000024 	blt	3480e55c <readline_into_buffer+0x5d0>
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
3480e4c8:	e2432001 	sub	r2, r3, #1
3480e4cc:	e3720001 	cmn	r2, #1
3480e4d0:	e5852000 	str	r2, [r5]
		hist_cur = hist_max;
3480e4d4:	05962004 	ldreq	r2, [r6, #4]

	if (hist_cur == hist_add_idx) {
3480e4d8:	e5961008 	ldr	r1, [r6, #8]
	if (hist_cur < 0)
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;
3480e4dc:	05852000 	streq	r2, [r5]

	if (hist_cur == hist_add_idx) {
3480e4e0:	e5952000 	ldr	r2, [r5]
3480e4e4:	e1520001 	cmp	r2, r1
		hist_cur = old_cur;
3480e4e8:	05853000 	streq	r3, [r5]

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;

	if (hist_cur == hist_add_idx) {
3480e4ec:	0a00001a 	beq	3480e55c <readline_into_buffer+0x5d0>
		hist_cur = old_cur;
		ret = NULL;
	} else
		ret = hist_list[hist_cur];
3480e4f0:	e59f3378 	ldr	r3, [pc, #888]	; 3480e870 <readline_into_buffer+0x8e4>
3480e4f4:	e0832102 	add	r2, r3, r2, lsl #2
3480e4f8:	e512abd4 	ldr	sl, [r2, #-3028]	; 0xbd4
3480e4fc:	ea000011 	b	3480e548 <readline_into_buffer+0x5bc>

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480e500:	e5953000 	ldr	r3, [r5]
3480e504:	e3530000 	cmp	r3, #0
3480e508:	ba000013 	blt	3480e55c <readline_into_buffer+0x5d0>
		return NULL;

	if (hist_cur == hist_add_idx)
3480e50c:	e5962008 	ldr	r2, [r6, #8]
3480e510:	e1530002 	cmp	r3, r2
3480e514:	0a000010 	beq	3480e55c <readline_into_buffer+0x5d0>
		return NULL;

	if (++hist_cur > hist_max)
3480e518:	e5961004 	ldr	r1, [r6, #4]
3480e51c:	e2833001 	add	r3, r3, #1
3480e520:	e1530001 	cmp	r3, r1
		hist_cur = 0;
3480e524:	c3a00000 	movgt	r0, #0
		return NULL;

	if (hist_cur == hist_add_idx)
		return NULL;

	if (++hist_cur > hist_max)
3480e528:	e5853000 	str	r3, [r5]
		hist_cur = 0;
3480e52c:	c5850000 	strgt	r0, [r5]

	if (hist_cur == hist_add_idx) {
3480e530:	e5953000 	ldr	r3, [r5]
3480e534:	e1530002 	cmp	r3, r2
3480e538:	0a000005 	beq	3480e554 <readline_into_buffer+0x5c8>
		ret = "";
	} else
		ret = hist_list[hist_cur];
3480e53c:	e59f132c 	ldr	r1, [pc, #812]	; 3480e870 <readline_into_buffer+0x8e4>
3480e540:	e0813103 	add	r3, r1, r3, lsl #2
3480e544:	e513abd4 	ldr	sl, [r3, #-3028]	; 0xbd4
			if (ichar == CTL_CH('p'))
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
3480e548:	e35a0000 	cmp	sl, #0
3480e54c:	1a00000a 	bne	3480e57c <readline_into_buffer+0x5f0>
3480e550:	ea000001 	b	3480e55c <readline_into_buffer+0x5d0>

	if (++hist_cur > hist_max)
		hist_cur = 0;

	if (hist_cur == hist_add_idx) {
		ret = "";
3480e554:	e59fa310 	ldr	sl, [pc, #784]	; 3480e86c <readline_into_buffer+0x8e0>
3480e558:	ea000007 	b	3480e57c <readline_into_buffer+0x5f0>
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
				getcmd_cbeep();
3480e55c:	e3a00007 	mov	r0, #7
3480e560:	ebffed80 	bl	34809b68 <putc>
3480e564:	eafffec9 	b	3480e090 <readline_into_buffer+0x104>
				continue;
			}

			/* nuke the current line */
			/* first, go home */
			BEGINNING_OF_LINE();
3480e568:	e3a00008 	mov	r0, #8
3480e56c:	ebffed7d 	bl	34809b68 <putc>
3480e570:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e574:	e2433001 	sub	r3, r3, #1
3480e578:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e57c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480e580:	e3530000 	cmp	r3, #0
3480e584:	1afffff7 	bne	3480e568 <readline_into_buffer+0x5dc>

			/* erase to end of line */
			ERASE_TO_EOL();
3480e588:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480e58c:	e3510000 	cmp	r1, #0
3480e590:	0a00000a 	beq	3480e5c0 <readline_into_buffer+0x634>
3480e594:	e59f02cc 	ldr	r0, [pc, #716]	; 3480e868 <readline_into_buffer+0x8dc>
3480e598:	e59f22cc 	ldr	r2, [pc, #716]	; 3480e86c <readline_into_buffer+0x8e0>
3480e59c:	ebffed85 	bl	34809bb8 <printf>
3480e5a0:	e3a00008 	mov	r0, #8
3480e5a4:	ebffed6f 	bl	34809b68 <putc>
3480e5a8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e5ac:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480e5b0:	e2433001 	sub	r3, r3, #1
3480e5b4:	e1530002 	cmp	r3, r2
3480e5b8:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480e5bc:	8afffff7 	bhi	3480e5a0 <readline_into_buffer+0x614>

			/* copy new line into place and display */
			strcpy(buf, hline);
3480e5c0:	e1a0100a 	mov	r1, sl
3480e5c4:	e1a00004 	mov	r0, r4
3480e5c8:	eb0037c6 	bl	3481c4e8 <strcpy>
			eol_num = strlen(buf);
3480e5cc:	e1a00004 	mov	r0, r4
3480e5d0:	eb003829 	bl	3481c67c <strlen>
			REFRESH_TO_EOL();
3480e5d4:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
			/* erase to end of line */
			ERASE_TO_EOL();

			/* copy new line into place and display */
			strcpy(buf, hline);
			eol_num = strlen(buf);
3480e5d8:	e1a01000 	mov	r1, r0
3480e5dc:	e58d0030 	str	r0, [sp, #48]	; 0x30
			REFRESH_TO_EOL();
3480e5e0:	e1520001 	cmp	r2, r1
3480e5e4:	2afffea9 	bcs	3480e090 <readline_into_buffer+0x104>
3480e5e8:	e0621001 	rsb	r1, r2, r1
3480e5ec:	e59f0270 	ldr	r0, [pc, #624]	; 3480e864 <readline_into_buffer+0x8d8>
3480e5f0:	e0842002 	add	r2, r4, r2
3480e5f4:	ebffed6f 	bl	34809bb8 <printf>
3480e5f8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480e5fc:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480e600:	eafffea2 	b	3480e090 <readline_into_buffer+0x104>
			}
			break;
		}
#endif
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
3480e604:	e3a03c01 	mov	r3, #256	; 0x100
3480e608:	e58d3004 	str	r3, [sp, #4]
3480e60c:	e1a01007 	mov	r1, r7
3480e610:	e28d2034 	add	r2, sp, #52	; 0x34
3480e614:	e28d3030 	add	r3, sp, #48	; 0x30
3480e618:	e58d4000 	str	r4, [sp]
3480e61c:	ebfffe1e 	bl	3480de9c <cread_add_char>
3480e620:	eafffe9a 	b	3480e090 <readline_into_buffer+0x104>
	}
}

static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);
3480e624:	e59f5228 	ldr	r5, [pc, #552]	; 3480e854 <readline_into_buffer+0x8c8>
3480e628:	e59f3240 	ldr	r3, [pc, #576]	; 3480e870 <readline_into_buffer+0x8e4>
3480e62c:	e5952008 	ldr	r2, [r5, #8]
3480e630:	e1a01004 	mov	r1, r4
3480e634:	e0833102 	add	r3, r3, r2, lsl #2
3480e638:	e5130bd4 	ldr	r0, [r3, #-3028]	; 0xbd4
3480e63c:	eb0037a9 	bl	3481c4e8 <strcpy>

	if (++hist_add_idx >= HIST_MAX)
3480e640:	e995000c 	ldmib	r5, {r2, r3}
3480e644:	e2833001 	add	r3, r3, #1
		hist_add_idx = 0;
3480e648:	e3530013 	cmp	r3, #19
3480e64c:	c3a03000 	movgt	r3, #0

	if (hist_add_idx > hist_max)
3480e650:	e1530002 	cmp	r3, r2
static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);

	if (++hist_add_idx >= HIST_MAX)
		hist_add_idx = 0;
3480e654:	e5853008 	str	r3, [r5, #8]

	if (hist_add_idx > hist_max)
		hist_max = hist_add_idx;
3480e658:	c5853004 	strgt	r3, [r5, #4]

	hist_num++;
3480e65c:	e59f31f0 	ldr	r3, [pc, #496]	; 3480e854 <readline_into_buffer+0x8c8>
3480e660:	e593200c 	ldr	r2, [r3, #12]
3480e664:	e2822001 	add	r2, r2, #1
3480e668:	e583200c 	str	r2, [r3, #12]
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480e66c:	e59f31e0 	ldr	r3, [pc, #480]	; 3480e854 <readline_into_buffer+0x8c8>

		if (prompt)
			puts (prompt);

		rc = cread_line(prompt, p, &len, timeout);
		return rc < 0 ? rc : len;
3480e670:	e1a00006 	mov	r0, r6
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480e674:	e5932008 	ldr	r2, [r3, #8]
3480e678:	e59f31d8 	ldr	r3, [pc, #472]	; 3480e858 <readline_into_buffer+0x8cc>
3480e67c:	e5832000 	str	r2, [r3]
3480e680:	ea000071 	b	3480e84c <readline_into_buffer+0x8c0>
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
					return -2;	/* timed out */
3480e684:	e3e00001 	mvn	r0, #1
3480e688:	ea00006f 	b	3480e84c <readline_into_buffer+0x8c0>
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480e68c:	e3500000 	cmp	r0, #0
		return rc < 0 ? rc : len;

	} else {
#endif	/* CONFIG_CMDLINE_EDITING */
	char * p_buf = p;
	int	n = 0;				/* buffer index		*/
3480e690:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int	plen = 0;			/* prompt length	*/
3480e694:	01a05000 	moveq	r5, r0
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480e698:	0a000003 	beq	3480e6ac <readline_into_buffer+0x720>
		plen = strlen (prompt);
3480e69c:	eb0037f6 	bl	3481c67c <strlen>
3480e6a0:	e1a05000 	mov	r5, r0
		puts (prompt);
3480e6a4:	e1a00006 	mov	r0, r6
3480e6a8:	ebffed38 	bl	34809b90 <puts>
	}
	col = plen;
3480e6ac:	e28d6040 	add	r6, sp, #64	; 0x40
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480e6b0:	e59fa1bc 	ldr	sl, [pc, #444]	; 3480e874 <readline_into_buffer+0x8e8>
	/* print prompt */
	if (prompt) {
		plen = strlen (prompt);
		puts (prompt);
	}
	col = plen;
3480e6b4:	e5265008 	str	r5, [r6, #-8]!
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480e6b8:	e28d703c 	add	r7, sp, #60	; 0x3c
			while (col > plen) {
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480e6bc:	e3a09000 	mov	r9, #0
3480e6c0:	e1a01004 	mov	r1, r4
		while (!tstc()) {
			show_activity(0);
			WATCHDOG_RESET();
		}
#endif
		c = getc();
3480e6c4:	e58d100c 	str	r1, [sp, #12]
3480e6c8:	ebffed14 	bl	34809b20 <getc>
3480e6cc:	e6efb070 	uxtb	fp, r0

		/*
		 * Special character handling
		 */
		switch (c) {
3480e6d0:	e35b000a 	cmp	fp, #10
3480e6d4:	e59d100c 	ldr	r1, [sp, #12]
3480e6d8:	0a000012 	beq	3480e728 <readline_into_buffer+0x79c>
3480e6dc:	8a000006 	bhi	3480e6fc <readline_into_buffer+0x770>
3480e6e0:	e35b0003 	cmp	fp, #3
3480e6e4:	0a000016 	beq	3480e744 <readline_into_buffer+0x7b8>
3480e6e8:	e35b0008 	cmp	fp, #8
3480e6ec:	0a000030 	beq	3480e7b4 <readline_into_buffer+0x828>
3480e6f0:	e35b0000 	cmp	fp, #0
3480e6f4:	0afffff2 	beq	3480e6c4 <readline_into_buffer+0x738>
3480e6f8:	ea000034 	b	3480e7d0 <readline_into_buffer+0x844>
3480e6fc:	e35b0015 	cmp	fp, #21
3480e700:	0a000018 	beq	3480e768 <readline_into_buffer+0x7dc>
3480e704:	8a000002 	bhi	3480e714 <readline_into_buffer+0x788>
3480e708:	e35b000d 	cmp	fp, #13
3480e70c:	1a00002f 	bne	3480e7d0 <readline_into_buffer+0x844>
3480e710:	ea000004 	b	3480e728 <readline_into_buffer+0x79c>
3480e714:	e35b0017 	cmp	fp, #23
3480e718:	0a000018 	beq	3480e780 <readline_into_buffer+0x7f4>
3480e71c:	e35b007f 	cmp	fp, #127	; 0x7f
3480e720:	1a00002a 	bne	3480e7d0 <readline_into_buffer+0x844>
3480e724:	ea000022 	b	3480e7b4 <readline_into_buffer+0x828>
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480e728:	e3a03000 	mov	r3, #0
3480e72c:	e1a0b001 	mov	fp, r1
			puts ("\r\n");
3480e730:	e59f0140 	ldr	r0, [pc, #320]	; 3480e878 <readline_into_buffer+0x8ec>
		 * Special character handling
		 */
		switch (c) {
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480e734:	e5c13000 	strb	r3, [r1]
			puts ("\r\n");
3480e738:	ebffed14 	bl	34809b90 <puts>
			return (p - p_buf);
3480e73c:	e064000b 	rsb	r0, r4, fp
3480e740:	ea000041 	b	3480e84c <readline_into_buffer+0x8c0>

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
3480e744:	e3a03000 	mov	r3, #0
3480e748:	e5c43000 	strb	r3, [r4]
			return (-1);
3480e74c:	e3e00000 	mvn	r0, #0
3480e750:	ea00003d 	b	3480e84c <readline_into_buffer+0x8c0>

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
3480e754:	e59f0120 	ldr	r0, [pc, #288]	; 3480e87c <readline_into_buffer+0x8f0>
3480e758:	ebffed0c 	bl	34809b90 <puts>
				--col;
3480e75c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480e760:	e2433001 	sub	r3, r3, #1
3480e764:	e58d3038 	str	r3, [sp, #56]	; 0x38
		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return (-1);

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
3480e768:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480e76c:	e1530005 	cmp	r3, r5
3480e770:	cafffff7 	bgt	3480e754 <readline_into_buffer+0x7c8>
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480e774:	e58d903c 	str	r9, [sp, #60]	; 0x3c
			continue;
3480e778:	e1a01004 	mov	r1, r4
3480e77c:	eaffffd0 	b	3480e6c4 <readline_into_buffer+0x738>

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
				p=delete_char(p_buf, p, &col, &n, plen);
3480e780:	e1a03007 	mov	r3, r7
3480e784:	e1a00004 	mov	r0, r4
3480e788:	e1a02006 	mov	r2, r6
3480e78c:	e58d5000 	str	r5, [sp]
3480e790:	ebfffd8b 	bl	3480ddc4 <delete_char>
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480e794:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
				p=delete_char(p_buf, p, &col, &n, plen);
3480e798:	e1a01000 	mov	r1, r0
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480e79c:	e3530000 	cmp	r3, #0
3480e7a0:	daffffc7 	ble	3480e6c4 <readline_into_buffer+0x738>
3480e7a4:	e5d03000 	ldrb	r3, [r0]
3480e7a8:	e3530020 	cmp	r3, #32
3480e7ac:	1afffff3 	bne	3480e780 <readline_into_buffer+0x7f4>
3480e7b0:	eaffffc3 	b	3480e6c4 <readline_into_buffer+0x738>
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480e7b4:	e1a00004 	mov	r0, r4
3480e7b8:	e1a02006 	mov	r2, r6
3480e7bc:	e1a03007 	mov	r3, r7
3480e7c0:	e58d5000 	str	r5, [sp]
3480e7c4:	ebfffd7e 	bl	3480ddc4 <delete_char>
3480e7c8:	e1a01000 	mov	r1, r0
			continue;
3480e7cc:	eaffffbc 	b	3480e6c4 <readline_into_buffer+0x738>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < CONFIG_SYS_CBSIZE-2) {
3480e7d0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480e7d4:	e35300fd 	cmp	r3, #253	; 0xfd
3480e7d8:	ca000016 	bgt	3480e838 <readline_into_buffer+0x8ac>
				if (c == '\t') {	/* expand TABs		*/
3480e7dc:	e35b0009 	cmp	fp, #9
3480e7e0:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
3480e7e4:	1a000008 	bne	3480e80c <readline_into_buffer+0x880>
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480e7e8:	e2000007 	and	r0, r0, #7
3480e7ec:	e08a0000 	add	r0, sl, r0
3480e7f0:	e58d100c 	str	r1, [sp, #12]
3480e7f4:	ebffece5 	bl	34809b90 <puts>
					col += 8 - (col&07);
3480e7f8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480e7fc:	e3c33007 	bic	r3, r3, #7
3480e800:	e2833008 	add	r3, r3, #8
3480e804:	e58d3038 	str	r3, [sp, #56]	; 0x38
3480e808:	ea000004 	b	3480e820 <readline_into_buffer+0x894>
				} else {
					++col;		/* echo input		*/
3480e80c:	e2800001 	add	r0, r0, #1
3480e810:	e58d0038 	str	r0, [sp, #56]	; 0x38
					putc (c);
3480e814:	e1a0000b 	mov	r0, fp
3480e818:	e58d100c 	str	r1, [sp, #12]
3480e81c:	ebffecd1 	bl	34809b68 <putc>
3480e820:	e59d100c 	ldr	r1, [sp, #12]
				}
				*p++ = c;
3480e824:	e4c1b001 	strb	fp, [r1], #1
				++n;
3480e828:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480e82c:	e2833001 	add	r3, r3, #1
3480e830:	e58d303c 	str	r3, [sp, #60]	; 0x3c
3480e834:	eaffffa2 	b	3480e6c4 <readline_into_buffer+0x738>
			} else {			/* Buffer full		*/
				putc ('\a');
3480e838:	e3a00007 	mov	r0, #7
3480e83c:	e58d100c 	str	r1, [sp, #12]
3480e840:	ebffecc8 	bl	34809b68 <putc>
3480e844:	e59d100c 	ldr	r1, [sp, #12]
3480e848:	eaffff9d 	b	3480e6c4 <readline_into_buffer+0x738>
		}
	}
#ifdef CONFIG_CMDLINE_EDITING
	}
#endif
}
3480e84c:	e28dd040 	add	sp, sp, #64	; 0x40
3480e850:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480e854:	3482a2ac 	.word	0x3482a2ac
3480e858:	34828d08 	.word	0x34828d08
3480e85c:	3482b6cc 	.word	0x3482b6cc
3480e860:	3482b6d0 	.word	0x3482b6d0
3480e864:	34826bb2 	.word	0x34826bb2
3480e868:	34826bb7 	.word	0x34826bb7
3480e86c:	34824003 	.word	0x34824003
3480e870:	3482c2a4 	.word	0x3482c2a4
3480e874:	34821644 	.word	0x34821644
3480e878:	34826bbb 	.word	0x34826bbb
3480e87c:	34821640 	.word	0x34821640

3480e880 <readline>:
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480e880:	e59f300c 	ldr	r3, [pc, #12]	; 3480e894 <readline+0x14>

	return readline_into_buffer(prompt, console_buffer, 0);
3480e884:	e59f100c 	ldr	r1, [pc, #12]	; 3480e898 <readline+0x18>
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480e888:	e3a02000 	mov	r2, #0
3480e88c:	e5432b84 	strb	r2, [r3, #-2948]	; 0xb84

	return readline_into_buffer(prompt, console_buffer, 0);
3480e890:	eafffdbd 	b	3480df8c <readline_into_buffer>
3480e894:	3482c2a4 	.word	0x3482c2a4
3480e898:	3482b720 	.word	0x3482b720

3480e89c <parse_line>:
}

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
3480e89c:	e92d4010 	push	{r4, lr}
	int nargs = 0;
3480e8a0:	e1a0c001 	mov	ip, r1
3480e8a4:	e3a04000 	mov	r4, #0
3480e8a8:	e1a02000 	mov	r2, r0
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {

		/* skip any white space */
		while (isblank(*line))
3480e8ac:	e4d03001 	ldrb	r3, [r0], #1
3480e8b0:	e3530020 	cmp	r3, #32
3480e8b4:	13530009 	cmpne	r3, #9
3480e8b8:	0afffffa 	beq	3480e8a8 <parse_line+0xc>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
3480e8bc:	e3530000 	cmp	r3, #0
3480e8c0:	0a000005 	beq	3480e8dc <parse_line+0x40>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
3480e8c4:	e48c2004 	str	r2, [ip], #4
3480e8c8:	e2844001 	add	r4, r4, #1

		/* find end of string */
		while (*line && !isblank(*line))
3480e8cc:	e1a00002 	mov	r0, r2
3480e8d0:	e4d23001 	ldrb	r3, [r2], #1
3480e8d4:	e3530000 	cmp	r3, #0
3480e8d8:	1a000001 	bne	3480e8e4 <parse_line+0x48>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
3480e8dc:	e7813104 	str	r3, [r1, r4, lsl #2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
3480e8e0:	ea00000b 	b	3480e914 <parse_line+0x78>
		}

		argv[nargs++] = line;	/* begin of argument string	*/

		/* find end of string */
		while (*line && !isblank(*line))
3480e8e4:	e3530009 	cmp	r3, #9
3480e8e8:	13530020 	cmpne	r3, #32
3480e8ec:	03a03000 	moveq	r3, #0
3480e8f0:	13a03001 	movne	r3, #1
3480e8f4:	1afffff4 	bne	3480e8cc <parse_line+0x30>
	int nargs = 0;

#ifdef DEBUG_PARSER
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {
3480e8f8:	e3540010 	cmp	r4, #16
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		*line++ = '\0';		/* terminate current arg	 */
3480e8fc:	e5c03000 	strb	r3, [r0]
3480e900:	12800001 	addne	r0, r0, #1
3480e904:	1affffe7 	bne	3480e8a8 <parse_line+0xc>
	}

	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
3480e908:	e59f000c 	ldr	r0, [pc, #12]	; 3480e91c <parse_line+0x80>
3480e90c:	e1a01004 	mov	r1, r4
3480e910:	ebffeca8 	bl	34809bb8 <printf>

#ifdef DEBUG_PARSER
	printf ("parse_line: nargs=%d\n", nargs);
#endif
	return (nargs);
}
3480e914:	e1a00004 	mov	r0, r4
3480e918:	e8bd8010 	pop	{r4, pc}
3480e91c:	34826bbe 	.word	0x34826bbe

3480e920 <run_command>:
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480e920:	e3a01003 	mov	r1, #3
3480e924:	eafff702 	b	3480c534 <parse_string_outer>

3480e928 <run_command_list>:
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480e928:	e3710001 	cmn	r1, #1
	return rcode;
}
#endif

int run_command_list(const char *cmd, int len, int flag)
{
3480e92c:	e92d4070 	push	{r4, r5, r6, lr}
3480e930:	e1a06000 	mov	r6, r0
3480e934:	e1a04001 	mov	r4, r1
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480e938:	1a000002 	bne	3480e948 <run_command_list+0x20>
		len = strlen(cmd);
3480e93c:	eb00374e 	bl	3481c67c <strlen>
#endif

int run_command_list(const char *cmd, int len, int flag)
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
3480e940:	e1a05006 	mov	r5, r6
3480e944:	ea000008 	b	3480e96c <run_command_list+0x44>
		/* the built-in parser will change our string if it sees \n */
		need_buff = strchr(cmd, '\n') != NULL;
#endif
	}
	if (need_buff) {
		buff = malloc(len + 1);
3480e948:	e2810001 	add	r0, r1, #1
3480e94c:	ebffee60 	bl	3480a2d4 <malloc>
		if (!buff)
3480e950:	e2505000 	subs	r5, r0, #0
3480e954:	0a000008 	beq	3480e97c <run_command_list+0x54>
			return 1;
		memcpy(buff, cmd, len);
3480e958:	e1a01006 	mov	r1, r6
3480e95c:	e1a02004 	mov	r2, r4
3480e960:	eb003809 	bl	3481c98c <memcpy>
		buff[len] = '\0';
3480e964:	e3a03000 	mov	r3, #0
3480e968:	e7c53004 	strb	r3, [r5, r4]
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480e96c:	e1a00005 	mov	r0, r5
3480e970:	e3a01002 	mov	r1, #2
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480e974:	e8bd4070 	pop	{r4, r5, r6, lr}
			return 1;
		memcpy(buff, cmd, len);
		buff[len] = '\0';
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480e978:	eafff6ed 	b	3480c534 <parse_string_outer>
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480e97c:	e3a00001 	mov	r0, #1
3480e980:	e8bd8070 	pop	{r4, r5, r6, pc}

3480e984 <main_loop>:
#endif	/* CONFIG_BOOTDELAY >= 0  */

/****************************************************************************/

void main_loop (void)
{
3480e984:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
		setenv ("ver", version_string);  /* set version variable */
	}
#endif /* CONFIG_VERSION_VARIABLE */

#ifdef CONFIG_SYS_HUSH_PARSER
	u_boot_hush_start ();
3480e988:	ebfffacc 	bl	3480d4c0 <u_boot_hush_start>
#if defined(CONFIG_UPDATE_TFTP)
	update_tftp (0UL);
#endif /* CONFIG_UPDATE_TFTP */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
3480e98c:	e59f00fc 	ldr	r0, [pc, #252]	; 3480ea90 <main_loop+0x10c>
3480e990:	ebffe59a 	bl	34808000 <getenv>
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
3480e994:	e3500000 	cmp	r0, #0
3480e998:	03a04001 	moveq	r4, #1
3480e99c:	0a000003 	beq	3480e9b0 <main_loop+0x2c>
3480e9a0:	e3a01000 	mov	r1, #0
3480e9a4:	e3a0200a 	mov	r2, #10
3480e9a8:	eb003b0f 	bl	3481d5ec <simple_strtol>
3480e9ac:	e1a04000 	mov	r4, r0
		        (unsigned)bootlimit);
		s = getenv ("altbootcmd");
	}
	else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");
3480e9b0:	e59f00dc 	ldr	r0, [pc, #220]	; 3480ea94 <main_loop+0x110>
3480e9b4:	ebffe591 	bl	34808000 <getenv>

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480e9b8:	e3500000 	cmp	r0, #0
3480e9bc:	13740001 	cmnne	r4, #1
3480e9c0:	e1a06000 	mov	r6, r0
3480e9c4:	0a00002f 	beq	3480ea88 <main_loop+0x104>
	int abort = 0;

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480e9c8:	e3540000 	cmp	r4, #0
#ifndef CONFIG_MENU
static inline
#endif
int abortboot(int bootdelay)
{
	int abort = 0;
3480e9cc:	b3a05000 	movlt	r5, #0

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480e9d0:	ba00001d 	blt	3480ea4c <main_loop+0xc8>
		printf("Hit any key to stop autoboot: %2d ", bootdelay);
3480e9d4:	e1a01004 	mov	r1, r4
3480e9d8:	e59f00b8 	ldr	r0, [pc, #184]	; 3480ea98 <main_loop+0x114>
3480e9dc:	ebffec75 	bl	34809bb8 <printf>
	/*
	 * Check if key already pressed
	 * Don't check if bootdelay < 0
	 */
	if (bootdelay >= 0) {
		if (tstc()) {	/* we got a key press	*/
3480e9e0:	ebffec57 	bl	34809b44 <tstc>
3480e9e4:	e2505000 	subs	r5, r0, #0
3480e9e8:	0a000017 	beq	3480ea4c <main_loop+0xc8>
			(void) getc();  /* consume input	*/
3480e9ec:	ebffec4b 	bl	34809b20 <getc>
			puts ("\b\b\b 0");
3480e9f0:	e59f00a4 	ldr	r0, [pc, #164]	; 3480ea9c <main_loop+0x118>
3480e9f4:	ebffec65 	bl	34809b90 <puts>
			abort = 1;	/* don't auto boot	*/
3480e9f8:	e3a05001 	mov	r5, #1
3480e9fc:	ea000012 	b	3480ea4c <main_loop+0xc8>
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
3480ea00:	ebffec4f 	bl	34809b44 <tstc>
3480ea04:	e3500000 	cmp	r0, #0
3480ea08:	0a000003 	beq	3480ea1c <main_loop+0x98>
				abort  = 1;	/* don't auto boot	*/
				bootdelay = 0;	/* no more delay	*/
# ifdef CONFIG_MENUKEY
				menukey = getc();
# else
				(void) getc();  /* consume input	*/
3480ea0c:	ebffec43 	bl	34809b20 <getc>

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
				abort  = 1;	/* don't auto boot	*/
3480ea10:	e3a05001 	mov	r5, #1
				bootdelay = 0;	/* no more delay	*/
3480ea14:	e3a04000 	mov	r4, #0
3480ea18:	ea000008 	b	3480ea40 <main_loop+0xbc>
# else
				(void) getc();  /* consume input	*/
# endif
				break;
			}
			udelay(10000);
3480ea1c:	e3020710 	movw	r0, #10000	; 0x2710
3480ea20:	eb003864 	bl	3481cbb8 <udelay>
	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
3480ea24:	e2877001 	add	r7, r7, #1
3480ea28:	e3570063 	cmp	r7, #99	; 0x63
3480ea2c:	c3a05000 	movgt	r5, #0
3480ea30:	d3a05001 	movle	r5, #1
3480ea34:	e3550000 	cmp	r5, #0
3480ea38:	1afffff0 	bne	3480ea00 <main_loop+0x7c>
#endif

	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
3480ea3c:	e2444001 	sub	r4, r4, #1
				break;
			}
			udelay(10000);
		}

		printf("\b\b\b%2d ", bootdelay);
3480ea40:	e59f0058 	ldr	r0, [pc, #88]	; 3480eaa0 <main_loop+0x11c>
3480ea44:	e1a01004 	mov	r1, r4
3480ea48:	ebffec5a 	bl	34809bb8 <printf>
			abort = 1;	/* don't auto boot	*/
		}
	}
#endif

	while ((bootdelay > 0) && (!abort)) {
3480ea4c:	e2753001 	rsbs	r3, r5, #1
3480ea50:	33a03000 	movcc	r3, #0
3480ea54:	e3540000 	cmp	r4, #0
3480ea58:	d3a03000 	movle	r3, #0
3480ea5c:	e3530000 	cmp	r3, #0
3480ea60:	13a07000 	movne	r7, #0
3480ea64:	1affffef 	bne	3480ea28 <main_loop+0xa4>
		}

		printf("\b\b\b%2d ", bootdelay);
	}

	putc('\n');
3480ea68:	e3a0000a 	mov	r0, #10
3480ea6c:	ebffec3d 	bl	34809b68 <putc>
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480ea70:	e3550000 	cmp	r5, #0
3480ea74:	1a000003 	bne	3480ea88 <main_loop+0x104>
# ifdef CONFIG_AUTOBOOT_KEYED
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

		run_command_list(s, -1, 0);
3480ea78:	e1a00006 	mov	r0, r6
3480ea7c:	e3e01000 	mvn	r1, #0
3480ea80:	e1a02005 	mov	r2, r5
3480ea84:	ebffffa7 	bl	3480e928 <run_command_list>

	/*
	 * Main Loop for Monitor Command Processing
	 */
#ifdef CONFIG_SYS_HUSH_PARSER
	parse_file_outer();
3480ea88:	ebfffa7b 	bl	3480d47c <parse_file_outer>
3480ea8c:	eafffffe 	b	3480ea8c <main_loop+0x108>
3480ea90:	34826bdd 	.word	0x34826bdd
3480ea94:	3482307d 	.word	0x3482307d
3480ea98:	34826be7 	.word	0x34826be7
3480ea9c:	34826c0a 	.word	0x34826c0a
3480eaa0:	34826c10 	.word	0x34826c10

3480eaa4 <do_run>:
#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int i;

	if (argc < 2)
3480eaa4:	e3520001 	cmp	r2, #1

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480eaa8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;
3480eaac:	d3e00000 	mvnle	r0, #0

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480eab0:	e1a04002 	mov	r4, r2
	int i;

	if (argc < 2)
3480eab4:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
}

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
3480eab8:	e2836004 	add	r6, r3, #4
3480eabc:	e3a05001 	mov	r5, #1
{
	int i;

	if (argc < 2)
3480eac0:	e1a07006 	mov	r7, r6
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
3480eac4:	e4960004 	ldr	r0, [r6], #4
3480eac8:	ebffe54c 	bl	34808000 <getenv>
3480eacc:	e3500000 	cmp	r0, #0
3480ead0:	1a000004 	bne	3480eae8 <do_run+0x44>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
3480ead4:	e59f0034 	ldr	r0, [pc, #52]	; 3480eb10 <do_run+0x6c>
3480ead8:	e5971000 	ldr	r1, [r7]
3480eadc:	ebffec35 	bl	34809bb8 <printf>
			return 1;
3480eae0:	e3a00001 	mov	r0, #1
3480eae4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480eae8:	e3a01003 	mov	r1, #3
3480eaec:	ebfff690 	bl	3480c534 <parse_string_outer>
		if ((arg = getenv (argv[i])) == NULL) {
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
3480eaf0:	e3500000 	cmp	r0, #0
3480eaf4:	1a000003 	bne	3480eb08 <do_run+0x64>
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
3480eaf8:	e2855001 	add	r5, r5, #1
3480eafc:	e1550004 	cmp	r5, r4
3480eb00:	baffffee 	blt	3480eac0 <do_run+0x1c>
3480eb04:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
			return 1;
3480eb08:	e3a00001 	mov	r0, #1
	}
	return 0;
}
3480eb0c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480eb10:	34825509 	.word	0x34825509

3480eb14 <get_ram_size>:
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
{
3480eb14:	e92d40f0 	push	{r4, r5, r6, r7, lr}
3480eb18:	e24dd084 	sub	sp, sp, #132	; 0x84
3480eb1c:	e1a03000 	mov	r3, r0
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480eb20:	e1a04121 	lsr	r4, r1, #2
3480eb24:	e1a021a1 	lsr	r2, r1, #3
3480eb28:	e24d0004 	sub	r0, sp, #4
	volatile long *addr;
	long           save[32];
	long           cnt;
	long           val;
	long           size;
	int            i = 0;
3480eb2c:	e3a0c000 	mov	ip, #0

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480eb30:	ea000005 	b	3480eb4c <get_ram_size+0x38>
		addr = base + cnt;	/* pointer arith! */
		sync ();
		save[i++] = *addr;
3480eb34:	e7935102 	ldr	r5, [r3, r2, lsl #2]
3480eb38:	e28cc001 	add	ip, ip, #1
3480eb3c:	e5a05004 	str	r5, [r0, #4]!
		sync ();
		*addr = ~cnt;
3480eb40:	e1e05002 	mvn	r5, r2
3480eb44:	e7835102 	str	r5, [r3, r2, lsl #2]
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480eb48:	e1a020c2 	asr	r2, r2, #1
3480eb4c:	e3520000 	cmp	r2, #0
3480eb50:	1afffff7 	bne	3480eb34 <get_ram_size+0x20>
		*addr = ~cnt;
	}

	addr = base;
	sync ();
	save[i] = *addr;
3480eb54:	e5935000 	ldr	r5, [r3]
3480eb58:	e1a0010c 	lsl	r0, ip, #2
3480eb5c:	e28d7080 	add	r7, sp, #128	; 0x80
3480eb60:	e0876000 	add	r6, r7, r0
3480eb64:	e5065080 	str	r5, [r6, #-128]	; 0x80
	sync ();
	*addr = 0;
3480eb68:	e5832000 	str	r2, [r3]

	sync ();
	if ((val = *addr) != 0) {
3480eb6c:	e5932000 	ldr	r2, [r3]
3480eb70:	e3520000 	cmp	r2, #0
3480eb74:	e1a0200d 	mov	r2, sp
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480eb78:	10820000 	addne	r0, r2, r0
3480eb7c:	008d5000 	addeq	r5, sp, r0
3480eb80:	03a02001 	moveq	r2, #1
	sync ();
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
3480eb84:	15835000 	strne	r5, [r3]
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480eb88:	13a02001 	movne	r2, #1
	save[i] = *addr;
	sync ();
	*addr = 0;

	sync ();
	if ((val = *addr) != 0) {
3480eb8c:	1a000003 	bne	3480eba0 <get_ram_size+0x8c>
3480eb90:	ea000018 	b	3480ebf8 <get_ram_size+0xe4>
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
3480eb94:	e5301004 	ldr	r1, [r0, #-4]!
3480eb98:	e7831102 	str	r1, [r3, r2, lsl #2]
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480eb9c:	e1a02082 	lsl	r2, r2, #1
3480eba0:	e1520004 	cmp	r2, r4
3480eba4:	3afffffa 	bcc	3480eb94 <get_ram_size+0x80>
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
		}
		return (0);
3480eba8:	e3a00000 	mov	r0, #0
3480ebac:	ea000014 	b	3480ec04 <get_ram_size+0xf0>
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
		*addr = save[--i];
3480ebb0:	e5356004 	ldr	r6, [r5, #-4]!
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
3480ebb4:	e7937102 	ldr	r7, [r3, r2, lsl #2]
		*addr = save[--i];
3480ebb8:	e7836102 	str	r6, [r3, r2, lsl #2]
		if (val != ~cnt) {
3480ebbc:	e1e06002 	mvn	r6, r2
3480ebc0:	e1570006 	cmp	r7, r6
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
3480ebc4:	e1a00102 	lsl	r0, r2, #2
		val = *addr;
		*addr = save[--i];
3480ebc8:	e24cc001 	sub	ip, ip, #1
3480ebcc:	e1a02082 	lsl	r2, r2, #1
		if (val != ~cnt) {
3480ebd0:	0a000008 	beq	3480ebf8 <get_ram_size+0xe4>
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480ebd4:	e1a0100d 	mov	r1, sp
3480ebd8:	e081c10c 	add	ip, r1, ip, lsl #2
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480ebdc:	ea000002 	b	3480ebec <get_ram_size+0xd8>
				addr  = base + cnt;
				*addr = save[--i];
3480ebe0:	e53c1004 	ldr	r1, [ip, #-4]!
3480ebe4:	e7831102 	str	r1, [r3, r2, lsl #2]
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480ebe8:	e1a02082 	lsl	r2, r2, #1
3480ebec:	e1520004 	cmp	r2, r4
3480ebf0:	3afffffa 	bcc	3480ebe0 <get_ram_size+0xcc>
3480ebf4:	ea000002 	b	3480ec04 <get_ram_size+0xf0>
			*addr = save[--i];
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480ebf8:	e1520004 	cmp	r2, r4
3480ebfc:	3affffeb 	bcc	3480ebb0 <get_ram_size+0x9c>
			}
			return (size);
		}
	}

	return (maxsize);
3480ec00:	e1a00001 	mov	r0, r1
}
3480ec04:	e28dd084 	add	sp, sp, #132	; 0x84
3480ec08:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

3480ec0c <hex1_bin>:
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480ec0c:	e2403030 	sub	r3, r0, #48	; 0x30
3480ec10:	e6ef2073 	uxtb	r2, r3
3480ec14:	e3520009 	cmp	r2, #9
		return (c - '0');
3480ec18:	91a00003 	movls	r0, r3
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480ec1c:	912fff1e 	bxls	lr
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480ec20:	e2403061 	sub	r3, r0, #97	; 0x61
3480ec24:	e6ef3073 	uxtb	r3, r3
3480ec28:	e3530005 	cmp	r3, #5
		return (c + 10 - 'a');
3480ec2c:	92400057 	subls	r0, r0, #87	; 0x57

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480ec30:	912fff1e 	bxls	lr
		return (c + 10 - 'a');
	if (c >= 'A' && c <= 'F')
3480ec34:	e2403041 	sub	r3, r0, #65	; 0x41
3480ec38:	e6ef3073 	uxtb	r3, r3
3480ec3c:	e3530005 	cmp	r3, #5
		return (c + 10 - 'A');
3480ec40:	92400037 	subls	r0, r0, #55	; 0x37
	return (-1);
3480ec44:	83e00000 	mvnhi	r0, #0
}
3480ec48:	e12fff1e 	bx	lr

3480ec4c <hex2_bin>:

static int hex2_bin (char *s)
{
3480ec4c:	e92d4038 	push	{r3, r4, r5, lr}
3480ec50:	e1a04000 	mov	r4, r0
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480ec54:	e5d00000 	ldrb	r0, [r0]
3480ec58:	ebffffeb 	bl	3480ec0c <hex1_bin>
3480ec5c:	e2505000 	subs	r5, r0, #0
		return (-1);
3480ec60:	b3e00000 	mvnlt	r0, #0

static int hex2_bin (char *s)
{
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480ec64:	b8bd8038 	poplt	{r3, r4, r5, pc}
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
3480ec68:	e5d40001 	ldrb	r0, [r4, #1]
3480ec6c:	ebffffe6 	bl	3480ec0c <hex1_bin>
3480ec70:	e3500000 	cmp	r0, #0
		return (-1);
	}

	return ((i<<4) + j);
3480ec74:	a0800205 	addge	r0, r0, r5, lsl #4

	if ((i = hex1_bin(*s++)) < 0) {
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
		return (-1);
3480ec78:	b3e00000 	mvnlt	r0, #0
	}

	return ((i<<4) + j);
}
3480ec7c:	e8bd8038 	pop	{r3, r4, r5, pc}

3480ec80 <srec_decode>:

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
3480ec80:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480ec84:	e1a04001 	mov	r4, r1
3480ec88:	e1a05002 	mov	r5, r2
3480ec8c:	e1a09003 	mov	r9, r3

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480ec90:	ea000002 	b	3480eca0 <srec_decode+0x20>
		if (*input == 'S') {		/* skip 'S' */
3480ec94:	e3530053 	cmp	r3, #83	; 0x53
			++input;
3480ec98:	01a07000 	moveq	r7, r0
			break;
3480ec9c:	0a000004 	beq	3480ecb4 <srec_decode+0x34>

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480eca0:	e5d03000 	ldrb	r3, [r0]
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
3480eca4:	e1a07000 	mov	r7, r0

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480eca8:	e3530000 	cmp	r3, #0
3480ecac:	e2800001 	add	r0, r0, #1
3480ecb0:	1afffff7 	bne	3480ec94 <srec_decode+0x14>
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480ecb4:	e5d7b000 	ldrb	fp, [r7]
3480ecb8:	e35b0000 	cmp	fp, #0
		return (SREC_EMPTY);
3480ecbc:	03a0600a 	moveq	r6, #10
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480ecc0:	0a000088 	beq	3480eee8 <srec_decode+0x268>
		return (SREC_EMPTY);
	}

	v = *input++;				/* record type		*/
3480ecc4:	e2877001 	add	r7, r7, #1

	if ((*count = hex2_bin(input)) < 0) {
3480ecc8:	e1a00007 	mov	r0, r7
3480eccc:	ebffffde 	bl	3480ec4c <hex2_bin>
3480ecd0:	e3500000 	cmp	r0, #0
3480ecd4:	e5840000 	str	r0, [r4]
3480ecd8:	ba000081 	blt	3480eee4 <srec_decode+0x264>
	}

	chksum += *count;
	input  += 2;

	switch (v) {				/* record type		*/
3480ecdc:	e24b3030 	sub	r3, fp, #48	; 0x30
3480ece0:	e3530009 	cmp	r3, #9
3480ece4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480ece8:	ea00007b 	b	3480eedc <srec_decode+0x25c>
3480ecec:	3480ed14 	.word	0x3480ed14
3480ecf0:	3480ed24 	.word	0x3480ed24
3480ecf4:	3480ed34 	.word	0x3480ed34
3480ecf8:	3480ed44 	.word	0x3480ed44
3480ecfc:	3480eedc 	.word	0x3480eedc
3480ed00:	3480ed54 	.word	0x3480ed54
3480ed04:	3480eedc 	.word	0x3480eedc
3480ed08:	3480ed64 	.word	0x3480ed64
3480ed0c:	3480ed74 	.word	0x3480ed74
3480ed10:	3480ed84 	.word	0x3480ed84

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480ed14:	e2403003 	sub	r3, r0, #3
3480ed18:	e5843000 	str	r3, [r4]
	input  += 2;

	switch (v) {				/* record type		*/

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
3480ed1c:	e3a06000 	mov	r6, #0
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480ed20:	ea00001a 	b	3480ed90 <srec_decode+0x110>
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480ed24:	e2403003 	sub	r3, r0, #3
3480ed28:	e5843000 	str	r3, [r4]
	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
3480ed2c:	e3a06001 	mov	r6, #1
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480ed30:	ea000016 	b	3480ed90 <srec_decode+0x110>
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480ed34:	e2403004 	sub	r3, r0, #4
3480ed38:	e5843000 	str	r3, [r4]
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
3480ed3c:	e3a06002 	mov	r6, #2
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480ed40:	ea000012 	b	3480ed90 <srec_decode+0x110>
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480ed44:	e2403005 	sub	r3, r0, #5
3480ed48:	e5843000 	str	r3, [r4]
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
3480ed4c:	e3a06003 	mov	r6, #3
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480ed50:	ea00000e 	b	3480ed90 <srec_decode+0x110>
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
3480ed54:	e3a03000 	mov	r3, #0
3480ed58:	e5843000 	str	r3, [r4]
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
3480ed5c:	e3a06005 	mov	r6, #5
		*count    = 0;			/* no data		*/
		break;
3480ed60:	ea00000a 	b	3480ed90 <srec_decode+0x110>
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480ed64:	e2403005 	sub	r3, r0, #5
3480ed68:	e5843000 	str	r3, [r4]
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
		break;
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
3480ed6c:	e3a06007 	mov	r6, #7
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480ed70:	ea000006 	b	3480ed90 <srec_decode+0x110>
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480ed74:	e2403004 	sub	r3, r0, #4
3480ed78:	e5843000 	str	r3, [r4]
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
3480ed7c:	e3a06008 	mov	r6, #8
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480ed80:	ea000002 	b	3480ed90 <srec_decode+0x110>
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480ed84:	e2403003 	sub	r3, r0, #3
3480ed88:	e5843000 	str	r3, [r4]
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
3480ed8c:	e3a06009 	mov	r6, #9
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480ed90:	e3a03000 	mov	r3, #0

	switch (v) {
3480ed94:	e24bb030 	sub	fp, fp, #48	; 0x30
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480ed98:	e5853000 	str	r3, [r5]

	switch (v) {
3480ed9c:	e6ef307b 	uxtb	r3, fp
3480eda0:	e3530009 	cmp	r3, #9

	if ((*count = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
	}

	chksum += *count;
3480eda4:	e6efa070 	uxtb	sl, r0
	input  += 2;
3480eda8:	e2877002 	add	r7, r7, #2
	}

	/* read address field */
	*addr = 0;

	switch (v) {
3480edac:	8a00004a 	bhi	3480eedc <srec_decode+0x25c>
3480edb0:	e3a03001 	mov	r3, #1
3480edb4:	e6afb07b 	sxtb	fp, fp
3480edb8:	e1a0bb13 	lsl	fp, r3, fp
3480edbc:	e3003223 	movw	r3, #547	; 0x223
3480edc0:	e00b3003 	and	r3, fp, r3
3480edc4:	e3530000 	cmp	r3, #0
3480edc8:	1a000016 	bne	3480ee28 <srec_decode+0x1a8>
3480edcc:	e31b0088 	tst	fp, #136	; 0x88
3480edd0:	1a000002 	bne	3480ede0 <srec_decode+0x160>
3480edd4:	e31b0f41 	tst	fp, #260	; 0x104
3480edd8:	1a000008 	bne	3480ee00 <srec_decode+0x180>
3480eddc:	ea00003e 	b	3480eedc <srec_decode+0x25c>
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
3480ede0:	e1a00007 	mov	r0, r7
3480ede4:	ebffff98 	bl	3480ec4c <hex2_bin>
3480ede8:	e3500000 	cmp	r0, #0
3480edec:	ba00003c 	blt	3480eee4 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr  += v;
		chksum += v;
3480edf0:	e08aa000 	add	sl, sl, r0
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr  += v;
3480edf4:	e5850000 	str	r0, [r5]
		chksum += v;
3480edf8:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480edfc:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '2':				/* 3 byte addr field	*/
	case '8':
		if ((v = hex2_bin(input)) < 0) {
3480ee00:	e1a00007 	mov	r0, r7
3480ee04:	ebffff90 	bl	3480ec4c <hex2_bin>
3480ee08:	e3500000 	cmp	r0, #0
3480ee0c:	ba000034 	blt	3480eee4 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480ee10:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
3480ee14:	e08aa000 	add	sl, sl, r0
	case '8':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480ee18:	e0803403 	add	r3, r0, r3, lsl #8
3480ee1c:	e5853000 	str	r3, [r5]
		chksum += v;
3480ee20:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480ee24:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '0':				/* 2 byte addr field	*/
	case '1':
	case '5':
	case '9':
		if ((v = hex2_bin(input)) < 0) {
3480ee28:	e1a00007 	mov	r0, r7
3480ee2c:	ebffff86 	bl	3480ec4c <hex2_bin>
3480ee30:	e250b000 	subs	fp, r0, #0
3480ee34:	ba00002a 	blt	3480eee4 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480ee38:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
		input  += 2;
3480ee3c:	e2877002 	add	r7, r7, #2
	case '9':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480ee40:	e08b3403 	add	r3, fp, r3, lsl #8
3480ee44:	e5853000 	str	r3, [r5]
		chksum += v;
		input  += 2;

		if ((v = hex2_bin(input)) < 0) {
3480ee48:	e1a00007 	mov	r0, r7
3480ee4c:	e58d3004 	str	r3, [sp, #4]
3480ee50:	ebffff7d 	bl	3480ec4c <hex2_bin>
3480ee54:	e3500000 	cmp	r0, #0
3480ee58:	e59d3004 	ldr	r3, [sp, #4]
3480ee5c:	ba000020 	blt	3480eee4 <srec_decode+0x264>
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
		chksum += v;
3480ee60:	e08aa00b 	add	sl, sl, fp

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480ee64:	e0803403 	add	r3, r0, r3, lsl #8
		chksum += v;
3480ee68:	e6e0a07a 	uxtab	sl, r0, sl

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480ee6c:	e5853000 	str	r3, [r5]
		chksum += v;
3480ee70:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480ee74:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480ee78:	e3a05000 	mov	r5, #0
3480ee7c:	ea000009 	b	3480eea8 <srec_decode+0x228>
		if ((v = hex2_bin(input)) < 0) {
3480ee80:	e1a00007 	mov	r0, r7
3480ee84:	ebffff70 	bl	3480ec4c <hex2_bin>
3480ee88:	e3500000 	cmp	r0, #0
3480ee8c:	ba000014 	blt	3480eee4 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480ee90:	e6ef0070 	uxtb	r0, r0
		chksum += v;
3480ee94:	e080a00a 	add	sl, r0, sl
	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480ee98:	e7c90005 	strb	r0, [r9, r5]
		chksum += v;
3480ee9c:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480eea0:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480eea4:	e2855001 	add	r5, r5, #1
3480eea8:	e5943000 	ldr	r3, [r4]
3480eeac:	e1550003 	cmp	r5, r3
3480eeb0:	bafffff2 	blt	3480ee80 <srec_decode+0x200>
		chksum += v;
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
3480eeb4:	e1a00007 	mov	r0, r7
3480eeb8:	ebffff63 	bl	3480ec4c <hex2_bin>
3480eebc:	e3500000 	cmp	r0, #0
3480eec0:	ba000007 	blt	3480eee4 <srec_decode+0x264>
		return (SREC_E_NOSREC);
	}

	if ((unsigned char)v != (unsigned char)~chksum) {
3480eec4:	e1e0a00a 	mvn	sl, sl
3480eec8:	e6ef0070 	uxtb	r0, r0
3480eecc:	e6efa07a 	uxtb	sl, sl
		return (SREC_E_BADCHKS);
3480eed0:	e150000a 	cmp	r0, sl
3480eed4:	13e06002 	mvnne	r6, #2
3480eed8:	ea000002 	b	3480eee8 <srec_decode+0x268>
		chksum += v;
		input  += 2;

		break;
	default:
		return (SREC_E_BADTYPE);
3480eedc:	e3e06000 	mvn	r6, #0
3480eee0:	ea000000 	b	3480eee8 <srec_decode+0x268>
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
3480eee4:	e3e06001 	mvn	r6, #1
	if ((unsigned char)v != (unsigned char)~chksum) {
		return (SREC_E_BADCHKS);
	}

	return (srec_type);
}
3480eee8:	e1a00006 	mov	r0, r6
3480eeec:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480eef0 <get_current>:
	for (s = serial_devices; s; s = s->next)
		s->init();
}

static struct serial_device *get_current(void)
{
3480eef0:	e92d4008 	push	{r3, lr}
	struct serial_device *dev;

	if (!(gd->flags & GD_FLG_RELOC) || !serial_current) {
3480eef4:	e5983004 	ldr	r3, [r8, #4]
3480eef8:	e3130001 	tst	r3, #1
3480eefc:	0a000003 	beq	3480ef10 <get_current+0x20>
3480ef00:	e59f301c 	ldr	r3, [pc, #28]	; 3480ef24 <get_current+0x34>
3480ef04:	e5930000 	ldr	r0, [r3]
3480ef08:	e3500000 	cmp	r0, #0
3480ef0c:	18bd8008 	popne	{r3, pc}
		dev = default_serial_console();
3480ef10:	eb0026cd 	bl	34818a4c <default_serial_console>

		/* We must have a console device */
		if (!dev)
3480ef14:	e3500000 	cmp	r0, #0
3480ef18:	18bd8008 	popne	{r3, pc}
			panic("Cannot find console");
3480ef1c:	e59f0004 	ldr	r0, [pc, #4]	; 3480ef28 <get_current+0x38>
3480ef20:	eb003a17 	bl	3481d784 <panic>
3480ef24:	3482b824 	.word	0x3482b824
3480ef28:	34826c18 	.word	0x34826c18

3480ef2c <serial_register>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480ef2c:	e59f300c 	ldr	r3, [pc, #12]	; 3480ef40 <serial_register+0x14>
3480ef30:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
3480ef34:	e5830004 	str	r0, [r3, #4]
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480ef38:	e580202c 	str	r2, [r0, #44]	; 0x2c
	serial_devices = dev;
}
3480ef3c:	e12fff1e 	bx	lr
3480ef40:	3482b824 	.word	0x3482b824

3480ef44 <serial_stdio_init>:
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480ef44:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480ef48:	e59f3080 	ldr	r3, [pc, #128]	; 3480efd0 <serial_stdio_init+0x8c>
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480ef4c:	e24dd044 	sub	sp, sp, #68	; 0x44
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
		memset(&dev, 0, sizeof(dev));
3480ef50:	e28d5004 	add	r5, sp, #4
}

void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480ef54:	e5934004 	ldr	r4, [r3, #4]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
3480ef58:	e2857008 	add	r7, r5, #8
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480ef5c:	e3a06003 	mov	r6, #3
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480ef60:	ea000016 	b	3480efc0 <serial_stdio_init+0x7c>
		memset(&dev, 0, sizeof(dev));
3480ef64:	e3a0203c 	mov	r2, #60	; 0x3c
3480ef68:	e3a01000 	mov	r1, #0
3480ef6c:	e1a00005 	mov	r0, r5
3480ef70:	eb003661 	bl	3481c8fc <memset>

		strcpy(dev.name, s->name);
3480ef74:	e1a01004 	mov	r1, r4
3480ef78:	e1a00007 	mov	r0, r7
3480ef7c:	eb003559 	bl	3481c4e8 <strcpy>
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480ef80:	e5943010 	ldr	r3, [r4, #16]
		dev.putc = s->putc;
		dev.puts = s->puts;
		dev.getc = s->getc;
		dev.tstc = s->tstc;

		stdio_register(&dev);
3480ef84:	e1a00005 	mov	r0, r5
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480ef88:	e58d301c 	str	r3, [sp, #28]
		dev.stop = s->uninit;
3480ef8c:	e5943014 	ldr	r3, [r4, #20]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480ef90:	e58d6004 	str	r6, [sp, #4]

		dev.start = s->init;
		dev.stop = s->uninit;
3480ef94:	e58d3020 	str	r3, [sp, #32]
		dev.putc = s->putc;
3480ef98:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3480ef9c:	e58d3024 	str	r3, [sp, #36]	; 0x24
		dev.puts = s->puts;
3480efa0:	e5943028 	ldr	r3, [r4, #40]	; 0x28
3480efa4:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dev.getc = s->getc;
3480efa8:	e594301c 	ldr	r3, [r4, #28]
3480efac:	e58d3030 	str	r3, [sp, #48]	; 0x30
		dev.tstc = s->tstc;
3480efb0:	e5943020 	ldr	r3, [r4, #32]
3480efb4:	e58d302c 	str	r3, [sp, #44]	; 0x2c

		stdio_register(&dev);
3480efb8:	eb000083 	bl	3480f1cc <stdio_register>

		s = s->next;
3480efbc:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480efc0:	e3540000 	cmp	r4, #0
3480efc4:	1affffe6 	bne	3480ef64 <serial_stdio_init+0x20>

		stdio_register(&dev);

		s = s->next;
	}
}
3480efc8:	e28dd044 	add	sp, sp, #68	; 0x44
3480efcc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
3480efd0:	3482b824 	.word	0x3482b824

3480efd4 <serial_assign>:

int serial_assign(const char *name)
{
3480efd4:	e92d4038 	push	{r3, r4, r5, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480efd8:	e59f303c 	ldr	r3, [pc, #60]	; 3480f01c <serial_assign+0x48>
		s = s->next;
	}
}

int serial_assign(const char *name)
{
3480efdc:	e1a05000 	mov	r5, r0
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480efe0:	e5934004 	ldr	r4, [r3, #4]
3480efe4:	ea000008 	b	3480f00c <serial_assign+0x38>
		if (strcmp(s->name, name) == 0) {
3480efe8:	e1a00004 	mov	r0, r4
3480efec:	e1a01005 	mov	r1, r5
3480eff0:	eb00356d 	bl	3481c5ac <strcmp>
3480eff4:	e3500000 	cmp	r0, #0
3480eff8:	1a000002 	bne	3480f008 <serial_assign+0x34>
			serial_current = s;
3480effc:	e59f3018 	ldr	r3, [pc, #24]	; 3480f01c <serial_assign+0x48>
3480f000:	e5834000 	str	r4, [r3]
			return 0;
3480f004:	e8bd8038 	pop	{r3, r4, r5, pc}

int serial_assign(const char *name)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480f008:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480f00c:	e3540000 	cmp	r4, #0
3480f010:	1afffff4 	bne	3480efe8 <serial_assign+0x14>
			serial_current = s;
			return 0;
		}
	}

	return 1;
3480f014:	e3a00001 	mov	r0, #1
}
3480f018:	e8bd8038 	pop	{r3, r4, r5, pc}
3480f01c:	3482b824 	.word	0x3482b824

3480f020 <serial_initialize>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480f020:	e59f3034 	ldr	r3, [pc, #52]	; 3480f05c <serial_initialize+0x3c>
3480f024:	e59f1034 	ldr	r1, [pc, #52]	; 3480f060 <serial_initialize+0x40>
3480f028:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
}

void serial_initialize(void)
{
3480f02c:	e92d4010 	push	{r4, lr}
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480f030:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480f034:	e59f2028 	ldr	r2, [pc, #40]	; 3480f064 <serial_initialize+0x44>
3480f038:	e582102c 	str	r1, [r2, #44]	; 0x2c
3480f03c:	e59f1024 	ldr	r1, [pc, #36]	; 3480f068 <serial_initialize+0x48>
3480f040:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480f044:	e59f2020 	ldr	r2, [pc, #32]	; 3480f06c <serial_initialize+0x4c>
3480f048:	e582102c 	str	r1, [r2, #44]	; 0x2c
	serial_devices = dev;
3480f04c:	e5832004 	str	r2, [r3, #4]
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480f050:	eb00267d 	bl	34818a4c <default_serial_console>
}
3480f054:	e8bd4010 	pop	{r4, lr}
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480f058:	eaffffdd 	b	3480efd4 <serial_assign>
3480f05c:	3482b824 	.word	0x3482b824
3480f060:	348294f4 	.word	0x348294f4
3480f064:	34829524 	.word	0x34829524
3480f068:	34829554 	.word	0x34829554
3480f06c:	34829584 	.word	0x34829584

3480f070 <serial_reinit_all>:

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480f070:	e59f3020 	ldr	r3, [pc, #32]	; 3480f098 <serial_reinit_all+0x28>

	return 1;
}

void serial_reinit_all(void)
{
3480f074:	e92d4010 	push	{r4, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480f078:	e5934004 	ldr	r4, [r3, #4]
3480f07c:	ea000002 	b	3480f08c <serial_reinit_all+0x1c>
		s->init();
3480f080:	e5943010 	ldr	r3, [r4, #16]
3480f084:	e12fff33 	blx	r3

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480f088:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480f08c:	e3540000 	cmp	r4, #0
3480f090:	1afffffa 	bne	3480f080 <serial_reinit_all+0x10>
		s->init();
}
3480f094:	e8bd8010 	pop	{r4, pc}
3480f098:	3482b824 	.word	0x3482b824

3480f09c <serial_init>:
		dev = serial_current;
	return dev;
}

int serial_init(void)
{
3480f09c:	e92d4008 	push	{r3, lr}
	return get_current()->init();
3480f0a0:	ebffff92 	bl	3480eef0 <get_current>
3480f0a4:	e5903010 	ldr	r3, [r0, #16]
3480f0a8:	e12fff33 	blx	r3
}
3480f0ac:	e8bd8008 	pop	{r3, pc}

3480f0b0 <serial_setbrg>:

void serial_setbrg(void)
{
3480f0b0:	e92d4008 	push	{r3, lr}
	get_current()->setbrg();
3480f0b4:	ebffff8d 	bl	3480eef0 <get_current>
3480f0b8:	e5903018 	ldr	r3, [r0, #24]
3480f0bc:	e12fff33 	blx	r3
}
3480f0c0:	e8bd8008 	pop	{r3, pc}

3480f0c4 <serial_getc>:

int serial_getc(void)
{
3480f0c4:	e92d4008 	push	{r3, lr}
	return get_current()->getc();
3480f0c8:	ebffff88 	bl	3480eef0 <get_current>
3480f0cc:	e590301c 	ldr	r3, [r0, #28]
3480f0d0:	e12fff33 	blx	r3
}
3480f0d4:	e8bd8008 	pop	{r3, pc}

3480f0d8 <serial_tstc>:

int serial_tstc(void)
{
3480f0d8:	e92d4008 	push	{r3, lr}
	return get_current()->tstc();
3480f0dc:	ebffff83 	bl	3480eef0 <get_current>
3480f0e0:	e5903020 	ldr	r3, [r0, #32]
3480f0e4:	e12fff33 	blx	r3
}
3480f0e8:	e8bd8008 	pop	{r3, pc}

3480f0ec <serial_putc>:

void serial_putc(const char c)
{
3480f0ec:	e92d4010 	push	{r4, lr}
3480f0f0:	e1a04000 	mov	r4, r0
	get_current()->putc(c);
3480f0f4:	ebffff7d 	bl	3480eef0 <get_current>
3480f0f8:	e5903024 	ldr	r3, [r0, #36]	; 0x24
3480f0fc:	e1a00004 	mov	r0, r4
3480f100:	e12fff33 	blx	r3
}
3480f104:	e8bd8010 	pop	{r4, pc}

3480f108 <serial_puts>:

void serial_puts(const char *s)
{
3480f108:	e92d4010 	push	{r4, lr}
3480f10c:	e1a04000 	mov	r4, r0
	get_current()->puts(s);
3480f110:	ebffff76 	bl	3480eef0 <get_current>
3480f114:	e5903028 	ldr	r3, [r0, #40]	; 0x28
3480f118:	e1a00004 	mov	r0, r4
3480f11c:	e12fff33 	blx	r3
}
3480f120:	e8bd8010 	pop	{r4, pc}

3480f124 <stdio_get_list>:
 **************************************************************************
 */
struct list_head* stdio_get_list(void)
{
	return &(devs.list);
}
3480f124:	e59f0000 	ldr	r0, [pc, #0]	; 3480f12c <stdio_get_list+0x8>
3480f128:	e12fff1e 	bx	lr
3480f12c:	3482b860 	.word	0x3482b860

3480f130 <stdio_get_by_name>:

struct stdio_dev* stdio_get_by_name(const char *name)
{
3480f130:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480f134:	e2507000 	subs	r7, r0, #0
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480f138:	159f6040 	ldrne	r6, [pc, #64]	; 3480f180 <stdio_get_by_name+0x50>
3480f13c:	15b65034 	ldrne	r5, [r6, #52]!	; 0x34
struct stdio_dev* stdio_get_by_name(const char *name)
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480f140:	0a00000b 	beq	3480f174 <stdio_get_by_name+0x44>
3480f144:	ea000006 	b	3480f164 <stdio_get_by_name+0x34>
		return NULL;

	list_for_each(pos, &(devs.list)) {
		dev = list_entry(pos, struct stdio_dev, list);
3480f148:	e2454034 	sub	r4, r5, #52	; 0x34
		if(strcmp(dev->name, name) == 0)
3480f14c:	e2840008 	add	r0, r4, #8
3480f150:	e1a01007 	mov	r1, r7
3480f154:	eb003514 	bl	3481c5ac <strcmp>
3480f158:	e3500000 	cmp	r0, #0
3480f15c:	0a000005 	beq	3480f178 <stdio_get_by_name+0x48>
	struct stdio_dev *dev;

	if(!name)
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480f160:	e5955000 	ldr	r5, [r5]
3480f164:	e1550006 	cmp	r5, r6
3480f168:	1afffff6 	bne	3480f148 <stdio_get_by_name+0x18>
		dev = list_entry(pos, struct stdio_dev, list);
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
3480f16c:	e3a04000 	mov	r4, #0
3480f170:	ea000000 	b	3480f178 <stdio_get_by_name+0x48>
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
		return NULL;
3480f174:	e1a04007 	mov	r4, r7
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
}
3480f178:	e1a00004 	mov	r0, r4
3480f17c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480f180:	3482b82c 	.word	0x3482b82c

3480f184 <stdio_clone>:

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
3480f184:	e92d4038 	push	{r3, r4, r5, lr}
	struct stdio_dev *_dev;

	if(!dev)
3480f188:	e2505000 	subs	r5, r0, #0
		return NULL;
3480f18c:	01a04005 	moveq	r4, r5

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
	struct stdio_dev *_dev;

	if(!dev)
3480f190:	0a00000b 	beq	3480f1c4 <stdio_clone+0x40>
		return NULL;

	_dev = calloc(1, sizeof(struct stdio_dev));
3480f194:	e3a00001 	mov	r0, #1
3480f198:	e3a0103c 	mov	r1, #60	; 0x3c
3480f19c:	ebffedb9 	bl	3480a888 <calloc>

	if(!_dev)
3480f1a0:	e2504000 	subs	r4, r0, #0
3480f1a4:	0a000006 	beq	3480f1c4 <stdio_clone+0x40>
		return NULL;

	memcpy(_dev, dev, sizeof(struct stdio_dev));
3480f1a8:	e1a01005 	mov	r1, r5
3480f1ac:	e3a0203c 	mov	r2, #60	; 0x3c
3480f1b0:	eb0035f5 	bl	3481c98c <memcpy>
	strncpy(_dev->name, dev->name, 16);
3480f1b4:	e2840008 	add	r0, r4, #8
3480f1b8:	e2851008 	add	r1, r5, #8
3480f1bc:	e3a02010 	mov	r2, #16
3480f1c0:	eb0034cf 	bl	3481c504 <strncpy>

	return _dev;
}
3480f1c4:	e1a00004 	mov	r0, r4
3480f1c8:	e8bd8038 	pop	{r3, r4, r5, pc}

3480f1cc <stdio_register>:

int stdio_register (struct stdio_dev * dev)
{
3480f1cc:	e92d4008 	push	{r3, lr}
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
3480f1d0:	ebffffeb 	bl	3480f184 <stdio_clone>
	if(!_dev)
3480f1d4:	e3500000 	cmp	r0, #0
3480f1d8:	0a000009 	beq	3480f204 <stdio_register+0x38>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480f1dc:	e59f3028 	ldr	r3, [pc, #40]	; 3480f20c <stdio_register+0x40>
		return -1;
	list_add_tail(&(_dev->list), &(devs.list));
3480f1e0:	e2801034 	add	r1, r0, #52	; 0x34
3480f1e4:	e5932038 	ldr	r2, [r3, #56]	; 0x38
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3480f1e8:	e5831038 	str	r1, [r3, #56]	; 0x38
	new->next = next;
3480f1ec:	e2833034 	add	r3, r3, #52	; 0x34
3480f1f0:	e5803034 	str	r3, [r0, #52]	; 0x34
	new->prev = prev;
3480f1f4:	e5802038 	str	r2, [r0, #56]	; 0x38
	prev->next = new;
3480f1f8:	e5821000 	str	r1, [r2]
	return 0;
3480f1fc:	e3a00000 	mov	r0, #0
3480f200:	e8bd8008 	pop	{r3, pc}
{
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
	if(!_dev)
		return -1;
3480f204:	e3e00000 	mvn	r0, #0
	list_add_tail(&(_dev->list), &(devs.list));
	return 0;
}
3480f208:	e8bd8008 	pop	{r3, pc}
3480f20c:	3482b82c 	.word	0x3482b82c

3480f210 <stdio_init>:
	return 0;
}
#endif	/* CONFIG_SYS_STDIO_DEREGISTER */

int stdio_init (void)
{
3480f210:	e92d4010 	push	{r4, lr}
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3480f214:	e59f3078 	ldr	r3, [pc, #120]	; 3480f294 <stdio_init+0x84>
3480f218:	e24dd040 	sub	sp, sp, #64	; 0x40
3480f21c:	e2832034 	add	r2, r3, #52	; 0x34
3480f220:	e5832034 	str	r2, [r3, #52]	; 0x34
	list->prev = list;
3480f224:	e5832038 	str	r2, [r3, #56]	; 0x38

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480f228:	e28d4004 	add	r4, sp, #4

#ifdef CONFIG_ARM_DCC_MULTI
	drv_arm_dcc_init ();
#endif
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
3480f22c:	e30c0350 	movw	r0, #50000	; 0xc350
3480f230:	e3a010fe 	mov	r1, #254	; 0xfe
3480f234:	eb000654 	bl	34810b8c <i2c_init>

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480f238:	e3a0203c 	mov	r2, #60	; 0x3c
3480f23c:	e1a00004 	mov	r0, r4
3480f240:	e3a01000 	mov	r1, #0
3480f244:	eb0035ac 	bl	3481c8fc <memset>

	strcpy (dev.name, "serial");
3480f248:	e59f1048 	ldr	r1, [pc, #72]	; 3480f298 <stdio_init+0x88>
3480f24c:	e2840008 	add	r0, r4, #8
3480f250:	eb0034a4 	bl	3481c4e8 <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
3480f254:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
3480f258:	e58d3004 	str	r3, [sp, #4]
	dev.putc = serial_putc;
3480f25c:	e59f3038 	ldr	r3, [pc, #56]	; 3480f29c <stdio_init+0x8c>
	dev.puts = serial_puts;
	dev.getc = serial_getc;
	dev.tstc = serial_tstc;
	stdio_register (&dev);
3480f260:	e1a00004 	mov	r0, r4

	memset (&dev, 0, sizeof (dev));

	strcpy (dev.name, "serial");
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
	dev.putc = serial_putc;
3480f264:	e58d3024 	str	r3, [sp, #36]	; 0x24
	dev.puts = serial_puts;
3480f268:	e59f3030 	ldr	r3, [pc, #48]	; 3480f2a0 <stdio_init+0x90>
3480f26c:	e58d3028 	str	r3, [sp, #40]	; 0x28
	dev.getc = serial_getc;
3480f270:	e59f302c 	ldr	r3, [pc, #44]	; 3480f2a4 <stdio_init+0x94>
3480f274:	e58d3030 	str	r3, [sp, #48]	; 0x30
	dev.tstc = serial_tstc;
3480f278:	e59f3028 	ldr	r3, [pc, #40]	; 3480f2a8 <stdio_init+0x98>
3480f27c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	stdio_register (&dev);
3480f280:	ebffffd1 	bl	3480f1cc <stdio_register>
#ifdef CONFIG_LOGBUFFER
	drv_logbuff_init ();
#endif
	drv_system_init ();
#ifdef CONFIG_SERIAL_MULTI
	serial_stdio_init ();
3480f284:	ebffff2e 	bl	3480ef44 <serial_stdio_init>
#ifdef CONFIG_JTAG_CONSOLE
	drv_jtag_console_init ();
#endif

	return (0);
}
3480f288:	e3a00000 	mov	r0, #0
3480f28c:	e28dd040 	add	sp, sp, #64	; 0x40
3480f290:	e8bd8010 	pop	{r4, pc}
3480f294:	3482b82c 	.word	0x3482b82c
3480f298:	34826323 	.word	0x34826323
3480f29c:	3480f0ec 	.word	0x3480f0ec
3480f2a0:	3480f108 	.word	0x3480f108
3480f2a4:	3480f0c4 	.word	0x3480f0c4
3480f2a8:	3480f0d8 	.word	0x3480f0d8

3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>:

#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
3480f2ac:	e92d4070 	push	{r4, r5, r6, lr}
3480f2b0:	e1a05001 	mov	r5, r1
#define DELAY 20
  unsigned long counter = 0;
3480f2b4:	e3a04000 	mov	r4, #0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480f2b8:	e59f603c 	ldr	r6, [pc, #60]	; 3480f2fc <CYGACC_COMM_IF_GETC_TIMEOUT+0x50>
3480f2bc:	ea000002 	b	3480f2cc <CYGACC_COMM_IF_GETC_TIMEOUT+0x20>
    {
      udelay (DELAY);
3480f2c0:	e3a00014 	mov	r0, #20
3480f2c4:	eb00363b 	bl	3481cbb8 <udelay>
      counter++;
3480f2c8:	e2844001 	add	r4, r4, #1
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
#define DELAY 20
  unsigned long counter = 0;
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480f2cc:	ebffea1c 	bl	34809b44 <tstc>
3480f2d0:	e3500000 	cmp	r0, #0
3480f2d4:	1a000001 	bne	3480f2e0 <CYGACC_COMM_IF_GETC_TIMEOUT+0x34>
3480f2d8:	e1540006 	cmp	r4, r6
3480f2dc:	1afffff7 	bne	3480f2c0 <CYGACC_COMM_IF_GETC_TIMEOUT+0x14>
    {
      udelay (DELAY);
      counter++;
    }
  if (tstc ())
3480f2e0:	ebffea17 	bl	34809b44 <tstc>
3480f2e4:	e3500000 	cmp	r0, #0
3480f2e8:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
      *c = getc ();
3480f2ec:	ebffea0b 	bl	34809b20 <getc>
3480f2f0:	e5c50000 	strb	r0, [r5]
      return 1;
3480f2f4:	e3a00001 	mov	r0, #1
    }
  return 0;
}
3480f2f8:	e8bd8070 	pop	{r4, r5, r6, pc}
3480f2fc:	000186a0 	.word	0x000186a0

3480f300 <xyzModem_flush>:
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
3480f300:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f304:	e59f501c 	ldr	r5, [pc, #28]	; 3480f328 <xyzModem_flush+0x28>
3480f308:	e28d4007 	add	r4, sp, #7
3480f30c:	e5953000 	ldr	r3, [r5]
3480f310:	e1a01004 	mov	r1, r4
3480f314:	e5d30000 	ldrb	r0, [r3]
3480f318:	ebffffe3 	bl	3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (!res)
3480f31c:	e3500000 	cmp	r0, #0
3480f320:	1afffff9 	bne	3480f30c <xyzModem_flush+0xc>
	return;
    }
}
3480f324:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
3480f328:	3482b874 	.word	0x3482b874

3480f32c <xyzModem_get_hdr>:

static int
xyzModem_get_hdr (void)
{
3480f32c:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
3480f330:	e59f4250 	ldr	r4, [pc, #592]	; 3480f588 <xyzModem_get_hdr+0x25c>
3480f334:	e5943430 	ldr	r3, [r4, #1072]	; 0x430
3480f338:	e3530000 	cmp	r3, #0
3480f33c:	0a000003 	beq	3480f350 <xyzModem_get_hdr+0x24>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f340:	e3a00006 	mov	r0, #6
3480f344:	ebffea07 	bl	34809b68 <putc>
  hdr_chars = 0;

  if (xyz.tx_ack)
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
3480f348:	e3a03000 	mov	r3, #0
3480f34c:	e5843430 	str	r3, [r4, #1072]	; 0x430
    }
}

static int
xyzModem_get_hdr (void)
{
3480f350:	e3a05000 	mov	r5, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f354:	e59f622c 	ldr	r6, [pc, #556]	; 3480f588 <xyzModem_get_hdr+0x25c>
    }
}

static int
xyzModem_get_hdr (void)
{
3480f358:	e1a07005 	mov	r7, r5
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f35c:	e28da007 	add	sl, sp, #7
3480f360:	e5963000 	ldr	r3, [r6]
3480f364:	e1a0100a 	mov	r1, sl
3480f368:	e5d30000 	ldrb	r0, [r3]
3480f36c:	ebffffce 	bl	3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480f370:	e3500000 	cmp	r0, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f374:	e59f420c 	ldr	r4, [pc, #524]	; 3480f588 <xyzModem_get_hdr+0x25c>
      ZM_DEBUG (zm_save (c));
      if (res)
3480f378:	0a000021 	beq	3480f404 <xyzModem_get_hdr+0xd8>
	{
	  hdr_chars++;
	  switch (c)
3480f37c:	e5dd3007 	ldrb	r3, [sp, #7]
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  hdr_chars++;
3480f380:	e2855001 	add	r5, r5, #1
	  switch (c)
3480f384:	e3530002 	cmp	r3, #2
3480f388:	0a00000c 	beq	3480f3c0 <xyzModem_get_hdr+0x94>
3480f38c:	8a000002 	bhi	3480f39c <xyzModem_get_hdr+0x70>
3480f390:	e3530001 	cmp	r3, #1
3480f394:	1afffff1 	bne	3480f360 <xyzModem_get_hdr+0x34>
3480f398:	ea000004 	b	3480f3b0 <xyzModem_get_hdr+0x84>
3480f39c:	e3530004 	cmp	r3, #4
3480f3a0:	0a000011 	beq	3480f3ec <xyzModem_get_hdr+0xc0>
3480f3a4:	e3530018 	cmp	r3, #24
3480f3a8:	1affffec 	bne	3480f360 <xyzModem_get_hdr+0x34>
3480f3ac:	ea000007 	b	3480f3d0 <xyzModem_get_hdr+0xa4>
	    {
	    case SOH:
	      xyz.total_SOH++;
3480f3b0:	e594341c 	ldr	r3, [r4, #1052]	; 0x41c
3480f3b4:	e2833001 	add	r3, r3, #1
3480f3b8:	e584341c 	str	r3, [r4, #1052]	; 0x41c
3480f3bc:	ea000069 	b	3480f568 <xyzModem_get_hdr+0x23c>
	    case STX:
	      if (c == STX)
		xyz.total_STX++;
3480f3c0:	e5943420 	ldr	r3, [r4, #1056]	; 0x420
3480f3c4:	e2833001 	add	r3, r3, #1
3480f3c8:	e5843420 	str	r3, [r4, #1056]	; 0x420
3480f3cc:	ea000065 	b	3480f568 <xyzModem_get_hdr+0x23c>
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480f3d0:	e5963424 	ldr	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480f3d4:	e2877001 	add	r7, r7, #1
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480f3d8:	e2833001 	add	r3, r3, #1
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480f3dc:	e3570003 	cmp	r7, #3
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480f3e0:	e5863424 	str	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480f3e4:	1affffdd 	bne	3480f360 <xyzModem_get_hdr+0x34>
3480f3e8:	ea00005a 	b	3480f558 <xyzModem_get_hdr+0x22c>
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
3480f3ec:	e3550001 	cmp	r5, #1
3480f3f0:	1affffda 	bne	3480f360 <xyzModem_get_hdr+0x34>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f3f4:	e3a00006 	mov	r0, #6
3480f3f8:	ebffe9da 	bl	34809b68 <putc>
	      if (hdr_chars == 1)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
3480f3fc:	e3e00003 	mvn	r0, #3
3480f400:	ea000057 	b	3480f564 <xyzModem_get_hdr+0x238>
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
3480f404:	ebffffbd 	bl	3480f300 <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f408:	e59f017c 	ldr	r0, [pc, #380]	; 3480f58c <xyzModem_get_hdr+0x260>
3480f40c:	eb0035e9 	bl	3481cbb8 <udelay>
3480f410:	ea000052 	b	3480f560 <xyzModem_get_hdr+0x234>
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
3480f414:	e5943000 	ldr	r3, [r4]
3480f418:	e59f1170 	ldr	r1, [pc, #368]	; 3480f590 <xyzModem_get_hdr+0x264>
3480f41c:	e5d30000 	ldrb	r0, [r3]
3480f420:	ebffffa1 	bl	3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
3480f424:	e3500000 	cmp	r0, #0
3480f428:	0a00004c 	beq	3480f560 <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480f42c:	e28d7008 	add	r7, sp, #8
3480f430:	e5773001 	ldrb	r3, [r7, #-1]!
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480f434:	e3a05000 	mov	r5, #0
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480f438:	e3530001 	cmp	r3, #1
3480f43c:	13a03b01 	movne	r3, #1024	; 0x400
3480f440:	03a03080 	moveq	r3, #128	; 0x80
3480f444:	e5843410 	str	r3, [r4, #1040]	; 0x410
  xyz.bufp = xyz.pkt;
3480f448:	e2843004 	add	r3, r4, #4
3480f44c:	e5843404 	str	r3, [r4, #1028]	; 0x404
  for (i = 0; i < xyz.len; i++)
3480f450:	ea000009 	b	3480f47c <xyzModem_get_hdr+0x150>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480f454:	e5943000 	ldr	r3, [r4]
3480f458:	e1a01007 	mov	r1, r7
3480f45c:	e5d30000 	ldrb	r0, [r3]
3480f460:	ebffff91 	bl	3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480f464:	e3500000 	cmp	r0, #0
3480f468:	0a00003c 	beq	3480f560 <xyzModem_get_hdr+0x234>
	{
	  xyz.pkt[i] = c;
3480f46c:	e5dd2007 	ldrb	r2, [sp, #7]
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480f470:	e0843005 	add	r3, r4, r5
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  xyz.pkt[i] = c;
3480f474:	e5c32004 	strb	r2, [r3, #4]
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480f478:	e2855001 	add	r5, r5, #1
3480f47c:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f480:	e59f6100 	ldr	r6, [pc, #256]	; 3480f588 <xyzModem_get_hdr+0x25c>
3480f484:	e1550003 	cmp	r5, r3
3480f488:	bafffff1 	blt	3480f454 <xyzModem_get_hdr+0x128>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
3480f48c:	e5963000 	ldr	r3, [r6]
3480f490:	e59f10fc 	ldr	r1, [pc, #252]	; 3480f594 <xyzModem_get_hdr+0x268>
3480f494:	e5d30000 	ldrb	r0, [r3]
3480f498:	ebffff83 	bl	3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
3480f49c:	e3500000 	cmp	r0, #0
3480f4a0:	0a00002e 	beq	3480f560 <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  if (xyz.crc_mode)
3480f4a4:	e5963428 	ldr	r3, [r6, #1064]	; 0x428
3480f4a8:	e3530000 	cmp	r3, #0
3480f4ac:	0a000005 	beq	3480f4c8 <xyzModem_get_hdr+0x19c>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
3480f4b0:	e5963000 	ldr	r3, [r6]
3480f4b4:	e59f10dc 	ldr	r1, [pc, #220]	; 3480f598 <xyzModem_get_hdr+0x26c>
3480f4b8:	e5d30000 	ldrb	r0, [r3]
3480f4bc:	ebffff7a 	bl	3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (xyz.crc2));
      if (!res)
3480f4c0:	e3500000 	cmp	r0, #0
3480f4c4:	0a000025 	beq	3480f560 <xyzModem_get_hdr+0x234>
	  return xyzModem_timeout;
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
3480f4c8:	e59f40b8 	ldr	r4, [pc, #184]	; 3480f588 <xyzModem_get_hdr+0x25c>
3480f4cc:	e5d42409 	ldrb	r2, [r4, #1033]	; 0x409
3480f4d0:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480f4d4:	e0223003 	eor	r3, r2, r3
3480f4d8:	e35300ff 	cmp	r3, #255	; 0xff
3480f4dc:	0a000002 	beq	3480f4ec <xyzModem_get_hdr+0x1c0>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
3480f4e0:	ebffff86 	bl	3480f300 <xyzModem_flush>
      return xyzModem_frame;
3480f4e4:	e3e00005 	mvn	r0, #5
3480f4e8:	ea00001d 	b	3480f564 <xyzModem_get_hdr+0x238>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480f4ec:	e5943428 	ldr	r3, [r4, #1064]	; 0x428
3480f4f0:	e3530000 	cmp	r3, #0
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480f4f4:	05941410 	ldreq	r1, [r4, #1040]	; 0x410
3480f4f8:	01a02003 	moveq	r2, r3
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
      return xyzModem_frame;
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480f4fc:	0a00000c 	beq	3480f534 <xyzModem_get_hdr+0x208>
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
3480f500:	e2840004 	add	r0, r4, #4
3480f504:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480f508:	eb002d52 	bl	3481aa58 <cyg_crc16>
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
3480f50c:	e5d4240a 	ldrb	r2, [r4, #1034]	; 0x40a
3480f510:	e5d4340b 	ldrb	r3, [r4, #1035]	; 0x40b
3480f514:	e1833402 	orr	r3, r3, r2, lsl #8
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480f518:	e1500003 	cmp	r0, r3
3480f51c:	ea00000a 	b	3480f54c <xyzModem_get_hdr+0x220>
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480f520:	e0840002 	add	r0, r4, r2
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
	{
	  cksum += xyz.pkt[i];
3480f524:	e5d00004 	ldrb	r0, [r0, #4]
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480f528:	e2822001 	add	r2, r2, #1
	{
	  cksum += xyz.pkt[i];
3480f52c:	e0833000 	add	r3, r3, r0
3480f530:	e6ff3073 	uxth	r3, r3
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480f534:	e1520001 	cmp	r2, r1
3480f538:	bafffff8 	blt	3480f520 <xyzModem_get_hdr+0x1f4>
	{
	  cksum += xyz.pkt[i];
	}
      if (xyz.crc1 != (cksum & 0xFF))
3480f53c:	e59f2044 	ldr	r2, [pc, #68]	; 3480f588 <xyzModem_get_hdr+0x25c>
3480f540:	e20330ff 	and	r3, r3, #255	; 0xff
3480f544:	e5d2240a 	ldrb	r2, [r2, #1034]	; 0x40a
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480f548:	e1520003 	cmp	r2, r3
3480f54c:	13e00006 	mvnne	r0, #6
3480f550:	03a00000 	moveq	r0, #0
3480f554:	ea000002 	b	3480f564 <xyzModem_get_hdr+0x238>
	    case CAN:
	      xyz.total_CAN++;
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
		{
		  return xyzModem_cancel;
3480f558:	e3e00004 	mvn	r0, #4
3480f55c:	ea000000 	b	3480f564 <xyzModem_get_hdr+0x238>
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
3480f560:	e3e00002 	mvn	r0, #2
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
}
3480f564:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
	  return xyzModem_timeout;
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
3480f568:	e59f4018 	ldr	r4, [pc, #24]	; 3480f588 <xyzModem_get_hdr+0x25c>
3480f56c:	e59f1028 	ldr	r1, [pc, #40]	; 3480f59c <xyzModem_get_hdr+0x270>
3480f570:	e5943000 	ldr	r3, [r4]
3480f574:	e5d30000 	ldrb	r0, [r3]
3480f578:	ebffff4b 	bl	3480f2ac <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
3480f57c:	e3500000 	cmp	r0, #0
3480f580:	0afffff6 	beq	3480f560 <xyzModem_get_hdr+0x234>
3480f584:	eaffffa2 	b	3480f414 <xyzModem_get_hdr+0xe8>
3480f588:	3482b874 	.word	0x3482b874
3480f58c:	0003d090 	.word	0x0003d090
3480f590:	3482bc7d 	.word	0x3482bc7d
3480f594:	3482bc7e 	.word	0x3482bc7e
3480f598:	3482bc7f 	.word	0x3482bc7f
3480f59c:	3482bc7c 	.word	0x3482bc7c

3480f5a0 <CYGACC_COMM_IF_PUTC>:
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f5a0:	e1a00001 	mov	r0, r1
3480f5a4:	eaffe96f 	b	34809b68 <putc>

3480f5a8 <parse_num>:
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
3480f5a8:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
  int radix = 10;
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
3480f5ac:	e5d04000 	ldrb	r4, [r0]
3480f5b0:	e1a0c000 	mov	ip, r0
3480f5b4:	e3540020 	cmp	r4, #32
3480f5b8:	e2800001 	add	r0, r0, #1
3480f5bc:	0afffffa 	beq	3480f5ac <parse_num+0x4>
3480f5c0:	e3a05000 	mov	r5, #0
3480f5c4:	e3a0600a 	mov	r6, #10
3480f5c8:	e3a00001 	mov	r0, #1
3480f5cc:	ea000037 	b	3480f6b0 <parse_num+0x108>
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480f5d0:	e3500000 	cmp	r0, #0
3480f5d4:	0a00000a 	beq	3480f604 <parse_num+0x5c>
3480f5d8:	e3540030 	cmp	r4, #48	; 0x30
3480f5dc:	1a000008 	bne	3480f604 <parse_num+0x5c>
3480f5e0:	e5dc0001 	ldrb	r0, [ip, #1]

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
  if ((c >= 'A') && (c <= 'Z'))
3480f5e4:	e2404041 	sub	r4, r0, #65	; 0x41
3480f5e8:	e6ef4074 	uxtb	r4, r4
3480f5ec:	e3540019 	cmp	r4, #25
    {
      c = (c - 'A') + 'a';
3480f5f0:	92800020 	addls	r0, r0, #32
3480f5f4:	96ef0070 	uxtbls	r0, r0

  while (*s == ' ')
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480f5f8:	e3500078 	cmp	r0, #120	; 0x78
	{
	  radix = 16;
	  s += 2;
3480f5fc:	028cc002 	addeq	ip, ip, #2
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
3480f600:	03a06010 	moveq	r6, #16
	  s += 2;
	}
      first = false;
      c = *s++;
3480f604:	e4dc4001 	ldrb	r4, [ip], #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f608:	e2447030 	sub	r7, r4, #48	; 0x30
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f60c:	e2440041 	sub	r0, r4, #65	; 0x41

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f610:	e6efa077 	uxtb	sl, r7
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f614:	e6ef0070 	uxtb	r0, r0

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f618:	e35a0009 	cmp	sl, #9
3480f61c:	83a0a000 	movhi	sl, #0
3480f620:	93a0a001 	movls	sl, #1
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f624:	e3500005 	cmp	r0, #5
3480f628:	83a00000 	movhi	r0, #0
3480f62c:	93a00001 	movls	r0, #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480f630:	e190900a 	orrs	r9, r0, sl
3480f634:	1a000004 	bne	3480f64c <parse_num+0xa4>
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480f638:	e2447061 	sub	r7, r4, #97	; 0x61
3480f63c:	e6ef7077 	uxtb	r7, r7
3480f640:	e3570005 	cmp	r7, #5
3480f644:	9a000003 	bls	3480f658 <parse_num+0xb0>
3480f648:	ea00000f 	b	3480f68c <parse_num+0xe4>
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480f64c:	e35a0000 	cmp	sl, #0
    {
      ret = (c - '0');
3480f650:	11a00007 	movne	r0, r7
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480f654:	1a000009 	bne	3480f680 <parse_num+0xd8>
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480f658:	e2447061 	sub	r7, r4, #97	; 0x61
3480f65c:	e6ef7077 	uxtb	r7, r7
3480f660:	e3570005 	cmp	r7, #5
    {
      ret = (c - 'a' + 0x0a);
3480f664:	92440057 	subls	r0, r4, #87	; 0x57

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480f668:	9a000002 	bls	3480f678 <parse_num+0xd0>
    {
      ret = (c - 'a' + 0x0a);
    }
  else if ((c >= 'A') && (c <= 'F'))
3480f66c:	e3500000 	cmp	r0, #0
3480f670:	0a000002 	beq	3480f680 <parse_num+0xd8>
    {
      ret = (c - 'A' + 0x0A);
3480f674:	e2440037 	sub	r0, r4, #55	; 0x37
	  radix = 16;
	  s += 2;
	}
      first = false;
      c = *s++;
      if (_is_hex (c) && ((digit = _from_hex (c)) < radix))
3480f678:	e1500006 	cmp	r0, r6
3480f67c:	aa000002 	bge	3480f68c <parse_num+0xe4>
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480f680:	e0250695 	mla	r5, r5, r6, r0
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
	  s += 2;
	}
      first = false;
3480f684:	e3a00000 	mov	r0, #0
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480f688:	ea000008 	b	3480f6b0 <parse_num+0x108>
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480f68c:	e3530000 	cmp	r3, #0
	      while (*dp && (c != *dp))
		dp++;
	      if (*dp)
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
3480f690:	01a00003 	moveq	r0, r3
	  result = (result * radix) + digit;
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480f694:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
	      while (*dp && (c != *dp))
3480f698:	e4d30001 	ldrb	r0, [r3], #1
3480f69c:	e3500000 	cmp	r0, #0
3480f6a0:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
3480f6a4:	e1540000 	cmp	r4, r0
3480f6a8:	1afffffa 	bne	3480f698 <parse_num+0xf0>
3480f6ac:	ea000002 	b	3480f6bc <parse_num+0x114>
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
    s++;
  while (*s)
3480f6b0:	e5dc4000 	ldrb	r4, [ip]
3480f6b4:	e3540000 	cmp	r4, #0
3480f6b8:	1affffc4 	bne	3480f5d0 <parse_num+0x28>
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
  if (es != (char **) 0)
3480f6bc:	e3520000 	cmp	r2, #0
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
3480f6c0:	e5815000 	str	r5, [r1]
  if (es != (char **) 0)
    {
      *es = s;
    }
  return true;
3480f6c4:	13a00001 	movne	r0, #1
	}
    }
  *val = result;
  if (es != (char **) 0)
    {
      *es = s;
3480f6c8:	1582c000 	strne	ip, [r2]
    }
  return true;
3480f6cc:	03a00001 	moveq	r0, #1
}
3480f6d0:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3480f6d4 <xyzModem_stream_open>:
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480f6d4:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
3480f6d8:	e59f412c 	ldr	r4, [pc, #300]	; 3480f80c <xyzModem_stream_open+0x138>
  CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
3480f6dc:	e3a05000 	mov	r5, #0
3480f6e0:	e28d3008 	add	r3, sp, #8
3480f6e4:	e5235004 	str	r5, [r3, #-4]!
  xyz.__chan = &dummy;
3480f6e8:	e5843000 	str	r3, [r4]
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
3480f6ec:	e3a03001 	mov	r3, #1
3480f6f0:	e5843428 	str	r3, [r4, #1064]	; 0x428
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480f6f4:	e5903004 	ldr	r3, [r0, #4]
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f6f8:	e3a00043 	mov	r0, #67	; 0x43
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480f6fc:	e5843414 	str	r3, [r4, #1044]	; 0x414
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480f700:	e1a0a001 	mov	sl, r1
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
3480f704:	e5845410 	str	r5, [r4, #1040]	; 0x410
  xyz.crc_mode = true;
  xyz.at_eof = false;
3480f708:	e584542c 	str	r5, [r4, #1068]	; 0x42c
  xyz.tx_ack = false;
3480f70c:	e5845430 	str	r5, [r4, #1072]	; 0x430
  xyz.mode = info->mode;
  xyz.total_retries = 0;
3480f710:	e5845418 	str	r5, [r4, #1048]	; 0x418
  xyz.total_SOH = 0;
3480f714:	e584541c 	str	r5, [r4, #1052]	; 0x41c
  xyz.total_STX = 0;
3480f718:	e5845420 	str	r5, [r4, #1056]	; 0x420
  xyz.total_CAN = 0;
3480f71c:	e5845424 	str	r5, [r4, #1060]	; 0x424
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
3480f720:	e5845438 	str	r5, [r4, #1080]	; 0x438
  xyz.file_length = 0;
3480f724:	e5845434 	str	r5, [r4, #1076]	; 0x434
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f728:	ebffe90e 	bl	34809b68 <putc>
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480f72c:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480f730:	e3530001 	cmp	r3, #1
3480f734:	13a0700a 	movne	r7, #10
3480f738:	13a06014 	movne	r6, #20
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480f73c:	11a09005 	movne	r9, r5
  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
3480f740:	05c4340c 	strbeq	r3, [r4, #1036]	; 0x40c
      return 0;
3480f744:	01a00005 	moveq	r0, r5
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480f748:	1a00002a 	bne	3480f7f8 <xyzModem_stream_open+0x124>
3480f74c:	ea00002d 	b	3480f808 <xyzModem_stream_open+0x134>
      return 0;
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
3480f750:	ebfffef5 	bl	3480f32c <xyzModem_get_hdr>
      if (stat == 0)
3480f754:	e2505000 	subs	r5, r0, #0
3480f758:	1a000014 	bne	3480f7b0 <xyzModem_stream_open+0xdc>
	{
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
3480f75c:	e59f30a8 	ldr	r3, [pc, #168]	; 3480f80c <xyzModem_stream_open+0x138>
3480f760:	e5d32408 	ldrb	r2, [r3, #1032]	; 0x408
3480f764:	e3520000 	cmp	r2, #0
3480f768:	1a00000a 	bne	3480f798 <xyzModem_stream_open+0xc4>
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
3480f76c:	e5930404 	ldr	r0, [r3, #1028]	; 0x404
3480f770:	e4d02001 	ldrb	r2, [r0], #1
3480f774:	e3520000 	cmp	r2, #0
3480f778:	e5830404 	str	r0, [r3, #1028]	; 0x404
3480f77c:	1afffffa 	bne	3480f76c <xyzModem_stream_open+0x98>
	      /* get the length */
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
3480f780:	e59f3088 	ldr	r3, [pc, #136]	; 3480f810 <xyzModem_stream_open+0x13c>
3480f784:	e59f1088 	ldr	r1, [pc, #136]	; 3480f814 <xyzModem_stream_open+0x140>
3480f788:	ebffff86 	bl	3480f5a8 <parse_num>
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
3480f78c:	e59f3078 	ldr	r3, [pc, #120]	; 3480f80c <xyzModem_stream_open+0x138>
3480f790:	e3a02001 	mov	r2, #1
3480f794:	e5832430 	str	r2, [r3, #1072]	; 0x430
	    }
	  xyz.next_blk = 1;
3480f798:	e59f306c 	ldr	r3, [pc, #108]	; 3480f80c <xyzModem_stream_open+0x138>
3480f79c:	e3a02001 	mov	r2, #1
	  xyz.len = 0;
3480f7a0:	e3a00000 	mov	r0, #0
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
	    }
	  xyz.next_blk = 1;
3480f7a4:	e5c3240c 	strb	r2, [r3, #1036]	; 0x40c
	  xyz.len = 0;
3480f7a8:	e5830410 	str	r0, [r3, #1040]	; 0x410
	  return 0;
3480f7ac:	ea000015 	b	3480f808 <xyzModem_stream_open+0x134>
	}
      else if (stat == xyzModem_timeout)
3480f7b0:	e3750003 	cmn	r5, #3
3480f7b4:	1a00000d 	bne	3480f7f0 <xyzModem_stream_open+0x11c>
	{
	  if (--crc_retries <= 0)
3480f7b8:	e2477001 	sub	r7, r7, #1
3480f7bc:	e3570000 	cmp	r7, #0
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480f7c0:	e59f0050 	ldr	r0, [pc, #80]	; 3480f818 <xyzModem_stream_open+0x144>
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480f7c4:	d5849428 	strle	r9, [r4, #1064]	; 0x428
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480f7c8:	eb0034fa 	bl	3481cbb8 <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f7cc:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f7d0:	e3500000 	cmp	r0, #0
3480f7d4:	03a00015 	moveq	r0, #21
3480f7d8:	13a00043 	movne	r0, #67	; 0x43
3480f7dc:	ebffe8e1 	bl	34809b68 <putc>
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	  xyz.total_retries++;
3480f7e0:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480f7e4:	e2833001 	add	r3, r3, #1
3480f7e8:	e5843418 	str	r3, [r4, #1048]	; 0x418
3480f7ec:	ea000001 	b	3480f7f8 <xyzModem_stream_open+0x124>
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
3480f7f0:	e3750005 	cmn	r5, #5
3480f7f4:	0a000001 	beq	3480f800 <xyzModem_stream_open+0x12c>
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
      return 0;
    }

  while (retries-- > 0)
3480f7f8:	e2566001 	subs	r6, r6, #1
3480f7fc:	2affffd3 	bcs	3480f750 <xyzModem_stream_open+0x7c>
      if (stat == xyzModem_cancel)
	{
	  break;
	}
    }
  *err = stat;
3480f800:	e58a5000 	str	r5, [sl]
  ZM_DEBUG (zm_flush ());
  return -1;
3480f804:	e3e00000 	mvn	r0, #0
}
3480f808:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
3480f80c:	3482b874 	.word	0x3482b874
3480f810:	348266f2 	.word	0x348266f2
3480f814:	3482bca8 	.word	0x3482bca8
3480f818:	0007a120 	.word	0x0007a120

3480f81c <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480f81c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480f820:	e59f4240 	ldr	r4, [pc, #576]	; 3480fa68 <xyzModem_stream_read+0x24c>
  return -1;
}

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480f824:	e1a09000 	mov	r9, r0
3480f828:	e1a0a001 	mov	sl, r1
3480f82c:	e58d2004 	str	r2, [sp, #4]
  int stat, total, len;
  int retries;

  total = 0;
3480f830:	e3a0b000 	mov	fp, #0
  stat = xyzModem_cancel;
3480f834:	e3e05004 	mvn	r5, #4
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f838:	e1a07004 	mov	r7, r4
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480f83c:	ea00007f 	b	3480fa40 <xyzModem_stream_read+0x224>
    {
      if (xyz.len == 0)
3480f840:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f844:	e3530000 	cmp	r3, #0
3480f848:	03a06014 	moveq	r6, #20
3480f84c:	0a00005d 	beq	3480f9c8 <xyzModem_stream_read+0x1ac>
3480f850:	ea000066 	b	3480f9f0 <xyzModem_stream_read+0x1d4>
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
3480f854:	ebfffeb4 	bl	3480f32c <xyzModem_get_hdr>
	      if (stat == 0)
3480f858:	e2505000 	subs	r5, r0, #0
3480f85c:	1a000039 	bne	3480f948 <xyzModem_stream_read+0x12c>
		{
		  if (xyz.blk == xyz.next_blk)
3480f860:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480f864:	e5d4240c 	ldrb	r2, [r4, #1036]	; 0x40c
3480f868:	e1530002 	cmp	r3, r2
3480f86c:	1a00002d 	bne	3480f928 <xyzModem_stream_read+0x10c>
		    {
		      xyz.tx_ack = true;
3480f870:	e3a02001 	mov	r2, #1
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480f874:	e0833002 	add	r3, r3, r2
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
3480f878:	e5872430 	str	r2, [r7, #1072]	; 0x430
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480f87c:	e5972414 	ldr	r2, [r7, #1044]	; 0x414
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480f880:	e5c7340c 	strb	r3, [r7, #1036]	; 0x40c

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480f884:	e3520001 	cmp	r2, #1
3480f888:	0a000002 	beq	3480f898 <xyzModem_stream_read+0x7c>
3480f88c:	e5973434 	ldr	r3, [r7, #1076]	; 0x434
3480f890:	e3530000 	cmp	r3, #0
3480f894:	1a000017 	bne	3480f8f8 <xyzModem_stream_read+0xdc>
		      if (1)
			{
#endif
			  /* Data blocks can be padded with ^Z (EOF) characters */
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
3480f898:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480f89c:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f8a0:	e0813003 	add	r3, r1, r3
3480f8a4:	e5530001 	ldrb	r0, [r3, #-1]
3480f8a8:	e350001a 	cmp	r0, #26
3480f8ac:	1a00000f 	bne	3480f8f0 <xyzModem_stream_read+0xd4>
3480f8b0:	e5530002 	ldrb	r0, [r3, #-2]
3480f8b4:	e350001a 	cmp	r0, #26
3480f8b8:	1a00000c 	bne	3480f8f0 <xyzModem_stream_read+0xd4>
			      (xyz.bufp[xyz.len - 2] == EOF) &&
3480f8bc:	e5533003 	ldrb	r3, [r3, #-3]
3480f8c0:	e353001a 	cmp	r3, #26
3480f8c4:	1a000009 	bne	3480f8f0 <xyzModem_stream_read+0xd4>
3480f8c8:	ea000001 	b	3480f8d4 <xyzModem_stream_read+0xb8>
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
				     && (xyz.bufp[xyz.len - 1] == EOF))
				{
				  xyz.len--;
3480f8cc:	e2433001 	sub	r3, r3, #1
3480f8d0:	e5843410 	str	r3, [r4, #1040]	; 0x410
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
			      (xyz.bufp[xyz.len - 2] == EOF) &&
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
3480f8d4:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480f8d8:	e3530000 	cmp	r3, #0
3480f8dc:	0a000003 	beq	3480f8f0 <xyzModem_stream_read+0xd4>
				     && (xyz.bufp[xyz.len - 1] == EOF))
3480f8e0:	e0810003 	add	r0, r1, r3
3480f8e4:	e5500001 	ldrb	r0, [r0, #-1]
3480f8e8:	e350001a 	cmp	r0, #26
3480f8ec:	0afffff6 	beq	3480f8cc <xyzModem_stream_read+0xb0>
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
3480f8f0:	e3520001 	cmp	r2, #1
3480f8f4:	0a00003d 	beq	3480f9f0 <xyzModem_stream_read+0x1d4>
3480f8f8:	e5942434 	ldr	r2, [r4, #1076]	; 0x434
3480f8fc:	e3520000 	cmp	r2, #0
3480f900:	0a00003a 	beq	3480f9f0 <xyzModem_stream_read+0x1d4>
			{
			  xyz.read_length += xyz.len;
3480f904:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480f908:	e5943438 	ldr	r3, [r4, #1080]	; 0x438
3480f90c:	e0813003 	add	r3, r1, r3
			  if (xyz.read_length > xyz.file_length)
3480f910:	e1530002 	cmp	r3, r2
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480f914:	80812002 	addhi	r2, r1, r2
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
			{
			  xyz.read_length += xyz.len;
3480f918:	e5843438 	str	r3, [r4, #1080]	; 0x438
			  if (xyz.read_length > xyz.file_length)
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480f91c:	80633002 	rsbhi	r3, r3, r2
3480f920:	85843410 	strhi	r3, [r4, #1040]	; 0x410
3480f924:	ea000031 	b	3480f9f0 <xyzModem_stream_read+0x1d4>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480f928:	e2422001 	sub	r2, r2, #1
3480f92c:	e20220ff 	and	r2, r2, #255	; 0xff
3480f930:	e1530002 	cmp	r3, r2
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
		    }
		  else
		    {
		      stat = xyzModem_sequence;
3480f934:	13e05007 	mvnne	r5, #7
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480f938:	1a00001a 	bne	3480f9a8 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f93c:	e3a00006 	mov	r0, #6
3480f940:	ebffe888 	bl	34809b68 <putc>
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
3480f944:	ea00001f 	b	3480f9c8 <xyzModem_stream_read+0x1ac>
		  else
		    {
		      stat = xyzModem_sequence;
		    }
		}
	      if (stat == xyzModem_cancel)
3480f948:	e3750005 	cmn	r5, #5
3480f94c:	0a000021 	beq	3480f9d8 <xyzModem_stream_read+0x1bc>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
3480f950:	e3750004 	cmn	r5, #4
3480f954:	1a000013 	bne	3480f9a8 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f958:	e3a00006 	mov	r0, #6
3480f95c:	ebffe881 	bl	34809b68 <putc>
		}
	      if (stat == xyzModem_eof)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
3480f960:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480f964:	e3530002 	cmp	r3, #2
3480f968:	1a00000b 	bne	3480f99c <xyzModem_stream_read+0x180>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
3480f96c:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f970:	e3500000 	cmp	r0, #0
3480f974:	03a00015 	moveq	r0, #21
3480f978:	13a00043 	movne	r0, #67	; 0x43
3480f97c:	ebffe879 	bl	34809b68 <putc>
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
3480f980:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480f984:	e2833001 	add	r3, r3, #1
3480f988:	e5843418 	str	r3, [r4, #1048]	; 0x418
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
3480f98c:	ebfffe66 	bl	3480f32c <xyzModem_get_hdr>
3480f990:	e1a05000 	mov	r5, r0
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f994:	e3a00006 	mov	r0, #6
3480f998:	ebffe872 	bl	34809b68 <putc>
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
3480f99c:	e3a03001 	mov	r3, #1
3480f9a0:	e584342c 	str	r3, [r4, #1068]	; 0x42c
		  break;
3480f9a4:	ea000009 	b	3480f9d0 <xyzModem_stream_read+0x1b4>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480f9a8:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f9ac:	e3500000 	cmp	r0, #0
3480f9b0:	03a00015 	moveq	r0, #21
3480f9b4:	13a00043 	movne	r0, #67	; 0x43
3480f9b8:	ebffe86a 	bl	34809b68 <putc>
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
3480f9bc:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480f9c0:	e2833001 	add	r3, r3, #1
3480f9c4:	e5843418 	str	r3, [r4, #1048]	; 0x418
  while (!xyz.at_eof && (size > 0))
    {
      if (xyz.len == 0)
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
3480f9c8:	e2566001 	subs	r6, r6, #1
3480f9cc:	2affffa0 	bcs	3480f854 <xyzModem_stream_read+0x38>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
3480f9d0:	e3550000 	cmp	r5, #0
3480f9d4:	aa000005 	bge	3480f9f0 <xyzModem_stream_read+0x1d4>
	    {
	      *err = stat;
3480f9d8:	e59d2004 	ldr	r2, [sp, #4]
	      xyz.len = -1;
3480f9dc:	e59f3084 	ldr	r3, [pc, #132]	; 3480fa68 <xyzModem_stream_read+0x24c>
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
	    {
	      *err = stat;
3480f9e0:	e5825000 	str	r5, [r2]
	      xyz.len = -1;
3480f9e4:	e3e02000 	mvn	r2, #0
3480f9e8:	e5832410 	str	r2, [r3, #1040]	; 0x410
	      return total;
3480f9ec:	ea00001b 	b	3480fa60 <xyzModem_stream_read+0x244>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
3480f9f0:	e594342c 	ldr	r3, [r4, #1068]	; 0x42c
3480f9f4:	e3530000 	cmp	r3, #0
3480f9f8:	1a000010 	bne	3480fa40 <xyzModem_stream_read+0x224>
	{
	  len = xyz.len;
3480f9fc:	e5946410 	ldr	r6, [r4, #1040]	; 0x410
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480fa00:	e1a00009 	mov	r0, r9
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
	{
	  len = xyz.len;
3480fa04:	e15a0006 	cmp	sl, r6
3480fa08:	b1a0600a 	movlt	r6, sl
3480fa0c:	a1a06006 	movge	r6, r6
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480fa10:	e1a02006 	mov	r2, r6
3480fa14:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480fa18:	eb0033db 	bl	3481c98c <memcpy>
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480fa1c:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
	{
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
3480fa20:	e066a00a 	rsb	sl, r6, sl
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480fa24:	e0663003 	rsb	r3, r6, r3
3480fa28:	e5843410 	str	r3, [r4, #1040]	; 0x410
	  xyz.bufp += len;
3480fa2c:	e5943404 	ldr	r3, [r4, #1028]	; 0x404
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
3480fa30:	e0899006 	add	r9, r9, r6
	  total += len;
3480fa34:	e08bb006 	add	fp, fp, r6
	  xyz.len -= len;
	  xyz.bufp += len;
3480fa38:	e0836006 	add	r6, r3, r6
3480fa3c:	e5846404 	str	r6, [r4, #1028]	; 0x404
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480fa40:	e594242c 	ldr	r2, [r4, #1068]	; 0x42c
3480fa44:	e35a0000 	cmp	sl, #0
3480fa48:	d3a03000 	movle	r3, #0
3480fa4c:	c3a03001 	movgt	r3, #1
3480fa50:	e3520000 	cmp	r2, #0
3480fa54:	13a03000 	movne	r3, #0
3480fa58:	e3530000 	cmp	r3, #0
3480fa5c:	1affff77 	bne	3480f840 <xyzModem_stream_read+0x24>
	  xyz.len -= len;
	  xyz.bufp += len;
	}
    }
  return total;
}
3480fa60:	e1a0000b 	mov	r0, fp
3480fa64:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480fa68:	3482b874 	.word	0x3482b874

3480fa6c <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
3480fa6c:	e92d4007 	push	{r0, r1, r2, lr}
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
3480fa70:	e59f3034 	ldr	r3, [pc, #52]	; 3480faac <xyzModem_stream_close+0x40>

void
xyzModem_stream_close (int *err)
{
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
3480fa74:	e59f1034 	ldr	r1, [pc, #52]	; 3480fab0 <xyzModem_stream_close+0x44>
3480fa78:	e5932424 	ldr	r2, [r3, #1060]	; 0x424
3480fa7c:	e593c428 	ldr	ip, [r3, #1064]	; 0x428
3480fa80:	e58d2000 	str	r2, [sp]
3480fa84:	e5932418 	ldr	r2, [r3, #1048]	; 0x418
3480fa88:	e35c0000 	cmp	ip, #0
3480fa8c:	e58d2004 	str	r2, [sp, #4]
3480fa90:	e59f201c 	ldr	r2, [pc, #28]	; 3480fab4 <xyzModem_stream_close+0x48>
3480fa94:	e59f001c 	ldr	r0, [pc, #28]	; 3480fab8 <xyzModem_stream_close+0x4c>
3480fa98:	11a01002 	movne	r1, r2
3480fa9c:	e593241c 	ldr	r2, [r3, #1052]	; 0x41c
3480faa0:	e5933420 	ldr	r3, [r3, #1056]	; 0x420
3480faa4:	ebffe843 	bl	34809bb8 <printf>
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
     xyz.total_CAN, xyz.total_retries);
  ZM_DEBUG (zm_flush ());
}
3480faa8:	e8bd800e 	pop	{r1, r2, r3, pc}
3480faac:	3482b874 	.word	0x3482b874
3480fab0:	34826c2c 	.word	0x34826c2c
3480fab4:	34826386 	.word	0x34826386
3480fab8:	34826c32 	.word	0x34826c32

3480fabc <xyzModem_stream_terminate>:
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
  int c;

  if (abort)
3480fabc:	e3500000 	cmp	r0, #0

/* Need to be able to clean out the input buffer, so have to take the */
/* getc */
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
3480fac0:	e92d4010 	push	{r4, lr}
3480fac4:	e1a04001 	mov	r4, r1
  int c;

  if (abort)
3480fac8:	0a000018 	beq	3480fb30 <xyzModem_stream_terminate+0x74>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
3480facc:	e59f4074 	ldr	r4, [pc, #116]	; 3480fb48 <xyzModem_stream_terminate+0x8c>
3480fad0:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480fad4:	e2433001 	sub	r3, r3, #1
3480fad8:	e3530001 	cmp	r3, #1
3480fadc:	88bd8010 	pophi	{r4, pc}
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480fae0:	e3a00018 	mov	r0, #24
3480fae4:	ebffe81f 	bl	34809b68 <putc>
3480fae8:	e3a00018 	mov	r0, #24
3480faec:	ebffe81d 	bl	34809b68 <putc>
3480faf0:	e3a00018 	mov	r0, #24
3480faf4:	ebffe81b 	bl	34809b68 <putc>
3480faf8:	e3a00018 	mov	r0, #24
3480fafc:	ebffe819 	bl	34809b68 <putc>
3480fb00:	e3a00008 	mov	r0, #8
3480fb04:	ebffe817 	bl	34809b68 <putc>
3480fb08:	e3a00008 	mov	r0, #8
3480fb0c:	ebffe815 	bl	34809b68 <putc>
3480fb10:	e3a00008 	mov	r0, #8
3480fb14:	ebffe813 	bl	34809b68 <putc>
3480fb18:	e3a00008 	mov	r0, #8
3480fb1c:	ebffe811 	bl	34809b68 <putc>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
3480fb20:	ebfffdf6 	bl	3480f300 <xyzModem_flush>
	  xyz.at_eof = true;
3480fb24:	e3a03001 	mov	r3, #1
3480fb28:	e584342c 	str	r3, [r4, #1068]	; 0x42c
3480fb2c:	e8bd8010 	pop	{r4, pc}
       * previous received blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
3480fb30:	e12fff34 	blx	r4
3480fb34:	e3500000 	cmp	r0, #0
3480fb38:	aafffffc 	bge	3480fb30 <xyzModem_stream_terminate+0x74>
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480fb3c:	e59f0008 	ldr	r0, [pc, #8]	; 3480fb4c <xyzModem_stream_terminate+0x90>
    }
}
3480fb40:	e8bd4010 	pop	{r4, lr}
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480fb44:	ea00341b 	b	3481cbb8 <udelay>
3480fb48:	3482b874 	.word	0x3482b874
3480fb4c:	0003d090 	.word	0x0003d090

3480fb50 <xyzModem_error>:
    }
}

char *
xyzModem_error (int err)
{
3480fb50:	e2800008 	add	r0, r0, #8
3480fb54:	e3500007 	cmp	r0, #7
3480fb58:	959f3008 	ldrls	r3, [pc, #8]	; 3480fb68 <xyzModem_error+0x18>
3480fb5c:	859f0008 	ldrhi	r0, [pc, #8]	; 3480fb6c <xyzModem_error+0x1c>
3480fb60:	97930100 	ldrls	r0, [r3, r0, lsl #2]
      break;
    default:
      return "Unknown error";
      break;
    }
}
3480fb64:	e12fff1e 	bx	lr
3480fb68:	34821650 	.word	0x34821650
3480fb6c:	34826c73 	.word	0x34826c73

3480fb70 <get_dev>:
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480fb70:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480fb74:	e2505000 	subs	r5, r0, #0
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480fb78:	e1a07001 	mov	r7, r1
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480fb7c:	159f4054 	ldrne	r4, [pc, #84]	; 3480fbd8 <get_dev+0x68>
3480fb80:	0a000012 	beq	3480fbd0 <get_dev+0x60>
3480fb84:	ea00000c 	b	3480fbbc <get_dev+0x4c>
		reloc_get_dev = drvr->get_dev;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480fb88:	e1a0000a 	mov	r0, sl
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
		name = drvr->name;
		reloc_get_dev = drvr->get_dev;
3480fb8c:	e5146004 	ldr	r6, [r4, #-4]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480fb90:	eb0032b9 	bl	3481c67c <strlen>
3480fb94:	e1a0100a 	mov	r1, sl
3480fb98:	e1a02000 	mov	r2, r0
3480fb9c:	e1a00005 	mov	r0, r5
3480fba0:	eb00328d 	bl	3481c5dc <strncmp>
3480fba4:	e3500000 	cmp	r0, #0
3480fba8:	e2844008 	add	r4, r4, #8
3480fbac:	1a000002 	bne	3480fbbc <get_dev+0x4c>
			return reloc_get_dev(dev);
3480fbb0:	e1a00007 	mov	r0, r7
3480fbb4:	e12fff36 	blx	r6
3480fbb8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	name = drvr->name;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
3480fbbc:	e514a008 	ldr	sl, [r4, #-8]
3480fbc0:	e35a0000 	cmp	sl, #0
3480fbc4:	1affffef 	bne	3480fb88 <get_dev+0x18>
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
3480fbc8:	e1a0000a 	mov	r0, sl
3480fbcc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
		return NULL;
3480fbd0:	e1a00005 	mov	r0, r5
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
}
3480fbd4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480fbd8:	34821678 	.word	0x34821678

3480fbdc <dev_print>:
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480fbdc:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480fbe0:	e5d0300b 	ldrb	r3, [r0, #11]
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480fbe4:	e1a04000 	mov	r4, r0
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480fbe8:	e35300ff 	cmp	r3, #255	; 0xff
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480fbec:	e24dd014 	sub	sp, sp, #20
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
		puts ("not available\n");
3480fbf0:	059f01b0 	ldreq	r0, [pc, #432]	; 3480fda8 <dev_print+0x1cc>

void dev_print (block_dev_desc_t *dev_desc)
{
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480fbf4:	0a000068 	beq	3480fd9c <dev_print+0x1c0>
		puts ("not available\n");
		return;
	}

	switch (dev_desc->if_type) {
3480fbf8:	e5941000 	ldr	r1, [r4]
3480fbfc:	e3510008 	cmp	r1, #8
3480fc00:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480fc04:	ea00001e 	b	3480fc84 <dev_print+0xa8>
3480fc08:	3480fc7c 	.word	0x3480fc7c
3480fc0c:	3480fc54 	.word	0x3480fc54
3480fc10:	3480fc2c 	.word	0x3480fc2c
3480fc14:	3480fc54 	.word	0x3480fc54
3480fc18:	3480fc5c 	.word	0x3480fc5c
3480fc1c:	3480fc74 	.word	0x3480fc74
3480fc20:	3480fc5c 	.word	0x3480fc5c
3480fc24:	3480fc5c 	.word	0x3480fc5c
3480fc28:	3480fc54 	.word	0x3480fc54
	case IF_TYPE_SCSI:
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
3480fc2c:	e2843041 	add	r3, r4, #65	; 0x41
3480fc30:	e5d41009 	ldrb	r1, [r4, #9]
3480fc34:	e5d4200a 	ldrb	r2, [r4, #10]
3480fc38:	e58d3000 	str	r3, [sp]
3480fc3c:	e2843056 	add	r3, r4, #86	; 0x56
3480fc40:	e58d3004 	str	r3, [sp, #4]
3480fc44:	e59f0160 	ldr	r0, [pc, #352]	; 3480fdac <dev_print+0x1d0>
3480fc48:	e2843018 	add	r3, r4, #24
3480fc4c:	ebffe7d9 	bl	34809bb8 <printf>
			dev_desc->target,dev_desc->lun,
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
		break;
3480fc50:	ea00000f 	b	3480fc94 <dev_print+0xb8>
	case IF_TYPE_ATAPI:
	case IF_TYPE_IDE:
	case IF_TYPE_SATA:
		printf ("Model: %s Firm: %s Ser#: %s\n",
3480fc54:	e59f0154 	ldr	r0, [pc, #340]	; 3480fdb0 <dev_print+0x1d4>
3480fc58:	ea000000 	b	3480fc60 <dev_print+0x84>
			dev_desc->product);
		break;
	case IF_TYPE_SD:
	case IF_TYPE_MMC:
	case IF_TYPE_USB:
		printf ("Vendor: %s Rev: %s Prod: %s\n",
3480fc5c:	e59f0150 	ldr	r0, [pc, #336]	; 3480fdb4 <dev_print+0x1d8>
3480fc60:	e2841018 	add	r1, r4, #24
3480fc64:	e2842056 	add	r2, r4, #86	; 0x56
3480fc68:	e2843041 	add	r3, r4, #65	; 0x41
3480fc6c:	ebffe7d1 	bl	34809bb8 <printf>
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
		break;
3480fc70:	ea000007 	b	3480fc94 <dev_print+0xb8>
	case IF_TYPE_DOC:
		puts("device type DOC\n");
3480fc74:	e59f013c 	ldr	r0, [pc, #316]	; 3480fdb8 <dev_print+0x1dc>
3480fc78:	ea000047 	b	3480fd9c <dev_print+0x1c0>
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
3480fc7c:	e59f0138 	ldr	r0, [pc, #312]	; 3480fdbc <dev_print+0x1e0>
3480fc80:	ea000045 	b	3480fd9c <dev_print+0x1c0>
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480fc84:	e59f0134 	ldr	r0, [pc, #308]	; 3480fdc0 <dev_print+0x1e4>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480fc88:	e28dd014 	add	sp, sp, #20
3480fc8c:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480fc90:	eaffe7c8 	b	34809bb8 <printf>
		return;
	}
	puts ("            Type: ");
3480fc94:	e59f0128 	ldr	r0, [pc, #296]	; 3480fdc4 <dev_print+0x1e8>
3480fc98:	ebffe7bc 	bl	34809b90 <puts>
	if (dev_desc->removable)
3480fc9c:	e5d4300c 	ldrb	r3, [r4, #12]
3480fca0:	e3530000 	cmp	r3, #0
3480fca4:	0a000001 	beq	3480fcb0 <dev_print+0xd4>
		puts ("Removable ");
3480fca8:	e59f0118 	ldr	r0, [pc, #280]	; 3480fdc8 <dev_print+0x1ec>
3480fcac:	ebffe7b7 	bl	34809b90 <puts>
	switch (dev_desc->type & 0x1F) {
3480fcb0:	e5d4100b 	ldrb	r1, [r4, #11]
3480fcb4:	e201101f 	and	r1, r1, #31
3480fcb8:	e3510007 	cmp	r1, #7
3480fcbc:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480fcc0:	ea000010 	b	3480fd08 <dev_print+0x12c>
3480fcc4:	3480fce4 	.word	0x3480fce4
3480fcc8:	3480fd00 	.word	0x3480fd00
3480fccc:	3480fd08 	.word	0x3480fd08
3480fcd0:	3480fd08 	.word	0x3480fd08
3480fcd4:	3480fd08 	.word	0x3480fd08
3480fcd8:	3480fcec 	.word	0x3480fcec
3480fcdc:	3480fd08 	.word	0x3480fd08
3480fce0:	3480fcf8 	.word	0x3480fcf8
	case DEV_TYPE_HARDDISK:
		puts ("Hard Disk");
3480fce4:	e59f00e0 	ldr	r0, [pc, #224]	; 3480fdcc <dev_print+0x1f0>
3480fce8:	ea000000 	b	3480fcf0 <dev_print+0x114>
		break;
	case DEV_TYPE_CDROM:
		puts ("CD ROM");
3480fcec:	e59f00dc 	ldr	r0, [pc, #220]	; 3480fdd0 <dev_print+0x1f4>
3480fcf0:	ebffe7a6 	bl	34809b90 <puts>
		break;
3480fcf4:	ea000005 	b	3480fd10 <dev_print+0x134>
	case DEV_TYPE_OPDISK:
		puts ("Optical Device");
3480fcf8:	e59f00d4 	ldr	r0, [pc, #212]	; 3480fdd4 <dev_print+0x1f8>
3480fcfc:	eafffffb 	b	3480fcf0 <dev_print+0x114>
		break;
	case DEV_TYPE_TAPE:
		puts ("Tape");
3480fd00:	e59f00d0 	ldr	r0, [pc, #208]	; 3480fdd8 <dev_print+0x1fc>
3480fd04:	eafffff9 	b	3480fcf0 <dev_print+0x114>
		break;
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
3480fd08:	e59f00cc 	ldr	r0, [pc, #204]	; 3480fddc <dev_print+0x200>
3480fd0c:	ebffe7a9 	bl	34809bb8 <printf>
		break;
	}
	puts ("\n");
3480fd10:	e59f00c8 	ldr	r0, [pc, #200]	; 3480fde0 <dev_print+0x204>
3480fd14:	ebffe79d 	bl	34809b90 <puts>
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480fd18:	e5947010 	ldr	r7, [r4, #16]
3480fd1c:	e5946014 	ldr	r6, [r4, #20]
3480fd20:	e0130697 	muls	r3, r7, r6
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480fd24:	059f00b8 	ldreq	r0, [pc, #184]	; 3480fde4 <dev_print+0x208>
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
		break;
	}
	puts ("\n");
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480fd28:	0a00001b 	beq	3480fd9c <dev_print+0x1c0>
		ulong mb, mb_quot, mb_rem, gb, gb_quot, gb_rem;
		lbaint_t lba;

		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
3480fd2c:	e1a024a6 	lsr	r2, r6, #9
3480fd30:	e0020297 	mul	r2, r7, r2
static lba512_t lba512_muldiv (lba512_t block_count, lba512_t mul_by, lba512_t div_by)
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
3480fd34:	e1a035a2 	lsr	r3, r2, #11
	bc_rem  = block_count - div_by * bc_quot;
3480fd38:	e1a05583 	lsl	r5, r3, #11
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480fd3c:	e3a0400a 	mov	r4, #10
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
	bc_rem  = block_count - div_by * bc_quot;
3480fd40:	e0655002 	rsb	r5, r5, r2
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480fd44:	e0030394 	mul	r3, r4, r3
3480fd48:	e0050594 	mul	r5, r4, r5
3480fd4c:	e08355a5 	add	r5, r3, r5, lsr #11

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480fd50:	e1a01004 	mov	r1, r4
3480fd54:	e1a00005 	mov	r0, r5
3480fd58:	eb004053 	bl	3481feac <__udivsi3>
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
3480fd5c:	e1a0a435 	lsr	sl, r5, r4

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480fd60:	e1a09000 	mov	r9, r0
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480fd64:	e1a01004 	mov	r1, r4
3480fd68:	e1a0000a 	mov	r0, sl
3480fd6c:	eb00404e 	bl	3481feac <__udivsi3>
		gb_rem	= gb - (10 * gb_quot);
3480fd70:	e06aa094 	mls	sl, r4, r0, sl

		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480fd74:	e1a03000 	mov	r3, r0
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
3480fd78:	e1a01009 	mov	r1, r9
3480fd7c:	e0625994 	mls	r2, r4, r9, r5
3480fd80:	e59f0060 	ldr	r0, [pc, #96]	; 3480fde8 <dev_print+0x20c>
3480fd84:	e58da000 	str	sl, [sp]
3480fd88:	e58d7004 	str	r7, [sp, #4]
3480fd8c:	e58d6008 	str	r6, [sp, #8]
3480fd90:	ebffe788 	bl	34809bb8 <printf>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480fd94:	e28dd014 	add	sp, sp, #20
3480fd98:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3480fd9c:	e28dd014 	add	sp, sp, #20
3480fda0:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480fda4:	eaffe779 	b	34809b90 <puts>
3480fda8:	34826e49 	.word	0x34826e49
3480fdac:	34826d0b 	.word	0x34826d0b
3480fdb0:	34826d31 	.word	0x34826d31
3480fdb4:	34826d4e 	.word	0x34826d4e
3480fdb8:	34826d6b 	.word	0x34826d6b
3480fdbc:	34826d7c 	.word	0x34826d7c
3480fdc0:	34826d91 	.word	0x34826d91
3480fdc4:	34826dac 	.word	0x34826dac
3480fdc8:	34826dbf 	.word	0x34826dbf
3480fdcc:	34826dca 	.word	0x34826dca
3480fdd0:	34826dd4 	.word	0x34826dd4
3480fdd4:	34826ddb 	.word	0x34826ddb
3480fdd8:	34826dea 	.word	0x34826dea
3480fddc:	34826def 	.word	0x34826def
3480fde0:	348264dd 	.word	0x348264dd
3480fde4:	34826e33 	.word	0x34826e33
3480fde8:	34826df8 	.word	0x34826df8

3480fdec <init_part>:
    defined(CONFIG_ISO_PARTITION) || \
    defined(CONFIG_AMIGA_PARTITION) || \
    defined(CONFIG_EFI_PARTITION)

void init_part (block_dev_desc_t * dev_desc)
{
3480fdec:	e92d4010 	push	{r4, lr}
3480fdf0:	e1a04000 	mov	r4, r0
		return;
	}
#endif

#ifdef CONFIG_DOS_PARTITION
	if (test_part_dos(dev_desc) == 0) {
3480fdf4:	eb000259 	bl	34810760 <test_part_dos>
3480fdf8:	e3500000 	cmp	r0, #0
		dev_desc->part_type = PART_TYPE_DOS;
3480fdfc:	03a03002 	moveq	r3, #2
	if (test_part_amiga(dev_desc) == 0) {
	    dev_desc->part_type = PART_TYPE_AMIGA;
	    return;
	}
#endif
	dev_desc->part_type = PART_TYPE_UNKNOWN;
3480fe00:	13a03000 	movne	r3, #0
3480fe04:	e5c43008 	strb	r3, [r4, #8]
3480fe08:	e8bd8010 	pop	{r4, pc}

3480fe0c <print_part>:
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480fe0c:	e92d4010 	push	{r4, lr}

		switch (dev_desc->part_type) {
3480fe10:	e5d03008 	ldrb	r3, [r0, #8]
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480fe14:	e1a04000 	mov	r4, r0

		switch (dev_desc->part_type) {
3480fe18:	e3530002 	cmp	r3, #2
3480fe1c:	1a000025 	bne	3480feb8 <print_part+0xac>
}


static void print_part_header (const char *type, block_dev_desc_t * dev_desc)
{
	puts ("\nPartition Map for ");
3480fe20:	e59f009c 	ldr	r0, [pc, #156]	; 3480fec4 <print_part+0xb8>
3480fe24:	ebffe759 	bl	34809b90 <puts>
	switch (dev_desc->if_type) {
3480fe28:	e5943000 	ldr	r3, [r4]
3480fe2c:	e2433001 	sub	r3, r3, #1
3480fe30:	e3530007 	cmp	r3, #7
3480fe34:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480fe38:	ea000015 	b	3480fe94 <print_part+0x88>
3480fe3c:	3480fe5c 	.word	0x3480fe5c
3480fe40:	3480fe6c 	.word	0x3480fe6c
3480fe44:	3480fe74 	.word	0x3480fe74
3480fe48:	3480fe7c 	.word	0x3480fe7c
3480fe4c:	3480fe84 	.word	0x3480fe84
3480fe50:	3480fe8c 	.word	0x3480fe8c
3480fe54:	3480fe94 	.word	0x3480fe94
3480fe58:	3480fe64 	.word	0x3480fe64
	case IF_TYPE_IDE:
		puts ("IDE");
3480fe5c:	e59f0064 	ldr	r0, [pc, #100]	; 3480fec8 <print_part+0xbc>
3480fe60:	ea00000c 	b	3480fe98 <print_part+0x8c>
		break;
	case IF_TYPE_SATA:
		puts ("SATA");
3480fe64:	e59f0060 	ldr	r0, [pc, #96]	; 3480fecc <print_part+0xc0>
3480fe68:	ea00000a 	b	3480fe98 <print_part+0x8c>
		break;
	case IF_TYPE_SCSI:
		puts ("SCSI");
3480fe6c:	e59f005c 	ldr	r0, [pc, #92]	; 3480fed0 <print_part+0xc4>
3480fe70:	ea000008 	b	3480fe98 <print_part+0x8c>
		break;
	case IF_TYPE_ATAPI:
		puts ("ATAPI");
3480fe74:	e59f0058 	ldr	r0, [pc, #88]	; 3480fed4 <print_part+0xc8>
3480fe78:	ea000006 	b	3480fe98 <print_part+0x8c>
		break;
	case IF_TYPE_USB:
		puts ("USB");
3480fe7c:	e59f0054 	ldr	r0, [pc, #84]	; 3480fed8 <print_part+0xcc>
3480fe80:	ea000004 	b	3480fe98 <print_part+0x8c>
		break;
	case IF_TYPE_DOC:
		puts ("DOC");
3480fe84:	e59f0050 	ldr	r0, [pc, #80]	; 3480fedc <print_part+0xd0>
3480fe88:	ea000002 	b	3480fe98 <print_part+0x8c>
		break;
	case IF_TYPE_MMC:
		puts ("MMC");
3480fe8c:	e59f004c 	ldr	r0, [pc, #76]	; 3480fee0 <print_part+0xd4>
3480fe90:	ea000000 	b	3480fe98 <print_part+0x8c>
		break;
	default:
		puts ("UNKNOWN");
3480fe94:	e59f0048 	ldr	r0, [pc, #72]	; 3480fee4 <print_part+0xd8>
3480fe98:	ebffe73c 	bl	34809b90 <puts>
		break;
	}
	printf (" device %d  --   Partition Type: %s\n\n",
3480fe9c:	e5941004 	ldr	r1, [r4, #4]
3480fea0:	e59f2040 	ldr	r2, [pc, #64]	; 3480fee8 <print_part+0xdc>
3480fea4:	e59f0040 	ldr	r0, [pc, #64]	; 3480feec <print_part+0xe0>
3480fea8:	ebffe742 	bl	34809bb8 <printf>
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480feac:	e1a00004 	mov	r0, r4
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
}
3480feb0:	e8bd4010 	pop	{r4, lr}
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480feb4:	ea000241 	b	348107c0 <print_part_dos>
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480feb8:	e59f0030 	ldr	r0, [pc, #48]	; 3480fef0 <print_part+0xe4>
}
3480febc:	e8bd4010 	pop	{r4, lr}
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480fec0:	eaffe732 	b	34809b90 <puts>
3480fec4:	34826e58 	.word	0x34826e58
3480fec8:	34826e6c 	.word	0x34826e6c
3480fecc:	34826e70 	.word	0x34826e70
3480fed0:	34826e75 	.word	0x34826e75
3480fed4:	34826e7a 	.word	0x34826e7a
3480fed8:	34826e80 	.word	0x34826e80
3480fedc:	34826e84 	.word	0x34826e84
3480fee0:	348244ce 	.word	0x348244ce
3480fee4:	34826e88 	.word	0x34826e88
3480fee8:	34826eb6 	.word	0x34826eb6
3480feec:	34826e90 	.word	0x34826e90
3480fef0:	34826eba 	.word	0x34826eba

3480fef4 <get_partition_info>:

#endif

int get_partition_info(block_dev_desc_t *dev_desc, int part
					, disk_partition_t *info)
{
3480fef4:	e92d4008 	push	{r3, lr}
#ifdef CONFIG_PARTITION_UUIDS
	/* The common case is no UUID support */
	info->uuid[0] = 0;
#endif

	switch (dev_desc->part_type) {
3480fef8:	e5d03008 	ldrb	r3, [r0, #8]
3480fefc:	e3530002 	cmp	r3, #2
3480ff00:	1a000003 	bne	3480ff14 <get_partition_info+0x20>
		break;
#endif

#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		if (get_partition_info_dos(dev_desc, part, info) == 0) {
3480ff04:	eb000238 	bl	348107ec <get_partition_info_dos>
3480ff08:	e3500000 	cmp	r0, #0
	default:
		break;
	}
#endif

	return -1;
3480ff0c:	13e00000 	mvnne	r0, #0
3480ff10:	e8bd8008 	pop	{r3, pc}
3480ff14:	e3e00000 	mvn	r0, #0
}
3480ff18:	e8bd8008 	pop	{r3, pc}

3480ff1c <get_device>:

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480ff1c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3480ff20:	e1a05000 	mov	r5, r0
3480ff24:	e1a04001 	mov	r4, r1
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480ff28:	e1a00001 	mov	r0, r1
	return -1;
}

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480ff2c:	e1a06002 	mov	r6, r2
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480ff30:	e28d1004 	add	r1, sp, #4
3480ff34:	e3a02010 	mov	r2, #16
3480ff38:	eb003562 	bl	3481d4c8 <simple_strtoul>
	if (*ep) {
3480ff3c:	e59d3004 	ldr	r3, [sp, #4]
3480ff40:	e5d33000 	ldrb	r3, [r3]
3480ff44:	e3530000 	cmp	r3, #0
		printf("** Bad device specification %s %s **\n",
3480ff48:	159f0044 	ldrne	r0, [pc, #68]	; 3480ff94 <get_device+0x78>
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
	if (*ep) {
3480ff4c:	1a00000a 	bne	3480ff7c <get_device+0x60>
	       block_dev_desc_t **dev_desc)
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480ff50:	e1a07000 	mov	r7, r0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480ff54:	e1a01007 	mov	r1, r7
3480ff58:	e1a00005 	mov	r0, r5
3480ff5c:	ebffff03 	bl	3480fb70 <get_dev>
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480ff60:	e3500000 	cmp	r0, #0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480ff64:	e5860000 	str	r0, [r6]
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480ff68:	0a000002 	beq	3480ff78 <get_device+0x5c>
3480ff6c:	e5d0300b 	ldrb	r3, [r0, #11]
3480ff70:	e35300ff 	cmp	r3, #255	; 0xff
3480ff74:	1a000004 	bne	3480ff8c <get_device+0x70>
		printf("** Bad device %s %s **\n", ifname, dev_str);
3480ff78:	e59f0018 	ldr	r0, [pc, #24]	; 3480ff98 <get_device+0x7c>
3480ff7c:	e1a01005 	mov	r1, r5
3480ff80:	e1a02004 	mov	r2, r4
3480ff84:	ebffe70b 	bl	34809bb8 <printf>
		return -1;
3480ff88:	e3e07000 	mvn	r7, #0
	}

	return dev;
}
3480ff8c:	e1a00007 	mov	r0, r7
3480ff90:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
3480ff94:	34826ed6 	.word	0x34826ed6
3480ff98:	34826efc 	.word	0x34826efc

3480ff9c <get_device_and_partition>:
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480ff9c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480ffa0:	e2516000 	subs	r6, r1, #0
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480ffa4:	e24dd058 	sub	sp, sp, #88	; 0x58
3480ffa8:	e1a09000 	mov	r9, r0
3480ffac:	e1a0b002 	mov	fp, r2
3480ffb0:	e1a05003 	mov	r5, r3
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480ffb4:	0a000008 	beq	3480ffdc <get_device_and_partition+0x40>
3480ffb8:	e1a00006 	mov	r0, r6
3480ffbc:	eb0031ae 	bl	3481c67c <strlen>
3480ffc0:	e3500000 	cmp	r0, #0
3480ffc4:	0a000004 	beq	3480ffdc <get_device_and_partition+0x40>
	    !strcmp(dev_part_str, "-"))
3480ffc8:	e1a00006 	mov	r0, r6
3480ffcc:	e59f1280 	ldr	r1, [pc, #640]	; 34810254 <get_device_and_partition+0x2b8>
3480ffd0:	eb003175 	bl	3481c5ac <strcmp>
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480ffd4:	e3500000 	cmp	r0, #0
3480ffd8:	1a000007 	bne	3480fffc <get_device_and_partition+0x60>
	    !strcmp(dev_part_str, "-"))
		dev_part_str = getenv("bootdevice");
3480ffdc:	e59f0274 	ldr	r0, [pc, #628]	; 34810258 <get_device_and_partition+0x2bc>
3480ffe0:	ebffe006 	bl	34808000 <getenv>

	/* If still no dev_part_str, it's an error */
	if (!dev_part_str) {
3480ffe4:	e2506000 	subs	r6, r0, #0
3480ffe8:	1a000003 	bne	3480fffc <get_device_and_partition+0x60>
		printf("** No device specified **\n");
3480ffec:	e59f0268 	ldr	r0, [pc, #616]	; 3481025c <get_device_and_partition+0x2c0>
3480fff0:	ebffe6f0 	bl	34809bb8 <printf>
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
3480fff4:	e1a07006 	mov	r7, r6
3480fff8:	ea00008f 	b	3481023c <get_device_and_partition+0x2a0>
		printf("** No device specified **\n");
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
3480fffc:	e1a00006 	mov	r0, r6
34810000:	e3a0103a 	mov	r1, #58	; 0x3a
34810004:	eb003186 	bl	3481c624 <strchr>
	if (part_str) {
34810008:	e2504000 	subs	r4, r0, #0
3481000c:	01a0a006 	moveq	sl, r6
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
34810010:	01a07004 	moveq	r7, r4
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
34810014:	0a000007 	beq	34810038 <get_device_and_partition+0x9c>
		dup_str = strdup(dev_part_str);
34810018:	e1a00006 	mov	r0, r6
3481001c:	eb0031cb 	bl	3481c750 <strdup>
		dup_str[part_str - dev_part_str] = 0;
34810020:	e0663004 	rsb	r3, r6, r4
34810024:	e3a02000 	mov	r2, #0
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
34810028:	e1a07000 	mov	r7, r0
		dup_str[part_str - dev_part_str] = 0;
3481002c:	e7c02003 	strb	r2, [r0, r3]
		dev_str = dup_str;
		part_str++;
34810030:	e2844001 	add	r4, r4, #1
	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
		dup_str[part_str - dev_part_str] = 0;
		dev_str = dup_str;
34810034:	e1a0a000 	mov	sl, r0
	} else {
		dev_str = dev_part_str;
	}

	/* Look up the device */
	dev = get_device(ifname, dev_str, dev_desc);
34810038:	e1a00009 	mov	r0, r9
3481003c:	e1a0100a 	mov	r1, sl
34810040:	e1a0200b 	mov	r2, fp
34810044:	ebffffb4 	bl	3480ff1c <get_device>
	if (dev < 0)
34810048:	e3500000 	cmp	r0, #0
3481004c:	ba00007a 	blt	3481023c <get_device_and_partition+0x2a0>
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
34810050:	e3540000 	cmp	r4, #0
34810054:	0a000018 	beq	348100bc <get_device_and_partition+0x120>
34810058:	e5d43000 	ldrb	r3, [r4]
3481005c:	e3530000 	cmp	r3, #0
34810060:	0a000015 	beq	348100bc <get_device_and_partition+0x120>
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
34810064:	e1a00004 	mov	r0, r4
34810068:	e59f11f0 	ldr	r1, [pc, #496]	; 34810260 <get_device_and_partition+0x2c4>
3481006c:	eb00314e 	bl	3481c5ac <strcmp>
34810070:	e3500000 	cmp	r0, #0
		part = PART_AUTO;
34810074:	03e04000 	mvneq	r4, #0
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
34810078:	0a000010 	beq	348100c0 <get_device_and_partition+0x124>
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3481007c:	e1a00004 	mov	r0, r4
34810080:	e28d1054 	add	r1, sp, #84	; 0x54
34810084:	e3a02010 	mov	r2, #16
34810088:	eb00350e 	bl	3481d4c8 <simple_strtoul>
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3481008c:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
34810090:	e5d33000 	ldrb	r3, [r3]
34810094:	e3530000 	cmp	r3, #0
34810098:	1a000003 	bne	348100ac <get_device_and_partition+0x110>
3481009c:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
348100a0:	e1a04000 	mov	r4, r0
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
348100a4:	e1902002 	orrs	r2, r0, r2
348100a8:	1a000004 	bne	348100c0 <get_device_and_partition+0x124>
			printf("** Bad partition specification %s %s **\n",
348100ac:	e59f01b0 	ldr	r0, [pc, #432]	; 34810264 <get_device_and_partition+0x2c8>
348100b0:	e1a01009 	mov	r1, r9
348100b4:	e1a02006 	mov	r2, r6
348100b8:	ea00000d 	b	348100f4 <get_device_and_partition+0x158>
	if (dev < 0)
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
348100bc:	e3e04001 	mvn	r4, #1

	/*
	 * No partition table on device,
	 * or user requested partition 0 (entire device).
	 */
	if (((*dev_desc)->part_type == PART_TYPE_UNKNOWN) ||
348100c0:	e59b0000 	ldr	r0, [fp]
348100c4:	e5d03008 	ldrb	r3, [r0, #8]
348100c8:	e3530000 	cmp	r3, #0
348100cc:	13540000 	cmpne	r4, #0
348100d0:	13a03000 	movne	r3, #0
348100d4:	03a03001 	moveq	r3, #1
348100d8:	1a000015 	bne	34810134 <get_device_and_partition+0x198>
	    (part == 0)) {
		if (!(*dev_desc)->lba) {
348100dc:	e5903010 	ldr	r3, [r0, #16]
348100e0:	e3530000 	cmp	r3, #0
348100e4:	1a000004 	bne	348100fc <get_device_and_partition+0x160>
			printf("** Bad device size - %s %s **\n", ifname,
348100e8:	e59f0178 	ldr	r0, [pc, #376]	; 34810268 <get_device_and_partition+0x2cc>
348100ec:	e1a01009 	mov	r1, r9
348100f0:	e1a0200a 	mov	r2, sl
348100f4:	ebffe6af 	bl	34809bb8 <printf>
348100f8:	ea00004f 	b	3481023c <get_device_and_partition+0x2a0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
348100fc:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
34810100:	e2726001 	rsbs	r6, r2, #1
34810104:	33a06000 	movcc	r6, #0
34810108:	e3540000 	cmp	r4, #0
3481010c:	c3866001 	orrgt	r6, r6, #1
34810110:	e3560000 	cmp	r6, #0
			printf("** No partition table - %s %s **\n", ifname,
34810114:	159f0150 	ldrne	r0, [pc, #336]	; 3481026c <get_device_and_partition+0x2d0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
34810118:	1afffff3 	bne	348100ec <get_device_and_partition+0x150>
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
		info->size = (*dev_desc)->lba;
3481011c:	e5853004 	str	r3, [r5, #4]
		info->blksz = (*dev_desc)->blksz;
34810120:	e5903014 	ldr	r3, [r0, #20]
			printf("** No partition table - %s %s **\n", ifname,
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
34810124:	e5856000 	str	r6, [r5]
		info->size = (*dev_desc)->lba;
		info->blksz = (*dev_desc)->blksz;
34810128:	e5853008 	str	r3, [r5, #8]
		info->bootable = 0;
3481012c:	e585604c 	str	r6, [r5, #76]	; 0x4c
#ifdef CONFIG_PARTITION_UUIDS
		info->uuid[0] = 0;
#endif

		ret = 0;
		goto cleanup;
34810130:	ea000042 	b	34810240 <get_device_and_partition+0x2a4>

	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
34810134:	e3740002 	cmn	r4, #2
34810138:	0a000005 	beq	34810154 <get_device_and_partition+0x1b8>

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3481013c:	e3740001 	cmn	r4, #1
34810140:	01a04003 	moveq	r4, r3
34810144:	03a0a001 	moveq	sl, #1
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
				tmpinfo = *info;
34810148:	028d9004 	addeq	r9, sp, #4

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3481014c:	0a00000a 	beq	3481017c <get_device_and_partition+0x1e0>
34810150:	ea000000 	b	34810158 <get_device_and_partition+0x1bc>
	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
		part = 1;
34810154:	e3a04001 	mov	r4, #1
	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
		ret = get_partition_info(*dev_desc, part, info);
34810158:	e1a01004 	mov	r1, r4
3481015c:	e1a02005 	mov	r2, r5
34810160:	ebffff63 	bl	3480fef4 <get_partition_info>
		if (ret) {
34810164:	e2506000 	subs	r6, r0, #0
34810168:	0a000028 	beq	34810210 <get_device_and_partition+0x274>
			printf("** Invalid partition %d **\n", part);
3481016c:	e1a01004 	mov	r1, r4
34810170:	e59f00f8 	ldr	r0, [pc, #248]	; 34810270 <get_device_and_partition+0x2d4>
34810174:	ebffe68f 	bl	34809bb8 <printf>
			goto cleanup;
34810178:	ea000030 	b	34810240 <get_device_and_partition+0x2a4>
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
			ret = get_partition_info(*dev_desc, p, info);
3481017c:	e59b0000 	ldr	r0, [fp]
34810180:	e1a0100a 	mov	r1, sl
34810184:	e1a02005 	mov	r2, r5
34810188:	ebffff59 	bl	3480fef4 <get_partition_info>
			if (ret)
3481018c:	e2506000 	subs	r6, r0, #0
34810190:	1a000011 	bne	348101dc <get_device_and_partition+0x240>

			/*
			 * First valid partition, or new better partition?
			 * If so, save partition ID.
			 */
			if (!part || info->bootable)
34810194:	e3540000 	cmp	r4, #0
34810198:	01a0400a 	moveq	r4, sl
3481019c:	0a000002 	beq	348101ac <get_device_and_partition+0x210>
348101a0:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
348101a4:	e3530000 	cmp	r3, #0
348101a8:	11a0400a 	movne	r4, sl
				part = p;

			/* Best possible partition? Stop searching. */
			if (info->bootable)
348101ac:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
348101b0:	e3530000 	cmp	r3, #0
348101b4:	0a000002 	beq	348101c4 <get_device_and_partition+0x228>
		if (part) {
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
348101b8:	e35a0011 	cmp	sl, #17
348101bc:	1a000013 	bne	34810210 <get_device_and_partition+0x274>
348101c0:	ea00000a 	b	348101f0 <get_device_and_partition+0x254>
			/*
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
348101c4:	e154000a 	cmp	r4, sl
348101c8:	1a000003 	bne	348101dc <get_device_and_partition+0x240>
				tmpinfo = *info;
348101cc:	e1a00009 	mov	r0, r9
348101d0:	e1a01005 	mov	r1, r5
348101d4:	e3a02050 	mov	r2, #80	; 0x50
348101d8:	eb0031eb 	bl	3481c98c <memcpy>
		/*
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
348101dc:	e28aa001 	add	sl, sl, #1
348101e0:	e35a0011 	cmp	sl, #17
348101e4:	1affffe4 	bne	3481017c <get_device_and_partition+0x1e0>
			 */
			if (part == p)
				tmpinfo = *info;
		}
		/* If we found any acceptable partition */
		if (part) {
348101e8:	e3540000 	cmp	r4, #0
348101ec:	0a000004 	beq	34810204 <get_device_and_partition+0x268>
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
				*info = tmpinfo;
348101f0:	e1a00005 	mov	r0, r5
348101f4:	e28d1004 	add	r1, sp, #4
348101f8:	e3a02050 	mov	r2, #80	; 0x50
348101fc:	eb0031e2 	bl	3481c98c <memcpy>
34810200:	ea000002 	b	34810210 <get_device_and_partition+0x274>
			ret = 0;
		} else {
			printf("** No valid partitions found **\n");
34810204:	e59f0068 	ldr	r0, [pc, #104]	; 34810274 <get_device_and_partition+0x2d8>
34810208:	ebffe66a 	bl	34809bb8 <printf>
			goto cleanup;
3481020c:	ea00000b 	b	34810240 <get_device_and_partition+0x2a4>
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
34810210:	e285502c 	add	r5, r5, #44	; 0x2c
34810214:	e1a00005 	mov	r0, r5
34810218:	e59f1058 	ldr	r1, [pc, #88]	; 34810278 <get_device_and_partition+0x2dc>
3481021c:	e3a02020 	mov	r2, #32
34810220:	eb0030ed 	bl	3481c5dc <strncmp>
34810224:	e3500000 	cmp	r0, #0
			info->type);
		ret  = -1;
		goto cleanup;
	}

	ret = part;
34810228:	01a06004 	moveq	r6, r4
		} else {
			printf("** No valid partitions found **\n");
			goto cleanup;
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3481022c:	0a000003 	beq	34810240 <get_device_and_partition+0x2a4>
		printf("** Invalid partition type \"%.32s\""
34810230:	e59f0044 	ldr	r0, [pc, #68]	; 3481027c <get_device_and_partition+0x2e0>
34810234:	e1a01005 	mov	r1, r5
34810238:	ebffe65e 	bl	34809bb8 <printf>
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
3481023c:	e3e06000 	mvn	r6, #0

	ret = part;
	goto cleanup;

cleanup:
	free(dup_str);
34810240:	e1a00007 	mov	r0, r7
34810244:	ebffe799 	bl	3480a0b0 <free>
	return ret;
}
34810248:	e1a00006 	mov	r0, r6
3481024c:	e28dd058 	add	sp, sp, #88	; 0x58
34810250:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810254:	3482774a 	.word	0x3482774a
34810258:	34826f14 	.word	0x34826f14
3481025c:	34826f1f 	.word	0x34826f1f
34810260:	34826f3a 	.word	0x34826f3a
34810264:	34826f3f 	.word	0x34826f3f
34810268:	34826f68 	.word	0x34826f68
3481026c:	34826f87 	.word	0x34826f87
34810270:	34826fa9 	.word	0x34826fa9
34810274:	34826fc5 	.word	0x34826fc5
34810278:	34826bab 	.word	0x34826bab
3481027c:	34826fe6 	.word	0x34826fe6

34810280 <le32_to_int>:
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
34810280:	e5d03002 	ldrb	r3, [r0, #2]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
34810284:	e5d02003 	ldrb	r2, [r0, #3]
	    (le32[2] << 16) +
34810288:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
3481028c:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
34810290:	e5d02000 	ldrb	r2, [r0]
34810294:	e5d00001 	ldrb	r0, [r0, #1]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
34810298:	e0833002 	add	r3, r3, r2
	    (le32[1] << 8) +
	     le32[0]
	   );
}
3481029c:	e0830400 	add	r0, r3, r0, lsl #8
348102a0:	e12fff1e 	bx	lr

348102a4 <is_extended>:

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
348102a4:	e3500005 	cmp	r0, #5
348102a8:	1350000f 	cmpne	r0, #15
348102ac:	0a000003 	beq	348102c0 <is_extended+0x1c>
348102b0:	e3500085 	cmp	r0, #133	; 0x85
348102b4:	13a00000 	movne	r0, #0
348102b8:	03a00001 	moveq	r0, #1
348102bc:	e12fff1e 	bx	lr
348102c0:	e3a00001 	mov	r0, #1
	    part_type == 0xf ||
	    part_type == 0x85);
}
348102c4:	e12fff1e 	bx	lr

348102c8 <test_block_type>:
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
348102c8:	e92d4010 	push	{r4, lr}
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
348102cc:	e5d031fe 	ldrb	r3, [r0, #510]	; 0x1fe
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
348102d0:	e1a04000 	mov	r4, r0
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
348102d4:	e3530055 	cmp	r3, #85	; 0x55
348102d8:	1a00000f 	bne	3481031c <test_block_type+0x54>
348102dc:	e5d031ff 	ldrb	r3, [r0, #511]	; 0x1ff
348102e0:	e35300aa 	cmp	r3, #170	; 0xaa
348102e4:	1a00000c 	bne	3481031c <test_block_type+0x54>
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
348102e8:	e2800036 	add	r0, r0, #54	; 0x36
348102ec:	e59f1038 	ldr	r1, [pc, #56]	; 3481032c <test_block_type+0x64>
348102f0:	e3a02003 	mov	r2, #3
348102f4:	eb0030b8 	bl	3481c5dc <strncmp>
348102f8:	e3500000 	cmp	r0, #0
348102fc:	0a000008 	beq	34810324 <test_block_type+0x5c>
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
34810300:	e2840052 	add	r0, r4, #82	; 0x52
34810304:	e59f1024 	ldr	r1, [pc, #36]	; 34810330 <test_block_type+0x68>
34810308:	e3a02005 	mov	r2, #5
3481030c:	eb0030b2 	bl	3481c5dc <strncmp>

static int test_block_type(unsigned char *buffer)
{
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
34810310:	e2700001 	rsbs	r0, r0, #1
34810314:	33a00000 	movcc	r0, #0
34810318:	e8bd8010 	pop	{r4, pc}
3481031c:	e3e00000 	mvn	r0, #0
34810320:	e8bd8010 	pop	{r4, pc}
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
		return DOS_PBR; /* is PBR */
34810324:	e3a00001 	mov	r0, #1
	}
	return DOS_MBR;	    /* Is MBR */
}
34810328:	e8bd8010 	pop	{r4, pc}
3481032c:	3482701b 	.word	0x3482701b
34810330:	3482701f 	.word	0x3482701f

34810334 <print_partition_extended>:

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810334:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810338:	e28db01c 	add	fp, sp, #28
3481033c:	e24dd020 	sub	sp, sp, #32
34810340:	e1a0a003 	mov	sl, r3
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810344:	e5903014 	ldr	r3, [r0, #20]

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810348:	e50b2024 	str	r2, [fp, #-36]	; 0x24
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3481034c:	e283303f 	add	r3, r3, #63	; 0x3f
34810350:	e3c3303f 	bic	r3, r3, #63	; 0x3f
34810354:	e2833048 	add	r3, r3, #72	; 0x48
34810358:	e04dd003 	sub	sp, sp, r3
3481035c:	e28d504f 	add	r5, sp, #79	; 0x4f
34810360:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810364:	e590c060 	ldr	ip, [r0, #96]	; 0x60

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810368:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3481036c:	e3a02001 	mov	r2, #1
34810370:	e5900004 	ldr	r0, [r0, #4]
34810374:	e1a03005 	mov	r3, r5

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
34810378:	e1a07001 	mov	r7, r1
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3481037c:	e12fff3c 	blx	ip
34810380:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
34810384:	159f0158 	ldrne	r0, [pc, #344]	; 348104e4 <print_partition_extended+0x1b0>
34810388:	15941004 	ldrne	r1, [r4, #4]
3481038c:	11a02007 	movne	r2, r7
34810390:	1a000006 	bne	348103b0 <print_partition_extended+0x7c>
			dev_desc->dev, ext_part_sector);
		return;
	}
	i=test_block_type(buffer);
34810394:	e1a00005 	mov	r0, r5
34810398:	ebffffca 	bl	348102c8 <test_block_type>
	if (i != DOS_MBR) {
3481039c:	e3500000 	cmp	r0, #0
348103a0:	0a000004 	beq	348103b8 <print_partition_extended+0x84>
		printf ("bad MBR sector signature 0x%02x%02x\n",
348103a4:	e59f013c 	ldr	r0, [pc, #316]	; 348104e8 <print_partition_extended+0x1b4>
348103a8:	e5d511fe 	ldrb	r1, [r5, #510]	; 0x1fe
348103ac:	e5d521ff 	ldrb	r2, [r5, #511]	; 0x1ff
348103b0:	ebffe600 	bl	34809bb8 <printf>
348103b4:	ea000048 	b	348104dc <print_partition_extended+0x1a8>
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
348103b8:	e2856f6f 	add	r6, r5, #444	; 0x1bc
348103bc:	e2866002 	add	r6, r6, #2
	return 0;
}

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
348103c0:	e2855f7b 	add	r5, r5, #492	; 0x1ec
348103c4:	e2859002 	add	r9, r5, #2
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
348103c8:	e1a05006 	mov	r5, r6
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */

		if ((pt->sys_ind != 0) &&
348103cc:	e5d51004 	ldrb	r1, [r5, #4]
348103d0:	e3510000 	cmp	r1, #0
348103d4:	e50b1020 	str	r1, [fp, #-32]
348103d8:	0a000022 	beq	34810468 <print_partition_extended+0x134>
348103dc:	e3570000 	cmp	r7, #0
348103e0:	0a000003 	beq	348103f4 <print_partition_extended+0xc0>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
348103e4:	e1a00001 	mov	r0, r1
348103e8:	ebffffad 	bl	348102a4 <is_extended>
348103ec:	e3500000 	cmp	r0, #0
348103f0:	1a00001e 	bne	34810470 <print_partition_extended+0x13c>
	return p->boot_ind == 0x80;
}

static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
348103f4:	e2850008 	add	r0, r5, #8
348103f8:	ebffffa0 	bl	34810280 <le32_to_int>
348103fc:	e0802007 	add	r2, r0, r7
	int lba_size  = le32_to_int (p->size4);
34810400:	e285000c 	add	r0, r5, #12
34810404:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
34810408:	ebffff9c 	bl	34810280 <le32_to_int>
3481040c:	e1a03000 	mov	r3, r0

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
		part_num, lba_start, lba_size, p->sys_ind,
		(is_extended(p->sys_ind) ? " Extd" : ""),
34810410:	e51b0020 	ldr	r0, [fp, #-32]
34810414:	e50b3028 	str	r3, [fp, #-40]	; 0x28
34810418:	ebffffa1 	bl	348102a4 <is_extended>
static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
3481041c:	e59fe0c8 	ldr	lr, [pc, #200]	; 348104ec <print_partition_extended+0x1b8>
34810420:	e5d51000 	ldrb	r1, [r5]
34810424:	e59fc0c4 	ldr	ip, [pc, #196]	; 348104f0 <print_partition_extended+0x1bc>
34810428:	e3500000 	cmp	r0, #0
3481042c:	11a0c00e 	movne	ip, lr
34810430:	e59fe0bc 	ldr	lr, [pc, #188]	; 348104f4 <print_partition_extended+0x1c0>
34810434:	e1a0000c 	mov	r0, ip
34810438:	e3510080 	cmp	r1, #128	; 0x80
3481043c:	e59fc0ac 	ldr	ip, [pc, #172]	; 348104f0 <print_partition_extended+0x1bc>
34810440:	01a0c00e 	moveq	ip, lr
34810444:	e1a0100c 	mov	r1, ip
34810448:	e51bc020 	ldr	ip, [fp, #-32]
3481044c:	e98d0003 	stmib	sp, {r0, r1}
34810450:	e59f00a0 	ldr	r0, [pc, #160]	; 348104f8 <print_partition_extended+0x1c4>
34810454:	e1a0100a 	mov	r1, sl
34810458:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
3481045c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
34810460:	e58dc000 	str	ip, [sp]
34810464:	ebffe5d3 	bl	34809bb8 <printf>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
34810468:	e3570000 	cmp	r7, #0
3481046c:	0a000005 	beq	34810488 <print_partition_extended+0x154>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
34810470:	e5d50004 	ldrb	r0, [r5, #4]
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
34810474:	e3500000 	cmp	r0, #0
34810478:	0a000003 	beq	3481048c <print_partition_extended+0x158>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3481047c:	ebffff88 	bl	348102a4 <is_extended>
34810480:	e3500000 	cmp	r0, #0
34810484:	1a000000 	bne	3481048c <print_partition_extended+0x158>
			part_num++;
34810488:	e28aa001 	add	sl, sl, #1
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3481048c:	e1550009 	cmp	r5, r9
34810490:	12855010 	addne	r5, r5, #16
34810494:	1affffcc 	bne	348103cc <print_partition_extended+0x98>
34810498:	e51b5024 	ldr	r5, [fp, #-36]	; 0x24
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
3481049c:	e5d60004 	ldrb	r0, [r6, #4]
348104a0:	ebffff7f 	bl	348102a4 <is_extended>
348104a4:	e3500000 	cmp	r0, #0
348104a8:	0a000008 	beq	348104d0 <print_partition_extended+0x19c>
			int lba_start = le32_to_int (pt->start4) + relative;
348104ac:	e2860008 	add	r0, r6, #8
348104b0:	ebffff72 	bl	34810280 <le32_to_int>

			print_partition_extended (dev_desc, lba_start,
348104b4:	e3570000 	cmp	r7, #0

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
348104b8:	e0801005 	add	r1, r0, r5

			print_partition_extended (dev_desc, lba_start,
348104bc:	11a02005 	movne	r2, r5
348104c0:	e1a00004 	mov	r0, r4
348104c4:	01a02001 	moveq	r2, r1
348104c8:	e1a0300a 	mov	r3, sl
348104cc:	ebffff98 	bl	34810334 <print_partition_extended>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
348104d0:	e1560009 	cmp	r6, r9
348104d4:	12866010 	addne	r6, r6, #16
348104d8:	1affffef 	bne	3481049c <print_partition_extended+0x168>
						  part_num);
		}
	}

	return;
}
348104dc:	e24bd01c 	sub	sp, fp, #28
348104e0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348104e4:	34827031 	.word	0x34827031
348104e8:	3482705c 	.word	0x3482705c
348104ec:	34827025 	.word	0x34827025
348104f0:	34824003 	.word	0x34824003
348104f4:	3482702b 	.word	0x3482702b
348104f8:	34827081 	.word	0x34827081

348104fc <get_partition_info_extended.clone.1>:


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
348104fc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810500:	e28db01c 	add	fp, sp, #28
34810504:	e24dd010 	sub	sp, sp, #16
34810508:	e1a06003 	mov	r6, r3
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3481050c:	e5903014 	ldr	r3, [r0, #20]
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810510:	e590c060 	ldr	ip, [r0, #96]	; 0x60
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810514:	e283303f 	add	r3, r3, #63	; 0x3f
34810518:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3481051c:	e2833048 	add	r3, r3, #72	; 0x48
34810520:	e04dd003 	sub	sp, sp, r3
34810524:	e28d4047 	add	r4, sp, #71	; 0x47
34810528:	e3c4403f 	bic	r4, r4, #63	; 0x3f
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3481052c:	e1a05000 	mov	r5, r0
34810530:	e1a09002 	mov	r9, r2
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810534:	e5900004 	ldr	r0, [r0, #4]
34810538:	e3a02001 	mov	r2, #1
3481053c:	e1a03004 	mov	r3, r4
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
34810540:	e1a0a001 	mov	sl, r1
34810544:	e59b7008 	ldr	r7, [fp, #8]
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
34810548:	e12fff3c 	blx	ip
3481054c:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
34810550:	159f01e8 	ldrne	r0, [pc, #488]	; 34810740 <get_partition_info_extended.clone.1+0x244>
34810554:	15951004 	ldrne	r1, [r5, #4]
34810558:	11a0200a 	movne	r2, sl
3481055c:	1a000007 	bne	34810580 <get_partition_info_extended.clone.1+0x84>
			dev_desc->dev, ext_part_sector);
		return -1;
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
34810560:	e5d411fe 	ldrb	r1, [r4, #510]	; 0x1fe
34810564:	e3510055 	cmp	r1, #85	; 0x55
34810568:	1a000002 	bne	34810578 <get_partition_info_extended.clone.1+0x7c>
3481056c:	e5d431ff 	ldrb	r3, [r4, #511]	; 0x1ff
34810570:	e35300aa 	cmp	r3, #170	; 0xaa
34810574:	0a000003 	beq	34810588 <get_partition_info_extended.clone.1+0x8c>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		printf ("bad MBR sector signature 0x%02x%02x\n",
34810578:	e59f01c4 	ldr	r0, [pc, #452]	; 34810744 <get_partition_info_extended.clone.1+0x248>
3481057c:	e5d421ff 	ldrb	r2, [r4, #511]	; 0x1ff
34810580:	ebffe58c 	bl	34809bb8 <printf>
34810584:	ea00006a 	b	34810734 <get_partition_info_extended.clone.1+0x238>
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
34810588:	e2843f6f 	add	r3, r4, #444	; 0x1bc
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3481058c:	e2844f7b 	add	r4, r4, #492	; 0x1ec
34810590:	e2844002 	add	r4, r4, #2
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
34810594:	e2833002 	add	r3, r3, #2
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
34810598:	e50b4020 	str	r4, [fp, #-32]
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3481059c:	e1a04003 	mov	r4, r3
	for (i = 0; i < 4; i++, pt++) {
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
348105a0:	e5d42000 	ldrb	r2, [r4]
348105a4:	e312007f 	tst	r2, #127	; 0x7f
348105a8:	1a00003b 	bne	3481069c <get_partition_info_extended.clone.1+0x1a0>
		    (pt->sys_ind != 0) &&
348105ac:	e5d40004 	ldrb	r0, [r4, #4]
348105b0:	e59b1004 	ldr	r1, [fp, #4]
348105b4:	e1560001 	cmp	r6, r1
348105b8:	13a02000 	movne	r2, #0
348105bc:	03a02001 	moveq	r2, #1
348105c0:	e3500000 	cmp	r0, #0
348105c4:	03a02000 	moveq	r2, #0
348105c8:	e3520000 	cmp	r2, #0
348105cc:	0a000032 	beq	3481069c <get_partition_info_extended.clone.1+0x1a0>
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
348105d0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
348105d4:	ebffff32 	bl	348102a4 <is_extended>
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
348105d8:	e3500000 	cmp	r0, #0
348105dc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
348105e0:	1a00002d 	bne	3481069c <get_partition_info_extended.clone.1+0x1a0>
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
348105e4:	e3a03c02 	mov	r3, #512	; 0x200
348105e8:	e5873008 	str	r3, [r7, #8]
			info->start = ext_part_sector + le32_to_int (pt->start4);
348105ec:	e2840008 	add	r0, r4, #8
348105f0:	ebffff22 	bl	34810280 <le32_to_int>
348105f4:	e080000a 	add	r0, r0, sl
348105f8:	e5870000 	str	r0, [r7]
			info->size  = le32_to_int (pt->size4);
348105fc:	e284000c 	add	r0, r4, #12
34810600:	ebffff1e 	bl	34810280 <le32_to_int>
			switch(dev_desc->if_type) {
34810604:	e5953000 	ldr	r3, [r5]
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
			info->start = ext_part_sector + le32_to_int (pt->start4);
			info->size  = le32_to_int (pt->size4);
34810608:	e5870004 	str	r0, [r7, #4]
			switch(dev_desc->if_type) {
3481060c:	e2433001 	sub	r3, r3, #1
34810610:	e287000c 	add	r0, r7, #12
34810614:	e5952004 	ldr	r2, [r5, #4]
34810618:	e3530007 	cmp	r3, #7
3481061c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
34810620:	ea00000f 	b	34810664 <get_partition_info_extended.clone.1+0x168>
34810624:	34810644 	.word	0x34810644
34810628:	3481064c 	.word	0x3481064c
3481062c:	34810644 	.word	0x34810644
34810630:	34810654 	.word	0x34810654
34810634:	3481065c 	.word	0x3481065c
34810638:	34810664 	.word	0x34810664
3481063c:	34810664 	.word	0x34810664
34810640:	34810644 	.word	0x34810644
				case IF_TYPE_IDE:
				case IF_TYPE_SATA:
				case IF_TYPE_ATAPI:
					sprintf ((char *)info->name, "hd%c%d",
34810644:	e59f10fc 	ldr	r1, [pc, #252]	; 34810748 <get_partition_info_extended.clone.1+0x24c>
34810648:	ea000006 	b	34810668 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_SCSI:
					sprintf ((char *)info->name, "sd%c%d",
3481064c:	e59f10f8 	ldr	r1, [pc, #248]	; 3481074c <get_partition_info_extended.clone.1+0x250>
34810650:	ea000004 	b	34810668 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_USB:
					sprintf ((char *)info->name, "usbd%c%d",
34810654:	e59f10f4 	ldr	r1, [pc, #244]	; 34810750 <get_partition_info_extended.clone.1+0x254>
34810658:	ea000002 	b	34810668 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_DOC:
					sprintf ((char *)info->name, "docd%c%d",
3481065c:	e59f10f0 	ldr	r1, [pc, #240]	; 34810754 <get_partition_info_extended.clone.1+0x258>
34810660:	ea000000 	b	34810668 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				default:
					sprintf ((char *)info->name, "xx%c%d",
34810664:	e59f10ec 	ldr	r1, [pc, #236]	; 34810758 <get_partition_info_extended.clone.1+0x25c>
34810668:	e1a03006 	mov	r3, r6
3481066c:	e2822061 	add	r2, r2, #97	; 0x61
34810670:	eb00343a 	bl	3481d760 <sprintf>
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
34810674:	e287002c 	add	r0, r7, #44	; 0x2c
34810678:	e59f10dc 	ldr	r1, [pc, #220]	; 3481075c <get_partition_info_extended.clone.1+0x260>
3481067c:	eb003437 	bl	3481d760 <sprintf>
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
34810680:	e5d43000 	ldrb	r3, [r4]
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
#ifdef CONFIG_PARTITION_UUIDS
			sprintf(info->uuid, "%08x-%02x", disksig, part_num);
#endif
			return 0;
34810684:	e3a00000 	mov	r0, #0
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
34810688:	e3530080 	cmp	r3, #128	; 0x80
3481068c:	13a03000 	movne	r3, #0
34810690:	03a03001 	moveq	r3, #1
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
34810694:	e587304c 	str	r3, [r7, #76]	; 0x4c
34810698:	ea000026 	b	34810738 <get_partition_info_extended.clone.1+0x23c>
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3481069c:	e35a0000 	cmp	sl, #0
348106a0:	0a000007 	beq	348106c4 <get_partition_info_extended.clone.1+0x1c8>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
348106a4:	e5d40004 	ldrb	r0, [r4, #4]
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
348106a8:	e3500000 	cmp	r0, #0
348106ac:	0a000005 	beq	348106c8 <get_partition_info_extended.clone.1+0x1cc>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
348106b0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
348106b4:	ebfffefa 	bl	348102a4 <is_extended>
348106b8:	e3500000 	cmp	r0, #0
348106bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
348106c0:	1a000000 	bne	348106c8 <get_partition_info_extended.clone.1+0x1cc>
			part_num++;
348106c4:	e2866001 	add	r6, r6, #1
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
348106c8:	e51b2020 	ldr	r2, [fp, #-32]
348106cc:	e1540002 	cmp	r4, r2
348106d0:	12844010 	addne	r4, r4, #16
348106d4:	1affffb1 	bne	348105a0 <get_partition_info_extended.clone.1+0xa4>
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
348106d8:	e5d30004 	ldrb	r0, [r3, #4]
348106dc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
348106e0:	ebfffeef 	bl	348102a4 <is_extended>
348106e4:	e3500000 	cmp	r0, #0
348106e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
348106ec:	0a00000c 	beq	34810724 <get_partition_info_extended.clone.1+0x228>
			int lba_start = le32_to_int (pt->start4) + relative;
348106f0:	e2830008 	add	r0, r3, #8
348106f4:	ebfffee1 	bl	34810280 <le32_to_int>

			return get_partition_info_extended (dev_desc, lba_start,
348106f8:	e59b3004 	ldr	r3, [fp, #4]

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
348106fc:	e0801009 	add	r1, r0, r9

			return get_partition_info_extended (dev_desc, lba_start,
34810700:	e35a0000 	cmp	sl, #0
34810704:	e58d3000 	str	r3, [sp]
34810708:	e1a00005 	mov	r0, r5
3481070c:	11a02009 	movne	r2, r9
34810710:	01a02001 	moveq	r2, r1
34810714:	e1a03006 	mov	r3, r6
34810718:	e58d7004 	str	r7, [sp, #4]
3481071c:	ebffff76 	bl	348104fc <get_partition_info_extended.clone.1>
34810720:	ea000004 	b	34810738 <get_partition_info_extended.clone.1+0x23c>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
34810724:	e51b1020 	ldr	r1, [fp, #-32]
34810728:	e1530001 	cmp	r3, r1
3481072c:	12833010 	addne	r3, r3, #16
34810730:	1affffe8 	bne	348106d8 <get_partition_info_extended.clone.1+0x1dc>
			return get_partition_info_extended (dev_desc, lba_start,
				 ext_part_sector == 0 ? lba_start : relative,
				 part_num, which_part, info, disksig);
		}
	}
	return -1;
34810734:	e3e00000 	mvn	r0, #0
}
34810738:	e24bd01c 	sub	sp, fp, #28
3481073c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810740:	34827031 	.word	0x34827031
34810744:	3482705c 	.word	0x3482705c
34810748:	34827099 	.word	0x34827099
3481074c:	348270a0 	.word	0x348270a0
34810750:	348270a7 	.word	0x348270a7
34810754:	348270b0 	.word	0x348270b0
34810758:	348270b9 	.word	0x348270b9
3481075c:	34826bab 	.word	0x34826bab

34810760 <test_part_dos>:
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
34810760:	e92d4818 	push	{r3, r4, fp, lr}
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
34810764:	e5903014 	ldr	r3, [r0, #20]
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
34810768:	e28db00c 	add	fp, sp, #12
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3481076c:	e283303f 	add	r3, r3, #63	; 0x3f
34810770:	e3c3303f 	bic	r3, r3, #63	; 0x3f
34810774:	e2833048 	add	r3, r3, #72	; 0x48
34810778:	e04dd003 	sub	sp, sp, r3
3481077c:	e28d403f 	add	r4, sp, #63	; 0x3f
34810780:	e3c4403f 	bic	r4, r4, #63	; 0x3f

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
34810784:	e590c060 	ldr	ip, [r0, #96]	; 0x60
34810788:	e3a01000 	mov	r1, #0
3481078c:	e5900004 	ldr	r0, [r0, #4]
34810790:	e3a02001 	mov	r2, #1
34810794:	e1a03004 	mov	r3, r4
34810798:	e12fff3c 	blx	ip
3481079c:	e3500001 	cmp	r0, #1
		return -1;
348107a0:	13e00000 	mvnne	r0, #0

int test_part_dos (block_dev_desc_t *dev_desc)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
348107a4:	1a000003 	bne	348107b8 <test_part_dos+0x58>
		return -1;

	if (test_block_type(buffer) != DOS_MBR)
348107a8:	e1a00004 	mov	r0, r4
348107ac:	ebfffec5 	bl	348102c8 <test_block_type>
348107b0:	e3500000 	cmp	r0, #0
		return -1;
348107b4:	13e00000 	mvnne	r0, #0

	return 0;
}
348107b8:	e24bd00c 	sub	sp, fp, #12
348107bc:	e8bd8818 	pop	{r3, r4, fp, pc}

348107c0 <print_part_dos>:
	}
	return -1;
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
348107c0:	e92d4010 	push	{r4, lr}
348107c4:	e1a04000 	mov	r4, r0
	printf ("Partition     Start Sector     Num Sectors     Type\n");
348107c8:	e59f0018 	ldr	r0, [pc, #24]	; 348107e8 <print_part_dos+0x28>
348107cc:	ebffe4f9 	bl	34809bb8 <printf>
	print_partition_extended (dev_desc, 0, 0, 1);
348107d0:	e3a01000 	mov	r1, #0
348107d4:	e1a00004 	mov	r0, r4
348107d8:	e1a02001 	mov	r2, r1
348107dc:	e3a03001 	mov	r3, #1
}
348107e0:	e8bd4010 	pop	{r4, lr}
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
	printf ("Partition     Start Sector     Num Sectors     Type\n");
	print_partition_extended (dev_desc, 0, 0, 1);
348107e4:	eafffed2 	b	34810334 <print_partition_extended>
348107e8:	348270c0 	.word	0x348270c0

348107ec <get_partition_info_dos>:
}

int get_partition_info_dos (block_dev_desc_t *dev_desc, int part, disk_partition_t * info)
{
348107ec:	e92d4007 	push	{r0, r1, r2, lr}
	return get_partition_info_extended(dev_desc, 0, 0, 1, part, info, 0);
348107f0:	e58d1000 	str	r1, [sp]
348107f4:	e3a01000 	mov	r1, #0
348107f8:	e58d2004 	str	r2, [sp, #4]
348107fc:	e3a03001 	mov	r3, #1
34810800:	e1a02001 	mov	r2, r1
34810804:	ebffff3c 	bl	348104fc <get_partition_info_extended.clone.1>
}
34810808:	e8bd800e 	pop	{r1, r2, r3, pc}

3481080c <s5p_gpio_cfg_pin>:

void s5p_gpio_cfg_pin(struct s5p_gpio_bank *bank, int gpio, int cfg)
{
	unsigned int value;

	value = readl(&bank->con);
3481080c:	e5903000 	ldr	r3, [r0]
	value &= ~CON_MASK(gpio);
34810810:	e3a0c00f 	mov	ip, #15
34810814:	e1a01101 	lsl	r1, r1, #2
34810818:	e1c3311c 	bic	r3, r3, ip, lsl r1
	value |= CON_SFR(gpio, cfg);
3481081c:	e1831112 	orr	r1, r3, r2, lsl r1
	writel(value, &bank->con);
34810820:	e5801000 	str	r1, [r0]
}
34810824:	e12fff1e 	bx	lr

34810828 <s5p_gpio_direction_output>:

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
34810828:	e92d4070 	push	{r4, r5, r6, lr}
3481082c:	e1a04000 	mov	r4, r0
34810830:	e1a05002 	mov	r5, r2
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
34810834:	e3a02001 	mov	r2, #1
	value |= CON_SFR(gpio, cfg);
	writel(value, &bank->con);
}

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
34810838:	e1a06001 	mov	r6, r1
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
3481083c:	ebfffff2 	bl	3481080c <s5p_gpio_cfg_pin>

	value = readl(&bank->dat);
34810840:	e5943004 	ldr	r3, [r4, #4]
	value &= ~DAT_MASK(gpio);
34810844:	e3a02001 	mov	r2, #1
34810848:	e1a06612 	lsl	r6, r2, r6
	if (en)
3481084c:	e3550000 	cmp	r5, #0
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
34810850:	e1c33006 	bic	r3, r3, r6
	if (en)
		value |= DAT_SET(gpio);
34810854:	11833006 	orrne	r3, r3, r6
	writel(value, &bank->dat);
34810858:	e5843004 	str	r3, [r4, #4]
}
3481085c:	e8bd8070 	pop	{r4, r5, r6, pc}

34810860 <s5p_gpio_direction_input>:

void s5p_gpio_direction_input(struct s5p_gpio_bank *bank, int gpio)
{
	s5p_gpio_cfg_pin(bank, gpio, GPIO_INPUT);
34810860:	e3a02000 	mov	r2, #0
34810864:	eaffffe8 	b	3481080c <s5p_gpio_cfg_pin>

34810868 <s5p_gpio_set_value>:

void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
34810868:	e5903004 	ldr	r3, [r0, #4]
	value &= ~DAT_MASK(gpio);
3481086c:	e3a0c001 	mov	ip, #1
34810870:	e1a0111c 	lsl	r1, ip, r1
	if (en)
34810874:	e3520000 	cmp	r2, #0
void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
34810878:	e1c33001 	bic	r3, r3, r1
	if (en)
		value |= DAT_SET(gpio);
3481087c:	11833001 	orrne	r3, r3, r1
	writel(value, &bank->dat);
34810880:	e5803004 	str	r3, [r0, #4]
}
34810884:	e12fff1e 	bx	lr

34810888 <s5p_gpio_get_value>:

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
34810888:	e5903004 	ldr	r3, [r0, #4]
	return !!(value & DAT_MASK(gpio));
3481088c:	e3a02001 	mov	r2, #1
34810890:	e0132112 	ands	r2, r3, r2, lsl r1
}
34810894:	03a00000 	moveq	r0, #0
34810898:	13a00001 	movne	r0, #1
3481089c:	e12fff1e 	bx	lr

348108a0 <s5p_gpio_set_pull>:

void s5p_gpio_set_pull(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->pull);
348108a0:	e5903008 	ldr	r3, [r0, #8]
	value &= ~PULL_MASK(gpio);
348108a4:	e3a0c003 	mov	ip, #3
348108a8:	e1a01081 	lsl	r1, r1, #1
348108ac:	e1c3311c 	bic	r3, r3, ip, lsl r1

	switch (mode) {
348108b0:	e242c001 	sub	ip, r2, #1
348108b4:	e35c0001 	cmp	ip, #1
	case GPIO_PULL_DOWN:
	case GPIO_PULL_UP:
		value |= PULL_MODE(gpio, mode);
348108b8:	91833112 	orrls	r3, r3, r2, lsl r1
		break;
	default:
		break;
	}

	writel(value, &bank->pull);
348108bc:	e5803008 	str	r3, [r0, #8]
}
348108c0:	e12fff1e 	bx	lr

348108c4 <s5p_gpio_set_drv>:

void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
348108c4:	e590300c 	ldr	r3, [r0, #12]
	value &= ~DRV_MASK(gpio);

	switch (mode) {
348108c8:	e3520003 	cmp	r2, #3
348108cc:	812fff1e 	bxhi	lr
void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~DRV_MASK(gpio);
348108d0:	e1a01081 	lsl	r1, r1, #1
348108d4:	e3a0c003 	mov	ip, #3
348108d8:	e1c3311c 	bic	r3, r3, ip, lsl r1
	switch (mode) {
	case GPIO_DRV_1X:
	case GPIO_DRV_2X:
	case GPIO_DRV_3X:
	case GPIO_DRV_4X:
		value |= DRV_SET(gpio, mode);
348108dc:	e1831112 	orr	r1, r3, r2, lsl r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
348108e0:	e580100c 	str	r1, [r0, #12]
348108e4:	e12fff1e 	bx	lr

348108e8 <s5p_gpio_set_rate>:

void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
348108e8:	e590300c 	ldr	r3, [r0, #12]
	value &= ~RATE_MASK(gpio);

	switch (mode) {
348108ec:	e3520001 	cmp	r2, #1
348108f0:	812fff1e 	bxhi	lr
void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~RATE_MASK(gpio);
348108f4:	e3a02001 	mov	r2, #1
348108f8:	e2811010 	add	r1, r1, #16
348108fc:	e1a01112 	lsl	r1, r2, r1
34810900:	e1c33001 	bic	r3, r3, r1

	switch (mode) {
	case GPIO_DRV_FAST:
	case GPIO_DRV_SLOW:
		value |= RATE_SET(gpio);
34810904:	e1831001 	orr	r1, r3, r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
34810908:	e580100c 	str	r1, [r0, #12]
3481090c:	e12fff1e 	bx	lr

34810910 <s5p_gpio_get_bank>:
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
34810910:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
34810914:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
34810918:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
}
3481091c:	e2800602 	add	r0, r0, #2097152	; 0x200000
34810920:	e12fff1e 	bx	lr

34810924 <s5p_gpio_get_pin>:

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
}
34810924:	e2000007 	and	r0, r0, #7
34810928:	e12fff1e 	bx	lr

3481092c <gpio_request>:
/* Common GPIO API */

int gpio_request(unsigned gpio, const char *label)
{
	return 0;
}
3481092c:	e3a00000 	mov	r0, #0
34810930:	e12fff1e 	bx	lr

34810934 <gpio_free>:

int gpio_free(unsigned gpio)
{
	return 0;
}
34810934:	e3a00000 	mov	r0, #0
34810938:	e12fff1e 	bx	lr

3481093c <gpio_direction_input>:

int gpio_direction_input(unsigned gpio)
{
3481093c:	e1a01000 	mov	r1, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
34810940:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
34810944:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
34810948:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
{
	return 0;
}

int gpio_direction_input(unsigned gpio)
{
3481094c:	e92d4008 	push	{r3, lr}
	s5p_gpio_direction_input(s5p_gpio_get_bank(gpio),
34810950:	e2800602 	add	r0, r0, #2097152	; 0x200000
34810954:	e2011007 	and	r1, r1, #7
34810958:	ebffffc0 	bl	34810860 <s5p_gpio_direction_input>
				s5p_gpio_get_pin(gpio));
	return 0;
}
3481095c:	e3a00000 	mov	r0, #0
34810960:	e8bd8008 	pop	{r3, pc}

34810964 <gpio_direction_output>:

int gpio_direction_output(unsigned gpio, int value)
{
34810964:	e92d4008 	push	{r3, lr}
34810968:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3481096c:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
34810970:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
34810974:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
				s5p_gpio_get_pin(gpio));
	return 0;
}

int gpio_direction_output(unsigned gpio, int value)
{
34810978:	e1a02001 	mov	r2, r1
	s5p_gpio_direction_output(s5p_gpio_get_bank(gpio),
3481097c:	e2800602 	add	r0, r0, #2097152	; 0x200000
34810980:	e2031007 	and	r1, r3, #7
34810984:	ebffffa7 	bl	34810828 <s5p_gpio_direction_output>
				 s5p_gpio_get_pin(gpio), value);
	return 0;
}
34810988:	e3a00000 	mov	r0, #0
3481098c:	e8bd8008 	pop	{r3, pc}

34810990 <gpio_get_value>:
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
34810990:	e1a031a0 	lsr	r3, r0, #3

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
34810994:	e1a03283 	lsl	r3, r3, #5
34810998:	e283320e 	add	r3, r3, #-536870912	; 0xe0000000
3481099c:	e2833602 	add	r3, r3, #2097152	; 0x200000
348109a0:	e5933004 	ldr	r3, [r3, #4]
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
348109a4:	e3a02001 	mov	r2, #1
	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
}

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
348109a8:	e2000007 	and	r0, r0, #7
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
348109ac:	e0132012 	ands	r2, r3, r2, lsl r0
				       s5p_gpio_get_pin(gpio));
}
348109b0:	03a00000 	moveq	r0, #0
348109b4:	13a00001 	movne	r0, #1
348109b8:	e12fff1e 	bx	lr

348109bc <gpio_set_value>:

int gpio_set_value(unsigned gpio, int value)
{
348109bc:	e92d4008 	push	{r3, lr}
348109c0:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
348109c4:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
348109c8:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
348109cc:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
				       s5p_gpio_get_pin(gpio));
}

int gpio_set_value(unsigned gpio, int value)
{
348109d0:	e1a02001 	mov	r2, r1
	s5p_gpio_set_value(s5p_gpio_get_bank(gpio),
348109d4:	e2800602 	add	r0, r0, #2097152	; 0x200000
348109d8:	e2031007 	and	r1, r3, #7
348109dc:	ebffffa1 	bl	34810868 <s5p_gpio_set_value>
			  s5p_gpio_get_pin(gpio), value);

	return 0;
}
348109e0:	e3a00000 	mov	r0, #0
348109e4:	e8bd8008 	pop	{r3, pc}

348109e8 <send_start>:

/*-----------------------------------------------------------------------
 * START: High -> Low on SDA while SCL is High
 */
static void send_start(void)
{
348109e8:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_DELAY;
348109ec:	e3a00005 	mov	r0, #5
348109f0:	eb003070 	bl	3481cbb8 <udelay>
	I2C_SDA(1);
348109f4:	e3a000b0 	mov	r0, #176	; 0xb0
348109f8:	ebffffcf 	bl	3481093c <gpio_direction_input>
	I2C_ACTIVE;
	I2C_DELAY;
348109fc:	e3a00005 	mov	r0, #5
34810a00:	eb00306c 	bl	3481cbb8 <udelay>
	I2C_SCL(1);
34810a04:	e3a01001 	mov	r1, #1
34810a08:	e3a000b3 	mov	r0, #179	; 0xb3
34810a0c:	ebffffd4 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810a10:	e3a00005 	mov	r0, #5
34810a14:	eb003067 	bl	3481cbb8 <udelay>
	I2C_SDA(0);
34810a18:	e3a01000 	mov	r1, #0
34810a1c:	e3a000b0 	mov	r0, #176	; 0xb0
34810a20:	ebffffcf 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810a24:	e3a00005 	mov	r0, #5
}
34810a28:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(0);
	I2C_DELAY;
34810a2c:	ea003061 	b	3481cbb8 <udelay>

34810a30 <send_stop>:

/*-----------------------------------------------------------------------
 * STOP: Low -> High on SDA while SCL is High
 */
static void send_stop(void)
{
34810a30:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
34810a34:	e3a01000 	mov	r1, #0
34810a38:	e3a000b3 	mov	r0, #179	; 0xb3
34810a3c:	ebffffc8 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810a40:	e3a00005 	mov	r0, #5
34810a44:	eb00305b 	bl	3481cbb8 <udelay>
	I2C_SDA(0);
34810a48:	e3a01000 	mov	r1, #0
34810a4c:	e3a000b0 	mov	r0, #176	; 0xb0
34810a50:	ebffffc3 	bl	34810964 <gpio_direction_output>
	I2C_ACTIVE;
	I2C_DELAY;
34810a54:	e3a00005 	mov	r0, #5
34810a58:	eb003056 	bl	3481cbb8 <udelay>
	I2C_SCL(1);
34810a5c:	e3a01001 	mov	r1, #1
34810a60:	e3a000b3 	mov	r0, #179	; 0xb3
34810a64:	ebffffbe 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810a68:	e3a00005 	mov	r0, #5
34810a6c:	eb003051 	bl	3481cbb8 <udelay>
	I2C_SDA(1);
34810a70:	e3a000b0 	mov	r0, #176	; 0xb0
34810a74:	ebffffb0 	bl	3481093c <gpio_direction_input>
	I2C_DELAY;
34810a78:	e3a00005 	mov	r0, #5
	I2C_TRISTATE;
}
34810a7c:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(1);
	I2C_DELAY;
34810a80:	ea00304c 	b	3481cbb8 <udelay>

34810a84 <write_byte>:

/*-----------------------------------------------------------------------
 * Send 8 bits and look for an acknowledgement.
 */
static int write_byte(uchar data)
{
34810a84:	e92d4038 	push	{r3, r4, r5, lr}
34810a88:	e1a05000 	mov	r5, r0
34810a8c:	e3a04008 	mov	r4, #8
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
34810a90:	e3a01000 	mov	r1, #0
34810a94:	e3a000b3 	mov	r0, #179	; 0xb3
34810a98:	ebffffb1 	bl	34810964 <gpio_direction_output>
		I2C_DELAY;
34810a9c:	e3a00005 	mov	r0, #5
34810aa0:	eb003044 	bl	3481cbb8 <udelay>
		I2C_SDA(data & 0x80);
34810aa4:	e3150080 	tst	r5, #128	; 0x80
34810aa8:	0a000002 	beq	34810ab8 <write_byte+0x34>
34810aac:	e3a000b0 	mov	r0, #176	; 0xb0
34810ab0:	ebffffa1 	bl	3481093c <gpio_direction_input>
34810ab4:	ea000002 	b	34810ac4 <write_byte+0x40>
34810ab8:	e3a000b0 	mov	r0, #176	; 0xb0
34810abc:	e3a01000 	mov	r1, #0
34810ac0:	ebffffa7 	bl	34810964 <gpio_direction_output>
		I2C_DELAY;
34810ac4:	e3a00005 	mov	r0, #5
34810ac8:	eb00303a 	bl	3481cbb8 <udelay>
		I2C_SCL(1);
34810acc:	e3a01001 	mov	r1, #1
34810ad0:	e3a000b3 	mov	r0, #179	; 0xb3
34810ad4:	ebffffa2 	bl	34810964 <gpio_direction_output>
		I2C_DELAY;
34810ad8:	e3a00005 	mov	r0, #5
34810adc:	eb003035 	bl	3481cbb8 <udelay>
		I2C_DELAY;
34810ae0:	e3a00005 	mov	r0, #5
34810ae4:	eb003033 	bl	3481cbb8 <udelay>
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
34810ae8:	e2544001 	subs	r4, r4, #1
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;

		data <<= 1;
34810aec:	11a05085 	lslne	r5, r5, #1
34810af0:	16ef5075 	uxtbne	r5, r5
34810af4:	1affffe5 	bne	34810a90 <write_byte+0xc>
	}

	/*
	 * Look for an <ACK>(negative logic) and return it.
	 */
	I2C_SCL(0);
34810af8:	e1a01004 	mov	r1, r4
34810afc:	e3a000b3 	mov	r0, #179	; 0xb3
34810b00:	ebffff97 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810b04:	e3a00005 	mov	r0, #5
34810b08:	eb00302a 	bl	3481cbb8 <udelay>
	I2C_SDA(1);
34810b0c:	e3a000b0 	mov	r0, #176	; 0xb0
34810b10:	ebffff89 	bl	3481093c <gpio_direction_input>
	I2C_TRISTATE;
	I2C_DELAY;
34810b14:	e3a00005 	mov	r0, #5
34810b18:	eb003026 	bl	3481cbb8 <udelay>
	I2C_SCL(1);
34810b1c:	e3a01001 	mov	r1, #1
34810b20:	e3a000b3 	mov	r0, #179	; 0xb3
34810b24:	ebffff8e 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810b28:	e3a00005 	mov	r0, #5
34810b2c:	eb003021 	bl	3481cbb8 <udelay>
	I2C_DELAY;
34810b30:	e3a00005 	mov	r0, #5
34810b34:	eb00301f 	bl	3481cbb8 <udelay>
	nack = I2C_READ;
34810b38:	e3a000b0 	mov	r0, #176	; 0xb0
34810b3c:	ebffff93 	bl	34810990 <gpio_get_value>
	I2C_SCL(0);
34810b40:	e1a01004 	mov	r1, r4
	I2C_TRISTATE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_DELAY;
	nack = I2C_READ;
34810b44:	e1a05000 	mov	r5, r0
	I2C_SCL(0);
34810b48:	e3a000b3 	mov	r0, #179	; 0xb3
34810b4c:	ebffff84 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810b50:	e3a00005 	mov	r0, #5
34810b54:	eb003017 	bl	3481cbb8 <udelay>
	I2C_ACTIVE;

	return(nack);	/* not a nack is an ack */
}
34810b58:	e1a00005 	mov	r0, r5
34810b5c:	e8bd8038 	pop	{r3, r4, r5, pc}

34810b60 <i2c_get_bus_num>:
 * Functions for multiple I2C bus handling
 */
unsigned int i2c_get_bus_num(void)
{
	return i2c_bus_num;
}
34810b60:	e59f3004 	ldr	r3, [pc, #4]	; 34810b6c <i2c_get_bus_num+0xc>
34810b64:	e5930000 	ldr	r0, [r3]
34810b68:	e12fff1e 	bx	lr
34810b6c:	34828d18 	.word	0x34828d18

34810b70 <i2c_set_bus_num>:
			i2c_bus_num = bus;
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
34810b70:	e3500006 	cmp	r0, #6
		return -1;
	i2c_bus_num = bus;
34810b74:	959f300c 	ldrls	r3, [pc, #12]	; 34810b88 <i2c_set_bus_num+0x18>
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
		return -1;
34810b78:	83e00000 	mvnhi	r0, #0
	i2c_bus_num = bus;
34810b7c:	95830000 	strls	r0, [r3]
#endif
	return 0;
34810b80:	93a00000 	movls	r0, #0
}
34810b84:	e12fff1e 	bx	lr
34810b88:	34828d18 	.word	0x34828d18

34810b8c <i2c_init>:

/*-----------------------------------------------------------------------
 * Initialization
 */
void i2c_init (int speed, int slaveaddr)
{
34810b8c:	e92d4010 	push	{r4, lr}
static void send_reset(void)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;

	I2C_SCL(1);
34810b90:	e3a01001 	mov	r1, #1
34810b94:	e3a000b3 	mov	r0, #179	; 0xb3
34810b98:	ebffff71 	bl	34810964 <gpio_direction_output>
	I2C_SDA(1);
34810b9c:	e3a000b0 	mov	r0, #176	; 0xb0
34810ba0:	ebffff65 	bl	3481093c <gpio_direction_input>
#ifdef	I2C_INIT
	I2C_INIT;
34810ba4:	e59f105c 	ldr	r1, [pc, #92]	; 34810c08 <i2c_init+0x7c>
34810ba8:	e3a000b3 	mov	r0, #179	; 0xb3
34810bac:	ebffff5e 	bl	3481092c <gpio_request>
34810bb0:	e3a000b0 	mov	r0, #176	; 0xb0
34810bb4:	e59f104c 	ldr	r1, [pc, #76]	; 34810c08 <i2c_init+0x7c>
34810bb8:	ebffff5b 	bl	3481092c <gpio_request>
34810bbc:	e3a04009 	mov	r4, #9
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
		I2C_SCL(0);
34810bc0:	e3a01000 	mov	r1, #0
34810bc4:	e3a000b3 	mov	r0, #179	; 0xb3
34810bc8:	ebffff65 	bl	34810964 <gpio_direction_output>
		I2C_DELAY;
34810bcc:	e3a00005 	mov	r0, #5
34810bd0:	eb002ff8 	bl	3481cbb8 <udelay>
		I2C_DELAY;
34810bd4:	e3a00005 	mov	r0, #5
34810bd8:	eb002ff6 	bl	3481cbb8 <udelay>
		I2C_SCL(1);
34810bdc:	e3a01001 	mov	r1, #1
34810be0:	e3a000b3 	mov	r0, #179	; 0xb3
34810be4:	ebffff5e 	bl	34810964 <gpio_direction_output>
		I2C_DELAY;
34810be8:	e3a00005 	mov	r0, #5
34810bec:	eb002ff1 	bl	3481cbb8 <udelay>
		I2C_DELAY;
34810bf0:	e3a00005 	mov	r0, #5
34810bf4:	eb002fef 	bl	3481cbb8 <udelay>
	I2C_SDA(1);
#ifdef	I2C_INIT
	I2C_INIT;
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
34810bf8:	e2544001 	subs	r4, r4, #1
34810bfc:	1affffef 	bne	34810bc0 <i2c_init+0x34>
	 * the DIMM SPD, for instance), RAM won't be usable and your
	 * system will crash.
	 */
	send_reset ();
#endif
}
34810c00:	e8bd4010 	pop	{r4, lr}
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;
	}
	send_stop();
34810c04:	eaffff89 	b	34810a30 <send_stop>
34810c08:	348270f5 	.word	0x348270f5

34810c0c <i2c_probe>:
 * Probe to see if a chip is present.  Also good for checking for the
 * completion of EEPROM writes since the chip stops responding until
 * the write completes (typically 10mSec).
 */
int i2c_probe(uchar addr)
{
34810c0c:	e92d4010 	push	{r4, lr}
34810c10:	e1a04000 	mov	r4, r0

	/*
	 * perform 1 byte write transaction with just address byte
	 * (fake write)
	 */
	send_start();
34810c14:	ebffff73 	bl	348109e8 <send_start>
	rc = write_byte ((addr << 1) | 0);
34810c18:	e1a00084 	lsl	r0, r4, #1
34810c1c:	e20000fe 	and	r0, r0, #254	; 0xfe
34810c20:	ebffff97 	bl	34810a84 <write_byte>
34810c24:	e1a04000 	mov	r4, r0
	send_stop();
34810c28:	ebffff80 	bl	34810a30 <send_stop>

	return (rc ? 1 : 0);
}
34810c2c:	e2540000 	subs	r0, r4, #0
34810c30:	13a00001 	movne	r0, #1
34810c34:	e8bd8010 	pop	{r4, pc}

34810c38 <i2c_read>:

/*-----------------------------------------------------------------------
 * Read bytes
 */
int  i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
34810c38:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
34810c3c:	e1a07002 	mov	r7, r2
34810c40:	e1a04000 	mov	r4, r0
34810c44:	e1a05001 	mov	r5, r1
34810c48:	e1a0a003 	mov	sl, r3
34810c4c:	e59d6020 	ldr	r6, [sp, #32]
	 * Do the addressing portion of a write cycle to set the
	 * chip's address pointer.  If the address length is zero,
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
34810c50:	ebffff64 	bl	348109e8 <send_start>
	if(alen > 0) {
34810c54:	e3570000 	cmp	r7, #0
34810c58:	da000014 	ble	34810cb0 <i2c_read+0x78>
		if(write_byte(chip << 1)) {	/* write cycle */
34810c5c:	e1a00084 	lsl	r0, r4, #1
34810c60:	e20000fe 	and	r0, r0, #254	; 0xfe
34810c64:	ebffff86 	bl	34810a84 <write_byte>
34810c68:	e3500000 	cmp	r0, #0
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
34810c6c:	02479001 	subeq	r9, r7, #1
34810c70:	01a09189 	lsleq	r9, r9, #3
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
	if(alen > 0) {
		if(write_byte(chip << 1)) {	/* write cycle */
34810c74:	0a000009 	beq	34810ca0 <i2c_read+0x68>
			send_stop();
34810c78:	ebffff6c 	bl	34810a30 <send_stop>
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
34810c7c:	e3a00001 	mov	r0, #1
34810c80:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
34810c84:	e1a00935 	lsr	r0, r5, r9
34810c88:	e6ef0070 	uxtb	r0, r0
34810c8c:	ebffff7c 	bl	34810a84 <write_byte>
34810c90:	e3500000 	cmp	r0, #0
34810c94:	e2477001 	sub	r7, r7, #1
34810c98:	1a000041 	bne	34810da4 <i2c_read+0x16c>
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
			}
			shift -= 8;
34810c9c:	e2499008 	sub	r9, r9, #8
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
34810ca0:	e3570000 	cmp	r7, #0
34810ca4:	cafffff6 	bgt	34810c84 <i2c_read+0x4c>
		 * stop/start sequence.
		 */
#ifdef CONFIG_SOFT_I2C_READ_REPEATED_START
		send_start();
#else
		send_stop();
34810ca8:	ebffff60 	bl	34810a30 <send_stop>
		send_start();
34810cac:	ebffff4d 	bl	348109e8 <send_start>
	/*
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
34810cb0:	e1a04084 	lsl	r4, r4, #1
34810cb4:	e3840001 	orr	r0, r4, #1
34810cb8:	e6ef0070 	uxtb	r0, r0
34810cbc:	ebffff70 	bl	34810a84 <write_byte>
	while(len-- > 0) {
34810cc0:	ea000032 	b	34810d90 <i2c_read+0x158>

	/*
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
34810cc4:	e3a000b0 	mov	r0, #176	; 0xb0
34810cc8:	ebffff1b 	bl	3481093c <gpio_direction_input>
34810ccc:	e3a04008 	mov	r4, #8
	data = 0;
34810cd0:	e3a05000 	mov	r5, #0
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
34810cd4:	e3a01000 	mov	r1, #0
34810cd8:	e3a000b3 	mov	r0, #179	; 0xb3
34810cdc:	ebffff20 	bl	34810964 <gpio_direction_output>
		I2C_DELAY;
34810ce0:	e3a00005 	mov	r0, #5
34810ce4:	eb002fb3 	bl	3481cbb8 <udelay>
		I2C_SCL(1);
34810ce8:	e3a01001 	mov	r1, #1
34810cec:	e3a000b3 	mov	r0, #179	; 0xb3
34810cf0:	ebffff1b 	bl	34810964 <gpio_direction_output>
		I2C_DELAY;
34810cf4:	e3a00005 	mov	r0, #5
34810cf8:	eb002fae 	bl	3481cbb8 <udelay>
		data <<= 1;
		data |= I2C_READ;
34810cfc:	e3a000b0 	mov	r0, #176	; 0xb0
34810d00:	ebffff22 	bl	34810990 <gpio_get_value>
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		data <<= 1;
34810d04:	e1a05085 	lsl	r5, r5, #1
		data |= I2C_READ;
34810d08:	e1855000 	orr	r5, r5, r0
		I2C_DELAY;
34810d0c:	e3a00005 	mov	r0, #5
34810d10:	eb002fa8 	bl	3481cbb8 <udelay>
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
	data = 0;
	for(j = 0; j < 8; j++) {
34810d14:	e2544001 	subs	r4, r4, #1
34810d18:	1affffed 	bne	34810cd4 <i2c_read+0x9c>
 */
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
34810d1c:	e1a01004 	mov	r1, r4
34810d20:	e3a000b3 	mov	r0, #179	; 0xb3
34810d24:	ebffff0e 	bl	34810964 <gpio_direction_output>
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
34810d28:	e2466001 	sub	r6, r6, #1
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
	I2C_DELAY;
34810d2c:	e3a00005 	mov	r0, #5
34810d30:	eb002fa0 	bl	3481cbb8 <udelay>
	I2C_ACTIVE;
	I2C_SDA(ack);
34810d34:	e3560000 	cmp	r6, #0
34810d38:	1a000002 	bne	34810d48 <i2c_read+0x110>
34810d3c:	e3a000b0 	mov	r0, #176	; 0xb0
34810d40:	ebfffefd 	bl	3481093c <gpio_direction_input>
34810d44:	ea000002 	b	34810d54 <i2c_read+0x11c>
34810d48:	e3a000b0 	mov	r0, #176	; 0xb0
34810d4c:	e1a01004 	mov	r1, r4
34810d50:	ebffff03 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810d54:	e3a00005 	mov	r0, #5
34810d58:	eb002f96 	bl	3481cbb8 <udelay>
	I2C_SCL(1);
34810d5c:	e3a01001 	mov	r1, #1
34810d60:	e3a000b3 	mov	r0, #179	; 0xb3
34810d64:	ebfffefe 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810d68:	e3a00005 	mov	r0, #5
34810d6c:	eb002f91 	bl	3481cbb8 <udelay>
	I2C_DELAY;
34810d70:	e3a00005 	mov	r0, #5
34810d74:	eb002f8f 	bl	3481cbb8 <udelay>
	I2C_SCL(0);
34810d78:	e3a01000 	mov	r1, #0
34810d7c:	e3a000b3 	mov	r0, #179	; 0xb3
34810d80:	ebfffef7 	bl	34810964 <gpio_direction_output>
	I2C_DELAY;
34810d84:	e3a00005 	mov	r0, #5
34810d88:	eb002f8a 	bl	3481cbb8 <udelay>
		data |= I2C_READ;
		I2C_DELAY;
	}
	send_ack(ack);

	return(data);
34810d8c:	e4ca5001 	strb	r5, [sl], #1
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
34810d90:	e3560000 	cmp	r6, #0
34810d94:	caffffca 	bgt	34810cc4 <i2c_read+0x8c>
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
34810d98:	ebffff24 	bl	34810a30 <send_stop>
	return(0);
34810d9c:	e3a00000 	mov	r0, #0
34810da0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
34810da4:	e3a00001 	mov	r0, #1
	while(len-- > 0) {
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
	return(0);
}
34810da8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

34810dac <i2c_write>:

/*-----------------------------------------------------------------------
 * Write bytes
 */
int  i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
34810dac:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34810db0:	e1a05000 	mov	r5, r0
34810db4:	e1a06002 	mov	r6, r2
34810db8:	e1a04001 	mov	r4, r1
34810dbc:	e1a07003 	mov	r7, r3
	int shift, failures = 0;

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
34810dc0:	ebffff08 	bl	348109e8 <send_start>
	if(write_byte(chip << 1)) {	/* write cycle */
34810dc4:	e1a00085 	lsl	r0, r5, #1
34810dc8:	e20000fe 	and	r0, r0, #254	; 0xfe
34810dcc:	ebffff2c 	bl	34810a84 <write_byte>
34810dd0:	e3500000 	cmp	r0, #0
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
34810dd4:	02465001 	subeq	r5, r6, #1
34810dd8:	01a05185 	lsleq	r5, r5, #3

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
	if(write_byte(chip << 1)) {	/* write cycle */
34810ddc:	0a000008 	beq	34810e04 <i2c_write+0x58>
		send_stop();
34810de0:	ebffff12 	bl	34810a30 <send_stop>
34810de4:	ea000014 	b	34810e3c <i2c_write+0x90>
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
34810de8:	e1a00534 	lsr	r0, r4, r5
34810dec:	e6ef0070 	uxtb	r0, r0
34810df0:	ebffff23 	bl	34810a84 <write_byte>
34810df4:	e3500000 	cmp	r0, #0
34810df8:	e2466001 	sub	r6, r6, #1
34810dfc:	1a00000e 	bne	34810e3c <i2c_write+0x90>
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
		}
		shift -= 8;
34810e00:	e2455008 	sub	r5, r5, #8
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
34810e04:	e3560000 	cmp	r6, #0
34810e08:	cafffff6 	bgt	34810de8 <i2c_write+0x3c>
34810e0c:	e59d5018 	ldr	r5, [sp, #24]
34810e10:	e3a04000 	mov	r4, #0
34810e14:	ea000004 	b	34810e2c <i2c_write+0x80>
		}
		shift -= 8;
	}

	while(len-- > 0) {
		if(write_byte(*buffer++)) {
34810e18:	e4d70001 	ldrb	r0, [r7], #1
34810e1c:	ebffff18 	bl	34810a84 <write_byte>
34810e20:	e3500000 	cmp	r0, #0
			failures++;
34810e24:	12844001 	addne	r4, r4, #1
34810e28:	e2455001 	sub	r5, r5, #1
			return(1);
		}
		shift -= 8;
	}

	while(len-- > 0) {
34810e2c:	e3550000 	cmp	r5, #0
34810e30:	cafffff8 	bgt	34810e18 <i2c_write+0x6c>
		if(write_byte(*buffer++)) {
			failures++;
		}
	}
	send_stop();
34810e34:	ebfffefd 	bl	34810a30 <send_stop>
	return(failures);
34810e38:	ea000000 	b	34810e40 <i2c_write+0x94>
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
34810e3c:	e3a04001 	mov	r4, #1
			failures++;
		}
	}
	send_stop();
	return(failures);
}
34810e40:	e1a00004 	mov	r0, r4
34810e44:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34810e48 <sort_array_by_ordering>:
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810e48:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810e4c:	e28db01c 	add	fp, sp, #28
34810e50:	e24dd008 	sub	sp, sp, #8
34810e54:	e50b2020 	str	r2, [fp, #-32]
	int temp[count];
34810e58:	e1a02101 	lsl	r2, r1, #2
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810e5c:	e1a09003 	mov	r9, r3
	int temp[count];
34810e60:	e282300e 	add	r3, r2, #14
34810e64:	e3c33007 	bic	r3, r3, #7
34810e68:	e04dd003 	sub	sp, sp, r3
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810e6c:	e1a04000 	mov	r4, r0
34810e70:	e1a05001 	mov	r5, r1
	int dest_count;
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
34810e74:	e1a0000d 	mov	r0, sp
34810e78:	e1a01004 	mov	r1, r4
34810e7c:	eb002ec2 	bl	3481c98c <memcpy>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810e80:	e3a02000 	mov	r2, #0
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
	int temp[count];
34810e84:	e1a0600d 	mov	r6, sp
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810e88:	e51b0020 	ldr	r0, [fp, #-32]
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;
34810e8c:	e1a03002 	mov	r3, r2

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810e90:	ea00000d 	b	34810ecc <sort_array_by_ordering+0x84>
		if (array_search(temp, count, order[i]) != -1)
34810e94:	e490c004 	ldr	ip, [r0], #4
34810e98:	e1a07006 	mov	r7, r6
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810e9c:	e3a01000 	mov	r1, #0
34810ea0:	ea000003 	b	34810eb4 <sort_array_by_ordering+0x6c>
		if (array[i] == key)
34810ea4:	e497a004 	ldr	sl, [r7], #4
34810ea8:	e15a000c 	cmp	sl, ip
34810eac:	0a000003 	beq	34810ec0 <sort_array_by_ordering+0x78>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810eb0:	e2811001 	add	r1, r1, #1
34810eb4:	e1510005 	cmp	r1, r5
34810eb8:	bafffff9 	blt	34810ea4 <sort_array_by_ordering+0x5c>
34810ebc:	ea000001 	b	34810ec8 <sort_array_by_ordering+0x80>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
		if (array_search(temp, count, order[i]) != -1)
			dest[dest_count++] = order[i];
34810ec0:	e784c103 	str	ip, [r4, r3, lsl #2]
34810ec4:	e2833001 	add	r3, r3, #1
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810ec8:	e2822001 	add	r2, r2, #1
34810ecc:	e1520009 	cmp	r2, r9
34810ed0:	baffffef 	blt	34810e94 <sort_array_by_ordering+0x4c>
34810ed4:	e1a00003 	mov	r0, r3
34810ed8:	e3a02000 	mov	r2, #0
34810edc:	ea00000b 	b	34810f10 <sort_array_by_ordering+0xc8>
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
34810ee0:	e496c004 	ldr	ip, [r6], #4
34810ee4:	e51b7020 	ldr	r7, [fp, #-32]
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810ee8:	e3a01000 	mov	r1, #0
34810eec:	ea000003 	b	34810f00 <sort_array_by_ordering+0xb8>
		if (array[i] == key)
34810ef0:	e497a004 	ldr	sl, [r7], #4
34810ef4:	e15a000c 	cmp	sl, ip
34810ef8:	0a000003 	beq	34810f0c <sort_array_by_ordering+0xc4>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810efc:	e2811001 	add	r1, r1, #1
34810f00:	e1510009 	cmp	r1, r9
34810f04:	bafffff9 	blt	34810ef0 <sort_array_by_ordering+0xa8>
34810f08:	ea000004 	b	34810f20 <sort_array_by_ordering+0xd8>
			dest[dest_count++] = order[i];
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
34810f0c:	e2822001 	add	r2, r2, #1
34810f10:	e1520005 	cmp	r2, r5
34810f14:	bafffff1 	blt	34810ee0 <sort_array_by_ordering+0x98>
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
	}
	assert(dest_count == count);
	return same;
}
34810f18:	e24bd01c 	sub	sp, fp, #28
34810f1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
34810f20:	e784c103 	str	ip, [r4, r3, lsl #2]
34810f24:	e2833001 	add	r3, r3, #1
34810f28:	eafffff7 	b	34810f0c <sort_array_by_ordering+0xc4>

34810f2c <input_queue_ascii>:
};


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
34810f2c:	e5903010 	ldr	r3, [r0, #16]
34810f30:	e5902014 	ldr	r2, [r0, #20]
34810f34:	e353000f 	cmp	r3, #15
34810f38:	1a000003 	bne	34810f4c <input_queue_ascii+0x20>
		if (!config->fifo_out)
34810f3c:	e3520000 	cmp	r2, #0
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
34810f40:	13a03000 	movne	r3, #0


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
34810f44:	1a000003 	bne	34810f58 <input_queue_ascii+0x2c>
34810f48:	ea000007 	b	34810f6c <input_queue_ascii+0x40>
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
34810f4c:	e2833001 	add	r3, r3, #1
34810f50:	e1530002 	cmp	r3, r2
34810f54:	0a000006 	beq	34810f74 <input_queue_ascii+0x48>
			return -1; /* buffer full */
		config->fifo_in++;
34810f58:	e5803010 	str	r3, [r0, #16]
	}
	config->fifo[config->fifo_in] = (uchar)ch;
34810f5c:	e5903010 	ldr	r3, [r0, #16]
34810f60:	e7c01003 	strb	r1, [r0, r3]

	return 0;
34810f64:	e3a00000 	mov	r0, #0
34810f68:	e12fff1e 	bx	lr

int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
			return -1; /* buffer full */
34810f6c:	e3e00000 	mvn	r0, #0
34810f70:	e12fff1e 	bx	lr
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
			return -1; /* buffer full */
34810f74:	e3e00000 	mvn	r0, #0
		config->fifo_in++;
	}
	config->fifo[config->fifo_in] = (uchar)ch;

	return 0;
}
34810f78:	e12fff1e 	bx	lr

34810f7c <input_tstc>:

int input_tstc(struct input_config *config)
{
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810f7c:	e5902010 	ldr	r2, [r0, #16]
34810f80:	e5903014 	ldr	r3, [r0, #20]

	return 0;
}

int input_tstc(struct input_config *config)
{
34810f84:	e92d4010 	push	{r4, lr}
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810f88:	e1520003 	cmp	r2, r3

	return 0;
}

int input_tstc(struct input_config *config)
{
34810f8c:	e1a04000 	mov	r4, r0
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810f90:	1a000005 	bne	34810fac <input_tstc+0x30>
34810f94:	e59030a0 	ldr	r3, [r0, #160]	; 0xa0
34810f98:	e3530000 	cmp	r3, #0
34810f9c:	0a000002 	beq	34810fac <input_tstc+0x30>
		if (!(*config->read_keys)(config))
34810fa0:	e12fff33 	blx	r3
34810fa4:	e3500000 	cmp	r0, #0
34810fa8:	08bd8010 	popeq	{r4, pc}
			return 0;
	}
	return config->fifo_in != config->fifo_out;
34810fac:	e5940010 	ldr	r0, [r4, #16]
34810fb0:	e5943014 	ldr	r3, [r4, #20]
34810fb4:	e0500003 	subs	r0, r0, r3
34810fb8:	13a00001 	movne	r0, #1
}
34810fbc:	e8bd8010 	pop	{r4, pc}

34810fc0 <input_getc>:

int input_getc(struct input_config *config)
{
34810fc0:	e92d4010 	push	{r4, lr}
34810fc4:	e1a04000 	mov	r4, r0
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810fc8:	ea000006 	b	34810fe8 <input_getc+0x28>
		if (config->read_keys)
34810fcc:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
34810fd0:	e3530000 	cmp	r3, #0
34810fd4:	0a000003 	beq	34810fe8 <input_getc+0x28>
			err = (*config->read_keys)(config);
34810fd8:	e1a00004 	mov	r0, r4
34810fdc:	e12fff33 	blx	r3
		if (err)
34810fe0:	e3500000 	cmp	r0, #0
34810fe4:	1a00000b 	bne	34811018 <input_getc+0x58>

int input_getc(struct input_config *config)
{
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810fe8:	e5943014 	ldr	r3, [r4, #20]
34810fec:	e5942010 	ldr	r2, [r4, #16]
34810ff0:	e1520003 	cmp	r2, r3
34810ff4:	0afffff4 	beq	34810fcc <input_getc+0xc>
			err = (*config->read_keys)(config);
		if (err)
			return -1;
	}

	if (++config->fifo_out == INPUT_BUFFER_LEN)
34810ff8:	e2833001 	add	r3, r3, #1
34810ffc:	e3530010 	cmp	r3, #16
34811000:	e5843014 	str	r3, [r4, #20]
		config->fifo_out = 0;
34811004:	03a03000 	moveq	r3, #0
34811008:	05843014 	streq	r3, [r4, #20]

	return config->fifo[config->fifo_out];
3481100c:	e5943014 	ldr	r3, [r4, #20]
34811010:	e7d40003 	ldrb	r0, [r4, r3]
34811014:	e8bd8010 	pop	{r4, pc}

	while (config->fifo_in == config->fifo_out) {
		if (config->read_keys)
			err = (*config->read_keys)(config);
		if (err)
			return -1;
34811018:	e3e00000 	mvn	r0, #0

	if (++config->fifo_out == INPUT_BUFFER_LEN)
		config->fifo_out = 0;

	return config->fifo[config->fifo_out];
}
3481101c:	e8bd8010 	pop	{r4, pc}

34811020 <input_send_keycodes>:
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
34811020:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34811024:	e28db01c 	add	fp, sp, #28
34811028:	e24dd010 	sub	sp, sp, #16
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
3481102c:	e5d0701b 	ldrb	r7, [r0, #27]
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
34811030:	e282300e 	add	r3, r2, #14
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
34811034:	e3a09000 	mov	r9, #0
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
34811038:	e3c33007 	bic	r3, r3, #7
3481103c:	e04dd003 	sub	sp, sp, r3
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
34811040:	e1570009 	cmp	r7, r9
	char ch[num_keycodes];
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
34811044:	e5c09018 	strb	r9, [r0, #24]
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
34811048:	e1a04000 	mov	r4, r0
3481104c:	e1a06001 	mov	r6, r1
34811050:	e1a05002 	mov	r5, r2
	char ch[num_keycodes];
34811054:	e50bd020 	str	sp, [fp, #-32]
	int count, i, same = 0;
	int is_repeat = 0;
34811058:	01a09007 	moveq	r9, r7
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
3481105c:	0a000012 	beq	348110ac <input_send_keycodes+0x8c>
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
34811060:	e280a01c 	add	sl, r0, #28
34811064:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
34811068:	e1a00001 	mov	r0, r1
3481106c:	e1a01002 	mov	r1, r2
34811070:	e1a0200a 	mov	r2, sl
34811074:	ebffff73 	bl	34810e48 <sort_array_by_ordering>
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34811078:	e1a01006 	mov	r1, r6
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
3481107c:	e1a07000 	mov	r7, r0
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34811080:	e1a02105 	lsl	r2, r5, #2
34811084:	e1a0000a 	mov	r0, sl
34811088:	eb002e3f 	bl	3481c98c <memcpy>
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
3481108c:	e1570005 	cmp	r7, r5
	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
	config->num_prev_keycodes = num_keycodes;
34811090:	e584505c 	str	r5, [r4, #92]	; 0x5c
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
34811094:	1a000004 	bne	348110ac <input_send_keycodes+0x8c>
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
34811098:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
3481109c:	ebffc0be 	bl	3480139c <get_timer>
		if (!is_repeat)
348110a0:	e1500009 	cmp	r0, r9
348110a4:	a2899001 	addge	r9, r9, #1
348110a8:	ba000061 	blt	34811234 <input_send_keycodes+0x214>
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
348110ac:	e2840060 	add	r0, r4, #96	; 0x60
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
		if (!is_repeat)
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
348110b0:	e3590000 	cmp	r9, #0
348110b4:	13a07000 	movne	r7, #0
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
348110b8:	e50b0024 	str	r0, [fp, #-36]	; 0x24
348110bc:	e1a0e006 	mov	lr, r6
348110c0:	e1a03000 	mov	r3, r0

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
348110c4:	e3a0c000 	mov	ip, #0
348110c8:	ea000032 	b	34811198 <input_send_keycodes+0x178>
		int key = keycode[i] & KEY_MASK;
348110cc:	e49e1004 	ldr	r1, [lr], #4

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
348110d0:	e593a00c 	ldr	sl, [r3, #12]

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
		int key = keycode[i] & KEY_MASK;
348110d4:	e1a00a01 	lsl	r0, r1, #20
348110d8:	e1a02a20 	lsr	r2, r0, #20

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
348110dc:	e152000a 	cmp	r2, sl
348110e0:	aa000003 	bge	348110f4 <input_send_keycodes+0xd4>
348110e4:	e593a008 	ldr	sl, [r3, #8]
348110e8:	e7da0a20 	ldrb	r0, [sl, r0, lsr #20]
348110ec:	e35000ff 	cmp	r0, #255	; 0xff
348110f0:	1a000027 	bne	34811194 <input_send_keycodes+0x174>
			table = process_modifier(config, key,
348110f4:	e2011902 	and	r1, r1, #32768	; 0x8000
348110f8:	e50b1028 	str	r1, [fp, #-40]	; 0x28
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
348110fc:	e5d4101b 	ldrb	r1, [r4, #27]
34811100:	e1a00004 	mov	r0, r4
34811104:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
	int flip = -1;
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
34811108:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
	for (i = 1; i < config->num_tables; i++) {
3481110c:	e3a01001 	mov	r1, #1
34811110:	ea000009 	b	3481113c <input_send_keycodes+0x11c>
		struct input_key_xlate *tab = &config->table[i];

		if (key == tab->left_keycode || key == tab->right_keycode)
34811114:	e590a070 	ldr	sl, [r0, #112]	; 0x70
34811118:	e152000a 	cmp	r2, sl
3481111c:	0a000002 	beq	3481112c <input_send_keycodes+0x10c>
34811120:	e590a074 	ldr	sl, [r0, #116]	; 0x74
34811124:	e152000a 	cmp	r2, sl
34811128:	1a000001 	bne	34811134 <input_send_keycodes+0x114>

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
		struct input_key_xlate *tab = &config->table[i];
3481112c:	e2813006 	add	r3, r1, #6
34811130:	e0843203 	add	r3, r4, r3, lsl #4
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
34811134:	e2811001 	add	r1, r1, #1
34811138:	e2800010 	add	r0, r0, #16
3481113c:	e51ba02c 	ldr	sl, [fp, #-44]	; 0x2c
34811140:	e151000a 	cmp	r1, sl
34811144:	bafffff2 	blt	34811114 <input_send_keycodes+0xf4>
		if (key == tab->left_keycode || key == tab->right_keycode)
			table = tab;
	}

	/* Handle the lighted keys */
	if (!release) {
34811148:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
3481114c:	e3500000 	cmp	r0, #0
34811150:	1a00000f 	bne	34811194 <input_send_keycodes+0x174>
34811154:	e242203a 	sub	r2, r2, #58	; 0x3a
34811158:	e352000c 	cmp	r2, #12
3481115c:	8a00000c 	bhi	34811194 <input_send_keycodes+0x174>
			flip = FLAG_CAPS_LOCK;
			break;
		}
	}

	if (flip != -1) {
34811160:	e59f10d8 	ldr	r1, [pc, #216]	; 34811240 <input_send_keycodes+0x220>
34811164:	e7912102 	ldr	r2, [r1, r2, lsl #2]
34811168:	e3720001 	cmn	r2, #1
3481116c:	0a000008 	beq	34811194 <input_send_keycodes+0x174>
		int leds = 0;

		config->leds ^= flip;
		if (config->flags & FLAG_NUM_LOCK)
34811170:	e5d41019 	ldrb	r1, [r4, #25]
			leds |= INPUT_LED_NUM;
34811174:	e3110001 	tst	r1, #1
34811178:	03a02000 	moveq	r2, #0
3481117c:	13a02004 	movne	r2, #4
		if (config->flags & FLAG_CAPS_LOCK)
34811180:	e3110002 	tst	r1, #2
			leds |= INPUT_LED_CAPS;
34811184:	13822002 	orrne	r2, r2, #2
		if (config->flags & FLAG_SCROLL_LOCK)
34811188:	e3110004 	tst	r1, #4
			leds |= INPUT_LED_SCROLL;
3481118c:	13822001 	orrne	r2, r2, #1
		config->leds = leds;
34811190:	e5c4201a 	strb	r2, [r4, #26]
	int i;

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
34811194:	e28cc001 	add	ip, ip, #1
34811198:	e15c0005 	cmp	ip, r5
3481119c:	baffffca 	blt	348110cc <input_send_keycodes+0xac>
348111a0:	e3a02000 	mov	r2, #0
348111a4:	e1a0a002 	mov	sl, r2
348111a8:	ea00000f 	b	348111ec <input_send_keycodes+0x1cc>
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
		int key = keycode[i];
348111ac:	e4961004 	ldr	r1, [r6], #4

		if (key < table->num_entries && i >= same) {
348111b0:	e593c00c 	ldr	ip, [r3, #12]
348111b4:	e1520007 	cmp	r2, r7
348111b8:	b3a00000 	movlt	r0, #0
348111bc:	a3a00001 	movge	r0, #1
348111c0:	e151000c 	cmp	r1, ip
348111c4:	a3a00000 	movge	r0, #0
348111c8:	e3500000 	cmp	r0, #0
348111cc:	0a000005 	beq	348111e8 <input_send_keycodes+0x1c8>
			int ch = table->xlate[key];
348111d0:	e5930008 	ldr	r0, [r3, #8]
348111d4:	e7d01001 	ldrb	r1, [r0, r1]

			/* If a normal key with an ASCII value, add it! */
			if (ch != 0xff)
348111d8:	e35100ff 	cmp	r1, #255	; 0xff
				output_ch[ch_count++] = (uchar)ch;
348111dc:	151b0020 	ldrne	r0, [fp, #-32]
348111e0:	17c0100a 	strbne	r1, [r0, sl]
348111e4:	128aa001 	addne	sl, sl, #1
					keycode[i] & KEY_RELEASE);
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
348111e8:	e2822001 	add	r2, r2, #1
348111ec:	e1520005 	cmp	r2, r5
348111f0:	baffffed 	blt	348111ac <input_send_keycodes+0x18c>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
348111f4:	e3a05000 	mov	r5, #0
348111f8:	ea000004 	b	34811210 <input_send_keycodes+0x1f0>
		input_queue_ascii(config, ch[i]);
348111fc:	e51b3020 	ldr	r3, [fp, #-32]
34811200:	e1a00004 	mov	r0, r4
34811204:	e7d31005 	ldrb	r1, [r3, r5]
34811208:	ebffff47 	bl	34810f2c <input_queue_ascii>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
3481120c:	e2855001 	add	r5, r5, #1
34811210:	e155000a 	cmp	r5, sl
34811214:	bafffff8 	blt	348111fc <input_send_keycodes+0x1dc>
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
34811218:	e3590000 	cmp	r9, #0
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
3481121c:	e3a00000 	mov	r0, #0
	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
34811220:	159450ac 	ldrne	r5, [r4, #172]	; 0xac
34811224:	059450a8 	ldreq	r5, [r4, #168]	; 0xa8
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
34811228:	ebffc05b 	bl	3480139c <get_timer>
3481122c:	e0800005 	add	r0, r0, r5
34811230:	e58400a4 	str	r0, [r4, #164]	; 0xa4
	return 0;
}
34811234:	e3a00000 	mov	r0, #0
34811238:	e24bd01c 	sub	sp, fp, #28
3481123c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811240:	34821680 	.word	0x34821680

34811244 <input_add_table>:

int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
34811244:	e92d4010 	push	{r4, lr}
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34811248:	e5d0c01b 	ldrb	ip, [r0, #27]
3481124c:	e35c0004 	cmp	ip, #4
34811250:	0a00000b 	beq	34811284 <input_add_table+0x40>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811254:	e28c4001 	add	r4, ip, #1
34811258:	e5c0401b 	strb	r4, [r0, #27]
	table->left_keycode = left_keycode;
3481125c:	e28c4006 	add	r4, ip, #6
34811260:	e7801204 	str	r1, [r0, r4, lsl #4]
	table->right_keycode = right_keycode;
34811264:	e0804204 	add	r4, r0, r4, lsl #4
	table->xlate = xlate;
34811268:	e080020c 	add	r0, r0, ip, lsl #4
3481126c:	e5803068 	str	r3, [r0, #104]	; 0x68
	table->num_entries = num_entries;
34811270:	e59d3008 	ldr	r3, [sp, #8]
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34811274:	e5842004 	str	r2, [r4, #4]
	table->xlate = xlate;
	table->num_entries = num_entries;
34811278:	e580306c 	str	r3, [r0, #108]	; 0x6c

	return 0;
3481127c:	e3a00000 	mov	r0, #0
34811280:	e8bd8010 	pop	{r4, pc}
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
34811284:	e3e00000 	mvn	r0, #0
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;

	return 0;
}
34811288:	e8bd8010 	pop	{r4, pc}

3481128c <input_init>:

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
3481128c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34811290:	e1a04000 	mov	r4, r0
34811294:	e1a06001 	mov	r6, r1
34811298:	e1a05002 	mov	r5, r2
	memset(config, '\0', sizeof(*config));
3481129c:	e3a01000 	mov	r1, #0
348112a0:	e3a020b0 	mov	r2, #176	; 0xb0
	return 0;
}

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
348112a4:	e1a07003 	mov	r7, r3
	memset(config, '\0', sizeof(*config));
348112a8:	eb002d93 	bl	3481c8fc <memset>
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348112ac:	e5d4301b 	ldrb	r3, [r4, #27]

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
348112b0:	e5c4601a 	strb	r6, [r4, #26]
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348112b4:	e3530004 	cmp	r3, #4
int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
	config->repeat_delay_ms = repeat_delay_ms;
348112b8:	e58450a8 	str	r5, [r4, #168]	; 0xa8
	config->repeat_rate_ms = repeat_rate_ms;
348112bc:	e58470ac 	str	r7, [r4, #172]	; 0xac
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348112c0:	0a00002b 	beq	34811374 <input_init+0xe8>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
348112c4:	e2831006 	add	r1, r3, #6
348112c8:	e3e00000 	mvn	r0, #0
348112cc:	e7840201 	str	r0, [r4, r1, lsl #4]
	table->right_keycode = right_keycode;
348112d0:	e0841201 	add	r1, r4, r1, lsl #4
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348112d4:	e2832001 	add	r2, r3, #1
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
348112d8:	e5810004 	str	r0, [r1, #4]
	table->xlate = xlate;
348112dc:	e59f1098 	ldr	r1, [pc, #152]	; 3481137c <input_init+0xf0>
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348112e0:	e6ef2072 	uxtb	r2, r2
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
348112e4:	e0843203 	add	r3, r4, r3, lsl #4
348112e8:	e5831068 	str	r1, [r3, #104]	; 0x68
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348112ec:	e3520004 	cmp	r2, #4

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
348112f0:	e3a01063 	mov	r1, #99	; 0x63
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348112f4:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
348112f8:	e583106c 	str	r1, [r3, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348112fc:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
34811300:	e282c006 	add	ip, r2, #6
34811304:	e3a0502a 	mov	r5, #42	; 0x2a
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811308:	e2823001 	add	r3, r2, #1
	table->left_keycode = left_keycode;
3481130c:	e784520c 	str	r5, [r4, ip, lsl #4]
	table->right_keycode = right_keycode;
34811310:	e084c20c 	add	ip, r4, ip, lsl #4
34811314:	e285500c 	add	r5, r5, #12
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34811318:	e6ef3073 	uxtb	r3, r3
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
3481131c:	e58c5004 	str	r5, [ip, #4]
	table->xlate = xlate;
34811320:	e59fc058 	ldr	ip, [pc, #88]	; 34811380 <input_init+0xf4>
34811324:	e0842202 	add	r2, r4, r2, lsl #4
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34811328:	e3530004 	cmp	r3, #4
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
3481132c:	e5c4301b 	strb	r3, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
34811330:	e582c068 	str	ip, [r2, #104]	; 0x68
	table->num_entries = num_entries;
34811334:	e582106c 	str	r1, [r2, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34811338:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
3481133c:	e2832001 	add	r2, r3, #1
34811340:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
34811344:	e280001e 	add	r0, r0, #30
34811348:	e2832006 	add	r2, r3, #6
3481134c:	e7840202 	str	r0, [r4, r2, lsl #4]
	table->right_keycode = right_keycode;
	table->xlate = xlate;
34811350:	e28cc064 	add	ip, ip, #100	; 0x64
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34811354:	e0842202 	add	r2, r4, r2, lsl #4
34811358:	e2800044 	add	r0, r0, #68	; 0x44
	table->xlate = xlate;
3481135c:	e0844203 	add	r4, r4, r3, lsl #4
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34811360:	e5820004 	str	r0, [r2, #4]
	table->xlate = xlate;
34811364:	e584c068 	str	ip, [r4, #104]	; 0x68
	table->num_entries = num_entries;
34811368:	e584106c 	str	r1, [r4, #108]	; 0x6c
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
	}

	return 0;
3481136c:	e3a00000 	mov	r0, #0
34811370:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		input_add_table(config, KEY_LEFTSHIFT, KEY_RIGHTSHIFT,
			kbd_shift_xlate, ARRAY_SIZE(kbd_shift_xlate)) ||
		input_add_table(config, KEY_LEFTCTRL, KEY_RIGHTCTRL,
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
34811374:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
34811378:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481137c:	348216b4 	.word	0x348216b4
34811380:	34828d1c 	.word	0x34828d1c

34811384 <input_stdio_register>:

int input_stdio_register(struct stdio_dev *dev)
{
34811384:	e92d4038 	push	{r3, r4, r5, lr}
34811388:	e1a04000 	mov	r4, r0
	int error;

	error = stdio_register(dev);
3481138c:	ebfff78e 	bl	3480f1cc <stdio_register>

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34811390:	e2505000 	subs	r5, r0, #0
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
34811394:	13a00000 	movne	r0, #0
	int error;

	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34811398:	18bd8038 	popne	{r3, r4, r5, pc}
3481139c:	e59f0030 	ldr	r0, [pc, #48]	; 348113d4 <input_stdio_register+0x50>
348113a0:	e2844008 	add	r4, r4, #8
348113a4:	ebffdb15 	bl	34808000 <getenv>
348113a8:	e1a01004 	mov	r1, r4
348113ac:	eb002c7e 	bl	3481c5ac <strcmp>
348113b0:	e3500000 	cmp	r0, #0
348113b4:	1a000004 	bne	348113cc <input_stdio_register+0x48>
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
348113b8:	e1a01004 	mov	r1, r4
348113bc:	ebffe251 	bl	34809d08 <console_assign>
	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
348113c0:	e3500000 	cmp	r0, #0
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
348113c4:	13e00000 	mvnne	r0, #0
348113c8:	e8bd8038 	pop	{r3, r4, r5, pc}
348113cc:	e1a00005 	mov	r0, r5
}
348113d0:	e8bd8038 	pop	{r3, r4, r5, pc}
348113d4:	34825525 	.word	0x34825525

348113d8 <do_pmic>:
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
348113d8:	e3520001 	cmp	r2, #1
{
	return &pmic;
}

int do_pmic(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348113dc:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
348113e0:	e1a04000 	mov	r4, r0
348113e4:	e1a07002 	mov	r7, r2
348113e8:	e1a05003 	mov	r5, r3
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
348113ec:	da000045 	ble	34811508 <do_pmic+0x130>
		return cmd_usage(cmdtp);

	cmd = argv[1];
348113f0:	e5936004 	ldr	r6, [r3, #4]
	if (strcmp(cmd, "dump") == 0) {
348113f4:	e59f1154 	ldr	r1, [pc, #340]	; 34811550 <do_pmic+0x178>
348113f8:	e1a00006 	mov	r0, r6
348113fc:	eb002c6a 	bl	3481c5ac <strcmp>
34811400:	e250a000 	subs	sl, r0, #0
34811404:	1a00001d 	bne	34811480 <do_pmic+0xa8>

	/* No subcommand found */
	return 1;
}

U_BOOT_CMD(
34811408:	e59f6144 	ldr	r6, [pc, #324]	; 34811554 <do_pmic+0x17c>
	return 0;
}

static void pmic_show_info(struct pmic *p)
{
	printf("PMIC: %s\n", p->name);
3481140c:	e59f0144 	ldr	r0, [pc, #324]	; 34811558 <do_pmic+0x180>
34811410:	e5961000 	ldr	r1, [r6]
34811414:	ebffe1e7 	bl	34809bb8 <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
34811418:	e1a0400a 	mov	r4, sl
		ret = pmic_reg_read(p, i, &val);
3481141c:	e1a0500d 	mov	r5, sp
34811420:	ea000010 	b	34811468 <do_pmic+0x90>
34811424:	e59f0128 	ldr	r0, [pc, #296]	; 34811554 <do_pmic+0x17c>
34811428:	e1a01004 	mov	r1, r4
3481142c:	e1a0200d 	mov	r2, sp
34811430:	eb0000a2 	bl	348116c0 <pmic_reg_read>
		if (ret)
34811434:	e3500000 	cmp	r0, #0
34811438:	0a000001 	beq	34811444 <do_pmic+0x6c>
			puts("PMIC: Registers dump failed\n");
3481143c:	e59f0118 	ldr	r0, [pc, #280]	; 3481155c <do_pmic+0x184>
34811440:	ebffe1d2 	bl	34809b90 <puts>

		if (!(i % 8))
34811444:	e3140007 	tst	r4, #7
34811448:	1a000002 	bne	34811458 <do_pmic+0x80>
			printf("\n0x%02x: ", i);
3481144c:	e59f010c 	ldr	r0, [pc, #268]	; 34811560 <do_pmic+0x188>
34811450:	e1a01004 	mov	r1, r4
34811454:	ebffe1d7 	bl	34809bb8 <printf>

		printf("%08x ", val);
34811458:	e59f0104 	ldr	r0, [pc, #260]	; 34811564 <do_pmic+0x18c>
3481145c:	e59d1000 	ldr	r1, [sp]
34811460:	ebffe1d4 	bl	34809bb8 <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
34811464:	e2844001 	add	r4, r4, #1
34811468:	e5d63006 	ldrb	r3, [r6, #6]
3481146c:	e1540003 	cmp	r4, r3
34811470:	baffffeb 	blt	34811424 <do_pmic+0x4c>
		if (!(i % 8))
			printf("\n0x%02x: ", i);

		printf("%08x ", val);
	}
	puts("\n");
34811474:	e59f00ec 	ldr	r0, [pc, #236]	; 34811568 <do_pmic+0x190>
34811478:	ebffe1c4 	bl	34809b90 <puts>
3481147c:	ea000016 	b	348114dc <do_pmic+0x104>
	if (strcmp(cmd, "dump") == 0) {
		pmic_dump(p);
		return 0;
	}

	if (strcmp(cmd, "read") == 0) {
34811480:	e59f10e4 	ldr	r1, [pc, #228]	; 3481156c <do_pmic+0x194>
34811484:	e1a00006 	mov	r0, r6
34811488:	eb002c47 	bl	3481c5ac <strcmp>
3481148c:	e2501000 	subs	r1, r0, #0
34811490:	1a000013 	bne	348114e4 <do_pmic+0x10c>
		if (argc < 3)
34811494:	e3570002 	cmp	r7, #2
34811498:	0a000019 	beq	34811504 <do_pmic+0x12c>
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
3481149c:	e3a02010 	mov	r2, #16
348114a0:	e5950008 	ldr	r0, [r5, #8]
348114a4:	eb003007 	bl	3481d4c8 <simple_strtoul>
348114a8:	e1a04000 	mov	r4, r0

		ret = pmic_reg_read(p, reg, &val);
348114ac:	e1a01004 	mov	r1, r4
348114b0:	e59f009c 	ldr	r0, [pc, #156]	; 34811554 <do_pmic+0x17c>
348114b4:	e28d2004 	add	r2, sp, #4
348114b8:	eb000080 	bl	348116c0 <pmic_reg_read>

		if (ret)
348114bc:	e3500000 	cmp	r0, #0
348114c0:	0a000001 	beq	348114cc <do_pmic+0xf4>
			puts("PMIC: Register read failed\n");
348114c4:	e59f00a4 	ldr	r0, [pc, #164]	; 34811570 <do_pmic+0x198>
348114c8:	ebffe1b0 	bl	34809b90 <puts>

		printf("\n0x%02x: 0x%08x\n", reg, val);
348114cc:	e59f00a0 	ldr	r0, [pc, #160]	; 34811574 <do_pmic+0x19c>
348114d0:	e1a01004 	mov	r1, r4
348114d4:	e59d2004 	ldr	r2, [sp, #4]
348114d8:	ebffe1b6 	bl	34809bb8 <printf>

		return 0;
348114dc:	e3a00000 	mov	r0, #0
348114e0:	ea000019 	b	3481154c <do_pmic+0x174>
	}

	if (strcmp(cmd, "write") == 0) {
348114e4:	e1a00006 	mov	r0, r6
348114e8:	e59f1088 	ldr	r1, [pc, #136]	; 34811578 <do_pmic+0x1a0>
348114ec:	eb002c2e 	bl	3481c5ac <strcmp>
348114f0:	e2506000 	subs	r6, r0, #0

		return 0;
	}

	/* No subcommand found */
	return 1;
348114f4:	13a00001 	movne	r0, #1
		printf("\n0x%02x: 0x%08x\n", reg, val);

		return 0;
	}

	if (strcmp(cmd, "write") == 0) {
348114f8:	1a000013 	bne	3481154c <do_pmic+0x174>
		if (argc < 4)
348114fc:	e3570003 	cmp	r7, #3
34811500:	ca000002 	bgt	34811510 <do_pmic+0x138>
			return cmd_usage(cmdtp);
34811504:	e1a00004 	mov	r0, r4
34811508:	ebffe053 	bl	3480965c <cmd_usage>
3481150c:	ea00000e 	b	3481154c <do_pmic+0x174>

		reg = simple_strtoul(argv[2], NULL, 16);
34811510:	e1a01006 	mov	r1, r6
34811514:	e3a02010 	mov	r2, #16
34811518:	e5950008 	ldr	r0, [r5, #8]
3481151c:	eb002fe9 	bl	3481d4c8 <simple_strtoul>
		val = simple_strtoul(argv[3], NULL, 16);
34811520:	e1a01006 	mov	r1, r6

	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
34811524:	e1a04000 	mov	r4, r0
		val = simple_strtoul(argv[3], NULL, 16);
34811528:	e3a02010 	mov	r2, #16
3481152c:	e595000c 	ldr	r0, [r5, #12]
34811530:	eb002fe4 	bl	3481d4c8 <simple_strtoul>

		pmic_reg_write(p, reg, val);
34811534:	e1a01004 	mov	r1, r4
	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
		val = simple_strtoul(argv[3], NULL, 16);
34811538:	e1a02000 	mov	r2, r0
3481153c:	e58d0004 	str	r0, [sp, #4]

		pmic_reg_write(p, reg, val);
34811540:	e59f000c 	ldr	r0, [pc, #12]	; 34811554 <do_pmic+0x17c>
34811544:	eb000033 	bl	34811618 <pmic_reg_write>

		return 0;
34811548:	e1a00006 	mov	r0, r6
	}

	/* No subcommand found */
	return 1;
}
3481154c:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
34811550:	34825fc4 	.word	0x34825fc4
34811554:	3482bcb0 	.word	0x3482bcb0
34811558:	348270fe 	.word	0x348270fe
3481155c:	34827108 	.word	0x34827108
34811560:	34827125 	.word	0x34827125
34811564:	3482712f 	.word	0x3482712f
34811568:	348264dd 	.word	0x348264dd
3481156c:	3482447e 	.word	0x3482447e
34811570:	34827135 	.word	0x34827135
34811574:	34827151 	.word	0x34827151
34811578:	34824483 	.word	0x34824483

3481157c <check_reg>:
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
3481157c:	e92d4008 	push	{r3, lr}
	if (reg >= pmic.number_of_regs) {
34811580:	e59f3024 	ldr	r3, [pc, #36]	; 348115ac <check_reg+0x30>
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
34811584:	e1a01000 	mov	r1, r0
	if (reg >= pmic.number_of_regs) {
34811588:	e5d32006 	ldrb	r2, [r3, #6]
3481158c:	e1500002 	cmp	r0, r2
34811590:	3a000003 	bcc	348115a4 <check_reg+0x28>
		printf("<reg num> = %d is invalid. Should be less than %d\n",
34811594:	e59f0014 	ldr	r0, [pc, #20]	; 348115b0 <check_reg+0x34>
34811598:	ebffe186 	bl	34809bb8 <printf>
		       reg, pmic.number_of_regs);
		return -1;
3481159c:	e3e00000 	mvn	r0, #0
348115a0:	e8bd8008 	pop	{r3, pc}
	}
	return 0;
348115a4:	e3a00000 	mov	r0, #0
}
348115a8:	e8bd8008 	pop	{r3, pc}
348115ac:	3482bcb0 	.word	0x3482bcb0
348115b0:	34827162 	.word	0x34827162

348115b4 <pmic_set_output>:

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
348115b4:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
348115b8:	e1a04002 	mov	r4, r2
	u32 val;

	if (pmic_reg_read(p, reg, &val))
348115bc:	e28d2004 	add	r2, sp, #4
	}
	return 0;
}

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
348115c0:	e1a06000 	mov	r6, r0
348115c4:	e1a05001 	mov	r5, r1
348115c8:	e1a07003 	mov	r7, r3
	u32 val;

	if (pmic_reg_read(p, reg, &val))
348115cc:	eb00003b 	bl	348116c0 <pmic_reg_read>
348115d0:	e3500000 	cmp	r0, #0
		return -1;
348115d4:	13e00000 	mvnne	r0, #0

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
	u32 val;

	if (pmic_reg_read(p, reg, &val))
348115d8:	1a00000a 	bne	34811608 <pmic_set_output+0x54>
348115dc:	e59d3004 	ldr	r3, [sp, #4]
		return -1;

	if (on)
348115e0:	e3570000 	cmp	r7, #0
		val |= out;
348115e4:	11834004 	orrne	r4, r3, r4
	else
		val &= ~out;
348115e8:	01c34004 	biceq	r4, r3, r4
348115ec:	e58d4004 	str	r4, [sp, #4]

	if (pmic_reg_write(p, reg, val))
348115f0:	e1a00006 	mov	r0, r6
348115f4:	e1a01005 	mov	r1, r5
348115f8:	e59d2004 	ldr	r2, [sp, #4]
348115fc:	eb000005 	bl	34811618 <pmic_reg_write>
34811600:	e3500000 	cmp	r0, #0
		return -1;
34811604:	13e00000 	mvnne	r0, #0

	return 0;
}
34811608:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481160c <get_pmic>:
}

struct pmic *get_pmic(void)
{
	return &pmic;
}
3481160c:	e59f0000 	ldr	r0, [pc, #0]	; 34811614 <get_pmic+0x8>
34811610:	e12fff1e 	bx	lr
34811614:	3482bcb0 	.word	0x3482bcb0

34811618 <pmic_reg_write>:
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34811618:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
3481161c:	e3a03000 	mov	r3, #0
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34811620:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
34811624:	e1a00001 	mov	r0, r1
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34811628:	e1a05001 	mov	r5, r1
3481162c:	e1a06002 	mov	r6, r2
	unsigned char buf[4] = { 0 };
34811630:	e58d300c 	str	r3, [sp, #12]

	if (check_reg(reg))
34811634:	ebffffd0 	bl	3481157c <check_reg>
34811638:	e3500000 	cmp	r0, #0
3481163c:	1a00001a 	bne	348116ac <pmic_reg_write+0x94>
		return -1;

	switch (pmic_i2c_tx_num) {
34811640:	e5d43010 	ldrb	r3, [r4, #16]
34811644:	e3530001 	cmp	r3, #1
34811648:	0a000007 	beq	3481166c <pmic_reg_write+0x54>
3481164c:	e3530003 	cmp	r3, #3
34811650:	1a000007 	bne	34811674 <pmic_reg_write+0x5c>
	case 3:
		buf[0] = (val >> 16) & 0xff;
34811654:	e1a02826 	lsr	r2, r6, #16
34811658:	e5cd200c 	strb	r2, [sp, #12]
		buf[1] = (val >> 8) & 0xff;
3481165c:	e1a02426 	lsr	r2, r6, #8
34811660:	e5cd200d 	strb	r2, [sp, #13]
		buf[2] = val & 0xff;
34811664:	e5cd600e 	strb	r6, [sp, #14]
		break;
34811668:	ea000006 	b	34811688 <pmic_reg_write+0x70>
	case 1:
		buf[0] = val & 0xff;
3481166c:	e5cd600c 	strb	r6, [sp, #12]
		break;
34811670:	ea000004 	b	34811688 <pmic_reg_write+0x70>
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34811674:	e59f103c 	ldr	r1, [pc, #60]	; 348116b8 <pmic_reg_write+0xa0>
34811678:	e1a02003 	mov	r2, r3
3481167c:	e59f0038 	ldr	r0, [pc, #56]	; 348116bc <pmic_reg_write+0xa4>
34811680:	ebffe14c 	bl	34809bb8 <printf>
34811684:	ea000008 	b	348116ac <pmic_reg_write+0x94>
		return -1;
	}

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
34811688:	e58d3000 	str	r3, [sp]
3481168c:	e5d40008 	ldrb	r0, [r4, #8]
34811690:	e1a01005 	mov	r1, r5
34811694:	e3a02001 	mov	r2, #1
34811698:	e28d300c 	add	r3, sp, #12
3481169c:	ebfffdc2 	bl	34810dac <i2c_write>
348116a0:	e3500000 	cmp	r0, #0
		return -1;
348116a4:	13e00000 	mvnne	r0, #0
348116a8:	ea000000 	b	348116b0 <pmic_reg_write+0x98>
int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
		return -1;
348116ac:	e3e00000 	mvn	r0, #0

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;

	return 0;
}
348116b0:	e28dd010 	add	sp, sp, #16
348116b4:	e8bd8070 	pop	{r4, r5, r6, pc}
348116b8:	34821718 	.word	0x34821718
348116bc:	34827204 	.word	0x34827204

348116c0 <pmic_reg_read>:

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
348116c0:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
348116c4:	e3a03000 	mov	r3, #0

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
348116c8:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };
	u32 ret_val = 0;

	if (check_reg(reg))
348116cc:	e1a00001 	mov	r0, r1

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
348116d0:	e1a06001 	mov	r6, r1
348116d4:	e1a05002 	mov	r5, r2
	unsigned char buf[4] = { 0 };
348116d8:	e58d300c 	str	r3, [sp, #12]
	u32 ret_val = 0;
348116dc:	e58d3008 	str	r3, [sp, #8]

	if (check_reg(reg))
348116e0:	ebffffa5 	bl	3481157c <check_reg>
348116e4:	e3500000 	cmp	r0, #0
348116e8:	1a00001f 	bne	3481176c <pmic_reg_read+0xac>
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
348116ec:	e5d43010 	ldrb	r3, [r4, #16]
348116f0:	e5d40008 	ldrb	r0, [r4, #8]
348116f4:	e58d3000 	str	r3, [sp]
348116f8:	e1a01006 	mov	r1, r6
348116fc:	e3a02001 	mov	r2, #1
34811700:	e28d300c 	add	r3, sp, #12
34811704:	ebfffd4b 	bl	34810c38 <i2c_read>
34811708:	e3500000 	cmp	r0, #0
3481170c:	1a000016 	bne	3481176c <pmic_reg_read+0xac>
		return -1;

	switch (pmic_i2c_tx_num) {
34811710:	e5d42010 	ldrb	r2, [r4, #16]
34811714:	e3520001 	cmp	r2, #1
34811718:	0a000008 	beq	34811740 <pmic_reg_read+0x80>
3481171c:	e3520003 	cmp	r2, #3
34811720:	1a00000e 	bne	34811760 <pmic_reg_read+0xa0>
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
34811724:	e5dd300d 	ldrb	r3, [sp, #13]
34811728:	e5dd200c 	ldrb	r2, [sp, #12]
3481172c:	e1a03403 	lsl	r3, r3, #8
34811730:	e1833802 	orr	r3, r3, r2, lsl #16
34811734:	e5dd200e 	ldrb	r2, [sp, #14]
34811738:	e1833002 	orr	r3, r3, r2
3481173c:	ea000000 	b	34811744 <pmic_reg_read+0x84>
		break;
	case 1:
		ret_val = buf[0];
34811740:	e5dd300c 	ldrb	r3, [sp, #12]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
34811744:	e1a00005 	mov	r0, r5
34811748:	e28d1008 	add	r1, sp, #8
3481174c:	e3a02004 	mov	r2, #4
	switch (pmic_i2c_tx_num) {
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
		break;
	case 1:
		ret_val = buf[0];
34811750:	e58d3008 	str	r3, [sp, #8]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
34811754:	eb002c8c 	bl	3481c98c <memcpy>

	return 0;
34811758:	e3a00000 	mov	r0, #0
3481175c:	ea000003 	b	34811770 <pmic_reg_read+0xb0>
		break;
	case 1:
		ret_val = buf[0];
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34811760:	e59f0010 	ldr	r0, [pc, #16]	; 34811778 <pmic_reg_read+0xb8>
34811764:	e59f1010 	ldr	r1, [pc, #16]	; 3481177c <pmic_reg_read+0xbc>
34811768:	ebffe112 	bl	34809bb8 <printf>

	if (check_reg(reg))
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;
3481176c:	e3e00000 	mvn	r0, #0
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));

	return 0;
}
34811770:	e28dd010 	add	sp, sp, #16
34811774:	e8bd8070 	pop	{r4, r5, r6, pc}
34811778:	34827204 	.word	0x34827204
3481177c:	34821728 	.word	0x34821728

34811780 <pmic_probe>:

int pmic_probe(struct pmic *p)
{
34811780:	e92d4010 	push	{r4, lr}
34811784:	e1a04000 	mov	r4, r0

static inline void I2C_SET_BUS(unsigned int bus) __attribute__((always_inline));
static inline void I2C_SET_BUS(unsigned int bus)
{
	if (I2C_MULTI_BUS)
		i2c_set_bus_num(bus);
34811788:	e5d00004 	ldrb	r0, [r0, #4]
3481178c:	ebfffcf7 	bl	34810b70 <i2c_set_bus_num>
	I2C_SET_BUS(p->bus);
	debug("PMIC:%s probed!\n", p->name);
	if (i2c_probe(pmic_i2c_addr)) {
34811790:	e5d40008 	ldrb	r0, [r4, #8]
34811794:	ebfffd1c 	bl	34810c0c <i2c_probe>
34811798:	e3500000 	cmp	r0, #0
3481179c:	08bd8010 	popeq	{r4, pc}
		printf("Can't find PMIC:%s\n", p->name);
348117a0:	e5941000 	ldr	r1, [r4]
348117a4:	e59f0008 	ldr	r0, [pc, #8]	; 348117b4 <pmic_probe+0x34>
348117a8:	ebffe102 	bl	34809bb8 <printf>
		return -1;
348117ac:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
348117b0:	e8bd8010 	pop	{r4, pc}
348117b4:	3482721b 	.word	0x3482721b

348117b8 <pmic_init>:
#include <common.h>
#include <pmic.h>
#include <max8998_pmic.h>

int pmic_init(void)
{
348117b8:	e92d4010 	push	{r4, lr}
	struct pmic *p = get_pmic();
348117bc:	ebffff92 	bl	3481160c <get_pmic>
348117c0:	e1a04000 	mov	r4, r0
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");
348117c4:	e59f0030 	ldr	r0, [pc, #48]	; 348117fc <pmic_init+0x44>
348117c8:	ebffe0f0 	bl	34809b90 <puts>

	p->name = name;
348117cc:	e59f302c 	ldr	r3, [pc, #44]	; 34811800 <pmic_init+0x48>
	p->interface = PMIC_I2C;
348117d0:	e3a00000 	mov	r0, #0
	struct pmic *p = get_pmic();
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
348117d4:	e5843000 	str	r3, [r4]
	p->interface = PMIC_I2C;
	p->number_of_regs = PMIC_NUM_OF_REGS;
348117d8:	e3a0302d 	mov	r3, #45	; 0x2d
348117dc:	e5c43006 	strb	r3, [r4, #6]
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
348117e0:	e2833039 	add	r3, r3, #57	; 0x39
348117e4:	e5c43008 	strb	r3, [r4, #8]
	p->hw.i2c.tx_num = 1;
348117e8:	e3a03001 	mov	r3, #1
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
	p->interface = PMIC_I2C;
348117ec:	e5c40005 	strb	r0, [r4, #5]
	p->number_of_regs = PMIC_NUM_OF_REGS;
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
	p->hw.i2c.tx_num = 1;
348117f0:	e5c43010 	strb	r3, [r4, #16]
	p->bus = I2C_PMIC;
348117f4:	e5c40004 	strb	r0, [r4, #4]

	return 0;
}
348117f8:	e8bd8010 	pop	{r4, pc}
348117fc:	3482722f 	.word	0x3482722f
34811800:	34821738 	.word	0x34821738

34811804 <__fswab32>:
34811804:	e6bf0f30 	rev	r0, r0
34811808:	e12fff1e 	bx	lr

3481180c <__board_mmc_getcd>:
static struct list_head mmc_devices;
static int cur_dev_num = -1;

int __board_mmc_getcd(struct mmc *mmc) {
	return -1;
}
3481180c:	e3e00000 	mvn	r0, #0
34811810:	e12fff1e 	bx	lr

34811814 <mmc_send_cmd>:
static inline void mmc_bounce_buffer_stop(struct mmc_data *backup,
					struct mmc_data *orig) { }
#endif

int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
34811814:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34811818:	e1a04000 	mov	r4, r0
3481181c:	e1a06001 	mov	r6, r1
34811820:	e1a05002 	mov	r5, r2
	struct mmc_data backup;
	int ret;

	memset(&backup, 0, sizeof(backup));
34811824:	e1a0000d 	mov	r0, sp
34811828:	e3a01000 	mov	r1, #0
3481182c:	e3a02010 	mov	r2, #16
34811830:	eb002c31 	bl	3481c8fc <memset>
		default:
			printf("\t\tERROR MMC rsp not supported\n");
			break;
	}
#else
	ret = mmc->send_cmd(mmc, cmd, data);
34811834:	e5943110 	ldr	r3, [r4, #272]	; 0x110
34811838:	e1a00004 	mov	r0, r4
3481183c:	e1a01006 	mov	r1, r6
34811840:	e1a02005 	mov	r2, r5
34811844:	e12fff33 	blx	r3
#endif
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}
34811848:	e28dd010 	add	sp, sp, #16
3481184c:	e8bd8070 	pop	{r4, r5, r6, pc}

34811850 <mmc_send_status>:

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811850:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
34811854:	e3a0300d 	mov	r3, #13
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811858:	e24dd024 	sub	sp, sp, #36	; 0x24
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
3481185c:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34811860:	e3a03015 	mov	r3, #21
34811864:	e58d3008 	str	r3, [sp, #8]
	if (!mmc_host_is_spi(mmc))
34811868:	e5903050 	ldr	r3, [r0, #80]	; 0x50
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
3481186c:	e1a06000 	mov	r6, r0
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
34811870:	e3130b01 	tst	r3, #1024	; 0x400
		cmd.cmdarg = mmc->rca << 16;
34811874:	01d038b0 	ldrheq	r3, [r0, #128]	; 0x80
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811878:	e1a04001 	mov	r4, r1
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;
3481187c:	01a03803 	lsleq	r3, r3, #16
34811880:	058d300c 	streq	r3, [sp, #12]
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34811884:	e3a05005 	mov	r5, #5
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811888:	e28d7004 	add	r7, sp, #4
3481188c:	e1a00006 	mov	r0, r6
34811890:	e1a01007 	mov	r1, r7
34811894:	e3a02000 	mov	r2, #0
34811898:	ebffffdd 	bl	34811814 <mmc_send_cmd>
		if (!err) {
3481189c:	e3500000 	cmp	r0, #0
348118a0:	1a00000d 	bne	348118dc <mmc_send_status+0x8c>
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
348118a4:	e59d1010 	ldr	r1, [sp, #16]
348118a8:	e3110c01 	tst	r1, #256	; 0x100
348118ac:	0a000002 	beq	348118bc <mmc_send_status+0x6c>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
348118b0:	e2013c1e 	and	r3, r1, #7680	; 0x1e00
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
		if (!err) {
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
348118b4:	e3530c0e 	cmp	r3, #3584	; 0xe00
348118b8:	1a00000d 	bne	348118f4 <mmc_send_status+0xa4>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
			     MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
348118bc:	e59f3050 	ldr	r3, [pc, #80]	; 34811914 <mmc_send_status+0xc4>
348118c0:	e0013003 	and	r3, r1, r3
348118c4:	e3530000 	cmp	r3, #0
348118c8:	0a000005 	beq	348118e4 <mmc_send_status+0x94>
				printf("Status Error: 0x%08X\n",
348118cc:	e59f0044 	ldr	r0, [pc, #68]	; 34811918 <mmc_send_status+0xc8>
348118d0:	ebffe0b8 	bl	34809bb8 <printf>
					cmd.response[0]);
				return COMM_ERR;
348118d4:	e3e00011 	mvn	r0, #17
348118d8:	ea00000b 	b	3481190c <mmc_send_status+0xbc>
			}
		} else if (--retries < 0)
348118dc:	e2555001 	subs	r5, r5, #1
348118e0:	4a000009 	bmi	3481190c <mmc_send_status+0xbc>
			return err;

		udelay(1000);
348118e4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348118e8:	eb002cb2 	bl	3481cbb8 <udelay>

	} while (timeout--);
348118ec:	e2544001 	subs	r4, r4, #1
348118f0:	2affffe5 	bcs	3481188c <mmc_send_status+0x3c>

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
348118f4:	e3540000 	cmp	r4, #0
		printf("Timeout waiting card ready\n");
		return TIMEOUT;
	}

	return 0;
348118f8:	c3a00000 	movgt	r0, #0

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
348118fc:	ca000002 	bgt	3481190c <mmc_send_status+0xbc>
		printf("Timeout waiting card ready\n");
34811900:	e59f0014 	ldr	r0, [pc, #20]	; 3481191c <mmc_send_status+0xcc>
34811904:	ebffe0ab 	bl	34809bb8 <printf>
		return TIMEOUT;
34811908:	e3e00012 	mvn	r0, #18
	}

	return 0;
}
3481190c:	e28dd024 	add	sp, sp, #36	; 0x24
34811910:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34811914:	fdf94080 	.word	0xfdf94080
34811918:	34827240 	.word	0x34827240
3481191c:	34827256 	.word	0x34827256

34811920 <mmc_set_blocklen>:

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34811920:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34811924:	e3a03010 	mov	r3, #16

	return 0;
}

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34811928:	e24dd024 	sub	sp, sp, #36	; 0x24
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
3481192c:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = len;
34811930:	e58d100c 	str	r1, [sp, #12]
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
34811934:	e3a03015 	mov	r3, #21
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34811938:	e28d1004 	add	r1, sp, #4
3481193c:	e3a02000 	mov	r2, #0
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
34811940:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34811944:	ebffffb2 	bl	34811814 <mmc_send_cmd>
}
34811948:	e28dd024 	add	sp, sp, #36	; 0x24
3481194c:	e8bd8000 	pop	{pc}

34811950 <find_mmc_device>:
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811950:	e59f2038 	ldr	r2, [pc, #56]	; 34811990 <find_mmc_device+0x40>

	return mmc_send_cmd(mmc, &cmd, NULL);
}

struct mmc *find_mmc_device(int dev_num)
{
34811954:	e92d4008 	push	{r3, lr}
34811958:	e1a01000 	mov	r1, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
3481195c:	e5923000 	ldr	r3, [r2]
34811960:	ea000004 	b	34811978 <find_mmc_device+0x28>
		m = list_entry(entry, struct mmc, link);

		if (m->block_dev.dev == dev_num)
34811964:	e593c0a4 	ldr	ip, [r3, #164]	; 0xa4
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
		m = list_entry(entry, struct mmc, link);
34811968:	e1a00003 	mov	r0, r3

		if (m->block_dev.dev == dev_num)
3481196c:	e15c0001 	cmp	ip, r1
34811970:	08bd8008 	popeq	{r3, pc}
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811974:	e5933000 	ldr	r3, [r3]
34811978:	e1530002 	cmp	r3, r2
3481197c:	1afffff8 	bne	34811964 <find_mmc_device+0x14>

		if (m->block_dev.dev == dev_num)
			return m;
	}

	printf("MMC Device %d not found\n", dev_num);
34811980:	e59f000c 	ldr	r0, [pc, #12]	; 34811994 <find_mmc_device+0x44>
34811984:	ebffe08b 	bl	34809bb8 <printf>

	return NULL;
34811988:	e3a00000 	mov	r0, #0
}
3481198c:	e8bd8008 	pop	{r3, pc}
34811990:	3482bcd0 	.word	0x3482bcd0
34811994:	34827272 	.word	0x34827272

34811998 <mmc_berase>:
	return err;
}

static unsigned long
mmc_berase(int dev_num, unsigned long start, lbaint_t blkcnt)
{
34811998:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481199c:	e24dd028 	sub	sp, sp, #40	; 0x28
348119a0:	e1a05001 	mov	r5, r1
348119a4:	e1a06002 	mov	r6, r2
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
348119a8:	ebffffe8 	bl	34811950 <find_mmc_device>
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
348119ac:	e2504000 	subs	r4, r0, #0
		return -1;
348119b0:	03e07000 	mvneq	r7, #0
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
348119b4:	0a000056 	beq	34811b14 <mmc_berase+0x17c>
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
348119b8:	e5947090 	ldr	r7, [r4, #144]	; 0x90
348119bc:	e1a00005 	mov	r0, r5
348119c0:	e1a01007 	mov	r1, r7
348119c4:	eb0039b3 	bl	34820098 <__aeabi_uidivmod>
348119c8:	e3510000 	cmp	r1, #0
348119cc:	1a000004 	bne	348119e4 <mmc_berase+0x4c>
348119d0:	e1a00006 	mov	r0, r6
348119d4:	e1a01007 	mov	r1, r7
348119d8:	eb0039ae 	bl	34820098 <__aeabi_uidivmod>
348119dc:	e3510000 	cmp	r1, #0
348119e0:	0a000045 	beq	34811afc <mmc_berase+0x164>
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
348119e4:	e0853007 	add	r3, r5, r7
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
348119e8:	e2672000 	rsb	r2, r7, #0
		       ((start + blkcnt + mmc->erase_grp_size)
348119ec:	e0833006 	add	r3, r3, r6
		       & ~(mmc->erase_grp_size - 1)) - 1);
348119f0:	e0033002 	and	r3, r3, r2

	if (!mmc)
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
348119f4:	e1a01007 	mov	r1, r7
348119f8:	e0052002 	and	r2, r5, r2
348119fc:	e2433001 	sub	r3, r3, #1
34811a00:	e59f0118 	ldr	r0, [pc, #280]	; 34811b20 <mmc_berase+0x188>
34811a04:	ebffe06b 	bl	34809bb8 <printf>
34811a08:	ea00003b 	b	34811afc <mmc_berase+0x164>
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34811a0c:	e5943090 	ldr	r3, [r4, #144]	; 0x90
			mmc->erase_grp_size : (blkcnt - blk);
34811a10:	e067a006 	rsb	sl, r7, r6
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34811a14:	e15a0003 	cmp	sl, r3
34811a18:	21a0a003 	movcs	sl, r3
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34811a1c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
34811a20:	e0872005 	add	r2, r7, r5
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34811a24:	e3530000 	cmp	r3, #0
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34811a28:	0594308c 	ldreq	r3, [r4, #140]	; 0x8c
34811a2c:	e242b001 	sub	fp, r2, #1
34811a30:	008bb00a 	addeq	fp, fp, sl
		start *= mmc->write_bl_len;
34811a34:	00020293 	muleq	r2, r3, r2
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34811a38:	000b0b93 	muleq	fp, r3, fp
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
34811a3c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
34811a40:	108bb00a 	addne	fp, fp, sl
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
34811a44:	e2033802 	and	r3, r3, #131072	; 0x20000
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34811a48:	e3530000 	cmp	r3, #0
34811a4c:	03a01023 	moveq	r1, #35	; 0x23
34811a50:	13a01020 	movne	r1, #32
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
34811a54:	e58d2014 	str	r2, [sp, #20]
	cmd.resp_type = MMC_RSP_R1;
34811a58:	e3a02015 	mov	r2, #21
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34811a5c:	03a03024 	moveq	r3, #36	; 0x24
34811a60:	13a03021 	movne	r3, #33	; 0x21
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
34811a64:	e1cd10bc 	strh	r1, [sp, #12]
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;
34811a68:	e58d2010 	str	r2, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811a6c:	e1a00004 	mov	r0, r4
34811a70:	e3a02000 	mov	r2, #0
34811a74:	e1a01009 	mov	r1, r9
34811a78:	e58d3004 	str	r3, [sp, #4]
34811a7c:	ebffff64 	bl	34811814 <mmc_send_cmd>
	if (err)
34811a80:	e2502000 	subs	r2, r0, #0
34811a84:	e59d3004 	ldr	r3, [sp, #4]
34811a88:	1a000011 	bne	34811ad4 <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = end_cmd;
	cmd.cmdarg = end;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811a8c:	e1a00004 	mov	r0, r4
34811a90:	e1a01009 	mov	r1, r9

	err = mmc_send_cmd(mmc, &cmd, NULL);
	if (err)
		goto err_out;

	cmd.cmdidx = end_cmd;
34811a94:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = end;
34811a98:	e58db014 	str	fp, [sp, #20]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811a9c:	ebffff5c 	bl	34811814 <mmc_send_cmd>
	if (err)
34811aa0:	e2502000 	subs	r2, r0, #0
34811aa4:	1a00000a 	bne	34811ad4 <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
34811aa8:	e3a03026 	mov	r3, #38	; 0x26
34811aac:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = SECURE_ERASE;
34811ab0:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
34811ab4:	e58d3014 	str	r3, [sp, #20]
	cmd.resp_type = MMC_RSP_R1b;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811ab8:	e1a00004 	mov	r0, r4
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
34811abc:	e2833176 	add	r3, r3, #-2147483619	; 0x8000001d

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811ac0:	e1a01009 	mov	r1, r9
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
34811ac4:	e58d3010 	str	r3, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811ac8:	ebffff51 	bl	34811814 <mmc_send_cmd>
	if (err)
34811acc:	e250b000 	subs	fp, r0, #0
34811ad0:	0a000002 	beq	34811ae0 <mmc_berase+0x148>
		goto err_out;

	return 0;

err_out:
	puts("mmc erase failed\n");
34811ad4:	e59f0048 	ldr	r0, [pc, #72]	; 34811b24 <mmc_berase+0x18c>
34811ad8:	ebffe02c 	bl	34809b90 <puts>
34811adc:	ea00000c 	b	34811b14 <mmc_berase+0x17c>
			break;

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
34811ae0:	e1a00004 	mov	r0, r4
34811ae4:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811ae8:	ebffff58 	bl	34811850 <mmc_send_status>
34811aec:	e3500000 	cmp	r0, #0
34811af0:	1a000006 	bne	34811b10 <mmc_berase+0x178>
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
		if (err)
			break;

		blk += blk_r;
34811af4:	e087700a 	add	r7, r7, sl
34811af8:	ea000001 	b	34811b04 <mmc_berase+0x16c>

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
34811afc:	e3a07000 	mov	r7, #0

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811b00:	e28d900c 	add	r9, sp, #12
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
34811b04:	e1570006 	cmp	r7, r6
34811b08:	3affffbf 	bcc	34811a0c <mmc_berase+0x74>
34811b0c:	ea000000 	b	34811b14 <mmc_berase+0x17c>

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
			return 0;
34811b10:	e1a0700b 	mov	r7, fp
	}

	return blk;
}
34811b14:	e1a00007 	mov	r0, r7
34811b18:	e28dd028 	add	sp, sp, #40	; 0x28
34811b1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811b20:	3482728b 	.word	0x3482728b
34811b24:	348272e8 	.word	0x348272e8

34811b28 <mmc_bwrite>:
	return blkcnt;
}

static ulong
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
34811b28:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34811b2c:	e24dd030 	sub	sp, sp, #48	; 0x30
34811b30:	e1a04002 	mov	r4, r2
34811b34:	e1a05001 	mov	r5, r1
34811b38:	e1a09003 	mov	r9, r3
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
34811b3c:	ebffff83 	bl	34811950 <find_mmc_device>
	if (!mmc)
34811b40:	e2506000 	subs	r6, r0, #0
		return 0;
34811b44:	01a04006 	moveq	r4, r6
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
34811b48:	0a000052 	beq	34811c98 <mmc_bwrite+0x170>
		return 0;

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
34811b4c:	e596108c 	ldr	r1, [r6, #140]	; 0x8c
34811b50:	ebffff72 	bl	34811920 <mmc_set_blocklen>
34811b54:	e3500000 	cmp	r0, #0
34811b58:	1a00004b 	bne	34811c8c <mmc_bwrite+0x164>
34811b5c:	e1a0b004 	mov	fp, r4
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34811b60:	e1a0a004 	mov	sl, r4

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811b64:	e5964120 	ldr	r4, [r6, #288]	; 0x120
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811b68:	e59620b0 	ldr	r2, [r6, #176]	; 0xb0

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811b6c:	e15b0004 	cmp	fp, r4
34811b70:	31a0400b 	movcc	r4, fp
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811b74:	e0847005 	add	r7, r4, r5
34811b78:	e1570002 	cmp	r7, r2
34811b7c:	9a000003 	bls	34811b90 <mmc_bwrite+0x68>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
34811b80:	e1a01007 	mov	r1, r7
34811b84:	e59f0118 	ldr	r0, [pc, #280]	; 34811ca4 <mmc_bwrite+0x17c>
34811b88:	ebffe00a 	bl	34809bb8 <printf>
34811b8c:	ea000036 	b	34811c6c <mmc_bwrite+0x144>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (blkcnt > 1)
34811b90:	e3540001 	cmp	r4, #1
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
34811b94:	83a03019 	movhi	r3, #25
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
34811b98:	93a03018 	movls	r3, #24
34811b9c:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
34811ba0:	e5963040 	ldr	r3, [r6, #64]	; 0x40
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34811ba4:	e1a00006 	mov	r0, r6
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
34811ba8:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34811bac:	0596308c 	ldreq	r3, [r6, #140]	; 0x8c
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34811bb0:	e28d1004 	add	r1, sp, #4
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34811bb4:	00050593 	muleq	r5, r3, r5

	cmd.resp_type = MMC_RSP_R1;
34811bb8:	e3a03015 	mov	r3, #21
34811bbc:	e58d3008 	str	r3, [sp, #8]

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
34811bc0:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34811bc4:	e28d2020 	add	r2, sp, #32

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
34811bc8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_WRITE;
34811bcc:	e3a03002 	mov	r3, #2
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34811bd0:	e58d500c 	str	r5, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
34811bd4:	e58d9020 	str	r9, [sp, #32]
	data.blocks = blkcnt;
34811bd8:	e58d4028 	str	r4, [sp, #40]	; 0x28
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;
34811bdc:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34811be0:	ebffff0b 	bl	34811814 <mmc_send_cmd>
34811be4:	e2505000 	subs	r5, r0, #0
34811be8:	0a000002 	beq	34811bf8 <mmc_bwrite+0xd0>
		printf("mmc write failed\n");
34811bec:	e59f00b4 	ldr	r0, [pc, #180]	; 34811ca8 <mmc_bwrite+0x180>
34811bf0:	ebffdff0 	bl	34809bb8 <printf>
34811bf4:	ea00001c 	b	34811c6c <mmc_bwrite+0x144>
	}

	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
34811bf8:	e5963050 	ldr	r3, [r6, #80]	; 0x50
34811bfc:	e3130b01 	tst	r3, #1024	; 0x400
34811c00:	13a03000 	movne	r3, #0
34811c04:	03a03001 	moveq	r3, #1
34811c08:	e3540001 	cmp	r4, #1
34811c0c:	93a03000 	movls	r3, #0
34811c10:	82033001 	andhi	r3, r3, #1
34811c14:	e3530000 	cmp	r3, #0
34811c18:	0a00000e 	beq	34811c58 <mmc_bwrite+0x130>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34811c1c:	e3a0300c 	mov	r3, #12
34811c20:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811c24:	e1a00006 	mov	r0, r6
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34811c28:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811c2c:	e28d1004 	add	r1, sp, #4
34811c30:	e1a02005 	mov	r2, r5
	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
34811c34:	e58d500c 	str	r5, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
34811c38:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811c3c:	ebfffef4 	bl	34811814 <mmc_send_cmd>
34811c40:	e3500000 	cmp	r0, #0
34811c44:	0a000003 	beq	34811c58 <mmc_bwrite+0x130>
			printf("mmc fail to send stop cmd\n");
34811c48:	e59f005c 	ldr	r0, [pc, #92]	; 34811cac <mmc_bwrite+0x184>
34811c4c:	ebffdfd9 	bl	34809bb8 <printf>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
34811c50:	e1a04005 	mov	r4, r5
34811c54:	ea00000f 	b	34811c98 <mmc_bwrite+0x170>
			return 0;
		}
	}

	/* Waiting for the ready status */
	if (mmc_send_status(mmc, timeout))
34811c58:	e1a00006 	mov	r0, r6
34811c5c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811c60:	ebfffefa 	bl	34811850 <mmc_send_status>
34811c64:	e3500000 	cmp	r0, #0
34811c68:	0a000001 	beq	34811c74 <mmc_bwrite+0x14c>
	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
34811c6c:	e3540000 	cmp	r4, #0
34811c70:	1a000005 	bne	34811c8c <mmc_bwrite+0x164>
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);
34811c74:	e05bb004 	subs	fp, fp, r4
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
34811c78:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	} while (blocks_todo > 0);
34811c7c:	0a000004 	beq	34811c94 <mmc_bwrite+0x16c>
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
34811c80:	e0299493 	mla	r9, r3, r4, r9
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811c84:	e1a05007 	mov	r5, r7
34811c88:	eaffffb5 	b	34811b64 <mmc_bwrite+0x3c>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
34811c8c:	e3a04000 	mov	r4, #0
34811c90:	ea000000 	b	34811c98 <mmc_bwrite+0x170>
34811c94:	e1a0400a 	mov	r4, sl
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
34811c98:	e1a00004 	mov	r0, r4
34811c9c:	e28dd030 	add	sp, sp, #48	; 0x30
34811ca0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811ca4:	348272fa 	.word	0x348272fa
34811ca8:	34827326 	.word	0x34827326
34811cac:	34827338 	.word	0x34827338

34811cb0 <mmc_read_blocks>:

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34811cb0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
34811cb4:	e3530001 	cmp	r3, #1

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34811cb8:	e24dd034 	sub	sp, sp, #52	; 0x34
34811cbc:	e1a05003 	mov	r5, r3
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
34811cc0:	83a03012 	movhi	r3, #18
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
34811cc4:	93a03011 	movls	r3, #17
34811cc8:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
34811ccc:	e5903040 	ldr	r3, [r0, #64]	; 0x40
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34811cd0:	e28d7004 	add	r7, sp, #4
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
34811cd4:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
34811cd8:	05903088 	ldreq	r3, [r0, #136]	; 0x88

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
34811cdc:	e58d1020 	str	r1, [sp, #32]
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
34811ce0:	00020293 	muleq	r2, r3, r2

	cmd.resp_type = MMC_RSP_R1;
34811ce4:	e3a03015 	mov	r3, #21
34811ce8:	e58d3008 	str	r3, [sp, #8]

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
34811cec:	e5903088 	ldr	r3, [r0, #136]	; 0x88
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
34811cf0:	e58d200c 	str	r2, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
34811cf4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34811cf8:	e1a01007 	mov	r1, r7
	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
34811cfc:	e3a03001 	mov	r3, #1

	if (mmc_send_cmd(mmc, &cmd, &data))
34811d00:	e28d2020 	add	r2, sp, #32

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34811d04:	e1a04000 	mov	r4, r0
		cmd.cmdarg = start * mmc->read_bl_len;

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
34811d08:	e58d5028 	str	r5, [sp, #40]	; 0x28
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
34811d0c:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data))
34811d10:	ebfffebf 	bl	34811814 <mmc_send_cmd>
34811d14:	e2506000 	subs	r6, r0, #0
		return 0;
34811d18:	13a00000 	movne	r0, #0
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34811d1c:	1a000011 	bne	34811d68 <mmc_read_blocks+0xb8>
		return 0;

	if (blkcnt > 1) {
34811d20:	e3550001 	cmp	r5, #1
34811d24:	9a00000e 	bls	34811d64 <mmc_read_blocks+0xb4>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34811d28:	e3a0300c 	mov	r3, #12
34811d2c:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811d30:	e1a00004 	mov	r0, r4
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34811d34:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811d38:	e1a01007 	mov	r1, r7
34811d3c:	e1a02006 	mov	r2, r6
	if (mmc_send_cmd(mmc, &cmd, &data))
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
34811d40:	e58d600c 	str	r6, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
34811d44:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811d48:	ebfffeb1 	bl	34811814 <mmc_send_cmd>
34811d4c:	e3500000 	cmp	r0, #0
34811d50:	0a000003 	beq	34811d64 <mmc_read_blocks+0xb4>
			printf("mmc fail to send stop cmd\n");
34811d54:	e59f0014 	ldr	r0, [pc, #20]	; 34811d70 <mmc_read_blocks+0xc0>
34811d58:	ebffdf96 	bl	34809bb8 <printf>
			return 0;
34811d5c:	e1a00006 	mov	r0, r6
34811d60:	ea000000 	b	34811d68 <mmc_read_blocks+0xb8>
		}
	}

	return blkcnt;
34811d64:	e1a00005 	mov	r0, r5
}
34811d68:	e28dd034 	add	sp, sp, #52	; 0x34
34811d6c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34811d70:	34827338 	.word	0x34827338

34811d74 <mmc_bread>:

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34811d74:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34811d78:	e2524000 	subs	r4, r2, #0

	return blkcnt;
}

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34811d7c:	e1a06001 	mov	r6, r1
34811d80:	e1a07003 	mov	r7, r3
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34811d84:	0a000020 	beq	34811e0c <mmc_bread+0x98>
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
34811d88:	ebfffef0 	bl	34811950 <find_mmc_device>
	if (!mmc)
34811d8c:	e2505000 	subs	r5, r0, #0
		return 0;
34811d90:	01a04005 	moveq	r4, r5

	if (blkcnt == 0)
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
34811d94:	0a00001c 	beq	34811e0c <mmc_bread+0x98>
		return 0;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811d98:	e59520b0 	ldr	r2, [r5, #176]	; 0xb0
34811d9c:	e0841006 	add	r1, r4, r6
34811da0:	e1510002 	cmp	r1, r2
34811da4:	9a000002 	bls	34811db4 <mmc_bread+0x40>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
34811da8:	e59f0064 	ldr	r0, [pc, #100]	; 34811e14 <mmc_bread+0xa0>
34811dac:	ebffdf81 	bl	34809bb8 <printf>
34811db0:	ea000014 	b	34811e08 <mmc_bread+0x94>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
34811db4:	e5951088 	ldr	r1, [r5, #136]	; 0x88
34811db8:	ebfffed8 	bl	34811920 <mmc_set_blocklen>
34811dbc:	e3500000 	cmp	r0, #0
34811dc0:	1a000010 	bne	34811e08 <mmc_bread+0x94>
34811dc4:	e1a0a004 	mov	sl, r4
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811dc8:	e5959120 	ldr	r9, [r5, #288]	; 0x120
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
34811dcc:	e1a00005 	mov	r0, r5

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811dd0:	e15a0009 	cmp	sl, r9
34811dd4:	31a0900a 	movcc	r9, sl
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
34811dd8:	e1a01007 	mov	r1, r7
34811ddc:	e1a02006 	mov	r2, r6
34811de0:	e1a03009 	mov	r3, r9
34811de4:	ebffffb1 	bl	34811cb0 <mmc_read_blocks>
34811de8:	e1500009 	cmp	r0, r9
34811dec:	1a000005 	bne	34811e08 <mmc_bread+0x94>
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);
34811df0:	e05aa000 	subs	sl, sl, r0
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
34811df4:	e5953088 	ldr	r3, [r5, #136]	; 0x88
	} while (blocks_todo > 0);
34811df8:	0a000003 	beq	34811e0c <mmc_bread+0x98>
	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
34811dfc:	e0866000 	add	r6, r6, r0
		dst += cur * mmc->read_bl_len;
34811e00:	e0277093 	mla	r7, r3, r0, r7
34811e04:	eaffffef 	b	34811dc8 <mmc_bread+0x54>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
34811e08:	e3a04000 	mov	r4, #0
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
34811e0c:	e1a00004 	mov	r0, r4
34811e10:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
34811e14:	348272fa 	.word	0x348272fa

34811e18 <mmc_go_idle>:

int mmc_go_idle(struct mmc* mmc)
{
34811e18:	e92d4010 	push	{r4, lr}
34811e1c:	e1a04000 	mov	r4, r0
34811e20:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	udelay(1000);
34811e24:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34811e28:	eb002b62 	bl	3481cbb8 <udelay>

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34811e2c:	e3a02000 	mov	r2, #0
	cmd.cmdarg = 0;
	cmd.resp_type = MMC_RSP_NONE;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811e30:	e1a00004 	mov	r0, r4
34811e34:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	udelay(1000);

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34811e38:	e1cd20b4 	strh	r2, [sp, #4]
	cmd.cmdarg = 0;
34811e3c:	e58d200c 	str	r2, [sp, #12]
	cmd.resp_type = MMC_RSP_NONE;
34811e40:	e58d2008 	str	r2, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811e44:	ebfffe72 	bl	34811814 <mmc_send_cmd>

	if (err)
34811e48:	e2504000 	subs	r4, r0, #0
34811e4c:	1a000001 	bne	34811e58 <mmc_go_idle+0x40>
		return err;

	udelay(2000);
34811e50:	e2800e7d 	add	r0, r0, #2000	; 0x7d0
34811e54:	eb002b57 	bl	3481cbb8 <udelay>

	return 0;
}
34811e58:	e1a00004 	mov	r0, r4
34811e5c:	e28dd020 	add	sp, sp, #32
34811e60:	e8bd8010 	pop	{r4, pc}

34811e64 <sd_send_op_cond>:

int
sd_send_op_cond(struct mmc *mmc)
{
34811e64:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34811e68:	e24dd020 	sub	sp, sp, #32
34811e6c:	e1a04000 	mov	r4, r0
	int timeout = 1000;
34811e70:	e3a06ffa 	mov	r6, #1000	; 0x3e8
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
34811e74:	e3a09015 	mov	r9, #21
		cmd.cmdarg = 0;
34811e78:	e3a07000 	mov	r7, #0

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811e7c:	e28da004 	add	sl, sp, #4

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811e80:	e3a0b001 	mov	fp, #1
	int timeout = 1000;
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
34811e84:	e3a01037 	mov	r1, #55	; 0x37
34811e88:	e1cd10b4 	strh	r1, [sp, #4]
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811e8c:	e1a00004 	mov	r0, r4
34811e90:	e1a0100a 	mov	r1, sl
34811e94:	e1a02007 	mov	r2, r7
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
34811e98:	e58d9008 	str	r9, [sp, #8]
		cmd.cmdarg = 0;
34811e9c:	e58d700c 	str	r7, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811ea0:	ebfffe5b 	bl	34811814 <mmc_send_cmd>

		if (err)
34811ea4:	e2505000 	subs	r5, r0, #0
34811ea8:	1a00003a 	bne	34811f98 <sd_send_op_cond+0x134>
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
34811eac:	e3a03029 	mov	r3, #41	; 0x29
34811eb0:	e1cd30b4 	strh	r3, [sp, #4]
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811eb4:	e5943050 	ldr	r3, [r4, #80]	; 0x50
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811eb8:	e59f10e4 	ldr	r1, [pc, #228]	; 34811fa4 <sd_send_op_cond+0x140>
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811ebc:	e3130b01 	tst	r3, #1024	; 0x400
34811ec0:	059f30e0 	ldreq	r3, [pc, #224]	; 34811fa8 <sd_send_op_cond+0x144>
34811ec4:	0594202c 	ldreq	r2, [r4, #44]	; 0x2c
34811ec8:	11a03007 	movne	r3, r7
34811ecc:	00023003 	andeq	r3, r2, r3
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811ed0:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811ed4:	e58d300c 	str	r3, [sp, #12]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811ed8:	e1520001 	cmp	r2, r1
			cmd.cmdarg |= OCR_HCS;
34811edc:	03833101 	orreq	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811ee0:	e1a00004 	mov	r0, r4
34811ee4:	e1a0100a 	mov	r1, sl
34811ee8:	e3a02000 	mov	r2, #0
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;
34811eec:	058d300c 	streq	r3, [sp, #12]

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811ef0:	e58db008 	str	fp, [sp, #8]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811ef4:	ebfffe46 	bl	34811814 <mmc_send_cmd>

		if (err)
34811ef8:	e2505000 	subs	r5, r0, #0
34811efc:	1a000025 	bne	34811f98 <sd_send_op_cond+0x134>
			return err;

		udelay(1000);
34811f00:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
34811f04:	eb002b2b 	bl	3481cbb8 <udelay>
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
34811f08:	e59d3010 	ldr	r3, [sp, #16]
34811f0c:	e3530000 	cmp	r3, #0
34811f10:	ba000002 	blt	34811f20 <sd_send_op_cond+0xbc>
34811f14:	e2566001 	subs	r6, r6, #1
34811f18:	2affffd9 	bcs	34811e84 <sd_send_op_cond+0x20>
34811f1c:	ea00001c 	b	34811f94 <sd_send_op_cond+0x130>

	if (timeout <= 0)
34811f20:	e3560000 	cmp	r6, #0
34811f24:	da00001a 	ble	34811f94 <sd_send_op_cond+0x130>
		return UNUSABLE_ERR;

	if (mmc->version != SD_VERSION_2)
34811f28:	e59f3074 	ldr	r3, [pc, #116]	; 34811fa4 <sd_send_op_cond+0x140>
34811f2c:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34811f30:	e1520003 	cmp	r2, r3
		mmc->version = SD_VERSION_1_0;
34811f34:	12433010 	subne	r3, r3, #16
34811f38:	15843030 	strne	r3, [r4, #48]	; 0x30

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
34811f3c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811f40:	e3130b01 	tst	r3, #1024	; 0x400
34811f44:	0a00000b 	beq	34811f78 <sd_send_op_cond+0x114>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811f48:	e3a0303a 	mov	r3, #58	; 0x3a
34811f4c:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
34811f50:	e3a02000 	mov	r2, #0
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811f54:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811f58:	e1a00004 	mov	r0, r4
34811f5c:	e28d1004 	add	r1, sp, #4
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811f60:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;
34811f64:	e58d200c 	str	r2, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811f68:	ebfffe29 	bl	34811814 <mmc_send_cmd>

		if (err)
34811f6c:	e3500000 	cmp	r0, #0
34811f70:	11a05000 	movne	r5, r0
34811f74:	1a000007 	bne	34811f98 <sd_send_op_cond+0x134>
			return err;
	}

	mmc->ocr = cmd.response[0];
34811f78:	e59d3010 	ldr	r3, [sp, #16]

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;
34811f7c:	e3a01000 	mov	r1, #0

		if (err)
			return err;
	}

	mmc->ocr = cmd.response[0];
34811f80:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
34811f84:	e7e03f53 	ubfx	r3, r3, #30, #1
34811f88:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
34811f8c:	e1c418b0 	strh	r1, [r4, #128]	; 0x80

	return 0;
34811f90:	ea000000 	b	34811f98 <sd_send_op_cond+0x134>

		udelay(1000);
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
34811f94:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
34811f98:	e1a00005 	mov	r0, r5
34811f9c:	e28dd020 	add	sp, sp, #32
34811fa0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811fa4:	00020020 	.word	0x00020020
34811fa8:	00ff8000 	.word	0x00ff8000

34811fac <mmc_send_op_cond>:

int mmc_send_op_cond(struct mmc *mmc)
{
34811fac:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34811fb0:	e24dd020 	sub	sp, sp, #32
34811fb4:	e1a04000 	mov	r4, r0
 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811fb8:	e28da004 	add	sl, sp, #4
	int timeout = 10000;
	struct mmc_cmd cmd;
	int err;

	/* Some cards seem to need this */
	mmc_go_idle(mmc);
34811fbc:	ebffff95 	bl	34811e18 <mmc_go_idle>

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811fc0:	e3a07001 	mov	r7, #1
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;
34811fc4:	e3a02000 	mov	r2, #0

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811fc8:	e1a00004 	mov	r0, r4
34811fcc:	e1a0100a 	mov	r1, sl

	/* Some cards seem to need this */
	mmc_go_idle(mmc);

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811fd0:	e1cd70b4 	strh	r7, [sp, #4]
 	cmd.resp_type = MMC_RSP_R3;
34811fd4:	e58d7008 	str	r7, [sp, #8]
 	cmd.cmdarg = 0;
34811fd8:	e58d200c 	str	r2, [sp, #12]

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811fdc:	ebfffe0c 	bl	34811814 <mmc_send_cmd>

 	if (err)
34811fe0:	e2505000 	subs	r5, r0, #0
34811fe4:	1a00003d 	bne	348120e0 <mmc_send_op_cond+0x134>
 		return err;

 	udelay(1000);
34811fe8:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
34811fec:	eb002af1 	bl	3481cbb8 <udelay>
	return 0;
}

int mmc_send_op_cond(struct mmc *mmc)
{
	int timeout = 10000;
34811ff0:	e3026710 	movw	r6, #10000	; 0x2710
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811ff4:	e5941050 	ldr	r1, [r4, #80]	; 0x50
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811ff8:	e3a03001 	mov	r3, #1
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811ffc:	e3110b01 	tst	r1, #1024	; 0x400
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34812000:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
34812004:	0594002c 	ldreq	r0, [r4, #44]	; 0x2c
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
34812008:	059d3010 	ldreq	r3, [sp, #16]

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
3481200c:	059f20d8 	ldreq	r2, [pc, #216]	; 348120ec <mmc_send_op_cond+0x140>
34812010:	00030000 	andeq	r0, r3, r0
34812014:	00002002 	andeq	r2, r0, r2
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));
34812018:	02033206 	andeq	r3, r3, #1610612736	; 0x60000000
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
3481201c:	01823003 	orreq	r3, r2, r3
34812020:	13a03000 	movne	r3, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
34812024:	e3110b02 	tst	r1, #2048	; 0x800
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34812028:	e58d300c 	str	r3, [sp, #12]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
3481202c:	e1a00004 	mov	r0, r4
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
34812030:	13833101 	orrne	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
34812034:	e1a0100a 	mov	r1, sl
34812038:	e3a02000 	mov	r2, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
3481203c:	158d300c 	strne	r3, [sp, #12]

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34812040:	e58d7008 	str	r7, [sp, #8]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34812044:	ebfffdf2 	bl	34811814 <mmc_send_cmd>

		if (err)
34812048:	e2505000 	subs	r5, r0, #0
3481204c:	1a000023 	bne	348120e0 <mmc_send_op_cond+0x134>
			return err;

		udelay(1000);
34812050:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
34812054:	eb002ad7 	bl	3481cbb8 <udelay>
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34812058:	e59d3010 	ldr	r3, [sp, #16]
3481205c:	e3530000 	cmp	r3, #0
34812060:	aa000002 	bge	34812070 <mmc_send_op_cond+0xc4>

	if (timeout <= 0)
34812064:	e3560000 	cmp	r6, #0
34812068:	ca000003 	bgt	3481207c <mmc_send_op_cond+0xd0>
3481206c:	ea00001a 	b	348120dc <mmc_send_op_cond+0x130>

		if (err)
			return err;

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34812070:	e2566001 	subs	r6, r6, #1
34812074:	2affffde 	bcs	34811ff4 <mmc_send_op_cond+0x48>
34812078:	ea000017 	b	348120dc <mmc_send_op_cond+0x130>

	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
3481207c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34812080:	e3130b01 	tst	r3, #1024	; 0x400
34812084:	0a00000b 	beq	348120b8 <mmc_send_op_cond+0x10c>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34812088:	e3a0303a 	mov	r3, #58	; 0x3a
3481208c:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34812090:	e1a02005 	mov	r2, r5
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34812094:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34812098:	e1a00004 	mov	r0, r4
3481209c:	e1a0100a 	mov	r1, sl
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
348120a0:	e58d500c 	str	r5, [sp, #12]
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
348120a4:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348120a8:	ebfffdd9 	bl	34811814 <mmc_send_cmd>

		if (err)
348120ac:	e3500000 	cmp	r0, #0
348120b0:	11a05000 	movne	r5, r0
348120b4:	1a000009 	bne	348120e0 <mmc_send_op_cond+0x134>
			return err;
	}

	mmc->version = MMC_VERSION_UNKNOWN;
348120b8:	e3a03801 	mov	r3, #65536	; 0x10000
348120bc:	e5843030 	str	r3, [r4, #48]	; 0x30
	mmc->ocr = cmd.response[0];
348120c0:	e59d3010 	ldr	r3, [sp, #16]
348120c4:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
348120c8:	e7e03f53 	ubfx	r3, r3, #30, #1
348120cc:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
348120d0:	e3a03000 	mov	r3, #0
348120d4:	e1c438b0 	strh	r3, [r4, #128]	; 0x80

	return 0;
348120d8:	ea000000 	b	348120e0 <mmc_send_op_cond+0x134>

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
348120dc:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
348120e0:	e1a00005 	mov	r0, r5
348120e4:	e28dd020 	add	sp, sp, #32
348120e8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348120ec:	007fff80 	.word	0x007fff80

348120f0 <mmc_send_ext_csd>:


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
348120f0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
348120f4:	e3a03008 	mov	r3, #8
	return 0;
}


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
348120f8:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
348120fc:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34812100:	e3a03015 	mov	r3, #21
34812104:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
	data.blocksize = 512;
34812108:	e3a02c02 	mov	r2, #512	; 0x200
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
3481210c:	e3a03000 	mov	r3, #0
34812110:	e58d300c 	str	r3, [sp, #12]

	data.dest = (char *)ext_csd;
34812114:	e58d1020 	str	r1, [sp, #32]
	data.blocks = 1;
34812118:	e2833001 	add	r3, r3, #1
	data.blocksize = 512;
3481211c:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34812120:	e28d1004 	add	r1, sp, #4
34812124:	e28d2020 	add	r2, sp, #32
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
34812128:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.blocksize = 512;
	data.flags = MMC_DATA_READ;
3481212c:	e58d3024 	str	r3, [sp, #36]	; 0x24

	err = mmc_send_cmd(mmc, &cmd, &data);
34812130:	ebfffdb7 	bl	34811814 <mmc_send_cmd>

	return err;
}
34812134:	e28dd034 	add	sp, sp, #52	; 0x34
34812138:	e8bd8000 	pop	{pc}

3481213c <mmc_switch>:


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
3481213c:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
34812140:	e3a01006 	mov	r1, #6
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34812144:	e24dd020 	sub	sp, sp, #32
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
34812148:	e1a02802 	lsl	r2, r2, #16
{
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
3481214c:	e1cd10b4 	strh	r1, [sp, #4]
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
34812150:	e3822403 	orr	r2, r2, #50331648	; 0x3000000
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
34812154:	e3a0101d 	mov	r1, #29
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
34812158:	e1823403 	orr	r3, r2, r3, lsl #8
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
3481215c:	e58d1008 	str	r1, [sp, #8]
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34812160:	e3a02000 	mov	r2, #0
34812164:	e28d1004 	add	r1, sp, #4
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34812168:	e1a04000 	mov	r4, r0
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
3481216c:	e58d300c 	str	r3, [sp, #12]
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34812170:	ebfffda7 	bl	34811814 <mmc_send_cmd>

	/* Waiting for the ready status */
	if (!ret)
34812174:	e3500000 	cmp	r0, #0
34812178:	1a000002 	bne	34812188 <mmc_switch+0x4c>
		ret = mmc_send_status(mmc, timeout);
3481217c:	e1a00004 	mov	r0, r4
34812180:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34812184:	ebfffdb1 	bl	34811850 <mmc_send_status>

	return ret;

}
34812188:	e28dd020 	add	sp, sp, #32
3481218c:	e8bd8010 	pop	{r4, pc}

34812190 <mmc_change_freq>:

int mmc_change_freq(struct mmc *mmc)
{
34812190:	e92d4070 	push	{r4, r5, r6, lr}
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34812194:	e5902050 	ldr	r2, [r0, #80]	; 0x50
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
34812198:	e3a03000 	mov	r3, #0

	if (mmc_host_is_spi(mmc))
3481219c:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
348121a0:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
348121a4:	e580304c 	str	r3, [r0, #76]	; 0x4c
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
348121a8:	e24ddd09 	sub	sp, sp, #576	; 0x240
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
		return 0;
348121ac:	11a00003 	movne	r0, r3
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
348121b0:	1a00001f 	bne	34812234 <mmc_change_freq+0xa4>
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
348121b4:	e5941030 	ldr	r1, [r4, #48]	; 0x30
348121b8:	e59f307c 	ldr	r3, [pc, #124]	; 3481223c <mmc_change_freq+0xac>
348121bc:	e1510003 	cmp	r1, r3
		return 0;
348121c0:	91a00002 	movls	r0, r2

	if (mmc_host_is_spi(mmc))
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
348121c4:	9a00001a 	bls	34812234 <mmc_change_freq+0xa4>

}

int mmc_change_freq(struct mmc *mmc)
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
348121c8:	e28d503f 	add	r5, sp, #63	; 0x3f
348121cc:	e3c5503f 	bic	r5, r5, #63	; 0x3f

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
		return 0;

	err = mmc_send_ext_csd(mmc, ext_csd);
348121d0:	e1a01005 	mov	r1, r5
348121d4:	ebffffc5 	bl	348120f0 <mmc_send_ext_csd>

	if (err)
348121d8:	e3500000 	cmp	r0, #0
348121dc:	1a000014 	bne	34812234 <mmc_change_freq+0xa4>
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
348121e0:	e3a01001 	mov	r1, #1
348121e4:	e1a00004 	mov	r0, r4
348121e8:	e3a020b9 	mov	r2, #185	; 0xb9
348121ec:	e1a03001 	mov	r3, r1
	err = mmc_send_ext_csd(mmc, ext_csd);

	if (err)
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
348121f0:	e5d560c4 	ldrb	r6, [r5, #196]	; 0xc4

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
348121f4:	ebffffd0 	bl	3481213c <mmc_switch>

	if (err)
348121f8:	e3500000 	cmp	r0, #0
348121fc:	1a00000c 	bne	34812234 <mmc_change_freq+0xa4>
		return err;

	/* Now check to see that it worked */
	err = mmc_send_ext_csd(mmc, ext_csd);
34812200:	e1a00004 	mov	r0, r4
34812204:	e1a01005 	mov	r1, r5
34812208:	ebffffb8 	bl	348120f0 <mmc_send_ext_csd>

	if (err)
3481220c:	e3500000 	cmp	r0, #0
34812210:	1a000007 	bne	34812234 <mmc_change_freq+0xa4>
		return err;

	/* No high-speed support */
	if (!ext_csd[EXT_CSD_HS_TIMING])
34812214:	e5d530b9 	ldrb	r3, [r5, #185]	; 0xb9
34812218:	e3530000 	cmp	r3, #0
3481221c:	0a000004 	beq	34812234 <mmc_change_freq+0xa4>
34812220:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
34812224:	e3160002 	tst	r6, #2
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
34812228:	13833011 	orrne	r3, r3, #17
	else
		mmc->card_caps |= MMC_MODE_HS;
3481222c:	03833001 	orreq	r3, r3, #1
34812230:	e584304c 	str	r3, [r4, #76]	; 0x4c

	return 0;
}
34812234:	e28ddd09 	add	sp, sp, #576	; 0x240
34812238:	e8bd8070 	pop	{r4, r5, r6, pc}
3481223c:	0001003f 	.word	0x0001003f

34812240 <mmc_switch_part>:

int mmc_switch_part(int dev_num, unsigned int part_num)
{
34812240:	e92d4010 	push	{r4, lr}
34812244:	e1a04001 	mov	r4, r1
	struct mmc *mmc = find_mmc_device(dev_num);
34812248:	ebfffdc0 	bl	34811950 <find_mmc_device>

	if (!mmc)
3481224c:	e2503000 	subs	r3, r0, #0
34812250:	0a000007 	beq	34812274 <mmc_switch_part+0x34>
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34812254:	e5d33082 	ldrb	r3, [r3, #130]	; 0x82
34812258:	e204c007 	and	ip, r4, #7
3481225c:	e3c33007 	bic	r3, r3, #7
34812260:	e3a01001 	mov	r1, #1
34812264:	e3a020b3 	mov	r2, #179	; 0xb3
34812268:	e18c3003 	orr	r3, ip, r3
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
3481226c:	e8bd4010 	pop	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev_num);

	if (!mmc)
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34812270:	eaffffb1 	b	3481213c <mmc_switch>
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
34812274:	e3e00000 	mvn	r0, #0
34812278:	e8bd8010 	pop	{r4, pc}

3481227c <mmc_getcd>:

int mmc_getcd(struct mmc *mmc)
{
3481227c:	e92d4010 	push	{r4, lr}
34812280:	e1a04000 	mov	r4, r0
	int cd;

	cd = board_mmc_getcd(mmc);
34812284:	ebfffd60 	bl	3481180c <__board_mmc_getcd>

	if ((cd < 0) && mmc->getcd)
34812288:	e3500000 	cmp	r0, #0
3481228c:	a8bd8010 	popge	{r4, pc}
34812290:	e594311c 	ldr	r3, [r4, #284]	; 0x11c
34812294:	e3530000 	cmp	r3, #0
34812298:	08bd8010 	popeq	{r4, pc}
		cd = mmc->getcd(mmc);
3481229c:	e1a00004 	mov	r0, r4
348122a0:	e12fff33 	blx	r3

	return cd;
}
348122a4:	e8bd8010 	pop	{r4, pc}

348122a8 <sd_switch>:

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
348122a8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
348122ac:	e3a0c006 	mov	ip, #6

	return cd;
}

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
348122b0:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
348122b4:	e1cdc0b4 	strh	ip, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
348122b8:	e3a0c015 	mov	ip, #21
348122bc:	e58dc008 	str	ip, [sp, #8]
	cmd.cmdarg = (mode << 31) | 0xffffff;
348122c0:	e3e0c4ff 	mvn	ip, #-16777216	; 0xff000000
348122c4:	e18c1f81 	orr	r1, ip, r1, lsl #31
	cmd.cmdarg &= ~(0xf << (group * 4));
348122c8:	e1a02102 	lsl	r2, r2, #2
348122cc:	e3a0c00f 	mov	ip, #15
348122d0:	e1c1c21c 	bic	ip, r1, ip, lsl r2
	cmd.cmdarg |= value << (group * 4);
348122d4:	e18c2213 	orr	r2, ip, r3, lsl r2

	data.dest = (char *)resp;
348122d8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
348122dc:	e58d200c 	str	r2, [sp, #12]

	data.dest = (char *)resp;
348122e0:	e58d3020 	str	r3, [sp, #32]
	data.blocksize = 64;
348122e4:	e3a03040 	mov	r3, #64	; 0x40
348122e8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
348122ec:	e28d1004 	add	r1, sp, #4
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
348122f0:	e3a03001 	mov	r3, #1
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
348122f4:	e28d2020 	add	r2, sp, #32
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
348122f8:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.flags = MMC_DATA_READ;
348122fc:	e58d3024 	str	r3, [sp, #36]	; 0x24

	return mmc_send_cmd(mmc, &cmd, &data);
34812300:	ebfffd43 	bl	34811814 <mmc_send_cmd>
}
34812304:	e28dd034 	add	sp, sp, #52	; 0x34
34812308:	e8bd8000 	pop	{pc}

3481230c <sd_change_freq>:


int sd_change_freq(struct mmc *mmc)
{
3481230c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34812310:	e5902050 	ldr	r2, [r0, #80]	; 0x50
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
34812314:	e24ddd05 	sub	sp, sp, #320	; 0x140
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
34812318:	e28d70d3 	add	r7, sp, #211	; 0xd3
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
3481231c:	e28d6053 	add	r6, sp, #83	; 0x53
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
34812320:	e3a05000 	mov	r5, #0

	if (mmc_host_is_spi(mmc))
34812324:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
34812328:	e1a04000 	mov	r4, r0
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
3481232c:	e3c7703f 	bic	r7, r7, #63	; 0x3f
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
34812330:	e3c6603f 	bic	r6, r6, #63	; 0x3f
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
34812334:	e580504c 	str	r5, [r0, #76]	; 0x4c

	if (mmc_host_is_spi(mmc))
34812338:	1a000069 	bne	348124e4 <sd_change_freq+0x1d8>
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
3481233c:	e3a01037 	mov	r1, #55	; 0x37
34812340:	e28d3c01 	add	r3, sp, #256	; 0x100
34812344:	e1c311b4 	strh	r1, [r3, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
34812348:	e1d038b0 	ldrh	r3, [r0, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481234c:	e28dbf45 	add	fp, sp, #276	; 0x114
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
34812350:	e1a03803 	lsl	r3, r3, #16
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
34812354:	e3a0a015 	mov	sl, #21
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812358:	e1a0100b 	mov	r1, fp
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
3481235c:	e58da118 	str	sl, [sp, #280]	; 0x118
	cmd.cmdarg = mmc->rca << 16;
34812360:	e58d311c 	str	r3, [sp, #284]	; 0x11c

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812364:	ebfffd2a 	bl	34811814 <mmc_send_cmd>

	if (err)
34812368:	e2505000 	subs	r5, r0, #0
3481236c:	1a00005c 	bne	348124e4 <sd_change_freq+0x1d8>
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
34812370:	e3a01033 	mov	r1, #51	; 0x33
34812374:	e28d2c01 	add	r2, sp, #256	; 0x100
	cmd.resp_type = MMC_RSP_R1;
34812378:	e58da118 	str	sl, [sp, #280]	; 0x118
	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
3481237c:	e1c211b4 	strh	r1, [r2, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
34812380:	e58d511c 	str	r5, [sp, #284]	; 0x11c

	timeout = 3;
34812384:	e3a0a003 	mov	sl, #3

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
34812388:	e3a0c008 	mov	ip, #8
	data.blocks = 1;
3481238c:	e3a09001 	mov	r9, #1
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34812390:	e28d3e13 	add	r3, sp, #304	; 0x130
34812394:	e1a02003 	mov	r2, r3
34812398:	e1a00004 	mov	r0, r4
3481239c:	e1a0100b 	mov	r1, fp

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
348123a0:	e58dc13c 	str	ip, [sp, #316]	; 0x13c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
348123a4:	e58d3008 	str	r3, [sp, #8]
348123a8:	e58dc00c 	str	ip, [sp, #12]
	cmd.cmdarg = 0;

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
348123ac:	e58d7130 	str	r7, [sp, #304]	; 0x130
	data.blocksize = 8;
	data.blocks = 1;
348123b0:	e58d9138 	str	r9, [sp, #312]	; 0x138
	data.flags = MMC_DATA_READ;
348123b4:	e58d9134 	str	r9, [sp, #308]	; 0x134

	err = mmc_send_cmd(mmc, &cmd, &data);
348123b8:	ebfffd15 	bl	34811814 <mmc_send_cmd>

	if (err) {
348123bc:	e2505000 	subs	r5, r0, #0
348123c0:	e59d3008 	ldr	r3, [sp, #8]
348123c4:	e59dc00c 	ldr	ip, [sp, #12]
348123c8:	0a000003 	beq	348123dc <sd_change_freq+0xd0>
		if (timeout--)
348123cc:	e35a0000 	cmp	sl, #0
348123d0:	0a000043 	beq	348124e4 <sd_change_freq+0x1d8>
348123d4:	e24aa001 	sub	sl, sl, #1
348123d8:	eaffffed 	b	34812394 <sd_change_freq+0x88>
			goto retry_scr;

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
348123dc:	e5970000 	ldr	r0, [r7]
348123e0:	ebfffd07 	bl	34811804 <__fswab32>
348123e4:	e5840058 	str	r0, [r4, #88]	; 0x58
348123e8:	e1a0a000 	mov	sl, r0
	mmc->scr[1] = __be32_to_cpu(scr[1]);
348123ec:	e5970004 	ldr	r0, [r7, #4]
348123f0:	ebfffd03 	bl	34811804 <__fswab32>

	switch ((mmc->scr[0] >> 24) & 0xf) {
348123f4:	e7e33c5a 	ubfx	r3, sl, #24, #4
348123f8:	e3530001 	cmp	r3, #1

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);
348123fc:	e584005c 	str	r0, [r4, #92]	; 0x5c
	switch ((mmc->scr[0] >> 24) & 0xf) {
		case 0:
			mmc->version = SD_VERSION_1_0;
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
34812400:	059f30e8 	ldreq	r3, [pc, #232]	; 348124f0 <sd_change_freq+0x1e4>
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);

	switch ((mmc->scr[0] >> 24) & 0xf) {
34812404:	0a000004 	beq	3481241c <sd_change_freq+0x110>
34812408:	3a000002 	bcc	34812418 <sd_change_freq+0x10c>
3481240c:	e3530002 	cmp	r3, #2
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
			break;
		case 2:
			mmc->version = SD_VERSION_2;
34812410:	059f30dc 	ldreq	r3, [pc, #220]	; 348124f4 <sd_change_freq+0x1e8>
34812414:	0a000000 	beq	3481241c <sd_change_freq+0x110>
			break;
		default:
			mmc->version = SD_VERSION_1_0;
34812418:	e59f30d8 	ldr	r3, [pc, #216]	; 348124f8 <sd_change_freq+0x1ec>
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
3481241c:	e31a0701 	tst	sl, #262144	; 0x40000
			break;
		case 2:
			mmc->version = SD_VERSION_2;
			break;
		default:
			mmc->version = SD_VERSION_1_0;
34812420:	e5843030 	str	r3, [r4, #48]	; 0x30
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
34812424:	1594304c 	ldrne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
34812428:	e5942030 	ldr	r2, [r4, #48]	; 0x30
			mmc->version = SD_VERSION_1_0;
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
3481242c:	13833c01 	orrne	r3, r3, #256	; 0x100
34812430:	1584304c 	strne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
34812434:	e59f30bc 	ldr	r3, [pc, #188]	; 348124f8 <sd_change_freq+0x1ec>
34812438:	e1520003 	cmp	r2, r3
3481243c:	13a07004 	movne	r7, #4
34812440:	1a00000c 	bne	34812478 <sd_change_freq+0x16c>
34812444:	ea000026 	b	348124e4 <sd_change_freq+0x1d8>
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
34812448:	e3a01000 	mov	r1, #0
3481244c:	e1a00004 	mov	r0, r4
34812450:	e1a02001 	mov	r2, r1
34812454:	e3a03001 	mov	r3, #1
34812458:	e58d6000 	str	r6, [sp]
3481245c:	ebffff91 	bl	348122a8 <sd_switch>
				(u8 *)switch_status);

		if (err)
34812460:	e3500000 	cmp	r0, #0
34812464:	1a00001d 	bne	348124e0 <sd_change_freq+0x1d4>
			return err;

		/* The high-speed function is busy.  Try again */
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
34812468:	e596001c 	ldr	r0, [r6, #28]
3481246c:	ebfffce4 	bl	34811804 <__fswab32>
34812470:	e3100802 	tst	r0, #131072	; 0x20000
34812474:	0a000001 	beq	34812480 <sd_change_freq+0x174>
	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
34812478:	e2577001 	subs	r7, r7, #1
3481247c:	2afffff1 	bcs	34812448 <sd_change_freq+0x13c>
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
			break;
	}

	/* If high-speed isn't supported, we return */
	if (!(__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
34812480:	e596000c 	ldr	r0, [r6, #12]
34812484:	ebfffcde 	bl	34811804 <__fswab32>
34812488:	e3100802 	tst	r0, #131072	; 0x20000
3481248c:	0a000014 	beq	348124e4 <sd_change_freq+0x1d8>
	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
	 * This can avoid furthur problem when the card runs in different
	 * mode between the host.
	 */
	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
34812490:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34812494:	e2033011 	and	r3, r3, #17
34812498:	e3530011 	cmp	r3, #17
3481249c:	1a000010 	bne	348124e4 <sd_change_freq+0x1d8>
		(mmc->host_caps & MMC_MODE_HS)))
		return 0;

	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
348124a0:	e3a01001 	mov	r1, #1
348124a4:	e1a00004 	mov	r0, r4
348124a8:	e3a02000 	mov	r2, #0
348124ac:	e1a03001 	mov	r3, r1
348124b0:	e58d6000 	str	r6, [sp]
348124b4:	ebffff7b 	bl	348122a8 <sd_switch>

	if (err)
348124b8:	e2505000 	subs	r5, r0, #0
348124bc:	1a000008 	bne	348124e4 <sd_change_freq+0x1d8>
		return err;

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
348124c0:	e5960010 	ldr	r0, [r6, #16]
348124c4:	ebfffcce 	bl	34811804 <__fswab32>
348124c8:	e200040f 	and	r0, r0, #251658240	; 0xf000000
348124cc:	e3500401 	cmp	r0, #16777216	; 0x1000000
		mmc->card_caps |= MMC_MODE_HS;
348124d0:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
348124d4:	03833001 	orreq	r3, r3, #1
348124d8:	0584304c 	streq	r3, [r4, #76]	; 0x4c
348124dc:	ea000000 	b	348124e4 <sd_change_freq+0x1d8>
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
348124e0:	e1a05000 	mov	r5, r0

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
}
348124e4:	e1a00005 	mov	r0, r5
348124e8:	e28ddd05 	add	sp, sp, #320	; 0x140
348124ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348124f0:	0002001a 	.word	0x0002001a
348124f4:	00020020 	.word	0x00020020
348124f8:	00020010 	.word	0x00020010

348124fc <mmc_set_ios>:
	70,
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
348124fc:	e92d4008 	push	{r3, lr}
	mmc->set_ios(mmc);
34812500:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34812504:	e12fff33 	blx	r3
}
34812508:	e8bd8008 	pop	{r3, pc}

3481250c <mmc_set_clock>:

void mmc_set_clock(struct mmc *mmc, uint clock)
{
3481250c:	e590203c 	ldr	r2, [r0, #60]	; 0x3c
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
34812510:	e590c038 	ldr	ip, [r0, #56]	; 0x38
{
	mmc->set_ios(mmc);
}

void mmc_set_clock(struct mmc *mmc, uint clock)
{
34812514:	e1510002 	cmp	r1, r2
34812518:	31a02001 	movcc	r2, r1
3481251c:	e92d4008 	push	{r3, lr}
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
34812520:	e152000c 	cmp	r2, ip
34812524:	25802048 	strcs	r2, [r0, #72]	; 0x48
34812528:	3580c048 	strcc	ip, [r0, #72]	; 0x48
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
3481252c:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34812530:	e12fff33 	blx	r3
		clock = mmc->f_min;

	mmc->clock = clock;

	mmc_set_ios(mmc);
}
34812534:	e8bd8008 	pop	{r3, pc}

34812538 <mmc_set_bus_width>:

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
34812538:	e92d4008 	push	{r3, lr}
	mmc->bus_width = width;
3481253c:	e5801044 	str	r1, [r0, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812540:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34812544:	e12fff33 	blx	r3
void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}
34812548:	e8bd8008 	pop	{r3, pc}

3481254c <mmc_startup>:

int mmc_startup(struct mmc *mmc)
{
3481254c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34812550:	e5903050 	ldr	r3, [r0, #80]	; 0x50

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
34812554:	e24ddd13 	sub	sp, sp, #1216	; 0x4c0
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34812558:	e3130b01 	tst	r3, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481255c:	e28d5e49 	add	r5, sp, #1168	; 0x490
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34812560:	03a03002 	moveq	r3, #2
34812564:	13a0300a 	movne	r3, #10
34812568:	e28d1b01 	add	r1, sp, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481256c:	e285500c 	add	r5, r5, #12
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34812570:	e1c139bc 	strh	r3, [r1, #156]	; 0x9c
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;
34812574:	e3a02000 	mov	r2, #0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
34812578:	e3a03007 	mov	r3, #7
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481257c:	e1a01005 	mov	r1, r5

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
34812580:	e1a04000 	mov	r4, r0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
34812584:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = 0;
34812588:	e58d24a4 	str	r2, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481258c:	ebfffca0 	bl	34811814 <mmc_send_cmd>
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
34812590:	e28da020 	add	sl, sp, #32
34812594:	e28aa03b 	add	sl, sl, #59	; 0x3b
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
34812598:	e2506000 	subs	r6, r0, #0
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
3481259c:	e3caa03f 	bic	sl, sl, #63	; 0x3f
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
348125a0:	1a00017b 	bne	34812b94 <mmc_startup+0x648>
		return err;

	memcpy(mmc->cid, cmd.response, 16);
348125a4:	e3a02010 	mov	r2, #16
348125a8:	e2840070 	add	r0, r4, #112	; 0x70
348125ac:	e285100c 	add	r1, r5, #12
348125b0:	eb0028f5 	bl	3481c98c <memcpy>
	/*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
348125b4:	e5942050 	ldr	r2, [r4, #80]	; 0x50
348125b8:	e2122b01 	ands	r2, r2, #1024	; 0x400
348125bc:	1a000011 	bne	34812608 <mmc_startup+0xbc>
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
348125c0:	e3a03003 	mov	r3, #3
348125c4:	e28d0b01 	add	r0, sp, #1024	; 0x400
348125c8:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
		cmd.cmdarg = mmc->rca << 16;
348125cc:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348125d0:	e1a00004 	mov	r0, r4
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
348125d4:	e1a03803 	lsl	r3, r3, #16
348125d8:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348125dc:	e1a01005 	mov	r1, r5
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
		cmd.resp_type = MMC_RSP_R6;
348125e0:	e3a03015 	mov	r3, #21
348125e4:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0

		err = mmc_send_cmd(mmc, &cmd, NULL);
348125e8:	ebfffc89 	bl	34811814 <mmc_send_cmd>

		if (err)
348125ec:	e2506000 	subs	r6, r0, #0
348125f0:	1a000167 	bne	34812b94 <mmc_startup+0x648>
			return err;

		if (IS_SD(mmc))
348125f4:	e5943030 	ldr	r3, [r4, #48]	; 0x30
348125f8:	e3130802 	tst	r3, #131072	; 0x20000
			mmc->rca = (cmd.response[0] >> 16) & 0xffff;
348125fc:	128d1b01 	addne	r1, sp, #1024	; 0x400
34812600:	11d11aba 	ldrhne	r1, [r1, #170]	; 0xaa
34812604:	11c418b0 	strhne	r1, [r4, #128]	; 0x80
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
34812608:	e3a02009 	mov	r2, #9
3481260c:	e28d3b01 	add	r3, sp, #1024	; 0x400
34812610:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
	cmd.resp_type = MMC_RSP_R2;
34812614:	e3a03007 	mov	r3, #7
34812618:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = mmc->rca << 16;
3481261c:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812620:	e28d1e49 	add	r1, sp, #1168	; 0x490
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
34812624:	e1a03803 	lsl	r3, r3, #16

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812628:	e281100c 	add	r1, r1, #12
3481262c:	e3a02000 	mov	r2, #0
34812630:	e1a00004 	mov	r0, r4
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
34812634:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812638:	ebfffc75 	bl	34811814 <mmc_send_cmd>

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
3481263c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812640:	e1a06000 	mov	r6, r0

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
34812644:	e1a00004 	mov	r0, r4
34812648:	ebfffc80 	bl	34811850 <mmc_send_status>

	if (err)
3481264c:	e3560000 	cmp	r6, #0
34812650:	1a00014f 	bne	34812b94 <mmc_startup+0x648>
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
34812654:	e59d24b4 	ldr	r2, [sp, #1204]	; 0x4b4
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
34812658:	e59d34a8 	ldr	r3, [sp, #1192]	; 0x4a8
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
3481265c:	e584206c 	str	r2, [r4, #108]	; 0x6c

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34812660:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
34812664:	e59d04ac 	ldr	r0, [sp, #1196]	; 0x4ac
	mmc->csd[2] = cmd.response[2];
34812668:	e59d64b0 	ldr	r6, [sp, #1200]	; 0x4b0
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
3481266c:	e3520801 	cmp	r2, #65536	; 0x10000
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
34812670:	e5843060 	str	r3, [r4, #96]	; 0x60
	mmc->csd[1] = cmd.response[1];
34812674:	e5840064 	str	r0, [r4, #100]	; 0x64
	mmc->csd[2] = cmd.response[2];
34812678:	e5846068 	str	r6, [r4, #104]	; 0x68
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
3481267c:	1a000012 	bne	348126cc <mmc_startup+0x180>
		int version = (cmd.response[0] >> 26) & 0xf;
34812680:	e7e32d53 	ubfx	r2, r3, #26, #4

		switch (version) {
34812684:	e3520004 	cmp	r2, #4
34812688:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
3481268c:	ea00000c 	b	348126c4 <mmc_startup+0x178>
34812690:	348126c4 	.word	0x348126c4
34812694:	348126a4 	.word	0x348126a4
34812698:	348126ac 	.word	0x348126ac
3481269c:	348126b4 	.word	0x348126b4
348126a0:	348126bc 	.word	0x348126bc
			case 0:
				mmc->version = MMC_VERSION_1_2;
				break;
			case 1:
				mmc->version = MMC_VERSION_1_4;
348126a4:	e59f24f4 	ldr	r2, [pc, #1268]	; 34812ba0 <mmc_startup+0x654>
348126a8:	ea000006 	b	348126c8 <mmc_startup+0x17c>
				break;
			case 2:
				mmc->version = MMC_VERSION_2_2;
348126ac:	e59f24f0 	ldr	r2, [pc, #1264]	; 34812ba4 <mmc_startup+0x658>
348126b0:	ea000004 	b	348126c8 <mmc_startup+0x17c>
				break;
			case 3:
				mmc->version = MMC_VERSION_3;
348126b4:	e59f24ec 	ldr	r2, [pc, #1260]	; 34812ba8 <mmc_startup+0x65c>
348126b8:	ea000002 	b	348126c8 <mmc_startup+0x17c>
				break;
			case 4:
				mmc->version = MMC_VERSION_4;
348126bc:	e59f24e8 	ldr	r2, [pc, #1256]	; 34812bac <mmc_startup+0x660>
348126c0:	ea000000 	b	348126c8 <mmc_startup+0x17c>
				break;
			default:
				mmc->version = MMC_VERSION_1_2;
348126c4:	e59f24e4 	ldr	r2, [pc, #1252]	; 34812bb0 <mmc_startup+0x664>
348126c8:	e5842030 	str	r2, [r4, #48]	; 0x30
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
348126cc:	e59f24e0 	ldr	r2, [pc, #1248]	; 34812bb4 <mmc_startup+0x668>
348126d0:	e7e311d3 	ubfx	r1, r3, #3, #4
				break;
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
348126d4:	e2033007 	and	r3, r3, #7
348126d8:	e0823103 	add	r3, r2, r3, lsl #2
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
348126dc:	e5933040 	ldr	r3, [r3, #64]	; 0x40
348126e0:	e7922101 	ldr	r2, [r2, r1, lsl #2]

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
348126e4:	e7e35850 	ubfx	r5, r0, #16, #4

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
348126e8:	e0030293 	mul	r3, r3, r2

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
348126ec:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
348126f0:	e5843084 	str	r3, [r4, #132]	; 0x84

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
348126f4:	e3120802 	tst	r2, #131072	; 0x20000
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
348126f8:	059d24b4 	ldreq	r2, [sp, #1204]	; 0x4b4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
348126fc:	e3a03001 	mov	r3, #1

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34812700:	07e32b52 	ubfxeq	r2, r2, #22, #4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34812704:	e1a05513 	lsl	r5, r3, r5

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34812708:	01a03213 	lsleq	r3, r3, r2
3481270c:	0584308c 	streq	r3, [r4, #140]	; 0x8c

	if (mmc->high_capacity) {
34812710:	e5943040 	ldr	r3, [r4, #64]	; 0x40
	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
34812714:	1584508c 	strne	r5, [r4, #140]	; 0x8c
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
34812718:	e3530000 	cmp	r3, #0
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
3481271c:	e5845088 	str	r5, [r4, #136]	; 0x88
	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
34812720:	0a000006 	beq	34812740 <mmc_startup+0x1f4>
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
34812724:	e1a06826 	lsr	r6, r6, #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
34812728:	e200003f 	and	r0, r0, #63	; 0x3f
			| (mmc->csd[2] & 0xffff0000) >> 16;
3481272c:	e1860800 	orr	r0, r6, r0, lsl #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
34812730:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
34812734:	e3a06008 	mov	r6, #8
34812738:	e3a07000 	mov	r7, #0
3481273c:	ea000005 	b	34812758 <mmc_startup+0x20c>
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
			| (mmc->csd[2] & 0xc0000000) >> 30;
34812740:	e1a03f26 	lsr	r3, r6, #30
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
34812744:	e1a00b00 	lsl	r0, r0, #22
			| (mmc->csd[2] & 0xc0000000) >> 30;
34812748:	e1830a20 	orr	r0, r3, r0, lsr #20
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
3481274c:	e7e267d6 	ubfx	r6, r6, #15, #3
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
34812750:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
34812754:	e3a07000 	mov	r7, #0
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
34812758:	e3a02001 	mov	r2, #1
3481275c:	e0900002 	adds	r0, r0, r2
34812760:	e3a03000 	mov	r3, #0
34812764:	e0a11003 	adc	r1, r1, r3
34812768:	e2862002 	add	r2, r6, #2
3481276c:	eb0036ef 	bl	34820330 <__ashldi3>
	mmc->capacity *= mmc->read_bl_len;
34812770:	e0832590 	umull	r2, r3, r0, r5
34812774:	e0233195 	mla	r3, r5, r1, r3

	if (mmc->read_bl_len > 512)
34812778:	e3550c02 	cmp	r5, #512	; 0x200
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
	mmc->capacity *= mmc->read_bl_len;
3481277c:	e1c429f8 	strd	r2, [r4, #152]	; 0x98

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;
34812780:	83a03c02 	movhi	r3, #512	; 0x200
34812784:	85843088 	strhi	r3, [r4, #136]	; 0x88

	if (mmc->write_bl_len > 512)
34812788:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
3481278c:	e5942050 	ldr	r2, [r4, #80]	; 0x50
	mmc->capacity *= mmc->read_bl_len;

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;

	if (mmc->write_bl_len > 512)
34812790:	e3530c02 	cmp	r3, #512	; 0x200
		mmc->write_bl_len = 512;
34812794:	83a03c02 	movhi	r3, #512	; 0x200
34812798:	8584308c 	strhi	r3, [r4, #140]	; 0x8c

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
3481279c:	e2122b01 	ands	r2, r2, #1024	; 0x400
348127a0:	1a00000d 	bne	348127dc <mmc_startup+0x290>
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
348127a4:	e3a03015 	mov	r3, #21
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
348127a8:	e3a00007 	mov	r0, #7
348127ac:	e28d1b01 	add	r1, sp, #1024	; 0x400
		cmd.resp_type = MMC_RSP_R1;
348127b0:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
		cmd.cmdarg = mmc->rca << 16;
348127b4:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
348127b8:	e1c109bc 	strh	r0, [r1, #156]	; 0x9c
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
		err = mmc_send_cmd(mmc, &cmd, NULL);
348127bc:	e28d1e49 	add	r1, sp, #1168	; 0x490

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
348127c0:	e1a03803 	lsl	r3, r3, #16
		err = mmc_send_cmd(mmc, &cmd, NULL);
348127c4:	e1a00004 	mov	r0, r4
348127c8:	e281100c 	add	r1, r1, #12

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
348127cc:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		err = mmc_send_cmd(mmc, &cmd, NULL);
348127d0:	ebfffc0f 	bl	34811814 <mmc_send_cmd>

		if (err)
348127d4:	e2506000 	subs	r6, r0, #0
348127d8:	1a0000ed 	bne	34812b94 <mmc_startup+0x648>
	}

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
348127dc:	e3a03001 	mov	r3, #1
348127e0:	e5843090 	str	r3, [r4, #144]	; 0x90
	mmc->part_config = MMCPART_NOAVAILABLE;
348127e4:	e3e03000 	mvn	r3, #0
348127e8:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
348127ec:	e5943030 	ldr	r3, [r4, #48]	; 0x30
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
348127f0:	e28d5fa6 	add	r5, sp, #664	; 0x298
348127f4:	e2855003 	add	r5, r5, #3
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
348127f8:	e3130802 	tst	r3, #131072	; 0x20000
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
348127fc:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34812800:	1a000034 	bne	348128d8 <mmc_startup+0x38c>
34812804:	e59f23ac 	ldr	r2, [pc, #940]	; 34812bb8 <mmc_startup+0x66c>
34812808:	e1530002 	cmp	r3, r2
3481280c:	9a000031 	bls	348128d8 <mmc_startup+0x38c>
		/* check  ext_csd version and capacity */
		err = mmc_send_ext_csd(mmc, ext_csd);
34812810:	e1a00004 	mov	r0, r4
34812814:	e1a01005 	mov	r1, r5
34812818:	ebfffe34 	bl	348120f0 <mmc_send_ext_csd>
		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
3481281c:	e5d530c0 	ldrb	r3, [r5, #192]	; 0xc0
34812820:	e2700001 	rsbs	r0, r0, #1
34812824:	33a00000 	movcc	r0, #0
34812828:	e3530001 	cmp	r3, #1
3481282c:	93a00000 	movls	r0, #0
34812830:	e3500000 	cmp	r0, #0
34812834:	0a000014 	beq	3481288c <mmc_startup+0x340>
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
34812838:	e5d510d6 	ldrb	r1, [r5, #214]	; 0xd6
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
3481283c:	e5d530d5 	ldrb	r3, [r5, #213]	; 0xd5
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
34812840:	e1a01801 	lsl	r1, r1, #16
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
34812844:	e1811403 	orr	r1, r1, r3, lsl #8
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
34812848:	e5d530d4 	ldrb	r3, [r5, #212]	; 0xd4
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
3481284c:	e1811003 	orr	r1, r1, r3
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
34812850:	e5d530d7 	ldrb	r3, [r5, #215]	; 0xd7
34812854:	e1811c03 	orr	r1, r1, r3, lsl #24
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
34812858:	e1a02001 	mov	r2, r1
3481285c:	e1a03fc2 	asr	r3, r2, #31
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
			capacity *= 512;
34812860:	e1a03483 	lsl	r3, r3, #9
34812864:	e1833ba1 	orr	r3, r3, r1, lsr #23
34812868:	e1a01481 	lsl	r1, r1, #9
			if ((capacity >> 20) > 2 * 1024)
3481286c:	e1a02a21 	lsr	r2, r1, #20
34812870:	e1b00a23 	lsrs	r0, r3, #20
34812874:	e1822603 	orr	r2, r2, r3, lsl #12
34812878:	1a000001 	bne	34812884 <mmc_startup+0x338>
3481287c:	e3520b02 	cmp	r2, #2048	; 0x800
34812880:	9a000001 	bls	3481288c <mmc_startup+0x340>
				mmc->capacity = capacity;
34812884:	e5841098 	str	r1, [r4, #152]	; 0x98
34812888:	e584309c 	str	r3, [r4, #156]	; 0x9c
		/*
		 * Check whether GROUP_DEF is set, if yes, read out
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
3481288c:	e5d530af 	ldrb	r3, [r5, #175]	; 0xaf
34812890:	e3530000 	cmp	r3, #0
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
34812894:	05943068 	ldreq	r3, [r4, #104]	; 0x68
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
34812898:	15d530e0 	ldrbne	r3, [r5, #224]	; 0xe0
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
3481289c:	07e422d3 	ubfxeq	r2, r3, #5, #5
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
348128a0:	07e43553 	ubfxeq	r3, r3, #10, #5
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
348128a4:	02833001 	addeq	r3, r3, #1
				* (erase_gmul + 1);
348128a8:	02822001 	addeq	r2, r2, #1
348128ac:	00030293 	muleq	r3, r3, r2
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
348128b0:	11a03983 	lslne	r3, r3, #19
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
348128b4:	e5843090 	str	r3, [r4, #144]	; 0x90
				* (erase_gmul + 1);
		}

		/* store the partition info of emmc */
		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
348128b8:	e5d530a0 	ldrb	r3, [r5, #160]	; 0xa0
348128bc:	e3130001 	tst	r3, #1
348128c0:	1a000002 	bne	348128d0 <mmc_startup+0x384>
348128c4:	e5d530e2 	ldrb	r3, [r5, #226]	; 0xe2
348128c8:	e3530000 	cmp	r3, #0
348128cc:	0a000001 	beq	348128d8 <mmc_startup+0x38c>
		    ext_csd[EXT_CSD_BOOT_MULT])
			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
348128d0:	e5d530b3 	ldrb	r3, [r5, #179]	; 0xb3
348128d4:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	}

	if (IS_SD(mmc))
348128d8:	e5943030 	ldr	r3, [r4, #48]	; 0x30
348128dc:	e3130802 	tst	r3, #131072	; 0x20000
348128e0:	0a000002 	beq	348128f0 <mmc_startup+0x3a4>
		err = sd_change_freq(mmc);
348128e4:	e1a00004 	mov	r0, r4
348128e8:	ebfffe87 	bl	3481230c <sd_change_freq>
348128ec:	ea000001 	b	348128f8 <mmc_startup+0x3ac>
	else
		err = mmc_change_freq(mmc);
348128f0:	e1a00004 	mov	r0, r4
348128f4:	ebfffe25 	bl	34812190 <mmc_change_freq>

	if (err)
348128f8:	e3500000 	cmp	r0, #0
	}

	if (IS_SD(mmc))
		err = sd_change_freq(mmc);
	else
		err = mmc_change_freq(mmc);
348128fc:	e1a06000 	mov	r6, r0

	if (err)
34812900:	1a0000a3 	bne	34812b94 <mmc_startup+0x648>
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34812904:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34812908:	e5947050 	ldr	r7, [r4, #80]	; 0x50

	if (IS_SD(mmc)) {
3481290c:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34812910:	e0073003 	and	r3, r7, r3

	if (IS_SD(mmc)) {
34812914:	e3120802 	tst	r2, #131072	; 0x20000

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34812918:	e584304c 	str	r3, [r4, #76]	; 0x4c

	if (IS_SD(mmc)) {
3481291c:	0a000027 	beq	348129c0 <mmc_startup+0x474>
		if (mmc->card_caps & MMC_MODE_4BIT) {
34812920:	e3130c01 	tst	r3, #256	; 0x100
34812924:	0a000020 	beq	348129ac <mmc_startup+0x460>
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
34812928:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

			err = mmc_send_cmd(mmc, &cmd, NULL);
3481292c:	e28d5e49 	add	r5, sp, #1168	; 0x490
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
34812930:	e3a01037 	mov	r1, #55	; 0x37
34812934:	e28d2b01 	add	r2, sp, #1024	; 0x400
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34812938:	e285500c 	add	r5, r5, #12
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
3481293c:	e1c219bc 	strh	r1, [r2, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
34812940:	e1a03803 	lsl	r3, r3, #16
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34812944:	e3a07015 	mov	r7, #21
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34812948:	e1a00004 	mov	r0, r4
3481294c:	e1a01005 	mov	r1, r5
34812950:	e1a02006 	mov	r2, r6
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34812954:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = mmc->rca << 16;
34812958:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

			err = mmc_send_cmd(mmc, &cmd, NULL);
3481295c:	ebfffbac 	bl	34811814 <mmc_send_cmd>
			if (err)
34812960:	e3500000 	cmp	r0, #0
34812964:	1a000089 	bne	34812b90 <mmc_startup+0x644>
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
34812968:	e3a03006 	mov	r3, #6
3481296c:	e28d0b01 	add	r0, sp, #1024	; 0x400
34812970:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
34812974:	e1a01005 	mov	r1, r5
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
34812978:	e3a03002 	mov	r3, #2
			err = mmc_send_cmd(mmc, &cmd, NULL);
3481297c:	e1a00004 	mov	r0, r4
34812980:	e1a02006 	mov	r2, r6
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
34812984:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = 2;
34812988:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
			err = mmc_send_cmd(mmc, &cmd, NULL);
3481298c:	ebfffba0 	bl	34811814 <mmc_send_cmd>
			if (err)
34812990:	e3500000 	cmp	r0, #0
34812994:	1a00007d 	bne	34812b90 <mmc_startup+0x644>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812998:	e3a03004 	mov	r3, #4
3481299c:	e5843044 	str	r3, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
348129a0:	e1a00004 	mov	r0, r4
348129a4:	e5943114 	ldr	r3, [r4, #276]	; 0x114
348129a8:	e12fff33 	blx	r3
				return err;

			mmc_set_bus_width(mmc, 4);
		}

		if (mmc->card_caps & MMC_MODE_HS)
348129ac:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
348129b0:	e3130001 	tst	r3, #1
			mmc->tran_speed = 50000000;
348129b4:	159f3200 	ldrne	r3, [pc, #512]	; 34812bbc <mmc_startup+0x670>
		else
			mmc->tran_speed = 25000000;
348129b8:	059f3200 	ldreq	r3, [pc, #512]	; 34812bc0 <mmc_startup+0x674>
348129bc:	ea00003e 	b	34812abc <mmc_startup+0x570>
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
348129c0:	e7e17457 	ubfx	r7, r7, #8, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
348129c4:	e28a10d4 	add	r1, sl, #212	; 0xd4
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
348129c8:	e1a09107 	lsl	r9, r7, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
348129cc:	e285b0d4 	add	fp, r5, #212	; 0xd4
348129d0:	e58d1014 	str	r1, [sp, #20]
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
			/* Set the card to use 4 bit*/
			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
348129d4:	e1a00004 	mov	r0, r4
348129d8:	e3a01001 	mov	r1, #1
348129dc:	e3a020b7 	mov	r2, #183	; 0xb7
348129e0:	e6ef3077 	uxtb	r3, r7
348129e4:	ebfffdd4 	bl	3481213c <mmc_switch>
					EXT_CSD_BUS_WIDTH, width);

			if (err)
348129e8:	e3500000 	cmp	r0, #0
348129ec:	1a000028 	bne	34812a94 <mmc_startup+0x548>
				continue;

			if (!width) {
348129f0:	e3570000 	cmp	r7, #0
348129f4:	e5943114 	ldr	r3, [r4, #276]	; 0x114
348129f8:	1a000004 	bne	34812a10 <mmc_startup+0x4c4>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
348129fc:	e3a02001 	mov	r2, #1
34812a00:	e5842044 	str	r2, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812a04:	e1a00004 	mov	r0, r4
34812a08:	e12fff33 	blx	r3
			if (err)
				continue;

			if (!width) {
				mmc_set_bus_width(mmc, 1);
				break;
34812a0c:	ea000024 	b	34812aa4 <mmc_startup+0x558>
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812a10:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812a14:	e5849044 	str	r9, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812a18:	e12fff33 	blx	r3
				mmc_set_bus_width(mmc, 1);
				break;
			} else
				mmc_set_bus_width(mmc, 4 * width);

			err = mmc_send_ext_csd(mmc, test_csd);
34812a1c:	e1a00004 	mov	r0, r4
34812a20:	e1a0100a 	mov	r1, sl
34812a24:	ebfffdb1 	bl	348120f0 <mmc_send_ext_csd>
			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
34812a28:	e3500000 	cmp	r0, #0
34812a2c:	1a000018 	bne	34812a94 <mmc_startup+0x548>
34812a30:	e5d520a0 	ldrb	r2, [r5, #160]	; 0xa0
34812a34:	e5da30a0 	ldrb	r3, [sl, #160]	; 0xa0
34812a38:	e1520003 	cmp	r2, r3
34812a3c:	1a000014 	bne	34812a94 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
34812a40:	e5d520af 	ldrb	r2, [r5, #175]	; 0xaf
34812a44:	e5da30af 	ldrb	r3, [sl, #175]	; 0xaf
34812a48:	e1520003 	cmp	r2, r3
34812a4c:	1a000010 	bne	34812a94 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
34812a50:	e5d520c0 	ldrb	r2, [r5, #192]	; 0xc0
34812a54:	e5da30c0 	ldrb	r3, [sl, #192]	; 0xc0
34812a58:	e1520003 	cmp	r2, r3
34812a5c:	1a00000c 	bne	34812a94 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
34812a60:	e5d520e0 	ldrb	r2, [r5, #224]	; 0xe0
34812a64:	e5da30e0 	ldrb	r3, [sl, #224]	; 0xe0
34812a68:	e1520003 	cmp	r2, r3
34812a6c:	1a000008 	bne	34812a94 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
34812a70:	e1a0000b 	mov	r0, fp
34812a74:	e59d1014 	ldr	r1, [sp, #20]
34812a78:	e3a02004 	mov	r2, #4
34812a7c:	eb0027f5 	bl	3481ca58 <memcmp>
34812a80:	e3500000 	cmp	r0, #0
					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {

				mmc->card_caps |= width;
34812a84:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
34812a88:	01837007 	orreq	r7, r3, r7
34812a8c:	0584704c 	streq	r7, [r4, #76]	; 0x4c
				break;
34812a90:	0a000003 	beq	34812aa4 <mmc_startup+0x558>
		else
			mmc->tran_speed = 25000000;
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
34812a94:	e2477001 	sub	r7, r7, #1
34812a98:	e3770001 	cmn	r7, #1
34812a9c:	e2499004 	sub	r9, r9, #4
34812aa0:	1affffcb 	bne	348129d4 <mmc_startup+0x488>
				mmc->card_caps |= width;
				break;
			}
		}

		if (mmc->card_caps & MMC_MODE_HS) {
34812aa4:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34812aa8:	e3130001 	tst	r3, #1
34812aac:	0a000003 	beq	34812ac0 <mmc_startup+0x574>
			if (mmc->card_caps & MMC_MODE_HS_52MHz)
34812ab0:	e3130010 	tst	r3, #16
				mmc->tran_speed = 52000000;
34812ab4:	159f3108 	ldrne	r3, [pc, #264]	; 34812bc4 <mmc_startup+0x678>
			else
				mmc->tran_speed = 26000000;
34812ab8:	059f3108 	ldreq	r3, [pc, #264]	; 34812bc8 <mmc_startup+0x67c>
34812abc:	e5843084 	str	r3, [r4, #132]	; 0x84
		}
	}

	mmc_set_clock(mmc, mmc->tran_speed);
34812ac0:	e1a00004 	mov	r0, r4
34812ac4:	e5941084 	ldr	r1, [r4, #132]	; 0x84
34812ac8:	ebfffe8f 	bl	3481250c <mmc_set_clock>

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812acc:	e594509c 	ldr	r5, [r4, #156]	; 0x9c
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
34812ad0:	e3a03000 	mov	r3, #0
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
34812ad4:	e5941088 	ldr	r1, [r4, #136]	; 0x88
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812ad8:	e5940098 	ldr	r0, [r4, #152]	; 0x98
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
	do_div(__res, divisor);
34812adc:	e1550003 	cmp	r5, r3
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
34812ae0:	e5c430aa 	strb	r3, [r4, #170]	; 0xaa
	mmc->block_dev.type = 0;
34812ae4:	e5c430ab 	strb	r3, [r4, #171]	; 0xab
	mmc->block_dev.blksz = mmc->read_bl_len;
34812ae8:	e58410b4 	str	r1, [r4, #180]	; 0xb4
/* Wrapper for do_div(). Doesn't modify dividend and returns
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
34812aec:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
34812af0:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
	do_div(__res, divisor);
34812af4:	1a000003 	bne	34812b08 <mmc_startup+0x5bc>
34812af8:	eb0034eb 	bl	3481feac <__udivsi3>
34812afc:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
34812b00:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
34812b04:	ea000002 	b	34812b14 <mmc_startup+0x5c8>
34812b08:	e28d0e4b 	add	r0, sp, #1200	; 0x4b0
34812b0c:	e2800008 	add	r0, r0, #8
34812b10:	eb0020d8 	bl	3481ae78 <__div64_32>
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812b14:	e59d34b8 	ldr	r3, [sp, #1208]	; 0x4b8
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
34812b18:	e594c078 	ldr	ip, [r4, #120]	; 0x78

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812b1c:	e58430b0 	str	r3, [r4, #176]	; 0xb0
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
34812b20:	e5942070 	ldr	r2, [r4, #112]	; 0x70
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
34812b24:	e5d4307f 	ldrb	r3, [r4, #127]	; 0x7f
	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
34812b28:	e28400b8 	add	r0, r4, #184	; 0xb8
34812b2c:	e183340c 	orr	r3, r3, ip, lsl #8
34812b30:	e59f1094 	ldr	r1, [pc, #148]	; 34812bcc <mmc_startup+0x680>
34812b34:	e1a02422 	lsr	r2, r2, #8
34812b38:	eb002b08 	bl	3481d760 <sprintf>
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
34812b3c:	e5943074 	ldr	r3, [r4, #116]	; 0x74
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
34812b40:	e5d42070 	ldrb	r2, [r4, #112]	; 0x70
34812b44:	e7e71853 	ubfx	r1, r3, #16, #8
34812b48:	e58d1000 	str	r1, [sp]
34812b4c:	e7e71453 	ubfx	r1, r3, #8, #8
34812b50:	e58d1004 	str	r1, [sp, #4]
34812b54:	e20310ff 	and	r1, r3, #255	; 0xff
34812b58:	e58d1008 	str	r1, [sp, #8]
34812b5c:	e28400e1 	add	r0, r4, #225	; 0xe1
34812b60:	e59f1068 	ldr	r1, [pc, #104]	; 34812bd0 <mmc_startup+0x684>
34812b64:	e1a03c23 	lsr	r3, r3, #24
34812b68:	eb002afc 	bl	3481d760 <sprintf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
	sprintf(mmc->block_dev.revision, "%d.%d", mmc->cid[2] >> 28,
34812b6c:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34812b70:	e28400f6 	add	r0, r4, #246	; 0xf6
34812b74:	e1a02e23 	lsr	r2, r3, #28
34812b78:	e59f1054 	ldr	r1, [pc, #84]	; 34812bd4 <mmc_startup+0x688>
34812b7c:	e7e33c53 	ubfx	r3, r3, #24, #4
34812b80:	eb002af6 	bl	3481d760 <sprintf>
			(mmc->cid[2] >> 24) & 0xf);
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
34812b84:	e28400a0 	add	r0, r4, #160	; 0xa0
34812b88:	ebfff497 	bl	3480fdec <init_part>
#endif

	return 0;
34812b8c:	ea000000 	b	34812b94 <mmc_startup+0x648>

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
34812b90:	e1a06000 	mov	r6, r0
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
#endif

	return 0;
}
34812b94:	e1a00006 	mov	r0, r6
34812b98:	e28ddd13 	add	sp, sp, #1216	; 0x4c0
34812b9c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812ba0:	00010014 	.word	0x00010014
34812ba4:	00010022 	.word	0x00010022
34812ba8:	00010030 	.word	0x00010030
34812bac:	00010040 	.word	0x00010040
34812bb0:	00010012 	.word	0x00010012
34812bb4:	34821748 	.word	0x34821748
34812bb8:	0001003f 	.word	0x0001003f
34812bbc:	02faf080 	.word	0x02faf080
34812bc0:	017d7840 	.word	0x017d7840
34812bc4:	03197500 	.word	0x03197500
34812bc8:	018cba80 	.word	0x018cba80
34812bcc:	34827353 	.word	0x34827353
34812bd0:	34827365 	.word	0x34827365
34812bd4:	34827370 	.word	0x34827370

34812bd8 <mmc_send_if_cond>:

int mmc_send_if_cond(struct mmc *mmc)
{
34812bd8:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
34812bdc:	e3a03008 	mov	r3, #8

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
34812be0:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34812be4:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
int mmc_send_if_cond(struct mmc *mmc)
{
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
34812be8:	e1cd30b4 	strh	r3, [sp, #4]
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34812bec:	e59f3050 	ldr	r3, [pc, #80]	; 34812c44 <mmc_send_if_cond+0x6c>
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812bf0:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34812bf4:	e0023003 	and	r3, r2, r3
34812bf8:	e3530000 	cmp	r3, #0
34812bfc:	e30021aa 	movw	r2, #426	; 0x1aa
34812c00:	11a03002 	movne	r3, r2
34812c04:	03a030aa 	moveq	r3, #170	; 0xaa
34812c08:	e58d300c 	str	r3, [sp, #12]
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812c0c:	e3a02000 	mov	r2, #0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
34812c10:	e3a03015 	mov	r3, #21

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
34812c14:	e1a04000 	mov	r4, r0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
34812c18:	e58d3008 	str	r3, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34812c1c:	ebfffafc 	bl	34811814 <mmc_send_cmd>

	if (err)
34812c20:	e3500000 	cmp	r0, #0
34812c24:	1a000004 	bne	34812c3c <mmc_send_if_cond+0x64>
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
34812c28:	e5dd3010 	ldrb	r3, [sp, #16]
34812c2c:	e35300aa 	cmp	r3, #170	; 0xaa
		return UNUSABLE_ERR;
	else
		mmc->version = SD_VERSION_2;
34812c30:	059f3010 	ldreq	r3, [pc, #16]	; 34812c48 <mmc_send_if_cond+0x70>

	if (err)
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
		return UNUSABLE_ERR;
34812c34:	13e00010 	mvnne	r0, #16
	else
		mmc->version = SD_VERSION_2;
34812c38:	05843030 	streq	r3, [r4, #48]	; 0x30

	return 0;
}
34812c3c:	e28dd020 	add	sp, sp, #32
34812c40:	e8bd8010 	pop	{r4, pc}
34812c44:	00ff8000 	.word	0x00ff8000
34812c48:	00020020 	.word	0x00020020

34812c4c <mmc_register>:

int mmc_register(struct mmc *mmc)
{
	/* Setup the universal parts of the block interface just once */
	mmc->block_dev.if_type = IF_TYPE_MMC;
34812c4c:	e3a03006 	mov	r3, #6
34812c50:	e58030a0 	str	r3, [r0, #160]	; 0xa0
	mmc->block_dev.dev = cur_dev_num++;
34812c54:	e59f305c 	ldr	r3, [pc, #92]	; 34812cb8 <mmc_register+0x6c>
34812c58:	e5932000 	ldr	r2, [r3]
34812c5c:	e58020a4 	str	r2, [r0, #164]	; 0xa4
34812c60:	e2822001 	add	r2, r2, #1
34812c64:	e5832000 	str	r2, [r3]
	mmc->block_dev.removable = 1;
34812c68:	e3a03001 	mov	r3, #1
34812c6c:	e5c030ac 	strb	r3, [r0, #172]	; 0xac
	mmc->block_dev.block_read = mmc_bread;
34812c70:	e59f3044 	ldr	r3, [pc, #68]	; 34812cbc <mmc_register+0x70>
34812c74:	e5803100 	str	r3, [r0, #256]	; 0x100
	mmc->block_dev.block_write = mmc_bwrite;
34812c78:	e59f3040 	ldr	r3, [pc, #64]	; 34812cc0 <mmc_register+0x74>
34812c7c:	e5803104 	str	r3, [r0, #260]	; 0x104
	mmc->block_dev.block_erase = mmc_berase;
34812c80:	e59f303c 	ldr	r3, [pc, #60]	; 34812cc4 <mmc_register+0x78>
34812c84:	e5803108 	str	r3, [r0, #264]	; 0x108
	if (!mmc->b_max)
34812c88:	e5903120 	ldr	r3, [r0, #288]	; 0x120
34812c8c:	e3530000 	cmp	r3, #0
		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
34812c90:	030f3fff 	movweq	r3, #65535	; 0xffff
34812c94:	05803120 	streq	r3, [r0, #288]	; 0x120
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34812c98:	e59f3028 	ldr	r3, [pc, #40]	; 34812cc8 <mmc_register+0x7c>
34812c9c:	e5932004 	ldr	r2, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34812ca0:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34812ca4:	e5830004 	str	r0, [r3, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34812ca8:	e5820000 	str	r0, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34812cac:	e5802004 	str	r2, [r0, #4]
	INIT_LIST_HEAD (&mmc->link);

	list_add_tail (&mmc->link, &mmc_devices);

	return 0;
}
34812cb0:	e3a00000 	mov	r0, #0
34812cb4:	e12fff1e 	bx	lr
34812cb8:	34828de4 	.word	0x34828de4
34812cbc:	34811d74 	.word	0x34811d74
34812cc0:	34811b28 	.word	0x34811b28
34812cc4:	34811998 	.word	0x34811998
34812cc8:	3482bcd0 	.word	0x3482bcd0

34812ccc <mmc_init>:
	return &mmc->block_dev;
}
#endif

int mmc_init(struct mmc *mmc)
{
34812ccc:	e92d4038 	push	{r3, r4, r5, lr}
34812cd0:	e1a04000 	mov	r4, r0
	int err;

	if (mmc_getcd(mmc) == 0) {
34812cd4:	ebfffd68 	bl	3481227c <mmc_getcd>
34812cd8:	e3500000 	cmp	r0, #0
34812cdc:	1a000004 	bne	34812cf4 <mmc_init+0x28>
		mmc->has_init = 0;
34812ce0:	e5840034 	str	r0, [r4, #52]	; 0x34
		printf("MMC: no card present\n");
34812ce4:	e59f00b8 	ldr	r0, [pc, #184]	; 34812da4 <mmc_init+0xd8>
34812ce8:	ebffdbb2 	bl	34809bb8 <printf>
		return NO_CARD_ERR;
34812cec:	e3e0000f 	mvn	r0, #15
34812cf0:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	if (mmc->has_init)
34812cf4:	e5943034 	ldr	r3, [r4, #52]	; 0x34
34812cf8:	e3530000 	cmp	r3, #0
34812cfc:	1a000026 	bne	34812d9c <mmc_init+0xd0>
		return 0;

	err = mmc->init(mmc);
34812d00:	e5943118 	ldr	r3, [r4, #280]	; 0x118
34812d04:	e1a00004 	mov	r0, r4
34812d08:	e12fff33 	blx	r3

	if (err)
34812d0c:	e3500000 	cmp	r0, #0
34812d10:	18bd8038 	popne	{r3, r4, r5, pc}
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812d14:	e3a05001 	mov	r5, #1
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812d18:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34812d1c:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34812d20:	e5845044 	str	r5, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34812d24:	e12fff33 	blx	r3

	if (err)
		return err;

	mmc_set_bus_width(mmc, 1);
	mmc_set_clock(mmc, 1);
34812d28:	e1a00004 	mov	r0, r4
34812d2c:	e1a01005 	mov	r1, r5
34812d30:	ebfffdf5 	bl	3481250c <mmc_set_clock>

	/* Reset the Card */
	err = mmc_go_idle(mmc);
34812d34:	e1a00004 	mov	r0, r4
34812d38:	ebfffc36 	bl	34811e18 <mmc_go_idle>

	if (err)
34812d3c:	e3500000 	cmp	r0, #0
34812d40:	18bd8038 	popne	{r3, r4, r5, pc}
		return err;

	/* The internal partition reset to user partition(0) at every CMD0*/
	mmc->part_num = 0;
34812d44:	e5c40083 	strb	r0, [r4, #131]	; 0x83

	/* Test for SD version 2 */
	err = mmc_send_if_cond(mmc);
34812d48:	e1a00004 	mov	r0, r4
34812d4c:	ebffffa1 	bl	34812bd8 <mmc_send_if_cond>

	/* Now try to get the SD card's operating condition */
	err = sd_send_op_cond(mmc);
34812d50:	e1a00004 	mov	r0, r4
34812d54:	ebfffc42 	bl	34811e64 <sd_send_op_cond>

	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
34812d58:	e3700013 	cmn	r0, #19
34812d5c:	1a000007 	bne	34812d80 <mmc_init+0xb4>
		err = mmc_send_op_cond(mmc);
34812d60:	e1a00004 	mov	r0, r4
34812d64:	ebfffc90 	bl	34811fac <mmc_send_op_cond>

		if (err) {
34812d68:	e3500000 	cmp	r0, #0
34812d6c:	0a000003 	beq	34812d80 <mmc_init+0xb4>
			printf("Card did not respond to voltage select!\n");
34812d70:	e59f0030 	ldr	r0, [pc, #48]	; 34812da8 <mmc_init+0xdc>
34812d74:	ebffdb8f 	bl	34809bb8 <printf>
			return UNUSABLE_ERR;
34812d78:	e3e00010 	mvn	r0, #16
34812d7c:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	err = mmc_startup(mmc);
34812d80:	e1a00004 	mov	r0, r4
34812d84:	ebfffdf0 	bl	3481254c <mmc_startup>
	if (err)
34812d88:	e3500000 	cmp	r0, #0
		mmc->has_init = 0;
34812d8c:	13a03000 	movne	r3, #0
	else
		mmc->has_init = 1;
34812d90:	03a03001 	moveq	r3, #1
34812d94:	e5843034 	str	r3, [r4, #52]	; 0x34
34812d98:	e8bd8038 	pop	{r3, r4, r5, pc}
		printf("MMC: no card present\n");
		return NO_CARD_ERR;
	}

	if (mmc->has_init)
		return 0;
34812d9c:	e3a00000 	mov	r0, #0
	if (err)
		mmc->has_init = 0;
	else
		mmc->has_init = 1;
	return err;
}
34812da0:	e8bd8038 	pop	{r3, r4, r5, pc}
34812da4:	34827376 	.word	0x34827376
34812da8:	3482738c 	.word	0x3482738c

34812dac <mmc_get_dev>:
	return 0;
}

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
34812dac:	e92d4010 	push	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev);
34812db0:	ebfffae6 	bl	34811950 <find_mmc_device>
	if (!mmc || mmc_init(mmc))
34812db4:	e2504000 	subs	r4, r0, #0
		return NULL;
34812db8:	01a00004 	moveq	r0, r4

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
34812dbc:	08bd8010 	popeq	{r4, pc}
34812dc0:	ebffffc1 	bl	34812ccc <mmc_init>
34812dc4:	e3500000 	cmp	r0, #0
		return NULL;

	return &mmc->block_dev;
34812dc8:	028400a0 	addeq	r0, r4, #160	; 0xa0
#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
		return NULL;
34812dcc:	13a00000 	movne	r0, #0

	return &mmc->block_dev;
}
34812dd0:	e8bd8010 	pop	{r4, pc}

34812dd4 <cpu_mmc_init>:
 * signals caller to move on
 */
static int __def_mmc_init(bd_t *bis)
{
	return -1;
}
34812dd4:	e3e00000 	mvn	r0, #0
34812dd8:	e12fff1e 	bx	lr

34812ddc <print_mmc_devices>:

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
34812ddc:	e92d4070 	push	{r4, r5, r6, lr}
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34812de0:	e59f5048 	ldr	r5, [pc, #72]	; 34812e30 <print_mmc_devices+0x54>

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
34812de4:	e1a06000 	mov	r6, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34812de8:	e5954000 	ldr	r4, [r5]
34812dec:	ea00000a 	b	34812e1c <print_mmc_devices+0x40>
		m = list_entry(entry, struct mmc, link);

		printf("%s: %d", m->name, m->block_dev.dev);
34812df0:	e59f003c 	ldr	r0, [pc, #60]	; 34812e34 <print_mmc_devices+0x58>
34812df4:	e2841008 	add	r1, r4, #8
34812df8:	e59420a4 	ldr	r2, [r4, #164]	; 0xa4
34812dfc:	ebffdb6d 	bl	34809bb8 <printf>

		if (entry->next != &mmc_devices)
34812e00:	e5943000 	ldr	r3, [r4]
34812e04:	e1530005 	cmp	r3, r5
34812e08:	0a000002 	beq	34812e18 <print_mmc_devices+0x3c>
			printf("%c ", separator);
34812e0c:	e59f0024 	ldr	r0, [pc, #36]	; 34812e38 <print_mmc_devices+0x5c>
34812e10:	e1a01006 	mov	r1, r6
34812e14:	ebffdb67 	bl	34809bb8 <printf>
void print_mmc_devices(char separator)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34812e18:	e5944000 	ldr	r4, [r4]
34812e1c:	e1540005 	cmp	r4, r5
34812e20:	1afffff2 	bne	34812df0 <print_mmc_devices+0x14>

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
34812e24:	e59f0010 	ldr	r0, [pc, #16]	; 34812e3c <print_mmc_devices+0x60>
}
34812e28:	e8bd4070 	pop	{r4, r5, r6, lr}

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
34812e2c:	eaffdb61 	b	34809bb8 <printf>
34812e30:	3482bcd0 	.word	0x3482bcd0
34812e34:	348273b5 	.word	0x348273b5
34812e38:	34823a5a 	.word	0x34823a5a
34812e3c:	348264dd 	.word	0x348264dd

34812e40 <get_mmc_num>:
}

int get_mmc_num(void)
{
	return cur_dev_num;
}
34812e40:	e59f3004 	ldr	r3, [pc, #4]	; 34812e4c <get_mmc_num+0xc>
34812e44:	e5930000 	ldr	r0, [r3]
34812e48:	e12fff1e 	bx	lr
34812e4c:	34828de4 	.word	0x34828de4

34812e50 <mmc_initialize>:
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34812e50:	e59f303c 	ldr	r3, [pc, #60]	; 34812e94 <mmc_initialize+0x44>

int mmc_initialize(bd_t *bis)
{
34812e54:	e92d4010 	push	{r4, lr}
34812e58:	e5833000 	str	r3, [r3]
	list->prev = list;
34812e5c:	e5833004 	str	r3, [r3, #4]
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;
34812e60:	e59f3030 	ldr	r3, [pc, #48]	; 34812e98 <mmc_initialize+0x48>
34812e64:	e3a02000 	mov	r2, #0
34812e68:	e5832000 	str	r2, [r3]
{
	return cur_dev_num;
}

int mmc_initialize(bd_t *bis)
{
34812e6c:	e1a04000 	mov	r4, r0
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;

	if (board_mmc_init(bis) < 0)
34812e70:	ebffb7d5 	bl	34800dcc <board_mmc_init>
34812e74:	e3500000 	cmp	r0, #0
34812e78:	aa000001 	bge	34812e84 <mmc_initialize+0x34>
		cpu_mmc_init(bis);
34812e7c:	e1a00004 	mov	r0, r4
34812e80:	ebffffd3 	bl	34812dd4 <cpu_mmc_init>

	print_mmc_devices(',');
34812e84:	e3a0002c 	mov	r0, #44	; 0x2c
34812e88:	ebffffd3 	bl	34812ddc <print_mmc_devices>

	return 0;
}
34812e8c:	e3a00000 	mov	r0, #0
34812e90:	e8bd8010 	pop	{r4, pc}
34812e94:	3482bcd0 	.word	0x3482bcd0
34812e98:	34828de4 	.word	0x34828de4

34812e9c <sdhci_set_ios>:

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
34812e9c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812ea0:	e5905028 	ldr	r5, [r0, #40]	; 0x28

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
34812ea4:	e1a07000 	mov	r7, r0
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if (host->set_control_reg)
34812ea8:	e5953024 	ldr	r3, [r5, #36]	; 0x24
34812eac:	e3530000 	cmp	r3, #0
34812eb0:	0a000001 	beq	34812ebc <sdhci_set_ios+0x20>
		host->set_control_reg(host);
34812eb4:	e1a00005 	mov	r0, r5
34812eb8:	e12fff33 	blx	r3

	if (mmc->clock != host->clock)
34812ebc:	e597a048 	ldr	sl, [r7, #72]	; 0x48
34812ec0:	e5953014 	ldr	r3, [r5, #20]
34812ec4:	e15a0003 	cmp	sl, r3
34812ec8:	0a000040 	beq	34812fd0 <sdhci_set_ios+0x134>
		return COMM_ERR;
}

static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812ecc:	e5976028 	ldr	r6, [r7, #40]	; 0x28
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812ed0:	e5963004 	ldr	r3, [r6, #4]
34812ed4:	e3a02000 	mov	r2, #0
	unsigned int div, clk, timeout;

	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);

	if (clock == 0)
34812ed8:	e35a0000 	cmp	sl, #0
34812edc:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
34812ee0:	0a00003a 	beq	34812fd0 <sdhci_set_ios+0x134>
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
34812ee4:	e5d63010 	ldrb	r3, [r6, #16]
34812ee8:	e597b03c 	ldr	fp, [r7, #60]	; 0x3c
34812eec:	e3530001 	cmp	r3, #1
34812ef0:	9a00000d 	bls	34812f2c <sdhci_set_ios+0x90>
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
34812ef4:	e15b000a 	cmp	fp, sl
			div = 1;
34812ef8:	93a04001 	movls	r4, #1
	if (clock == 0)
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
34812efc:	9a000014 	bls	34812f54 <sdhci_set_ios+0xb8>
34812f00:	e3a04002 	mov	r4, #2
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
34812f04:	e30097fe 	movw	r9, #2046	; 0x7fe
				if ((mmc->f_max / div) <= clock)
34812f08:	e1a0000b 	mov	r0, fp
34812f0c:	e1a01004 	mov	r1, r4
34812f10:	eb0033e5 	bl	3481feac <__udivsi3>
34812f14:	e150000a 	cmp	r0, sl
34812f18:	9a00000d 	bls	34812f54 <sdhci_set_ios+0xb8>
	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
34812f1c:	e2844002 	add	r4, r4, #2
34812f20:	e1540009 	cmp	r4, r9
34812f24:	1afffff7 	bne	34812f08 <sdhci_set_ios+0x6c>
34812f28:	ea000009 	b	34812f54 <sdhci_set_ios+0xb8>
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
34812f2c:	e3a09008 	mov	r9, #8
34812f30:	e3a04001 	mov	r4, #1
34812f34:	e1a0000b 	mov	r0, fp
34812f38:	e1a01004 	mov	r1, r4
34812f3c:	eb0033da 	bl	3481feac <__udivsi3>
34812f40:	e150000a 	cmp	r0, sl
34812f44:	9a000002 	bls	34812f54 <sdhci_set_ios+0xb8>
					break;
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
34812f48:	e2599001 	subs	r9, r9, #1
34812f4c:	e1a04084 	lsl	r4, r4, #1
34812f50:	1afffff7 	bne	34812f34 <sdhci_set_ios+0x98>
				break;
		}
	}
	div >>= 1;

	if (host->set_clock)
34812f54:	e5963028 	ldr	r3, [r6, #40]	; 0x28
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
				break;
		}
	}
	div >>= 1;
34812f58:	e1a040a4 	lsr	r4, r4, #1

	if (host->set_clock)
34812f5c:	e3530000 	cmp	r3, #0
34812f60:	0a000002 	beq	34812f70 <sdhci_set_ios+0xd4>
		host->set_clock(host->index, div);
34812f64:	e5960020 	ldr	r0, [r6, #32]
34812f68:	e1a01004 	mov	r1, r4
34812f6c:	e12fff33 	blx	r3

	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
34812f70:	e1a03c04 	lsl	r3, r4, #24
34812f74:	e1a03823 	lsr	r3, r3, #16
	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
34812f78:	e3833001 	orr	r3, r3, #1
34812f7c:	e7e14454 	ubfx	r4, r4, #8, #2
		<< SDHCI_DIVIDER_HI_SHIFT;
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812f80:	e1834304 	orr	r4, r3, r4, lsl #6
34812f84:	e5963004 	ldr	r3, [r6, #4]
34812f88:	e1c342bc 	strh	r4, [r3, #44]	; 0x2c

	/* Wait max 20 ms */
	timeout = 20;
34812f8c:	e3a04014 	mov	r4, #20
34812f90:	ea000007 	b	34812fb4 <sdhci_set_ios+0x118>
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
34812f94:	e3540000 	cmp	r4, #0
34812f98:	1a000002 	bne	34812fa8 <sdhci_set_ios+0x10c>
			printf("Internal clock never stabilised.\n");
34812f9c:	e59f00a4 	ldr	r0, [pc, #164]	; 34813048 <sdhci_set_ios+0x1ac>
34812fa0:	ebffdb04 	bl	34809bb8 <printf>
34812fa4:	ea000009 	b	34812fd0 <sdhci_set_ios+0x134>
			return -1;
		}
		timeout--;
		udelay(1000);
34812fa8:	e3a00ffa 	mov	r0, #1000	; 0x3e8
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
			printf("Internal clock never stabilised.\n");
			return -1;
		}
		timeout--;
34812fac:	e2444001 	sub	r4, r4, #1
		udelay(1000);
34812fb0:	eb002700 	bl	3481cbb8 <udelay>
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
34812fb4:	e5963004 	ldr	r3, [r6, #4]
34812fb8:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);

	/* Wait max 20 ms */
	timeout = 20;
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
34812fbc:	e3130002 	tst	r3, #2
34812fc0:	0afffff3 	beq	34812f94 <sdhci_set_ios+0xf8>
		timeout--;
		udelay(1000);
	}

	clk |= SDHCI_CLOCK_CARD_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812fc4:	e3833004 	orr	r3, r3, #4
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812fc8:	e5962004 	ldr	r2, [r6, #4]
34812fcc:	e1c232bc 	strh	r3, [r2, #44]	; 0x2c
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
34812fd0:	e5953004 	ldr	r3, [r5, #4]
34812fd4:	e5d30028 	ldrb	r0, [r3, #40]	; 0x28
	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
34812fd8:	e5972044 	ldr	r2, [r7, #68]	; 0x44

	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
34812fdc:	e1a03000 	mov	r3, r0
	if (mmc->bus_width == 8) {
34812fe0:	e3520008 	cmp	r2, #8
34812fe4:	e5951010 	ldr	r1, [r5, #16]
34812fe8:	1a000004 	bne	34813000 <sdhci_set_ios+0x164>
		ctrl &= ~SDHCI_CTRL_4BITBUS;
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812fec:	e20110ff 	and	r1, r1, #255	; 0xff
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
		ctrl &= ~SDHCI_CTRL_4BITBUS;
34812ff0:	e3c03002 	bic	r3, r0, #2
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812ff4:	e3510001 	cmp	r1, #1
			ctrl |= SDHCI_CTRL_8BITBUS;
34812ff8:	83833020 	orrhi	r3, r3, #32
34812ffc:	ea000005 	b	34813018 <sdhci_set_ios+0x17c>
	} else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34813000:	e20110ff 	and	r1, r1, #255	; 0xff
34813004:	e3510001 	cmp	r1, #1
			ctrl &= ~SDHCI_CTRL_8BITBUS;
34813008:	83c03020 	bichi	r3, r0, #32
		if (mmc->bus_width == 4)
3481300c:	e3520004 	cmp	r2, #4
			ctrl |= SDHCI_CTRL_4BITBUS;
34813010:	03833002 	orreq	r3, r3, #2
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
34813014:	13c33002 	bicne	r3, r3, #2
	}

	if (mmc->clock > 26000000)
34813018:	e5971048 	ldr	r1, [r7, #72]	; 0x48
3481301c:	e59f2028 	ldr	r2, [pc, #40]	; 3481304c <sdhci_set_ios+0x1b0>
34813020:	e1510002 	cmp	r1, r2
		ctrl |= SDHCI_CTRL_HISPD;
	else
		ctrl &= ~SDHCI_CTRL_HISPD;

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
34813024:	e5952008 	ldr	r2, [r5, #8]
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
	}

	if (mmc->clock > 26000000)
		ctrl |= SDHCI_CTRL_HISPD;
34813028:	83833004 	orrhi	r3, r3, #4
	else
		ctrl &= ~SDHCI_CTRL_HISPD;
3481302c:	93c33004 	bicls	r3, r3, #4

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
34813030:	e3120008 	tst	r2, #8
		ctrl &= ~SDHCI_CTRL_HISPD;
34813034:	13c33004 	bicne	r3, r3, #4

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
34813038:	e6ef3073 	uxtb	r3, r3
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
3481303c:	e5952004 	ldr	r2, [r5, #4]
34813040:	e5c23028 	strb	r3, [r2, #40]	; 0x28
}
34813044:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34813048:	348273bc 	.word	0x348273bc
3481304c:	018cba80 	.word	0x018cba80

34813050 <sdhci_init>:

int sdhci_init(struct mmc *mmc)
{
34813050:	e92d4070 	push	{r4, r5, r6, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34813054:	e5904028 	ldr	r4, [r0, #40]	; 0x28

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
}

int sdhci_init(struct mmc *mmc)
{
34813058:	e1a05000 	mov	r5, r0
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
3481305c:	e5943008 	ldr	r3, [r4, #8]
34813060:	e3130001 	tst	r3, #1
34813064:	0a00000d 	beq	348130a0 <sdhci_init+0x50>
34813068:	e59f614c 	ldr	r6, [pc, #332]	; 348131bc <sdhci_init+0x16c>
3481306c:	e5963000 	ldr	r3, [r6]
34813070:	e3530000 	cmp	r3, #0
34813074:	1a000009 	bne	348130a0 <sdhci_init+0x50>
		aligned_buffer = memalign(8, 512*1024);
34813078:	e3a00008 	mov	r0, #8
3481307c:	e3a01702 	mov	r1, #524288	; 0x80000
34813080:	ebffde38 	bl	3480a968 <memalign>
		if (!aligned_buffer) {
34813084:	e3500000 	cmp	r0, #0
int sdhci_init(struct mmc *mmc)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
		aligned_buffer = memalign(8, 512*1024);
34813088:	e5860000 	str	r0, [r6]
		if (!aligned_buffer) {
3481308c:	1a000003 	bne	348130a0 <sdhci_init+0x50>
			printf("Aligned buffer alloc failed!!!");
34813090:	e59f0128 	ldr	r0, [pc, #296]	; 348131c0 <sdhci_init+0x170>
34813094:	ebffdac7 	bl	34809bb8 <printf>
			return -1;
34813098:	e3e00000 	mvn	r0, #0
3481309c:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);
348130a0:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
348130a4:	e3530000 	cmp	r3, #0
		return 0;
348130a8:	01a02003 	moveq	r2, r3
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
348130ac:	0a000010 	beq	348130f4 <sdhci_init+0xa4>
		return 0;
	if (!(x & 0xffff0000u)) {
348130b0:	e1a02823 	lsr	r2, r3, #16
348130b4:	e1a02802 	lsl	r2, r2, #16
348130b8:	e3520000 	cmp	r2, #0
		x <<= 16;
348130bc:	01a03803 	lsleq	r3, r3, #16
		r -= 16;
348130c0:	02822010 	addeq	r2, r2, #16
 * This is defined the same way as ffs.
 * Note fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.
 */
static inline int generic_fls(int x)
{
	int r = 32;
348130c4:	13a02020 	movne	r2, #32
		return 0;
	if (!(x & 0xffff0000u)) {
		x <<= 16;
		r -= 16;
	}
	if (!(x & 0xff000000u)) {
348130c8:	e31304ff 	tst	r3, #-16777216	; 0xff000000
		x <<= 8;
348130cc:	01a03403 	lsleq	r3, r3, #8
		r -= 8;
348130d0:	02422008 	subeq	r2, r2, #8
	}
	if (!(x & 0xf0000000u)) {
348130d4:	e313020f 	tst	r3, #-268435456	; 0xf0000000
		x <<= 4;
348130d8:	01a03203 	lsleq	r3, r3, #4
		r -= 4;
348130dc:	02422004 	subeq	r2, r2, #4
	}
	if (!(x & 0xc0000000u)) {
348130e0:	e3130103 	tst	r3, #-1073741824	; 0xc0000000
		x <<= 2;
348130e4:	01a03103 	lsleq	r3, r3, #2
		r -= 2;
348130e8:	02422002 	subeq	r2, r2, #2
	}
	if (!(x & 0x80000000u)) {
348130ec:	e3530000 	cmp	r3, #0
		x <<= 1;
		r -= 1;
348130f0:	a2422001 	subge	r2, r2, #1
348130f4:	e2422001 	sub	r2, r2, #1
348130f8:	e6ff2072 	uxth	r2, r2

static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
{
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
348130fc:	e30f3fff 	movw	r3, #65535	; 0xffff
34813100:	e1520003 	cmp	r2, r3
34813104:	0a00000f 	beq	34813148 <sdhci_init+0xf8>
		switch (1 << power) {
34813108:	e3a03001 	mov	r3, #1
3481310c:	e1a02213 	lsl	r2, r3, r2
34813110:	e3520701 	cmp	r2, #262144	; 0x40000
34813114:	0a000023 	beq	348131a8 <sdhci_init+0x158>
34813118:	ca000004 	bgt	34813130 <sdhci_init+0xe0>
3481311c:	e3520080 	cmp	r2, #128	; 0x80
34813120:	0a00001e 	beq	348131a0 <sdhci_init+0x150>
34813124:	e3520802 	cmp	r2, #131072	; 0x20000
34813128:	1a000006 	bne	34813148 <sdhci_init+0xf8>
3481312c:	ea00001d 	b	348131a8 <sdhci_init+0x158>
34813130:	e3520601 	cmp	r2, #1048576	; 0x100000
34813134:	0a000001 	beq	34813140 <sdhci_init+0xf0>
34813138:	e3520602 	cmp	r2, #2097152	; 0x200000
3481313c:	1a000001 	bne	34813148 <sdhci_init+0xf8>
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
			break;
		case MMC_VDD_32_33:
		case MMC_VDD_33_34:
			pwr = SDHCI_POWER_330;
34813140:	e3a0300e 	mov	r3, #14
34813144:	ea000018 	b	348131ac <sdhci_init+0x15c>
34813148:	e5943004 	ldr	r3, [r4, #4]
3481314c:	e3a02000 	mov	r2, #0
34813150:	e5c32029 	strb	r2, [r3, #41]	; 0x29
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);

	if (host->quirks & SDHCI_QUIRK_NO_CD) {
34813154:	e5943008 	ldr	r3, [r4, #8]
34813158:	e3130020 	tst	r3, #32
3481315c:	0a000008 	beq	34813184 <sdhci_init+0x134>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813160:	e5943004 	ldr	r3, [r4, #4]
34813164:	e3a020c0 	mov	r2, #192	; 0xc0
34813168:	e5832028 	str	r2, [r3, #40]	; 0x28
3481316c:	ea000000 	b	34813174 <sdhci_init+0x124>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813170:	e5943004 	ldr	r3, [r4, #4]
34813174:	e5933024 	ldr	r3, [r3, #36]	; 0x24
		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
		    (!(status & SDHCI_CARD_STATE_STABLE)) ||
34813178:	e2033807 	and	r3, r3, #458752	; 0x70000

		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
3481317c:	e3530807 	cmp	r3, #458752	; 0x70000
34813180:	1afffffa 	bne	34813170 <sdhci_init+0x120>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813184:	e5942004 	ldr	r2, [r4, #4]
34813188:	e3e03000 	mvn	r3, #0
3481318c:	e5823034 	str	r3, [r2, #52]	; 0x34
34813190:	e5942004 	ldr	r2, [r4, #4]

	/* Eable all state */
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_ENABLE);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_SIGNAL_ENABLE);

	return 0;
34813194:	e3a00000 	mov	r0, #0
34813198:	e5823038 	str	r3, [r2, #56]	; 0x38
}
3481319c:	e8bd8070 	pop	{r4, r5, r6, pc}
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
		switch (1 << power) {
		case MMC_VDD_165_195:
			pwr = SDHCI_POWER_180;
348131a0:	e3a0300a 	mov	r3, #10
348131a4:	ea000000 	b	348131ac <sdhci_init+0x15c>
			break;
		case MMC_VDD_29_30:
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
348131a8:	e3a0300c 	mov	r3, #12
	if (pwr == 0) {
		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
		return;
	}

	pwr |= SDHCI_POWER_ON;
348131ac:	e3833001 	orr	r3, r3, #1
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
348131b0:	e5942004 	ldr	r2, [r4, #4]
348131b4:	e5c23029 	strb	r3, [r2, #41]	; 0x29
348131b8:	eaffffe5 	b	34813154 <sdhci_init+0x104>
348131bc:	3482bcd8 	.word	0x3482bcd8
348131c0:	348273de 	.word	0x348273de

348131c4 <sdhci_reset.clone.9>:
#include <mmc.h>
#include <sdhci.h>

void *aligned_buffer;

static void sdhci_reset(struct sdhci_host *host, u8 mask)
348131c4:	e92d4070 	push	{r4, r5, r6, lr}
348131c8:	e1a04000 	mov	r4, r0
348131cc:	e1a05001 	mov	r5, r1
348131d0:	e5903000 	ldr	r3, [r0]
{
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
348131d4:	e3a06064 	mov	r6, #100	; 0x64
348131d8:	e5c3102f 	strb	r1, [r3, #47]	; 0x2f
348131dc:	ea000008 	b	34813204 <sdhci_reset.clone.9+0x40>
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
348131e0:	e3560000 	cmp	r6, #0
348131e4:	1a000003 	bne	348131f8 <sdhci_reset.clone.9+0x34>
			printf("Reset 0x%x never completed.\n", (int)mask);
348131e8:	e59f0028 	ldr	r0, [pc, #40]	; 34813218 <sdhci_reset.clone.9+0x54>
348131ec:	e1a01005 	mov	r1, r5
			return;
		}
		timeout--;
		udelay(1000);
	}
}
348131f0:	e8bd4070 	pop	{r4, r5, r6, lr}
	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
348131f4:	eaffda6f 	b	34809bb8 <printf>
			return;
		}
		timeout--;
		udelay(1000);
348131f8:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
			return;
		}
		timeout--;
348131fc:	e2466001 	sub	r6, r6, #1
		udelay(1000);
34813200:	eb00266c 	bl	3481cbb8 <udelay>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
34813204:	e5943000 	ldr	r3, [r4]
34813208:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
3481320c:	e1130005 	tst	r3, r5
34813210:	1afffff2 	bne	348131e0 <sdhci_reset.clone.9+0x1c>
			return;
		}
		timeout--;
		udelay(1000);
	}
}
34813214:	e8bd8070 	pop	{r4, r5, r6, pc}
34813218:	348273fd 	.word	0x348273fd

3481321c <sdhci_send_command>:
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
3481321c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34813220:	e5904028 	ldr	r4, [r0, #40]	; 0x28
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
34813224:	e1a05001 	mov	r5, r1
34813228:	e1a06002 	mov	r6, r2
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;

	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
3481322c:	e1d1a0b0 	ldrh	sl, [r1]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813230:	e5943004 	ldr	r3, [r4, #4]

	/* Wait max 10 ms */
	timeout = 10;

	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
34813234:	e35a000c 	cmp	sl, #12
34813238:	e3e02000 	mvn	r2, #0
3481323c:	e5832030 	str	r2, [r3, #48]	; 0x30
34813240:	03a0a001 	moveq	sl, #1
34813244:	13a0a003 	movne	sl, #3
34813248:	e3a0700a 	mov	r7, #10
3481324c:	ea000008 	b	34813274 <sdhci_send_command+0x58>
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
34813250:	e3570000 	cmp	r7, #0
34813254:	1a000003 	bne	34813268 <sdhci_send_command+0x4c>
			printf("Controller never released inhibit bit(s).\n");
34813258:	e59f0300 	ldr	r0, [pc, #768]	; 34813560 <sdhci_send_command+0x344>
3481325c:	ebffda55 	bl	34809bb8 <printf>
			return COMM_ERR;
34813260:	e3e00011 	mvn	r0, #17
34813264:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
		timeout--;
		udelay(1000);
34813268:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
			printf("Controller never released inhibit bit(s).\n");
			return COMM_ERR;
		}
		timeout--;
3481326c:	e2477001 	sub	r7, r7, #1
		udelay(1000);
34813270:	eb002650 	bl	3481cbb8 <udelay>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813274:	e5943004 	ldr	r3, [r4, #4]
34813278:	e5933024 	ldr	r3, [r3, #36]	; 0x24
	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
3481327c:	e11a0003 	tst	sl, r3
34813280:	1afffff2 	bne	34813250 <sdhci_send_command+0x34>
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
34813284:	e5951004 	ldr	r1, [r5, #4]
34813288:	e2113001 	ands	r3, r1, #1
3481328c:	0a000008 	beq	348132b4 <sdhci_send_command+0x98>
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34813290:	e3110002 	tst	r1, #2
		flags = SDHCI_CMD_RESP_LONG;
34813294:	13a03001 	movne	r3, #1
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34813298:	1a000002 	bne	348132a8 <sdhci_send_command+0x8c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
3481329c:	e3110008 	tst	r1, #8
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
348132a0:	13a03003 	movne	r3, #3
	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
348132a4:	0a000001 	beq	348132b0 <sdhci_send_command+0x94>
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
348132a8:	e1a02003 	mov	r2, r3
348132ac:	ea000001 	b	348132b8 <sdhci_send_command+0x9c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;
348132b0:	e3a03002 	mov	r3, #2
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
348132b4:	e3a02001 	mov	r2, #1
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;

	if (cmd->resp_type & MMC_RSP_CRC)
348132b8:	e3110004 	tst	r1, #4
		flags |= SDHCI_CMD_CRC;
348132bc:	13833008 	orrne	r3, r3, #8
	if (cmd->resp_type & MMC_RSP_OPCODE)
348132c0:	e3110010 	tst	r1, #16
		flags |= SDHCI_CMD_INDEX;
348132c4:	13833010 	orrne	r3, r3, #16
	if (data)
348132c8:	e3560000 	cmp	r6, #0
348132cc:	0a000014 	beq	34813324 <sdhci_send_command+0x108>
		flags |= SDHCI_CMD_DATA;
348132d0:	e3833020 	orr	r3, r3, #32
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
348132d4:	e5941004 	ldr	r1, [r4, #4]
348132d8:	e3a0000e 	mov	r0, #14
348132dc:	e5c1002e 	strb	r0, [r1, #46]	; 0x2e
	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
348132e0:	e9961003 	ldmib	r6, {r0, r1, ip}
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
348132e4:	e3510001 	cmp	r1, #1
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
348132e8:	e1a0ca0c 	lsl	ip, ip, #20
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
348132ec:	83a01022 	movhi	r1, #34	; 0x22
348132f0:	93a01002 	movls	r1, #2
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
348132f4:	e1a0ca2c 	lsr	ip, ip, #20
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
			mode |= SDHCI_TRNS_MULTI;

		if (data->flags == MMC_DATA_READ)
348132f8:	e3500001 	cmp	r0, #1
			mode |= SDHCI_TRNS_READ;
348132fc:	03811010 	orreq	r1, r1, #16
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
34813300:	e38cca07 	orr	ip, ip, #28672	; 0x7000
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34813304:	e5940004 	ldr	r0, [r4, #4]
34813308:	e1c0c0b4 	strh	ip, [r0, #4]
				data->blocksize),
				SDHCI_BLOCK_SIZE);
		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
3481330c:	e1d6c0b8 	ldrh	ip, [r6, #8]
34813310:	e5940004 	ldr	r0, [r4, #4]
		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
34813314:	e6ff1071 	uxth	r1, r1
34813318:	e1c0c0b6 	strh	ip, [r0, #6]
3481331c:	e5940004 	ldr	r0, [r4, #4]
34813320:	e1c010bc 	strh	r1, [r0, #12]
	}

	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
34813324:	e5950008 	ldr	r0, [r5, #8]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813328:	e5941004 	ldr	r1, [r4, #4]
#ifdef CONFIG_MMC_SDMA
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
3481332c:	e20330ff 	and	r3, r3, #255	; 0xff
34813330:	e5810008 	str	r0, [r1, #8]
34813334:	e1d510b0 	ldrh	r1, [r5]
34813338:	e1833401 	orr	r3, r3, r1, lsl #8
3481333c:	e6ff3073 	uxth	r3, r3
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34813340:	e5941004 	ldr	r1, [r4, #4]
34813344:	e1c130be 	strh	r3, [r1, #14]
	unsigned int stat = 0;
	int ret = 0;
	int trans_bytes = 0, is_aligned = 1;
	u32 mask, flags, mode;
	unsigned int timeout, start_addr = 0;
	unsigned int retry = 10000;
34813348:	e3023710 	movw	r3, #10000	; 0x2710
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
3481334c:	e5941004 	ldr	r1, [r4, #4]
34813350:	e5911030 	ldr	r1, [r1, #48]	; 0x30
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR)
34813354:	e3110902 	tst	r1, #32768	; 0x8000
34813358:	1a000005 	bne	34813374 <sdhci_send_command+0x158>
			break;
		if (--retry == 0)
3481335c:	e2533001 	subs	r3, r3, #1
34813360:	0a000005 	beq	3481337c <sdhci_send_command+0x160>
			break;
	} while ((stat & mask) != mask);
34813364:	e0020001 	and	r0, r2, r1
34813368:	e1500002 	cmp	r0, r2
3481336c:	1afffff6 	bne	3481334c <sdhci_send_command+0x130>
34813370:	ea000008 	b	34813398 <sdhci_send_command+0x17c>

	if (retry == 0) {
34813374:	e3530000 	cmp	r3, #0
34813378:	1a000006 	bne	34813398 <sdhci_send_command+0x17c>
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
3481337c:	e5943008 	ldr	r3, [r4, #8]
34813380:	e3130004 	tst	r3, #4
34813384:	1a000073 	bne	34813558 <sdhci_send_command+0x33c>
			return 0;
		else {
			printf("Timeout for status update!\n");
34813388:	e59f01d4 	ldr	r0, [pc, #468]	; 34813564 <sdhci_send_command+0x348>
3481338c:	ebffda09 	bl	34809bb8 <printf>
			return TIMEOUT;
34813390:	e3e00012 	mvn	r0, #18
34813394:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
34813398:	e3823902 	orr	r3, r2, #32768	; 0x8000
3481339c:	e0011003 	and	r1, r1, r3
348133a0:	e1510002 	cmp	r1, r2
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;
348133a4:	13e00000 	mvnne	r0, #0
			printf("Timeout for status update!\n");
			return TIMEOUT;
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
348133a8:	1a00001b 	bne	3481341c <sdhci_send_command+0x200>
}

static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
348133ac:	e5953004 	ldr	r3, [r5, #4]
348133b0:	e3130002 	tst	r3, #2
348133b4:	0a000012 	beq	34813404 <sdhci_send_command+0x1e8>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
348133b8:	e285500c 	add	r5, r5, #12
348133bc:	e3a0201c 	mov	r2, #28
348133c0:	e3a03000 	mov	r3, #0
348133c4:	e5940004 	ldr	r0, [r4, #4]
348133c8:	e7900002 	ldr	r0, [r0, r2]
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
					SDHCI_RESPONSE + (3-i)*4) << 8;
348133cc:	e1a00400 	lsl	r0, r0, #8
			if (i != 3)
348133d0:	e3530003 	cmp	r3, #3
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
348133d4:	e4850004 	str	r0, [r5], #4
					SDHCI_RESPONSE + (3-i)*4) << 8;
			if (i != 3)
348133d8:	0a000004 	beq	348133f0 <sdhci_send_command+0x1d4>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
348133dc:	e5947004 	ldr	r7, [r4, #4]
348133e0:	e242c001 	sub	ip, r2, #1
348133e4:	e7d7c00c 	ldrb	ip, [r7, ip]
				cmd->response[i] |= sdhci_readb(host,
348133e8:	e18c0000 	orr	r0, ip, r0
348133ec:	e5050004 	str	r0, [r5, #-4]
static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
348133f0:	e2833001 	add	r3, r3, #1
348133f4:	e3530004 	cmp	r3, #4
348133f8:	e2422004 	sub	r2, r2, #4
348133fc:	1afffff0 	bne	348133c4 <sdhci_send_command+0x1a8>
34813400:	ea000002 	b	34813410 <sdhci_send_command+0x1f4>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813404:	e5943004 	ldr	r3, [r4, #4]
34813408:	e5933010 	ldr	r3, [r3, #16]
			if (i != 3)
				cmd->response[i] |= sdhci_readb(host,
						SDHCI_RESPONSE + (3-i)*4-1);
		}
	} else {
		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
3481340c:	e585300c 	str	r3, [r5, #12]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813410:	e5943004 	ldr	r3, [r4, #4]
int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
	unsigned int stat = 0;
	int ret = 0;
34813414:	e3a00000 	mov	r0, #0
34813418:	e5831030 	str	r1, [r3, #48]	; 0x30
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;

	if (!ret && data)
3481341c:	e2803001 	add	r3, r0, #1
34813420:	e3560000 	cmp	r6, #0
34813424:	03a03000 	moveq	r3, #0
34813428:	12033001 	andne	r3, r3, #1
3481342c:	e3530000 	cmp	r3, #0
34813430:	0a000036 	beq	34813510 <sdhci_send_command+0x2f4>

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
34813434:	e2847004 	add	r7, r4, #4
}

static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
				unsigned int start_addr)
{
	unsigned int stat, rdy, mask, timeout, block = 0;
34813438:	e3a09000 	mov	r9, #0

	timeout = 10000;
3481343c:	e302a710 	movw	sl, #10000	; 0x2710
34813440:	e3a0b030 	mov	fp, #48	; 0x30
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813444:	e5973000 	ldr	r3, [r7]
34813448:	e5935030 	ldr	r5, [r3, #48]	; 0x30
	rdy = SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL;
	mask = SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE;
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR) {
3481344c:	e2153902 	ands	r3, r5, #32768	; 0x8000
34813450:	0a000003 	beq	34813464 <sdhci_send_command+0x248>
			printf("Error detected in status(0x%X)!\n", stat);
34813454:	e1a01005 	mov	r1, r5
34813458:	e59f0108 	ldr	r0, [pc, #264]	; 34813568 <sdhci_send_command+0x34c>
3481345c:	ebffd9d5 	bl	34809bb8 <printf>
34813460:	ea000025 	b	348134fc <sdhci_send_command+0x2e0>
			return -1;
		}
		if (stat & rdy) {
34813464:	e3150030 	tst	r5, #48	; 0x30
34813468:	0a00001b 	beq	348134dc <sdhci_send_command+0x2c0>
3481346c:	e5972000 	ldr	r2, [r7]
34813470:	e5922024 	ldr	r2, [r2, #36]	; 0x24
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
34813474:	e3120b03 	tst	r2, #3072	; 0xc00
34813478:	0a000021 	beq	34813504 <sdhci_send_command+0x2e8>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
3481347c:	e5972000 	ldr	r2, [r7]
34813480:	e582b030 	str	fp, [r2, #48]	; 0x30
34813484:	ea00000a 	b	348134b4 <sdhci_send_command+0x298>
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
		offs = data->dest + i;
		if (data->flags == MMC_DATA_READ)
34813488:	e5961004 	ldr	r1, [r6, #4]
3481348c:	e3510001 	cmp	r1, #1
34813490:	1a000003 	bne	348134a4 <sdhci_send_command+0x288>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813494:	e5971000 	ldr	r1, [r7]
34813498:	e5911020 	ldr	r1, [r1, #32]
			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
3481349c:	e7821003 	str	r1, [r2, r3]
348134a0:	ea000002 	b	348134b0 <sdhci_send_command+0x294>
		else
			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
348134a4:	e7921003 	ldr	r1, [r2, r3]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348134a8:	e5972000 	ldr	r2, [r7]
348134ac:	e5821020 	str	r1, [r2, #32]

static void sdhci_transfer_pio(struct sdhci_host *host, struct mmc_data *data)
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
348134b0:	e2833004 	add	r3, r3, #4
348134b4:	e596100c 	ldr	r1, [r6, #12]
348134b8:	e5962000 	ldr	r2, [r6]
348134bc:	e1530001 	cmp	r3, r1
348134c0:	3afffff0 	bcc	34813488 <sdhci_send_command+0x26c>
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
			if (++block >= data->blocks)
348134c4:	e5963008 	ldr	r3, [r6, #8]
348134c8:	e2899001 	add	r9, r9, #1
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
348134cc:	e0822001 	add	r2, r2, r1
			if (++block >= data->blocks)
348134d0:	e1590003 	cmp	r9, r3
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
348134d4:	e5862000 	str	r2, [r6]
			if (++block >= data->blocks)
348134d8:	2a00000b 	bcs	3481350c <sdhci_send_command+0x2f0>
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
348134dc:	e35a0000 	cmp	sl, #0
348134e0:	0a000003 	beq	348134f4 <sdhci_send_command+0x2d8>
			udelay(10);
348134e4:	e3a0000a 	mov	r0, #10
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
348134e8:	e24aa001 	sub	sl, sl, #1
			udelay(10);
348134ec:	eb0025b1 	bl	3481cbb8 <udelay>
348134f0:	ea000003 	b	34813504 <sdhci_send_command+0x2e8>
		else {
			printf("Transfer data timeout\n");
348134f4:	e59f0070 	ldr	r0, [pc, #112]	; 3481356c <sdhci_send_command+0x350>
348134f8:	ebffd9ae 	bl	34809bb8 <printf>
			return -1;
348134fc:	e3e00000 	mvn	r0, #0
34813500:	ea000002 	b	34813510 <sdhci_send_command+0x2f4>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
34813504:	e3150002 	tst	r5, #2
34813508:	0affffcd 	beq	34813444 <sdhci_send_command+0x228>
	return 0;
3481350c:	e3a00000 	mov	r0, #0
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813510:	e5943004 	ldr	r3, [r4, #4]
34813514:	e5935030 	ldr	r5, [r3, #48]	; 0x30

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813518:	e5943004 	ldr	r3, [r4, #4]
3481351c:	e3e02000 	mvn	r2, #0
	if (!ret && data)
		ret = sdhci_transfer_data(host, data, start_addr);

	stat = sdhci_readl(host, SDHCI_INT_STATUS);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	if (!ret) {
34813520:	e3500000 	cmp	r0, #0
34813524:	e5832030 	str	r2, [r3, #48]	; 0x30
34813528:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
3481352c:	e2844004 	add	r4, r4, #4
				!is_aligned && (data->flags == MMC_DATA_READ))
			memcpy(data->dest, aligned_buffer, trans_bytes);
		return 0;
	}

	sdhci_reset(host, SDHCI_RESET_CMD);
34813530:	e1a00004 	mov	r0, r4
34813534:	e3a01002 	mov	r1, #2
34813538:	ebffff21 	bl	348131c4 <sdhci_reset.clone.9>
	sdhci_reset(host, SDHCI_RESET_DATA);
3481353c:	e1a00004 	mov	r0, r4
34813540:	e3a01004 	mov	r1, #4
34813544:	ebffff1e 	bl	348131c4 <sdhci_reset.clone.9>
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
34813548:	e3150801 	tst	r5, #65536	; 0x10000
3481354c:	03e00011 	mvneq	r0, #17
34813550:	13e00012 	mvnne	r0, #18
34813554:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			break;
	} while ((stat & mask) != mask);

	if (retry == 0) {
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
			return 0;
34813558:	e3a00000 	mov	r0, #0
	sdhci_reset(host, SDHCI_RESET_DATA);
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
	else
		return COMM_ERR;
}
3481355c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34813560:	3482741a 	.word	0x3482741a
34813564:	34827445 	.word	0x34827445
34813568:	34827461 	.word	0x34827461
3481356c:	34827482 	.word	0x34827482

34813570 <add_sdhci>:

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
34813570:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34813574:	e1a05000 	mov	r5, r0
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34813578:	e3a00f4a 	mov	r0, #296	; 0x128

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
3481357c:	e1a07001 	mov	r7, r1
34813580:	e1a06002 	mov	r6, r2
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34813584:	ebffdb52 	bl	3480a2d4 <malloc>
	if (!mmc) {
34813588:	e2504000 	subs	r4, r0, #0
		printf("mmc malloc fail!\n");
3481358c:	059f0144 	ldreq	r0, [pc, #324]	; 348136d8 <add_sdhci+0x168>
{
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
	if (!mmc) {
34813590:	0a00001f 	beq	34813614 <add_sdhci+0xa4>
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
34813594:	e5845028 	str	r5, [r4, #40]	; 0x28
	host->mmc = mmc;

	sprintf(mmc->name, "%s", host->name);
34813598:	e2840008 	add	r0, r4, #8
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
	host->mmc = mmc;
3481359c:	e5854018 	str	r4, [r5, #24]

	sprintf(mmc->name, "%s", host->name);
348135a0:	e59f1134 	ldr	r1, [pc, #308]	; 348136dc <add_sdhci+0x16c>
348135a4:	e5952000 	ldr	r2, [r5]
348135a8:	eb00286c 	bl	3481d760 <sprintf>
	mmc->send_cmd = sdhci_send_command;
348135ac:	e59f312c 	ldr	r3, [pc, #300]	; 348136e0 <add_sdhci+0x170>
348135b0:	e5843110 	str	r3, [r4, #272]	; 0x110
	mmc->set_ios = sdhci_set_ios;
348135b4:	e59f3128 	ldr	r3, [pc, #296]	; 348136e4 <add_sdhci+0x174>
348135b8:	e5843114 	str	r3, [r4, #276]	; 0x114
	mmc->init = sdhci_init;
348135bc:	e59f3124 	ldr	r3, [pc, #292]	; 348136e8 <add_sdhci+0x178>
348135c0:	e5843118 	str	r3, [r4, #280]	; 0x118
	mmc->getcd = NULL;
348135c4:	e3a03000 	mov	r3, #0
348135c8:	e584311c 	str	r3, [r4, #284]	; 0x11c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348135cc:	e5953004 	ldr	r3, [r5, #4]
348135d0:	e593a040 	ldr	sl, [r3, #64]	; 0x40
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
348135d4:	e3570000 	cmp	r7, #0
		mmc->f_max = max_clk;
348135d8:	1584703c 	strne	r7, [r4, #60]	; 0x3c
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
348135dc:	1a000008 	bne	34813604 <add_sdhci+0x94>
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348135e0:	e5d53010 	ldrb	r3, [r5, #16]
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
348135e4:	e59f2100 	ldr	r2, [pc, #256]	; 348136ec <add_sdhci+0x17c>
#endif

	if (max_clk)
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348135e8:	e3530001 	cmp	r3, #1
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
348135ec:	87e7345a 	ubfxhi	r3, sl, #8, #8
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
348135f0:	97e5345a 	ubfxls	r3, sl, #8, #6
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
348135f4:	e584303c 	str	r3, [r4, #60]	; 0x3c
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
348135f8:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
348135fc:	e0030392 	mul	r3, r2, r3
34813600:	e584303c 	str	r3, [r4, #60]	; 0x3c
	}
	if (mmc->f_max == 0) {
34813604:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
34813608:	e3500000 	cmp	r0, #0
3481360c:	1a000003 	bne	34813620 <add_sdhci+0xb0>
		printf("Hardware doesn't specify base clock frequency\n");
34813610:	e59f00d8 	ldr	r0, [pc, #216]	; 348136f0 <add_sdhci+0x180>
34813614:	ebffd967 	bl	34809bb8 <printf>
		return -1;
34813618:	e3e00000 	mvn	r0, #0
3481361c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	if (min_clk)
34813620:	e3560000 	cmp	r6, #0
		mmc->f_min = min_clk;
34813624:	15846038 	strne	r6, [r4, #56]	; 0x38
	}
	if (mmc->f_max == 0) {
		printf("Hardware doesn't specify base clock frequency\n");
		return -1;
	}
	if (min_clk)
34813628:	1a000006 	bne	34813648 <add_sdhci+0xd8>
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
3481362c:	e5d53010 	ldrb	r3, [r5, #16]
34813630:	e3530001 	cmp	r3, #1
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
34813634:	91a00420 	lsrls	r0, r0, #8
		return -1;
	}
	if (min_clk)
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34813638:	9a000001 	bls	34813644 <add_sdhci+0xd4>
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
3481363c:	e30017fe 	movw	r1, #2046	; 0x7fe
34813640:	eb003219 	bl	3481feac <__udivsi3>
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
34813644:	e5840038 	str	r0, [r4, #56]	; 0x38
	}

	mmc->voltages = 0;
34813648:	e3a03000 	mov	r3, #0
	if (caps & SDHCI_CAN_VDD_330)
3481364c:	e31a0401 	tst	sl, #16777216	; 0x1000000
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
	}

	mmc->voltages = 0;
34813650:	e584302c 	str	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
34813654:	12833603 	addne	r3, r3, #3145728	; 0x300000
34813658:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_300)
3481365c:	e31a0402 	tst	sl, #33554432	; 0x2000000
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34813660:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34813664:	e2850004 	add	r0, r5, #4

	mmc->voltages = 0;
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34813668:	13833806 	orrne	r3, r3, #393216	; 0x60000
3481366c:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_180)
34813670:	e31a0301 	tst	sl, #67108864	; 0x4000000
		mmc->voltages |= MMC_VDD_165_195;
34813674:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34813678:	e3a01001 	mov	r1, #1
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
	if (caps & SDHCI_CAN_VDD_180)
		mmc->voltages |= MMC_VDD_165_195;
3481367c:	13833080 	orrne	r3, r3, #128	; 0x80
34813680:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
34813684:	e5953008 	ldr	r3, [r5, #8]
34813688:	e3130010 	tst	r3, #16
		mmc->voltages |= host->voltages;
3481368c:	1595302c 	ldrne	r3, [r5, #44]	; 0x2c
34813690:	1594202c 	ldrne	r2, [r4, #44]	; 0x2c
34813694:	11823003 	orrne	r3, r2, r3
34813698:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
3481369c:	e3003111 	movw	r3, #273	; 0x111
	if (caps & SDHCI_CAN_DO_8BIT)
348136a0:	e31a0701 	tst	sl, #262144	; 0x40000
		mmc->voltages |= MMC_VDD_165_195;

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
		mmc->voltages |= host->voltages;

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
348136a4:	e5843050 	str	r3, [r4, #80]	; 0x50
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
348136a8:	12833c02 	addne	r3, r3, #512	; 0x200
348136ac:	15843050 	strne	r3, [r4, #80]	; 0x50
	if (host->host_caps)
348136b0:	e595300c 	ldr	r3, [r5, #12]
348136b4:	e3530000 	cmp	r3, #0
		mmc->host_caps |= host->host_caps;
348136b8:	15942050 	ldrne	r2, [r4, #80]	; 0x50
348136bc:	11823003 	orrne	r3, r2, r3
348136c0:	15843050 	strne	r3, [r4, #80]	; 0x50

	sdhci_reset(host, SDHCI_RESET_ALL);
348136c4:	ebfffebe 	bl	348131c4 <sdhci_reset.clone.9>
	mmc_register(mmc);
348136c8:	e1a00004 	mov	r0, r4
348136cc:	ebfffd5e 	bl	34812c4c <mmc_register>

	return 0;
348136d0:	e3a00000 	mov	r0, #0
}
348136d4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348136d8:	34827499 	.word	0x34827499
348136dc:	34824d80 	.word	0x34824d80
348136e0:	3481321c 	.word	0x3481321c
348136e4:	34812e9c 	.word	0x34812e9c
348136e8:	34813050 	.word	0x34813050
348136ec:	000f4240 	.word	0x000f4240
348136f0:	348274ab 	.word	0x348274ab

348136f4 <s5p_sdhci_set_control_reg>:

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348136f4:	e5903004 	ldr	r3, [r0, #4]
348136f8:	e3a02803 	mov	r2, #196608	; 0x30000
348136fc:	e583208c 	str	r2, [r3, #140]	; 0x8c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813700:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 11 = 9mA
	 */
	sdhci_writel(host, SDHCI_CTRL4_DRIVE_MASK(0x3), SDHCI_CONTROL4);

	val = sdhci_readl(host, SDHCI_CONTROL2);
	val &= SDHCI_CTRL2_SELBASECLK_SHIFT;
34813704:	e2022004 	and	r2, r2, #4

	val |=	SDHCI_CTRL2_ENSTAASYNCCLR |
34813708:	e3822103 	orr	r2, r2, #-1073741824	; 0xc0000000
3481370c:	e3822c41 	orr	r2, r2, #16640	; 0x4100

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813710:	e5903004 	ldr	r3, [r0, #4]
34813714:	e5832080 	str	r2, [r3, #128]	; 0x80
34813718:	e5903004 	ldr	r3, [r0, #4]
3481371c:	e3082080 	movw	r2, #32896	; 0x8080
34813720:	e5832084 	str	r2, [r3, #132]	; 0x84
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34813724:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 00/01 = HCLK
	 * 10 = EPLL
	 * 11 = XTI or XEXTCLK
	 */
	ctrl = sdhci_readl(host, SDHCI_CONTROL2);
	ctrl &= ~SDHCI_CTRL2_SELBASECLK_MASK(0x3);
34813728:	e3c22030 	bic	r2, r2, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
3481372c:	e3822020 	orr	r2, r2, #32

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34813730:	e5903004 	ldr	r3, [r0, #4]
34813734:	e5832080 	str	r2, [r3, #128]	; 0x80
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}
34813738:	e12fff1e 	bx	lr

3481373c <s5p_sdhci_init>:

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
3481373c:	e92d4038 	push	{r3, r4, r5, lr}
34813740:	e1a04000 	mov	r4, r0
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
34813744:	e3a00030 	mov	r0, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
34813748:	e1a05001 	mov	r5, r1
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
3481374c:	ebffdae0 	bl	3480a2d4 <malloc>
	if (!host) {
34813750:	e2503000 	subs	r3, r0, #0
34813754:	1a000003 	bne	34813768 <s5p_sdhci_init+0x2c>
		printf("sdhci__host malloc fail!\n");
34813758:	e59f0058 	ldr	r0, [pc, #88]	; 348137b8 <s5p_sdhci_init+0x7c>
3481375c:	ebffd915 	bl	34809bb8 <printf>
		return 1;
34813760:	e3a00001 	mov	r0, #1
34813764:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	host->name = S5P_NAME;
34813768:	e59f204c 	ldr	r2, [pc, #76]	; 348137bc <s5p_sdhci_init+0x80>
	host->ioaddr = (void *)regbase;
3481376c:	e8830014 	stm	r3, {r2, r4}

	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
34813770:	e3a0201d 	mov	r2, #29
34813774:	e5832008 	str	r2, [r3, #8]
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
34813778:	e59f2040 	ldr	r2, [pc, #64]	; 348137c0 <s5p_sdhci_init+0x84>
3481377c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
34813780:	e1d42fbe 	ldrh	r2, [r4, #254]	; 0xfe
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
34813784:	e5832010 	str	r2, [r3, #16]

	host->set_control_reg = &s5p_sdhci_set_control_reg;
34813788:	e59f2034 	ldr	r2, [pc, #52]	; 348137c4 <s5p_sdhci_init+0x88>
	host->set_clock = set_mmc_clk;
	host->index = index;
3481378c:	e5835020 	str	r5, [r3, #32]
	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
34813790:	e5832024 	str	r2, [r3, #36]	; 0x24
	host->set_clock = set_mmc_clk;
34813794:	e59f202c 	ldr	r2, [pc, #44]	; 348137c8 <s5p_sdhci_init+0x8c>
	host->index = index;

	host->host_caps = MMC_MODE_HC;

	add_sdhci(host, 52000000, 400000);
34813798:	e59f102c 	ldr	r1, [pc, #44]	; 348137cc <s5p_sdhci_init+0x90>
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
	host->set_clock = set_mmc_clk;
3481379c:	e5832028 	str	r2, [r3, #40]	; 0x28
	host->index = index;

	host->host_caps = MMC_MODE_HC;
348137a0:	e3a02b02 	mov	r2, #2048	; 0x800
348137a4:	e583200c 	str	r2, [r3, #12]

	add_sdhci(host, 52000000, 400000);
348137a8:	e59f2020 	ldr	r2, [pc, #32]	; 348137d0 <s5p_sdhci_init+0x94>
348137ac:	ebffff6f 	bl	34813570 <add_sdhci>
	return 0;
348137b0:	e3a00000 	mov	r0, #0
}
348137b4:	e8bd8038 	pop	{r3, r4, r5, pc}
348137b8:	348274da 	.word	0x348274da
348137bc:	348274f4 	.word	0x348274f4
348137c0:	00300080 	.word	0x00300080
348137c4:	348136f4 	.word	0x348136f4
348137c8:	34801a38 	.word	0x34801a38
348137cc:	03197500 	.word	0x03197500
348137d0:	00061a80 	.word	0x00061a80

348137d4 <add_mtd_device>:

int add_mtd_device(struct mtd_info *mtd)
{
	int i;

	BUG_ON(mtd->writesize == 0);
348137d4:	e5903014 	ldr	r3, [r0, #20]
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
348137d8:	e92d4010 	push	{r4, lr}
	int i;

	BUG_ON(mtd->writesize == 0);
348137dc:	e3530000 	cmp	r3, #0
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
348137e0:	e1a04000 	mov	r4, r0
	int i;

	BUG_ON(mtd->writesize == 0);
348137e4:	1a000003 	bne	348137f8 <add_mtd_device+0x24>
348137e8:	e59f0044 	ldr	r0, [pc, #68]	; 34813834 <add_mtd_device+0x60>
348137ec:	e59f1044 	ldr	r1, [pc, #68]	; 34813838 <add_mtd_device+0x64>
348137f0:	e3a02014 	mov	r2, #20
348137f4:	ebffd8ef 	bl	34809bb8 <printf>
348137f8:	e59f203c 	ldr	r2, [pc, #60]	; 3481383c <add_mtd_device+0x68>

	for (i = 0; i < MAX_MTD_DEVICES; i++)
348137fc:	e3a03000 	mov	r3, #0
		if (!mtd_table[i]) {
34813800:	e5b20004 	ldr	r0, [r2, #4]!
34813804:	e3500000 	cmp	r0, #0
34813808:	1a000004 	bne	34813820 <add_mtd_device+0x4c>
			mtd_table[i] = mtd;
3481380c:	e59f202c 	ldr	r2, [pc, #44]	; 34813840 <add_mtd_device+0x6c>
34813810:	e7824103 	str	r4, [r2, r3, lsl #2]
			mtd->index = i;
34813814:	e5843024 	str	r3, [r4, #36]	; 0x24
			mtd->usecount = 0;
34813818:	e584009c 	str	r0, [r4, #156]	; 0x9c

			/* We _know_ we aren't being removed, because
			   our caller is still holding us here. So none
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
3481381c:	e8bd8010 	pop	{r4, pc}
{
	int i;

	BUG_ON(mtd->writesize == 0);

	for (i = 0; i < MAX_MTD_DEVICES; i++)
34813820:	e2833001 	add	r3, r3, #1
34813824:	e3530020 	cmp	r3, #32
34813828:	1afffff4 	bne	34813800 <add_mtd_device+0x2c>
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
		}

	return 1;
3481382c:	e3a00001 	mov	r0, #1
}
34813830:	e8bd8010 	pop	{r4, pc}
34813834:	34827502 	.word	0x34827502
34813838:	34827518 	.word	0x34827518
3481383c:	3482bcd8 	.word	0x3482bcd8
34813840:	3482bcdc 	.word	0x3482bcdc

34813844 <del_mtd_device>:
 */
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
34813844:	e5901024 	ldr	r1, [r0, #36]	; 0x24
34813848:	e59fc03c 	ldr	ip, [pc, #60]	; 3481388c <del_mtd_device+0x48>
 *      and notify each currently active MTD 'user' of its departure.
 *      Returns zero on success or 1 on failure, which currently will happen
 *      if the requested device does not appear to be present in the list.
 */
int del_mtd_device(struct mtd_info *mtd)
{
3481384c:	e92d4008 	push	{r3, lr}
	int ret;

	if (mtd_table[mtd->index] != mtd) {
34813850:	e79c2101 	ldr	r2, [ip, r1, lsl #2]
34813854:	e1520000 	cmp	r2, r0
34813858:	1a000009 	bne	34813884 <del_mtd_device+0x40>
		ret = -ENODEV;
	} else if (mtd->usecount) {
3481385c:	e592309c 	ldr	r3, [r2, #156]	; 0x9c
34813860:	e3530000 	cmp	r3, #0
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
	} else {
		/* No need to get a refcount on the module containing
		 * the notifier, since we hold the mtd_table_mutex */
		mtd_table[mtd->index] = NULL;
34813864:	078c3101 	streq	r3, [ip, r1, lsl #2]

		ret = 0;
34813868:	01a00003 	moveq	r0, r3
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
	} else if (mtd->usecount) {
3481386c:	08bd8008 	popeq	{r3, pc}
		printk(KERN_NOTICE "Removing MTD device #%d (%s)"
34813870:	e59f0018 	ldr	r0, [pc, #24]	; 34813890 <del_mtd_device+0x4c>
34813874:	e5922020 	ldr	r2, [r2, #32]
34813878:	ebffd8ce 	bl	34809bb8 <printf>
				" with use count %d\n",
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
3481387c:	e3e0000f 	mvn	r0, #15
34813880:	e8bd8008 	pop	{r3, pc}
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
34813884:	e3e00012 	mvn	r0, #18

		ret = 0;
	}

	return ret;
}
34813888:	e8bd8008 	pop	{r3, pc}
3481388c:	3482bcdc 	.word	0x3482bcdc
34813890:	34827522 	.word	0x34827522

34813894 <get_mtd_device>:
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
34813894:	e3710001 	cmn	r1, #1
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
34813898:	e1a03000 	mov	r3, r0
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
3481389c:	1a000008 	bne	348138c4 <get_mtd_device+0x30>
348138a0:	e59f2060 	ldr	r2, [pc, #96]	; 34813908 <get_mtd_device+0x74>
 *      table, if any.  Given an address and num == -1, search the device table
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
348138a4:	e3a00000 	mov	r0, #0
348138a8:	e2821080 	add	r1, r2, #128	; 0x80
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
			if (mtd_table[i] == mtd)
348138ac:	e5b2c004 	ldr	ip, [r2, #4]!
348138b0:	e15c0003 	cmp	ip, r3
348138b4:	01a00003 	moveq	r0, r3
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
348138b8:	e1520001 	cmp	r2, r1
348138bc:	1afffffa 	bne	348138ac <get_mtd_device+0x18>
348138c0:	ea000006 	b	348138e0 <get_mtd_device+0x4c>
			if (mtd_table[i] == mtd)
				ret = mtd_table[i];
	} else if (num < MAX_MTD_DEVICES) {
348138c4:	e351001f 	cmp	r1, #31
348138c8:	ca00000a 	bgt	348138f8 <get_mtd_device+0x64>
		ret = mtd_table[num];
348138cc:	e59f2038 	ldr	r2, [pc, #56]	; 3481390c <get_mtd_device+0x78>
348138d0:	e7920101 	ldr	r0, [r2, r1, lsl #2]
		if (mtd && mtd != ret)
348138d4:	e1530000 	cmp	r3, r0
348138d8:	13530000 	cmpne	r3, #0
348138dc:	1a000005 	bne	348138f8 <get_mtd_device+0x64>
			ret = NULL;
	}

	if (!ret)
348138e0:	e3500000 	cmp	r0, #0
		goto out_unlock;

	ret->usecount++;
348138e4:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
348138e8:	12833001 	addne	r3, r3, #1
348138ec:	1580309c 	strne	r3, [r0, #156]	; 0x9c
		ret = mtd_table[num];
		if (mtd && mtd != ret)
			ret = NULL;
	}

	if (!ret)
348138f0:	112fff1e 	bxne	lr
348138f4:	ea000001 	b	34813900 <get_mtd_device+0x6c>

	ret->usecount++;
	return ret;

out_unlock:
	return ERR_PTR(err);
348138f8:	e3e00012 	mvn	r0, #18
348138fc:	e12fff1e 	bx	lr
34813900:	e3e00012 	mvn	r0, #18
}
34813904:	e12fff1e 	bx	lr
34813908:	3482bcd8 	.word	0x3482bcd8
3481390c:	3482bcdc 	.word	0x3482bcdc

34813910 <get_mtd_device_nm>:
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34813910:	e92d4070 	push	{r4, r5, r6, lr}

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
34813914:	e59f5060 	ldr	r5, [pc, #96]	; 3481397c <get_mtd_device_nm+0x6c>
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34813918:	e1a06000 	mov	r6, r0
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
3481391c:	e3a04000 	mov	r4, #0
		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
34813920:	e5b53004 	ldr	r3, [r5, #4]!
34813924:	e3530000 	cmp	r3, #0
34813928:	0a00000c 	beq	34813960 <get_mtd_device_nm+0x50>
3481392c:	e1a00006 	mov	r0, r6
34813930:	e5931020 	ldr	r1, [r3, #32]
34813934:	eb00231c 	bl	3481c5ac <strcmp>
34813938:	e3500000 	cmp	r0, #0
3481393c:	1a000007 	bne	34813960 <get_mtd_device_nm+0x50>
			mtd = mtd_table[i];
34813940:	e59f3038 	ldr	r3, [pc, #56]	; 34813980 <get_mtd_device_nm+0x70>
34813944:	e7930104 	ldr	r0, [r3, r4, lsl #2]
			break;
		}
	}

	if (!mtd)
34813948:	e3500000 	cmp	r0, #0
		goto out_unlock;

	mtd->usecount++;
3481394c:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
34813950:	12833001 	addne	r3, r3, #1
34813954:	1580309c 	strne	r3, [r0, #156]	; 0x9c
			mtd = mtd_table[i];
			break;
		}
	}

	if (!mtd)
34813958:	18bd8070 	popne	{r4, r5, r6, pc}
3481395c:	ea000004 	b	34813974 <get_mtd_device_nm+0x64>
struct mtd_info *get_mtd_device_nm(const char *name)
{
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
34813960:	e2844001 	add	r4, r4, #1
34813964:	e3540020 	cmp	r4, #32
34813968:	1affffec 	bne	34813920 <get_mtd_device_nm+0x10>

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
3481396c:	e3e00012 	mvn	r0, #18
34813970:	e8bd8070 	pop	{r4, r5, r6, pc}
34813974:	e3e00012 	mvn	r0, #18
}
34813978:	e8bd8070 	pop	{r4, r5, r6, pc}
3481397c:	3482bcd8 	.word	0x3482bcd8
34813980:	3482bcdc 	.word	0x3482bcdc

34813984 <put_mtd_device>:

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
34813984:	e590309c 	ldr	r3, [r0, #156]	; 0x9c
34813988:	e2433001 	sub	r3, r3, #1
	BUG_ON(c < 0);
3481398c:	e3530000 	cmp	r3, #0

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
34813990:	e580309c 	str	r3, [r0, #156]	; 0x9c
	BUG_ON(c < 0);
34813994:	a12fff1e 	bxge	lr
34813998:	e59f0008 	ldr	r0, [pc, #8]	; 348139a8 <put_mtd_device+0x24>
3481399c:	e59f1008 	ldr	r1, [pc, #8]	; 348139ac <put_mtd_device+0x28>
348139a0:	e3a0208f 	mov	r2, #143	; 0x8f
348139a4:	eaffd883 	b	34809bb8 <printf>
348139a8:	34827502 	.word	0x34827502
348139ac:	34827518 	.word	0x34827518

348139b0 <part_read_user_prot_reg>:
	return res;
}

static int part_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
348139b0:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_user_prot_reg(part->master, from,
348139b4:	e59d1018 	ldr	r1, [sp, #24]
348139b8:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348139bc:	e58d1000 	str	r1, [sp]
348139c0:	e59d101c 	ldr	r1, [sp, #28]
348139c4:	e58d1004 	str	r1, [sp, #4]
348139c8:	e59d1020 	ldr	r1, [sp, #32]
348139cc:	e58d1008 	str	r1, [sp, #8]
348139d0:	e5901060 	ldr	r1, [r0, #96]	; 0x60
348139d4:	e12fff31 	blx	r1
					len, retlen, buf);
}
348139d8:	e28dd014 	add	sp, sp, #20
348139dc:	e8bd8000 	pop	{pc}

348139e0 <part_get_user_prot_info>:

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
348139e0:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
348139e4:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
348139e8:	e590305c 	ldr	r3, [r0, #92]	; 0x5c
348139ec:	e12fff33 	blx	r3
}
348139f0:	e8bd8008 	pop	{r3, pc}

348139f4 <part_read_fact_prot_reg>:

static int part_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
348139f4:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_fact_prot_reg(part->master, from,
348139f8:	e59d1018 	ldr	r1, [sp, #24]
348139fc:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813a00:	e58d1000 	str	r1, [sp]
34813a04:	e59d101c 	ldr	r1, [sp, #28]
34813a08:	e58d1004 	str	r1, [sp, #4]
34813a0c:	e59d1020 	ldr	r1, [sp, #32]
34813a10:	e58d1008 	str	r1, [sp, #8]
34813a14:	e5901058 	ldr	r1, [r0, #88]	; 0x58
34813a18:	e12fff31 	blx	r1
					len, retlen, buf);
}
34813a1c:	e28dd014 	add	sp, sp, #20
34813a20:	e8bd8000 	pop	{pc}

34813a24 <part_get_fact_prot_info>:

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34813a24:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
34813a28:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34813a2c:	e5903054 	ldr	r3, [r0, #84]	; 0x54
34813a30:	e12fff33 	blx	r3
}
34813a34:	e8bd8008 	pop	{r3, pc}

34813a38 <part_write>:

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813a38:	e92d4030 	push	{r4, r5, lr}
34813a3c:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813a40:	e5900004 	ldr	r0, [r0, #4]
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813a44:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813a48:	e3100b01 	tst	r0, #1024	; 0x400
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813a4c:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813a50:	03e0001d 	mvneq	r0, #29

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813a54:	0a00001b 	beq	34813ac8 <part_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
34813a58:	e591e00c 	ldr	lr, [r1, #12]
34813a5c:	e5910008 	ldr	r0, [r1, #8]
34813a60:	e15e0003 	cmp	lr, r3
34813a64:	8a000002 	bhi	34813a74 <part_write+0x3c>
34813a68:	1a00000a 	bne	34813a98 <part_write+0x60>
34813a6c:	e1500002 	cmp	r0, r2
34813a70:	9a000008 	bls	34813a98 <part_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
34813a74:	e092400c 	adds	r4, r2, ip
34813a78:	e2a35000 	adc	r5, r3, #0
34813a7c:	e155000e 	cmp	r5, lr
34813a80:	8a000002 	bhi	34813a90 <part_write+0x58>
34813a84:	1a000004 	bne	34813a9c <part_write+0x64>
34813a88:	e1540000 	cmp	r4, r0
34813a8c:	9a000002 	bls	34813a9c <part_write+0x64>
		len = mtd->size - to;
34813a90:	e062c000 	rsb	ip, r2, r0
34813a94:	ea000000 	b	34813a9c <part_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
34813a98:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->write(part->master, to + part->offset,
34813a9c:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813aa0:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813aa4:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34813aa8:	e58dc000 	str	ip, [sp]
34813aac:	e58d1004 	str	r1, [sp, #4]
34813ab0:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34813ab4:	e0922004 	adds	r2, r2, r4
34813ab8:	e58d1008 	str	r1, [sp, #8]
34813abc:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34813ac0:	e0a33005 	adc	r3, r3, r5
34813ac4:	e12fff31 	blx	r1
				    len, retlen, buf);
}
34813ac8:	e28dd014 	add	sp, sp, #20
34813acc:	e8bd8030 	pop	{r4, r5, pc}

34813ad0 <part_panic_write>:

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813ad0:	e92d4030 	push	{r4, r5, lr}
34813ad4:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813ad8:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813adc:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813ae0:	e3100b01 	tst	r0, #1024	; 0x400
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813ae4:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813ae8:	03e0001d 	mvneq	r0, #29

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813aec:	0a00001b 	beq	34813b60 <part_panic_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
34813af0:	e591e00c 	ldr	lr, [r1, #12]
34813af4:	e5910008 	ldr	r0, [r1, #8]
34813af8:	e15e0003 	cmp	lr, r3
34813afc:	8a000002 	bhi	34813b0c <part_panic_write+0x3c>
34813b00:	1a00000a 	bne	34813b30 <part_panic_write+0x60>
34813b04:	e1500002 	cmp	r0, r2
34813b08:	9a000008 	bls	34813b30 <part_panic_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
34813b0c:	e092400c 	adds	r4, r2, ip
34813b10:	e2a35000 	adc	r5, r3, #0
34813b14:	e155000e 	cmp	r5, lr
34813b18:	8a000002 	bhi	34813b28 <part_panic_write+0x58>
34813b1c:	1a000004 	bne	34813b34 <part_panic_write+0x64>
34813b20:	e1540000 	cmp	r4, r0
34813b24:	9a000002 	bls	34813b34 <part_panic_write+0x64>
		len = mtd->size - to;
34813b28:	e062c000 	rsb	ip, r2, r0
34813b2c:	ea000000 	b	34813b34 <part_panic_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
34813b30:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->panic_write(part->master, to + part->offset,
34813b34:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813b38:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813b3c:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34813b40:	e58dc000 	str	ip, [sp]
34813b44:	e58d1004 	str	r1, [sp, #4]
34813b48:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34813b4c:	e0922004 	adds	r2, r2, r4
34813b50:	e58d1008 	str	r1, [sp, #8]
34813b54:	e5901048 	ldr	r1, [r0, #72]	; 0x48
34813b58:	e0a33005 	adc	r3, r3, r5
34813b5c:	e12fff31 	blx	r1
				    len, retlen, buf);
}
34813b60:	e28dd014 	add	sp, sp, #20
34813b64:	e8bd8030 	pop	{r4, r5, pc}

34813b68 <part_write_oob>:

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34813b68:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813b6c:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813b70:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34813b74:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813b78:	e3100b01 	tst	r0, #1024	; 0x400
		return -EROFS;
34813b7c:	03e0001d 	mvneq	r0, #29
static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813b80:	0a00001a 	beq	34813bf0 <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
34813b84:	e591600c 	ldr	r6, [r1, #12]
34813b88:	e5910008 	ldr	r0, [r1, #8]
34813b8c:	e1560003 	cmp	r6, r3
34813b90:	8a000002 	bhi	34813ba0 <part_write_oob+0x38>
34813b94:	1a000014 	bne	34813bec <part_write_oob+0x84>
34813b98:	e1500002 	cmp	r0, r2
34813b9c:	9a000012 	bls	34813bec <part_write_oob+0x84>
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
34813ba0:	e59c4018 	ldr	r4, [ip, #24]
34813ba4:	e3540000 	cmp	r4, #0
34813ba8:	0a000007 	beq	34813bcc <part_write_oob+0x64>
34813bac:	e59c7004 	ldr	r7, [ip, #4]
34813bb0:	e0924007 	adds	r4, r2, r7
34813bb4:	e2a35000 	adc	r5, r3, #0
34813bb8:	e1550006 	cmp	r5, r6
34813bbc:	8a00000a 	bhi	34813bec <part_write_oob+0x84>
34813bc0:	1a000001 	bne	34813bcc <part_write_oob+0x64>
34813bc4:	e1540000 	cmp	r4, r0
34813bc8:	8a000007 	bhi	34813bec <part_write_oob+0x84>
		return -EINVAL;
	return part->master->write_oob(part->master, to + part->offset, ops);
34813bcc:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813bd0:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813bd4:	e58dc000 	str	ip, [sp]
34813bd8:	e0922004 	adds	r2, r2, r4
34813bdc:	e5901050 	ldr	r1, [r0, #80]	; 0x50
34813be0:	e0a33005 	adc	r3, r3, r5
34813be4:	e12fff31 	blx	r1
34813be8:	ea000000 	b	34813bf0 <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
		return -EINVAL;
34813bec:	e3e00015 	mvn	r0, #21
	return part->master->write_oob(part->master, to + part->offset, ops);
}
34813bf0:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813bf4 <part_write_user_prot_reg>:

static int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34813bf4:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->write_user_prot_reg(part->master, from,
34813bf8:	e59d1018 	ldr	r1, [sp, #24]
34813bfc:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813c00:	e58d1000 	str	r1, [sp]
34813c04:	e59d101c 	ldr	r1, [sp, #28]
34813c08:	e58d1004 	str	r1, [sp, #4]
34813c0c:	e59d1020 	ldr	r1, [sp, #32]
34813c10:	e58d1008 	str	r1, [sp, #8]
34813c14:	e5901064 	ldr	r1, [r0, #100]	; 0x64
34813c18:	e12fff31 	blx	r1
					len, retlen, buf);
}
34813c1c:	e28dd014 	add	sp, sp, #20
34813c20:	e8bd8000 	pop	{pc}

34813c24 <part_lock_user_prot_reg>:

static int part_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len)
{
34813c24:	e92d4007 	push	{r0, r1, r2, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
34813c28:	e59d1010 	ldr	r1, [sp, #16]
34813c2c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34813c30:	e58d1000 	str	r1, [sp]
34813c34:	e5901068 	ldr	r1, [r0, #104]	; 0x68
34813c38:	e12fff31 	blx	r1
}
34813c3c:	e8bd800e 	pop	{r1, r2, r3, pc}

34813c40 <part_erase>:

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34813c40:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813c44:	e5903004 	ldr	r3, [r0, #4]
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34813c48:	e1a07000 	mov	r7, r0
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813c4c:	e3130b01 	tst	r3, #1024	; 0x400
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34813c50:	e1a06001 	mov	r6, r1
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813c54:	03e0001d 	mvneq	r0, #29

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813c58:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return -EROFS;
	if (instr->addr >= mtd->size)
34813c5c:	e1c120d8 	ldrd	r2, [r1, #8]
34813c60:	e597100c 	ldr	r1, [r7, #12]
34813c64:	e1510003 	cmp	r1, r3
34813c68:	8a000003 	bhi	34813c7c <part_erase+0x3c>
34813c6c:	1a00001b 	bne	34813ce0 <part_erase+0xa0>
34813c70:	e5971008 	ldr	r1, [r7, #8]
34813c74:	e1510002 	cmp	r1, r2
34813c78:	9a000018 	bls	34813ce0 <part_erase+0xa0>
		return -EINVAL;
	instr->addr += part->offset;
34813c7c:	e1c70bd0 	ldrd	r0, [r7, #176]	; 0xb0
34813c80:	e0900002 	adds	r0, r0, r2
34813c84:	e0a11003 	adc	r1, r1, r3
34813c88:	e1c600f8 	strd	r0, [r6, #8]
	ret = part->master->erase(part->master, instr);
34813c8c:	e59700a8 	ldr	r0, [r7, #168]	; 0xa8
34813c90:	e1a01006 	mov	r1, r6
34813c94:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34813c98:	e12fff33 	blx	r3
	if (ret) {
34813c9c:	e3500000 	cmp	r0, #0
34813ca0:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
34813ca4:	e1c621d8 	ldrd	r2, [r6, #24]
34813ca8:	e3720001 	cmn	r2, #1
34813cac:	1a000001 	bne	34813cb8 <part_erase+0x78>
34813cb0:	e3730001 	cmn	r3, #1
34813cb4:	0a000003 	beq	34813cc8 <part_erase+0x88>
			instr->fail_addr -= part->offset;
34813cb8:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
34813cbc:	e0522004 	subs	r2, r2, r4
34813cc0:	e0c33005 	sbc	r3, r3, r5
34813cc4:	e1c621f8 	strd	r2, [r6, #24]
		instr->addr -= part->offset;
34813cc8:	e1c620d8 	ldrd	r2, [r6, #8]
34813ccc:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
34813cd0:	e0522004 	subs	r2, r2, r4
34813cd4:	e0c33005 	sbc	r3, r3, r5
34813cd8:	e1c620f8 	strd	r2, [r6, #8]
34813cdc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (instr->addr >= mtd->size)
		return -EINVAL;
34813ce0:	e3e00015 	mvn	r0, #21
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
			instr->fail_addr -= part->offset;
		instr->addr -= part->offset;
	}
	return ret;
}
34813ce4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34813ce8 <part_lock>:
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813ce8:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813cec:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813cf0:	e1a04002 	mov	r4, r2
34813cf4:	e0962004 	adds	r2, r6, r4
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813cf8:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813cfc:	e1a05003 	mov	r5, r3
34813d00:	e590000c 	ldr	r0, [r0, #12]
34813d04:	e0a73005 	adc	r3, r7, r5
34813d08:	e1500003 	cmp	r0, r3
34813d0c:	3a00000b 	bcc	34813d40 <part_lock+0x58>
34813d10:	1a000002 	bne	34813d20 <part_lock+0x38>
34813d14:	e5910008 	ldr	r0, [r1, #8]
34813d18:	e1500002 	cmp	r0, r2
34813d1c:	3a000007 	bcc	34813d40 <part_lock+0x58>
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
34813d20:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
34813d24:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813d28:	e1cd60f0 	strd	r6, [sp]
34813d2c:	e0922004 	adds	r2, r2, r4
34813d30:	e5901070 	ldr	r1, [r0, #112]	; 0x70
34813d34:	e0a33005 	adc	r3, r3, r5
34813d38:	e12fff31 	blx	r1
34813d3c:	ea000000 	b	34813d44 <part_lock+0x5c>

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34813d40:	e3e00015 	mvn	r0, #21
	return part->master->lock(part->master, ofs + part->offset, len);
}
34813d44:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813d48 <part_unlock>:

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813d48:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813d4c:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813d50:	e1a04002 	mov	r4, r2
34813d54:	e0962004 	adds	r2, r6, r4
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
}

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813d58:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813d5c:	e1a05003 	mov	r5, r3
34813d60:	e590000c 	ldr	r0, [r0, #12]
34813d64:	e0a73005 	adc	r3, r7, r5
34813d68:	e1500003 	cmp	r0, r3
34813d6c:	3a00000b 	bcc	34813da0 <part_unlock+0x58>
34813d70:	1a000002 	bne	34813d80 <part_unlock+0x38>
34813d74:	e5910008 	ldr	r0, [r1, #8]
34813d78:	e1500002 	cmp	r0, r2
34813d7c:	3a000007 	bcc	34813da0 <part_unlock+0x58>
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
34813d80:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
34813d84:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813d88:	e1cd60f0 	strd	r6, [sp]
34813d8c:	e0922004 	adds	r2, r2, r4
34813d90:	e5901074 	ldr	r1, [r0, #116]	; 0x74
34813d94:	e0a33005 	adc	r3, r3, r5
34813d98:	e12fff31 	blx	r1
34813d9c:	ea000000 	b	34813da4 <part_unlock+0x5c>

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34813da0:	e3e00015 	mvn	r0, #21
	return part->master->unlock(part->master, ofs + part->offset, len);
}
34813da4:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813da8 <part_sync>:

static void part_sync(struct mtd_info *mtd)
{
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34813da8:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
}

static void part_sync(struct mtd_info *mtd)
{
34813dac:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34813db0:	e590306c 	ldr	r3, [r0, #108]	; 0x6c
34813db4:	e12fff33 	blx	r3
}
34813db8:	e8bd8008 	pop	{r3, pc}

34813dbc <part_block_isbad>:

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813dbc:	e92d4038 	push	{r3, r4, r5, lr}
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34813dc0:	e1a05003 	mov	r5, r3
34813dc4:	e590300c 	ldr	r3, [r0, #12]
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813dc8:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34813dcc:	e1530005 	cmp	r3, r5
34813dd0:	e1a04002 	mov	r4, r2
34813dd4:	8a000003 	bhi	34813de8 <part_block_isbad+0x2c>
34813dd8:	1a000009 	bne	34813e04 <part_block_isbad+0x48>
34813ddc:	e5903008 	ldr	r3, [r0, #8]
34813de0:	e1530002 	cmp	r3, r2
34813de4:	9a000006 	bls	34813e04 <part_block_isbad+0x48>
		return -EINVAL;
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
34813de8:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
34813dec:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
	return part->master->block_isbad(part->master, ofs);
34813df0:	e0922004 	adds	r2, r2, r4
34813df4:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34813df8:	e0a33005 	adc	r3, r3, r5
34813dfc:	e12fff31 	blx	r1
34813e00:	e8bd8038 	pop	{r3, r4, r5, pc}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
34813e04:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}
34813e08:	e8bd8038 	pop	{r3, r4, r5, pc}

34813e0c <part_block_markbad>:
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34813e0c:	e5901004 	ldr	r1, [r0, #4]
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34813e10:	e92d4070 	push	{r4, r5, r6, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34813e14:	e3110b01 	tst	r1, #1024	; 0x400
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34813e18:	e1a06000 	mov	r6, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813e1c:	03e0001d 	mvneq	r0, #29
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34813e20:	08bd8070 	popeq	{r4, r5, r6, pc}
		return -EROFS;
	if (ofs >= mtd->size)
34813e24:	e1a05003 	mov	r5, r3
34813e28:	e596300c 	ldr	r3, [r6, #12]
34813e2c:	e1a04002 	mov	r4, r2
34813e30:	e1530005 	cmp	r3, r5
34813e34:	8a000003 	bhi	34813e48 <part_block_markbad+0x3c>
34813e38:	1a00000d 	bne	34813e74 <part_block_markbad+0x68>
34813e3c:	e5963008 	ldr	r3, [r6, #8]
34813e40:	e1530002 	cmp	r3, r2
34813e44:	9a00000a 	bls	34813e74 <part_block_markbad+0x68>
		return -EINVAL;
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
34813e48:	e59600a8 	ldr	r0, [r6, #168]	; 0xa8

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
34813e4c:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	res = part->master->block_markbad(part->master, ofs);
34813e50:	e0922004 	adds	r2, r2, r4
34813e54:	e0a33005 	adc	r3, r3, r5
34813e58:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
34813e5c:	e12fff31 	blx	r1
	if (!res)
34813e60:	e3500000 	cmp	r0, #0
		mtd->ecc_stats.badblocks++;
34813e64:	05963088 	ldreq	r3, [r6, #136]	; 0x88
34813e68:	02833001 	addeq	r3, r3, #1
34813e6c:	05863088 	streq	r3, [r6, #136]	; 0x88
34813e70:	e8bd8070 	pop	{r4, r5, r6, pc}
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
34813e74:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
	if (!res)
		mtd->ecc_stats.badblocks++;
	return res;
}
34813e78:	e8bd8070 	pop	{r4, r5, r6, pc}

34813e7c <part_read_oob>:
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813e7c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813e80:	e590500c 	ldr	r5, [r0, #12]
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813e84:	e1a04000 	mov	r4, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813e88:	e1550003 	cmp	r5, r3
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813e8c:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813e90:	e5906008 	ldr	r6, [r0, #8]
34813e94:	8a000002 	bhi	34813ea4 <part_read_oob+0x28>
34813e98:	1a00001f 	bne	34813f1c <part_read_oob+0xa0>
34813e9c:	e1560002 	cmp	r6, r2
34813ea0:	9a00001d 	bls	34813f1c <part_read_oob+0xa0>
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
34813ea4:	e59c1018 	ldr	r1, [ip, #24]
34813ea8:	e3510000 	cmp	r1, #0
34813eac:	0a000007 	beq	34813ed0 <part_read_oob+0x54>
34813eb0:	e59c7004 	ldr	r7, [ip, #4]
34813eb4:	e0920007 	adds	r0, r2, r7
34813eb8:	e2a31000 	adc	r1, r3, #0
34813ebc:	e1510005 	cmp	r1, r5
34813ec0:	8a000015 	bhi	34813f1c <part_read_oob+0xa0>
34813ec4:	1a000001 	bne	34813ed0 <part_read_oob+0x54>
34813ec8:	e1500006 	cmp	r0, r6
34813ecc:	8a000012 	bhi	34813f1c <part_read_oob+0xa0>
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);
34813ed0:	e59400a8 	ldr	r0, [r4, #168]	; 0xa8
34813ed4:	e1c46bd0 	ldrd	r6, [r4, #176]	; 0xb0
34813ed8:	e58dc000 	str	ip, [sp]
34813edc:	e0922006 	adds	r2, r2, r6
34813ee0:	e0a33007 	adc	r3, r3, r7
34813ee4:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
34813ee8:	e12fff31 	blx	r1

	if (unlikely(res)) {
34813eec:	e3500000 	cmp	r0, #0
34813ef0:	0a00000a 	beq	34813f20 <part_read_oob+0xa4>
		if (res == -EUCLEAN)
34813ef4:	e3700075 	cmn	r0, #117	; 0x75
			mtd->ecc_stats.corrected++;
34813ef8:	05943080 	ldreq	r3, [r4, #128]	; 0x80
34813efc:	02833001 	addeq	r3, r3, #1
34813f00:	05843080 	streq	r3, [r4, #128]	; 0x80
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);

	if (unlikely(res)) {
		if (res == -EUCLEAN)
34813f04:	0a000005 	beq	34813f20 <part_read_oob+0xa4>
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
34813f08:	e370004a 	cmn	r0, #74	; 0x4a
			mtd->ecc_stats.failed++;
34813f0c:	05943084 	ldreq	r3, [r4, #132]	; 0x84
34813f10:	02833001 	addeq	r3, r3, #1
34813f14:	05843084 	streq	r3, [r4, #132]	; 0x84
34813f18:	ea000000 	b	34813f20 <part_read_oob+0xa4>
	int res;

	if (from >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
34813f1c:	e3e00015 	mvn	r0, #21
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
			mtd->ecc_stats.failed++;
	}
	return res;
}
34813f20:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813f24 <part_read>:
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
34813f24:	e92d4c7f 	push	{r0, r1, r2, r3, r4, r5, r6, sl, fp, lr}
34813f28:	e1a04000 	mov	r4, r0
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
34813f2c:	e594e00c 	ldr	lr, [r4, #12]
{
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
34813f30:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8

	if (from >= mtd->size)
34813f34:	e15e0003 	cmp	lr, r3
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
34813f38:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
34813f3c:	e5905080 	ldr	r5, [r0, #128]	; 0x80
34813f40:	e5906084 	ldr	r6, [r0, #132]	; 0x84

	if (from >= mtd->size)
34813f44:	e594c008 	ldr	ip, [r4, #8]
34813f48:	8a000002 	bhi	34813f58 <part_read+0x34>
34813f4c:	1a00000a 	bne	34813f7c <part_read+0x58>
34813f50:	e15c0002 	cmp	ip, r2
34813f54:	9a000008 	bls	34813f7c <part_read+0x58>
		len = 0;
	else if (from + len > mtd->size)
34813f58:	e092a001 	adds	sl, r2, r1
34813f5c:	e2a3b000 	adc	fp, r3, #0
34813f60:	e15b000e 	cmp	fp, lr
34813f64:	8a000002 	bhi	34813f74 <part_read+0x50>
34813f68:	1a000004 	bne	34813f80 <part_read+0x5c>
34813f6c:	e15a000c 	cmp	sl, ip
34813f70:	9a000002 	bls	34813f80 <part_read+0x5c>
		len = mtd->size - from;
34813f74:	e062100c 	rsb	r1, r2, ip
34813f78:	ea000000 	b	34813f80 <part_read+0x5c>
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
		len = 0;
34813f7c:	e3a01000 	mov	r1, #0
	else if (from + len > mtd->size)
		len = mtd->size - from;
	res = part->master->read(part->master, from + part->offset,
34813f80:	e58d1000 	str	r1, [sp]
34813f84:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34813f88:	e1c4abd0 	ldrd	sl, [r4, #176]	; 0xb0
34813f8c:	e58d1004 	str	r1, [sp, #4]
34813f90:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
34813f94:	e092200a 	adds	r2, r2, sl
34813f98:	e58d1008 	str	r1, [sp, #8]
34813f9c:	e0a3300b 	adc	r3, r3, fp
34813fa0:	e5901040 	ldr	r1, [r0, #64]	; 0x40
34813fa4:	e12fff31 	blx	r1
				   len, retlen, buf);
	if (unlikely(res)) {
34813fa8:	e3500000 	cmp	r0, #0
34813fac:	0a000010 	beq	34813ff4 <part_read+0xd0>
		if (res == -EUCLEAN)
34813fb0:	e3700075 	cmn	r0, #117	; 0x75
34813fb4:	1a000006 	bne	34813fd4 <part_read+0xb0>
			mtd->ecc_stats.corrected += part->master->ecc_stats.corrected - stats.corrected;
34813fb8:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813fbc:	e5932080 	ldr	r2, [r3, #128]	; 0x80
34813fc0:	e5943080 	ldr	r3, [r4, #128]	; 0x80
34813fc4:	e0823003 	add	r3, r2, r3
34813fc8:	e0655003 	rsb	r5, r5, r3
34813fcc:	e5845080 	str	r5, [r4, #128]	; 0x80
34813fd0:	ea000007 	b	34813ff4 <part_read+0xd0>
		if (res == -EBADMSG)
34813fd4:	e370004a 	cmn	r0, #74	; 0x4a
34813fd8:	1a000005 	bne	34813ff4 <part_read+0xd0>
			mtd->ecc_stats.failed += part->master->ecc_stats.failed - stats.failed;
34813fdc:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813fe0:	e5932084 	ldr	r2, [r3, #132]	; 0x84
34813fe4:	e5943084 	ldr	r3, [r4, #132]	; 0x84
34813fe8:	e0823003 	add	r3, r2, r3
34813fec:	e0666003 	rsb	r6, r6, r3
34813ff0:	e5846084 	str	r6, [r4, #132]	; 0x84
	}
	return res;
}
34813ff4:	e28dd010 	add	sp, sp, #16
34813ff8:	e8bd8c70 	pop	{r4, r5, r6, sl, fp, pc}

34813ffc <mtd_erase_callback>:
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
	if (instr->mtd->erase == part_erase) {
34813ffc:	e5901000 	ldr	r1, [r0]
	}
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
34814000:	e92d4038 	push	{r3, r4, r5, lr}
	if (instr->mtd->erase == part_erase) {
34814004:	e5912034 	ldr	r2, [r1, #52]	; 0x34
34814008:	e59f3050 	ldr	r3, [pc, #80]	; 34814060 <mtd_erase_callback+0x64>
3481400c:	e1520003 	cmp	r2, r3
34814010:	1a00000d 	bne	3481404c <mtd_erase_callback+0x50>
		struct mtd_part *part = PART(instr->mtd);

		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
34814014:	e1c021d8 	ldrd	r2, [r0, #24]
34814018:	e3720001 	cmn	r2, #1
3481401c:	1a000001 	bne	34814028 <mtd_erase_callback+0x2c>
34814020:	e3730001 	cmn	r3, #1
34814024:	0a000003 	beq	34814038 <mtd_erase_callback+0x3c>
			instr->fail_addr -= part->offset;
34814028:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
3481402c:	e0522004 	subs	r2, r2, r4
34814030:	e0c33005 	sbc	r3, r3, r5
34814034:	e1c021f8 	strd	r2, [r0, #24]
		instr->addr -= part->offset;
34814038:	e1c020d8 	ldrd	r2, [r0, #8]
3481403c:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34814040:	e0522004 	subs	r2, r2, r4
34814044:	e0c33005 	sbc	r3, r3, r5
34814048:	e1c020f8 	strd	r2, [r0, #8]
	}
	if (instr->callback)
3481404c:	e5903030 	ldr	r3, [r0, #48]	; 0x30
34814050:	e3530000 	cmp	r3, #0
34814054:	08bd8038 	popeq	{r3, r4, r5, pc}
		instr->callback(instr);
34814058:	e12fff33 	blx	r3
3481405c:	e8bd8038 	pop	{r3, r4, r5, pc}
34814060:	34813c40 	.word	0x34813c40

34814064 <del_mtd_partitions>:
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
34814064:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34814068:	e59f7074 	ldr	r7, [pc, #116]	; 348140e4 <del_mtd_partitions+0x80>
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
3481406c:	e1a0a000 	mov	sl, r0
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34814070:	e5974000 	ldr	r4, [r7]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34814074:	e3a06000 	mov	r6, #0
34814078:	e41450bc 	ldr	r5, [r4], #-188	; 0xbc
3481407c:	e24550bc 	sub	r5, r5, #188	; 0xbc
34814080:	ea000012 	b	348140d0 <del_mtd_partitions+0x6c>
		if (slave->master == master) {
34814084:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34814088:	e153000a 	cmp	r3, sl
3481408c:	1a00000c 	bne	348140c4 <del_mtd_partitions+0x60>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34814090:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
34814094:	e59420bc 	ldr	r2, [r4, #188]	; 0xbc
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34814098:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
3481409c:	e5832000 	str	r2, [r3]
			list_del(&slave->list);
			if (slave->registered)
348140a0:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348140a4:	e58460bc 	str	r6, [r4, #188]	; 0xbc
348140a8:	e3530000 	cmp	r3, #0
	entry->prev = LIST_POISON2;
348140ac:	e58460c0 	str	r6, [r4, #192]	; 0xc0
348140b0:	0a000001 	beq	348140bc <del_mtd_partitions+0x58>
				del_mtd_device(&slave->mtd);
348140b4:	e1a00004 	mov	r0, r4
348140b8:	ebfffde1 	bl	34813844 <del_mtd_device>
			kfree(slave);
348140bc:	e1a00004 	mov	r0, r4
348140c0:	ebffd7fa 	bl	3480a0b0 <free>

int del_mtd_partitions(struct mtd_info *master)
{
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
348140c4:	e59530bc 	ldr	r3, [r5, #188]	; 0xbc
348140c8:	e1a04005 	mov	r4, r5
348140cc:	e24350bc 	sub	r5, r3, #188	; 0xbc
348140d0:	e28430bc 	add	r3, r4, #188	; 0xbc
348140d4:	e1570003 	cmp	r7, r3
348140d8:	1affffe9 	bne	34814084 <del_mtd_partitions+0x20>
				del_mtd_device(&slave->mtd);
			kfree(slave);
		}

	return 0;
}
348140dc:	e3a00000 	mov	r0, #0
348140e0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348140e4:	3482bd5c 	.word	0x3482bd5c

348140e8 <add_mtd_partitions>:
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348140e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
348140ec:	e59f35d4 	ldr	r3, [pc, #1492]	; 348146c8 <add_mtd_partitions+0x5e0>
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348140f0:	e24dd028 	sub	sp, sp, #40	; 0x28
348140f4:	e58d201c 	str	r2, [sp, #28]
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
348140f8:	e5932000 	ldr	r2, [r3]
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348140fc:	e1a04000 	mov	r4, r0
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
34814100:	e3520000 	cmp	r2, #0
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
34814104:	e1a05001 	mov	r5, r1
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34814108:	05833000 	streq	r3, [r3]
	list->prev = list;
3481410c:	05833004 	streq	r3, [r3, #4]
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
34814110:	e59f05b4 	ldr	r0, [pc, #1460]	; 348146cc <add_mtd_partitions+0x5e4>
34814114:	e59d101c 	ldr	r1, [sp, #28]
34814118:	e5942020 	ldr	r2, [r4, #32]
3481411c:	ebffd6a5 	bl	34809bb8 <printf>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
34814120:	e2855020 	add	r5, r5, #32
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
34814124:	e3a07000 	mov	r7, #0
int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
	struct mtd_part *slave;
	uint64_t cur_offset = 0;
34814128:	e3a0a000 	mov	sl, #0
3481412c:	e3a0b000 	mov	fp, #0
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
34814130:	ea00015e 	b	348146b0 <add_mtd_partitions+0x5c8>
		uint64_t cur_offset)
{
	struct mtd_part *slave;

	/* allocate the partition structure */
	slave = kzalloc(sizeof(*slave), GFP_KERNEL);
34814134:	e3a000c8 	mov	r0, #200	; 0xc8
34814138:	e3a01001 	mov	r1, #1
3481413c:	ebffd9d1 	bl	3480a888 <calloc>
	if (!slave) {
34814140:	e2506000 	subs	r6, r0, #0
34814144:	1a000006 	bne	34814164 <add_mtd_partitions+0x7c>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
34814148:	e5941020 	ldr	r1, [r4, #32]
3481414c:	e59f057c 	ldr	r0, [pc, #1404]	; 348146d0 <add_mtd_partitions+0x5e8>
34814150:	ebffd698 	bl	34809bb8 <printf>
			master->name);
		del_mtd_partitions(master);
34814154:	e1a00004 	mov	r0, r4
34814158:	ebffffc1 	bl	34814064 <del_mtd_partitions>
	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
3481415c:	e3e0000b 	mvn	r0, #11
34814160:	ea000156 	b	348146c0 <add_mtd_partitions+0x5d8>
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
34814164:	e59f055c 	ldr	r0, [pc, #1372]	; 348146c8 <add_mtd_partitions+0x5e0>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
			master->name);
		del_mtd_partitions(master);
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);
34814168:	e28630bc 	add	r3, r6, #188	; 0xbc
3481416c:	e5902000 	ldr	r2, [r0]
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	prev->next = new;
34814170:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34814174:	e5823004 	str	r3, [r2, #4]
	new->next = next;
34814178:	e58620bc 	str	r2, [r6, #188]	; 0xbc
	new->prev = prev;
3481417c:	e58600c0 	str	r0, [r6, #192]	; 0xc0

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34814180:	e5d43000 	ldrb	r3, [r4]
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
34814184:	e59f1548 	ldr	r1, [pc, #1352]	; 348146d4 <add_mtd_partitions+0x5ec>
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34814188:	e5c63000 	strb	r3, [r6]
	slave->mtd.flags = master->flags & ~part->mask_flags;
3481418c:	e5152008 	ldr	r2, [r5, #-8]
34814190:	e5943004 	ldr	r3, [r4, #4]
34814194:	e1c33002 	bic	r3, r3, r2
34814198:	e5863004 	str	r3, [r6, #4]
	slave->mtd.size = part->size;
3481419c:	e14521d8 	ldrd	r2, [r5, #-24]	; 0xffffffe8
348141a0:	e1c620f8 	strd	r2, [r6, #8]
	slave->mtd.writesize = master->writesize;
348141a4:	e5943014 	ldr	r3, [r4, #20]

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
348141a8:	e59f2528 	ldr	r2, [pc, #1320]	; 348146d8 <add_mtd_partitions+0x5f0>

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
	slave->mtd.flags = master->flags & ~part->mask_flags;
	slave->mtd.size = part->size;
	slave->mtd.writesize = master->writesize;
348141ac:	e5863014 	str	r3, [r6, #20]
	slave->mtd.oobsize = master->oobsize;
348141b0:	e5943018 	ldr	r3, [r4, #24]
348141b4:	e5863018 	str	r3, [r6, #24]
	slave->mtd.oobavail = master->oobavail;
348141b8:	e594301c 	ldr	r3, [r4, #28]
348141bc:	e586301c 	str	r3, [r6, #28]
	slave->mtd.subpage_sft = master->subpage_sft;
348141c0:	e5943090 	ldr	r3, [r4, #144]	; 0x90
348141c4:	e5863090 	str	r3, [r6, #144]	; 0x90

	slave->mtd.name = part->name;
348141c8:	e5153020 	ldr	r3, [r5, #-32]
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
348141cc:	e5861040 	str	r1, [r6, #64]	; 0x40
	slave->mtd.writesize = master->writesize;
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
348141d0:	e5863020 	str	r3, [r6, #32]
	slave->mtd.owner = master->owner;
348141d4:	e5943098 	ldr	r3, [r4, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
348141d8:	e5862044 	str	r2, [r6, #68]	; 0x44
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;
348141dc:	e5863098 	str	r3, [r6, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;

	if (master->panic_write)
348141e0:	e5943048 	ldr	r3, [r4, #72]	; 0x48
348141e4:	e3530000 	cmp	r3, #0
		slave->mtd.panic_write = part_panic_write;
348141e8:	159f34ec 	ldrne	r3, [pc, #1260]	; 348146dc <add_mtd_partitions+0x5f4>
348141ec:	15863048 	strne	r3, [r6, #72]	; 0x48

	if (master->read_oob)
348141f0:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
348141f4:	e3530000 	cmp	r3, #0
		slave->mtd.read_oob = part_read_oob;
348141f8:	159f04e0 	ldrne	r0, [pc, #1248]	; 348146e0 <add_mtd_partitions+0x5f8>
	if (master->write_oob)
348141fc:	e5943050 	ldr	r3, [r4, #80]	; 0x50

	if (master->panic_write)
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
34814200:	1586004c 	strne	r0, [r6, #76]	; 0x4c
	if (master->write_oob)
34814204:	e3530000 	cmp	r3, #0
		slave->mtd.write_oob = part_write_oob;
34814208:	159f14d4 	ldrne	r1, [pc, #1236]	; 348146e4 <add_mtd_partitions+0x5fc>
	if (master->read_user_prot_reg)
3481420c:	e5943060 	ldr	r3, [r4, #96]	; 0x60
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
34814210:	15861050 	strne	r1, [r6, #80]	; 0x50
	if (master->read_user_prot_reg)
34814214:	e3530000 	cmp	r3, #0
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
34814218:	159f24c8 	ldrne	r2, [pc, #1224]	; 348146e8 <add_mtd_partitions+0x600>
3481421c:	15862060 	strne	r2, [r6, #96]	; 0x60
	if (master->read_fact_prot_reg)
34814220:	e5943058 	ldr	r3, [r4, #88]	; 0x58
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
	slave->offset = part->offset;
34814224:	e5152010 	ldr	r2, [r5, #-16]
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
	if (master->read_user_prot_reg)
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
	if (master->read_fact_prot_reg)
34814228:	e3530000 	cmp	r3, #0
		slave->mtd.read_fact_prot_reg = part_read_fact_prot_reg;
3481422c:	159f34b8 	ldrne	r3, [pc, #1208]	; 348146ec <add_mtd_partitions+0x604>
34814230:	15863058 	strne	r3, [r6, #88]	; 0x58
	if (master->write_user_prot_reg)
34814234:	e5943064 	ldr	r3, [r4, #100]	; 0x64
34814238:	e3530000 	cmp	r3, #0
		slave->mtd.write_user_prot_reg = part_write_user_prot_reg;
3481423c:	159f34ac 	ldrne	r3, [pc, #1196]	; 348146f0 <add_mtd_partitions+0x608>
34814240:	15863064 	strne	r3, [r6, #100]	; 0x64
	if (master->lock_user_prot_reg)
34814244:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814248:	e3530000 	cmp	r3, #0
		slave->mtd.lock_user_prot_reg = part_lock_user_prot_reg;
3481424c:	159f34a0 	ldrne	r3, [pc, #1184]	; 348146f4 <add_mtd_partitions+0x60c>
34814250:	15863068 	strne	r3, [r6, #104]	; 0x68
	if (master->get_user_prot_info)
34814254:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
34814258:	e3530000 	cmp	r3, #0
		slave->mtd.get_user_prot_info = part_get_user_prot_info;
3481425c:	159f3494 	ldrne	r3, [pc, #1172]	; 348146f8 <add_mtd_partitions+0x610>
34814260:	1586305c 	strne	r3, [r6, #92]	; 0x5c
	if (master->get_fact_prot_info)
34814264:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814268:	e3530000 	cmp	r3, #0
		slave->mtd.get_fact_prot_info = part_get_fact_prot_info;
3481426c:	159f3488 	ldrne	r3, [pc, #1160]	; 348146fc <add_mtd_partitions+0x614>
34814270:	15863054 	strne	r3, [r6, #84]	; 0x54
	if (master->sync)
34814274:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814278:	e3530000 	cmp	r3, #0
		slave->mtd.sync = part_sync;
3481427c:	159f347c 	ldrne	r3, [pc, #1148]	; 34814700 <add_mtd_partitions+0x618>
34814280:	1586306c 	strne	r3, [r6, #108]	; 0x6c
	if (master->lock)
34814284:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34814288:	e3530000 	cmp	r3, #0
		slave->mtd.lock = part_lock;
3481428c:	159f3470 	ldrne	r3, [pc, #1136]	; 34814704 <add_mtd_partitions+0x61c>
34814290:	15863070 	strne	r3, [r6, #112]	; 0x70
	if (master->unlock)
34814294:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34814298:	e3530000 	cmp	r3, #0
		slave->mtd.unlock = part_unlock;
3481429c:	159f3464 	ldrne	r3, [pc, #1124]	; 34814708 <add_mtd_partitions+0x620>
348142a0:	15863074 	strne	r3, [r6, #116]	; 0x74
	if (master->block_isbad)
348142a4:	e5943078 	ldr	r3, [r4, #120]	; 0x78
348142a8:	e3530000 	cmp	r3, #0
		slave->mtd.block_isbad = part_block_isbad;
348142ac:	159f3458 	ldrne	r3, [pc, #1112]	; 3481470c <add_mtd_partitions+0x624>
348142b0:	15863078 	strne	r3, [r6, #120]	; 0x78
	if (master->block_markbad)
348142b4:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
348142b8:	e58640a8 	str	r4, [r6, #168]	; 0xa8
		slave->mtd.lock = part_lock;
	if (master->unlock)
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
348142bc:	e3530000 	cmp	r3, #0
		slave->mtd.block_markbad = part_block_markbad;
348142c0:	159f3448 	ldrne	r3, [pc, #1096]	; 34814710 <add_mtd_partitions+0x628>
348142c4:	1586307c 	strne	r3, [r6, #124]	; 0x7c
	slave->mtd.erase = part_erase;
348142c8:	e59f3444 	ldr	r3, [pc, #1092]	; 34814714 <add_mtd_partitions+0x62c>
	slave->master = master;
	slave->offset = part->offset;
	slave->index = partno;

	if (slave->offset == MTDPART_OFS_APPEND)
348142cc:	e3720001 	cmn	r2, #1
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
348142d0:	e5863034 	str	r3, [r6, #52]	; 0x34
	slave->master = master;
	slave->offset = part->offset;
348142d4:	e515300c 	ldr	r3, [r5, #-12]
348142d8:	e58620b0 	str	r2, [r6, #176]	; 0xb0
348142dc:	e58630b4 	str	r3, [r6, #180]	; 0xb4
	slave->index = partno;
348142e0:	e58670b8 	str	r7, [r6, #184]	; 0xb8

	if (slave->offset == MTDPART_OFS_APPEND)
348142e4:	1a000001 	bne	348142f0 <add_mtd_partitions+0x208>
348142e8:	e3730001 	cmn	r3, #1
		slave->offset = cur_offset;
348142ec:	01c6abf0 	strdeq	sl, [r6, #176]	; 0xb0
	if (slave->offset == MTDPART_OFS_NXTBLK) {
348142f0:	e59630b0 	ldr	r3, [r6, #176]	; 0xb0
348142f4:	e3730002 	cmn	r3, #2
348142f8:	1a000027 	bne	3481439c <add_mtd_partitions+0x2b4>
348142fc:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
34814300:	e3730001 	cmn	r3, #1
34814304:	1a000024 	bne	3481439c <add_mtd_partitions+0x2b4>
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
34814308:	e25b9000 	subs	r9, fp, #0
		slave->offset = cur_offset;
3481430c:	e1c6abf0 	strd	sl, [r6, #176]	; 0xb0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34814310:	e5941010 	ldr	r1, [r4, #16]
34814314:	e1cda2f0 	strd	sl, [sp, #32]
34814318:	1a000002 	bne	34814328 <add_mtd_partitions+0x240>
3481431c:	e1a0000a 	mov	r0, sl
34814320:	eb002f5c 	bl	34820098 <__aeabi_uidivmod>
34814324:	ea000002 	b	34814334 <add_mtd_partitions+0x24c>
34814328:	e28d0020 	add	r0, sp, #32
3481432c:	eb001ad1 	bl	3481ae78 <__div64_32>
34814330:	e1a01000 	mov	r1, r0

	if (slave->offset == MTDPART_OFS_APPEND)
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
34814334:	e3510000 	cmp	r1, #0
34814338:	0a000017 	beq	3481439c <add_mtd_partitions+0x2b4>
	void (*put_device) (struct mtd_info *mtd);
};

static inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	do_div(sz, mtd->erasesize);
3481433c:	e3590000 	cmp	r9, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34814340:	e5941010 	ldr	r1, [r4, #16]
34814344:	e1cda2f0 	strd	sl, [sp, #32]
34814348:	1a000004 	bne	34814360 <add_mtd_partitions+0x278>
3481434c:	e1a0000a 	mov	r0, sl
34814350:	eb002ed5 	bl	3481feac <__udivsi3>
34814354:	e58d9024 	str	r9, [sp, #36]	; 0x24
34814358:	e58d0020 	str	r0, [sp, #32]
3481435c:	ea000001 	b	34814368 <add_mtd_partitions+0x280>
34814360:	e28d0020 	add	r0, sp, #32
34814364:	eb001ac3 	bl	3481ae78 <__div64_32>
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
			/* Round up to next erasesize */
			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
34814368:	e59d2020 	ldr	r2, [sp, #32]
3481436c:	e5943010 	ldr	r3, [r4, #16]
34814370:	e2822001 	add	r2, r2, #1
34814374:	e0020293 	mul	r2, r3, r2
34814378:	e3a03000 	mov	r3, #0
3481437c:	e58620b0 	str	r2, [r6, #176]	; 0xb0
34814380:	e58630b4 	str	r3, [r6, #180]	; 0xb4
			printk(KERN_NOTICE "Moving partition %d: "
34814384:	e59f038c 	ldr	r0, [pc, #908]	; 34814718 <add_mtd_partitions+0x630>
34814388:	e88d000c 	stm	sp, {r2, r3}
3481438c:	e1a01007 	mov	r1, r7
34814390:	e1a0200a 	mov	r2, sl
34814394:	e1a0300b 	mov	r3, fp
34814398:	ebffd606 	bl	34809bb8 <printf>
			       "0x%012llx -> 0x%012llx\n", partno,
			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
3481439c:	e5962008 	ldr	r2, [r6, #8]
348143a0:	e596300c 	ldr	r3, [r6, #12]
348143a4:	e1923003 	orrs	r3, r2, r3
348143a8:	1a000004 	bne	348143c0 <add_mtd_partitions+0x2d8>
		slave->mtd.size = master->size - slave->offset;
348143ac:	e1c400d8 	ldrd	r0, [r4, #8]
348143b0:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
348143b4:	e0500002 	subs	r0, r0, r2
348143b8:	e0c11003 	sbc	r1, r1, r3
348143bc:	e1c600f8 	strd	r0, [r6, #8]

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);
348143c0:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
		slave->mtd.size = master->size - slave->offset;

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
348143c4:	e1c620d8 	ldrd	r2, [r6, #8]
348143c8:	e092200a 	adds	r2, r2, sl
348143cc:	e0a3300b 	adc	r3, r3, fp
348143d0:	e1cd20f0 	strd	r2, [sp]
348143d4:	e5963020 	ldr	r3, [r6, #32]
348143d8:	e1a0200a 	mov	r2, sl
348143dc:	e58d3008 	str	r3, [sp, #8]
348143e0:	e59f0334 	ldr	r0, [pc, #820]	; 3481471c <add_mtd_partitions+0x634>
348143e4:	e1a0300b 	mov	r3, fp
348143e8:	ebffd5f2 	bl	34809bb8 <printf>
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);

	/* let's do some sanity checks */
	if (slave->offset >= master->size) {
348143ec:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
348143f0:	e1c400d8 	ldrd	r0, [r4, #8]
348143f4:	e151000b 	cmp	r1, fp
348143f8:	8a00000a 	bhi	34814428 <add_mtd_partitions+0x340>
348143fc:	1a000001 	bne	34814408 <add_mtd_partitions+0x320>
34814400:	e150000a 	cmp	r0, sl
34814404:	8a000007 	bhi	34814428 <add_mtd_partitions+0x340>
		/* let's register it anyway to preserve ordering */
		slave->offset = 0;
34814408:	e3a02000 	mov	r2, #0
3481440c:	e3a03000 	mov	r3, #0
34814410:	e1c62bf0 	strd	r2, [r6, #176]	; 0xb0
		slave->mtd.size = 0;
34814414:	e1c620f8 	strd	r2, [r6, #8]
		printk(KERN_ERR"mtd: partition \"%s\" is out of reach -- disabled\n",
34814418:	e5151020 	ldr	r1, [r5, #-32]
3481441c:	e59f02fc 	ldr	r0, [pc, #764]	; 34814720 <add_mtd_partitions+0x638>
34814420:	ebffd5e4 	bl	34809bb8 <printf>
34814424:	ea000092 	b	34814674 <add_mtd_partitions+0x58c>
			part->name);
		goto out_register;
	}
	if (slave->offset + slave->mtd.size > master->size) {
34814428:	e1c620d8 	ldrd	r2, [r6, #8]
3481442c:	e092200a 	adds	r2, r2, sl
34814430:	e0a3300b 	adc	r3, r3, fp
34814434:	e1530001 	cmp	r3, r1
34814438:	8a000002 	bhi	34814448 <add_mtd_partitions+0x360>
3481443c:	1a000009 	bne	34814468 <add_mtd_partitions+0x380>
34814440:	e1520000 	cmp	r2, r0
34814444:	9a000007 	bls	34814468 <add_mtd_partitions+0x380>
		slave->mtd.size = master->size - slave->offset;
34814448:	e050000a 	subs	r0, r0, sl
3481444c:	e0c1100b 	sbc	r1, r1, fp
34814450:	e1c600f8 	strd	r0, [r6, #8]
		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
34814454:	e1cd00f0 	strd	r0, [sp]
34814458:	e5942020 	ldr	r2, [r4, #32]
3481445c:	e59f02c0 	ldr	r0, [pc, #704]	; 34814724 <add_mtd_partitions+0x63c>
34814460:	e5151020 	ldr	r1, [r5, #-32]
34814464:	ebffd5d3 	bl	34809bb8 <printf>
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
34814468:	e594a02c 	ldr	sl, [r4, #44]	; 0x2c
3481446c:	e35a0001 	cmp	sl, #1
34814470:	da000033 	ble	34814544 <add_mtd_partitions+0x45c>
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
34814474:	e1c60bd0 	ldrd	r0, [r6, #176]	; 0xb0
34814478:	e1c620d8 	ldrd	r2, [r6, #8]
3481447c:	e1cd01f0 	strd	r0, [sp, #16]
34814480:	e0922000 	adds	r2, r2, r0
		struct mtd_erase_region_info *regions = master->eraseregions;
34814484:	e3a00000 	mov	r0, #0
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
34814488:	e0a33001 	adc	r3, r3, r1
		struct mtd_erase_region_info *regions = master->eraseregions;
3481448c:	e594c030 	ldr	ip, [r4, #48]	; 0x30

		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
34814490:	e1a01000 	mov	r1, r0
34814494:	ea000003 	b	348144a8 <add_mtd_partitions+0x3c0>
34814498:	e2811001 	add	r1, r1, #1
3481449c:	e151000a 	cmp	r1, sl
348144a0:	e2800018 	add	r0, r0, #24
348144a4:	aa000009 	bge	348144d0 <add_mtd_partitions+0x3e8>
348144a8:	e08c9000 	add	r9, ip, r0
348144ac:	e5999004 	ldr	r9, [r9, #4]
348144b0:	e59db014 	ldr	fp, [sp, #20]
348144b4:	e159000b 	cmp	r9, fp
348144b8:	8a000004 	bhi	348144d0 <add_mtd_partitions+0x3e8>
348144bc:	1afffff5 	bne	34814498 <add_mtd_partitions+0x3b0>
348144c0:	e79c9000 	ldr	r9, [ip, r0]
348144c4:	e59db010 	ldr	fp, [sp, #16]
348144c8:	e159000b 	cmp	r9, fp
348144cc:	9afffff1 	bls	34814498 <add_mtd_partitions+0x3b0>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
348144d0:	e3a09018 	mov	r9, #24
		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
			;
		/* The loop searched for the region _behind_ the first one */
		i--;
348144d4:	e2410001 	sub	r0, r1, #1
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
348144d8:	e021c199 	mla	r1, r9, r1, ip
348144dc:	ea000005 	b	348144f8 <add_mtd_partitions+0x410>
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
			if (slave->mtd.erasesize < regions[i].erasesize) {
348144e0:	e511c010 	ldr	ip, [r1, #-16]
348144e4:	e5969010 	ldr	r9, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
348144e8:	e2800001 	add	r0, r0, #1
			if (slave->mtd.erasesize < regions[i].erasesize) {
348144ec:	e159000c 	cmp	r9, ip
				slave->mtd.erasesize = regions[i].erasesize;
348144f0:	3586c010 	strcc	ip, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
348144f4:	e2811018 	add	r1, r1, #24
348144f8:	e150000a 	cmp	r0, sl
348144fc:	aa000006 	bge	3481451c <add_mtd_partitions+0x434>
34814500:	e511c014 	ldr	ip, [r1, #-20]
34814504:	e15c0003 	cmp	ip, r3
34814508:	3afffff4 	bcc	348144e0 <add_mtd_partitions+0x3f8>
3481450c:	1a000002 	bne	3481451c <add_mtd_partitions+0x434>
34814510:	e511c018 	ldr	ip, [r1, #-24]
34814514:	e15c0002 	cmp	ip, r2
34814518:	3afffff0 	bcc	348144e0 <add_mtd_partitions+0x3f8>
			if (slave->mtd.erasesize < regions[i].erasesize) {
				slave->mtd.erasesize = regions[i].erasesize;
			}
		}
		BUG_ON(slave->mtd.erasesize == 0);
3481451c:	e5963010 	ldr	r3, [r6, #16]
34814520:	e3530000 	cmp	r3, #0
34814524:	1a000008 	bne	3481454c <add_mtd_partitions+0x464>
34814528:	e59f01f8 	ldr	r0, [pc, #504]	; 34814728 <add_mtd_partitions+0x640>
3481452c:	e59f11f8 	ldr	r1, [pc, #504]	; 3481472c <add_mtd_partitions+0x644>
34814530:	e300218a 	movw	r2, #394	; 0x18a
34814534:	e59f31f4 	ldr	r3, [pc, #500]	; 34814730 <add_mtd_partitions+0x648>
34814538:	ebffd59e 	bl	34809bb8 <printf>
3481453c:	e59f01f0 	ldr	r0, [pc, #496]	; 34814734 <add_mtd_partitions+0x64c>
34814540:	eb00248f 	bl	3481d784 <panic>
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
34814544:	e5943010 	ldr	r3, [r4, #16]
34814548:	e5863010 	str	r3, [r6, #16]
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
3481454c:	e5963004 	ldr	r3, [r6, #4]
34814550:	e3130b01 	tst	r3, #1024	; 0x400
34814554:	0a000013 	beq	348145a8 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
34814558:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
3481455c:	e59600b0 	ldr	r0, [r6, #176]	; 0xb0
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
34814560:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34814564:	e5961010 	ldr	r1, [r6, #16]
34814568:	e58d0020 	str	r0, [sp, #32]
3481456c:	e58d3024 	str	r3, [sp, #36]	; 0x24
34814570:	1a000001 	bne	3481457c <add_mtd_partitions+0x494>
34814574:	eb002ec7 	bl	34820098 <__aeabi_uidivmod>
34814578:	ea000002 	b	34814588 <add_mtd_partitions+0x4a0>
3481457c:	e28d0020 	add	r0, sp, #32
34814580:	eb001a3c 	bl	3481ae78 <__div64_32>
34814584:	e1a01000 	mov	r1, r0
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34814588:	e3510000 	cmp	r1, #0
3481458c:	0a000005 	beq	348145a8 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
34814590:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
34814594:	e59f019c 	ldr	r0, [pc, #412]	; 34814738 <add_mtd_partitions+0x650>
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
34814598:	e3c33b01 	bic	r3, r3, #1024	; 0x400
3481459c:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
348145a0:	e5151020 	ldr	r1, [r5, #-32]
348145a4:	ebffd583 	bl	34809bb8 <printf>
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
348145a8:	e5963004 	ldr	r3, [r6, #4]
348145ac:	e3130b01 	tst	r3, #1024	; 0x400
348145b0:	0a000013 	beq	34814604 <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
348145b4:	e596300c 	ldr	r3, [r6, #12]
348145b8:	e5960008 	ldr	r0, [r6, #8]
348145bc:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
348145c0:	e5961010 	ldr	r1, [r6, #16]
348145c4:	e58d0020 	str	r0, [sp, #32]
348145c8:	e58d3024 	str	r3, [sp, #36]	; 0x24
348145cc:	1a000001 	bne	348145d8 <add_mtd_partitions+0x4f0>
348145d0:	eb002eb0 	bl	34820098 <__aeabi_uidivmod>
348145d4:	ea000002 	b	348145e4 <add_mtd_partitions+0x4fc>
348145d8:	e28d0020 	add	r0, sp, #32
348145dc:	eb001a25 	bl	3481ae78 <__div64_32>
348145e0:	e1a01000 	mov	r1, r0
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
348145e4:	e3510000 	cmp	r1, #0
348145e8:	0a000005 	beq	34814604 <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
348145ec:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
348145f0:	e59f0144 	ldr	r0, [pc, #324]	; 3481473c <add_mtd_partitions+0x654>
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
348145f4:	e3c33b01 	bic	r3, r3, #1024	; 0x400
348145f8:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
348145fc:	e5151020 	ldr	r1, [r5, #-32]
34814600:	ebffd56c 	bl	34809bb8 <printf>
			part->name);
	}

	slave->mtd.ecclayout = master->ecclayout;
34814604:	e5943028 	ldr	r3, [r4, #40]	; 0x28
34814608:	e5863028 	str	r3, [r6, #40]	; 0x28
	if (master->block_isbad) {
3481460c:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34814610:	e3530000 	cmp	r3, #0
34814614:	13a0a000 	movne	sl, #0
34814618:	13a0b000 	movne	fp, #0
3481461c:	1a00000d 	bne	34814658 <add_mtd_partitions+0x570>
34814620:	ea000013 	b	34814674 <add_mtd_partitions+0x58c>
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
						offs + slave->offset))
34814624:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
34814628:	e092200a 	adds	r2, r2, sl
3481462c:	e0a3300b 	adc	r3, r3, fp
34814630:	e5941078 	ldr	r1, [r4, #120]	; 0x78
34814634:	e1a00004 	mov	r0, r4
34814638:	e12fff31 	blx	r1
3481463c:	e3500000 	cmp	r0, #0
						offs + slave->offset))
				slave->mtd.ecc_stats.badblocks++;
34814640:	15963088 	ldrne	r3, [r6, #136]	; 0x88
34814644:	12833001 	addne	r3, r3, #1
34814648:	15863088 	strne	r3, [r6, #136]	; 0x88
			offs += slave->mtd.erasesize;
3481464c:	e5963010 	ldr	r3, [r6, #16]
34814650:	e09aa003 	adds	sl, sl, r3
34814654:	e2abb000 	adc	fp, fp, #0

	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
34814658:	e596300c 	ldr	r3, [r6, #12]
3481465c:	e153000b 	cmp	r3, fp
34814660:	8affffef 	bhi	34814624 <add_mtd_partitions+0x53c>
34814664:	1a000002 	bne	34814674 <add_mtd_partitions+0x58c>
34814668:	e5963008 	ldr	r3, [r6, #8]
3481466c:	e153000a 	cmp	r3, sl
34814670:	8affffeb 	bhi	34814624 <add_mtd_partitions+0x53c>
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
34814674:	e5953000 	ldr	r3, [r5]
34814678:	e3530000 	cmp	r3, #0
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
3481467c:	15836000 	strne	r6, [r3]
		slave->registered = 0;
34814680:	13a03000 	movne	r3, #0
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
34814684:	1a000002 	bne	34814694 <add_mtd_partitions+0x5ac>
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
34814688:	e1a00006 	mov	r0, r6
3481468c:	ebfffc50 	bl	348137d4 <add_mtd_device>
		slave->registered = 1;
34814690:	e3a03001 	mov	r3, #1

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
34814694:	e1c6a0d8 	ldrd	sl, [r6, #8]
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
		slave->registered = 1;
34814698:	e58630c4 	str	r3, [r6, #196]	; 0xc4

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
3481469c:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
348146a0:	e09aa002 	adds	sl, sl, r2
348146a4:	e0abb003 	adc	fp, fp, r3
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
348146a8:	e2877001 	add	r7, r7, #1
348146ac:	e2855028 	add	r5, r5, #40	; 0x28
348146b0:	e59d001c 	ldr	r0, [sp, #28]
348146b4:	e1570000 	cmp	r7, r0
348146b8:	bafffe9d 	blt	34814134 <add_mtd_partitions+0x4c>
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
348146bc:	e3a00000 	mov	r0, #0
}
348146c0:	e28dd028 	add	sp, sp, #40	; 0x28
348146c4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348146c8:	3482bd5c 	.word	0x3482bd5c
348146cc:	34827552 	.word	0x34827552
348146d0:	34827577 	.word	0x34827577
348146d4:	34813f24 	.word	0x34813f24
348146d8:	34813a38 	.word	0x34813a38
348146dc:	34813ad0 	.word	0x34813ad0
348146e0:	34813e7c 	.word	0x34813e7c
348146e4:	34813b68 	.word	0x34813b68
348146e8:	348139b0 	.word	0x348139b0
348146ec:	348139f4 	.word	0x348139f4
348146f0:	34813bf4 	.word	0x34813bf4
348146f4:	34813c24 	.word	0x34813c24
348146f8:	348139e0 	.word	0x348139e0
348146fc:	34813a24 	.word	0x34813a24
34814700:	34813da8 	.word	0x34813da8
34814704:	34813ce8 	.word	0x34813ce8
34814708:	34813d48 	.word	0x34813d48
3481470c:	34813dbc 	.word	0x34813dbc
34814710:	34813e0c 	.word	0x34813e0c
34814714:	34813c40 	.word	0x34813c40
34814718:	348275b3 	.word	0x348275b3
3481471c:	348275e0 	.word	0x348275e0
34814720:	348275fc 	.word	0x348275fc
34814724:	3482762d 	.word	0x3482762d
34814728:	34827683 	.word	0x34827683
3481472c:	348276a0 	.word	0x348276a0
34814730:	34821798 	.word	0x34821798
34814734:	348276aa 	.word	0x348276aa
34814738:	348276af 	.word	0x348276af
3481473c:	34827700 	.word	0x34827700

34814740 <onenand_init>:
struct mtd_info onenand_mtd;
struct onenand_chip onenand_chip;
static __attribute__((unused)) char dev_name[] = "onenand0";

void onenand_init(void)
{
34814740:	e92d4070 	push	{r4, r5, r6, lr}
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34814744:	e59f407c 	ldr	r4, [pc, #124]	; 348147c8 <onenand_init+0x88>
34814748:	e3a01000 	mov	r1, #0
3481474c:	e3a020a8 	mov	r2, #168	; 0xa8
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
34814750:	e28450a8 	add	r5, r4, #168	; 0xa8
struct onenand_chip onenand_chip;
static __attribute__((unused)) char dev_name[] = "onenand0";

void onenand_init(void)
{
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34814754:	e1a00004 	mov	r0, r4
34814758:	eb002067 	bl	3481c8fc <memset>
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
3481475c:	e3a01000 	mov	r1, #0
34814760:	e3a020a8 	mov	r2, #168	; 0xa8
34814764:	e1a00005 	mov	r0, r5
34814768:	eb002063 	bl	3481c8fc <memset>

#ifdef CONFIG_USE_ONENAND_BOARD_INIT
	/*
	 * It's used for some board init required
	 */
	onenand_board_init(&onenand_mtd);
3481476c:	e1a00004 	mov	r0, r4
void onenand_init(void)
{
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));

	onenand_mtd.priv = &onenand_chip;
34814770:	e5845094 	str	r5, [r4, #148]	; 0x94

#ifdef CONFIG_USE_ONENAND_BOARD_INIT
	/*
	 * It's used for some board init required
	 */
	onenand_board_init(&onenand_mtd);
34814774:	ebffb1c0 	bl	34800e7c <onenand_board_init>
#else
	onenand_chip.base = (void *) CONFIG_SYS_ONENAND_BASE;
#endif

	onenand_scan(&onenand_mtd, 1);
34814778:	e1a00004 	mov	r0, r4
3481477c:	e3a01001 	mov	r1, #1
34814780:	eb000b47 	bl	348174a4 <onenand_scan>

	if (onenand_chip.device_id & DEVICE_IS_FLEXONENAND)
34814784:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
34814788:	e3130c02 	tst	r3, #512	; 0x200
3481478c:	0a000001 	beq	34814798 <onenand_init+0x58>
		puts("Flex-");
34814790:	e59f0034 	ldr	r0, [pc, #52]	; 348147cc <onenand_init+0x8c>
34814794:	ebffd4fd 	bl	34809b90 <puts>
	puts("OneNAND: ");
	print_size(onenand_chip.chipsize, "\n");
34814798:	e59f4028 	ldr	r4, [pc, #40]	; 348147c8 <onenand_init+0x88>

	onenand_scan(&onenand_mtd, 1);

	if (onenand_chip.device_id & DEVICE_IS_FLEXONENAND)
		puts("Flex-");
	puts("OneNAND: ");
3481479c:	e59f002c 	ldr	r0, [pc, #44]	; 348147d0 <onenand_init+0x90>
348147a0:	ebffd4fa 	bl	34809b90 <puts>
	print_size(onenand_chip.chipsize, "\n");
348147a4:	e59400c0 	ldr	r0, [r4, #192]	; 0xc0
348147a8:	e3a01000 	mov	r1, #0
348147ac:	e59f2020 	ldr	r2, [pc, #32]	; 348147d4 <onenand_init+0x94>
348147b0:	eb00190b 	bl	3481abe4 <print_size>
#ifdef CONFIG_MTD_DEVICE
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
348147b4:	e59f301c 	ldr	r3, [pc, #28]	; 348147d8 <onenand_init+0x98>
	add_mtd_device(&onenand_mtd);
348147b8:	e1a00004 	mov	r0, r4
#ifdef CONFIG_MTD_DEVICE
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
348147bc:	e5843020 	str	r3, [r4, #32]
	add_mtd_device(&onenand_mtd);
#endif
}
348147c0:	e8bd4070 	pop	{r4, r5, r6, lr}
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
	add_mtd_device(&onenand_mtd);
348147c4:	eafffc02 	b	348137d4 <add_mtd_device>
348147c8:	3482bd68 	.word	0x3482bd68
348147cc:	34827746 	.word	0x34827746
348147d0:	3482774c 	.word	0x3482774c
348147d4:	348264dd 	.word	0x348264dd
348147d8:	34828de8 	.word	0x34828de8

348147dc <generic_ffs>:

static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
348147dc:	e2503000 	subs	r3, r0, #0
348147e0:	0a000010 	beq	34814828 <generic_ffs+0x4c>
		return 0;
	if (!(x & 0xffff)) {
348147e4:	e6ff2073 	uxth	r2, r3
348147e8:	e3520000 	cmp	r2, #0
		x >>= 16;
348147ec:	01a03843 	asreq	r3, r3, #16
		r += 16;
348147f0:	03a00011 	moveq	r0, #17
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
	int r = 1;
348147f4:	13a00001 	movne	r0, #1
		return 0;
	if (!(x & 0xffff)) {
		x >>= 16;
		r += 16;
	}
	if (!(x & 0xff)) {
348147f8:	e31300ff 	tst	r3, #255	; 0xff
		x >>= 8;
348147fc:	01a03443 	asreq	r3, r3, #8
		r += 8;
34814800:	02800008 	addeq	r0, r0, #8
	}
	if (!(x & 0xf)) {
34814804:	e313000f 	tst	r3, #15
		x >>= 4;
34814808:	01a03243 	asreq	r3, r3, #4
		r += 4;
3481480c:	02800004 	addeq	r0, r0, #4
	}
	if (!(x & 3)) {
34814810:	e3130003 	tst	r3, #3
		x >>= 2;
34814814:	01a03143 	asreq	r3, r3, #2
		r += 2;
34814818:	02800002 	addeq	r0, r0, #2
	}
	if (!(x & 1)) {
3481481c:	e3130001 	tst	r3, #1
		x >>= 1;
		r += 1;
34814820:	02800001 	addeq	r0, r0, #1
34814824:	e12fff1e 	bx	lr
static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
		return 0;
34814828:	e1a00003 	mov	r0, r3
	if (!(x & 1)) {
		x >>= 1;
		r += 1;
	}
	return r;
}
3481482c:	e12fff1e 	bx	lr

34814830 <memcpy_16>:
{
	void *ret = dst;
	short *d = dst;
	const short *s = src;

	len >>= 1;
34814830:	e1a020a2 	lsr	r2, r2, #1
	while (len-- > 0)
34814834:	e3a03000 	mov	r3, #0
34814838:	ea000003 	b	3481484c <memcpy_16+0x1c>
		*d++ = *s++;
3481483c:	e191c0b3 	ldrh	ip, [r1, r3]
34814840:	e2422001 	sub	r2, r2, #1
34814844:	e180c0b3 	strh	ip, [r0, r3]
34814848:	e2833002 	add	r3, r3, #2
	void *ret = dst;
	short *d = dst;
	const short *s = src;

	len >>= 1;
	while (len-- > 0)
3481484c:	e3520000 	cmp	r2, #0
34814850:	1afffff9 	bne	3481483c <memcpy_16+0xc>
		*d++ = *s++;
	return ret;
}
34814854:	e12fff1e 	bx	lr

34814858 <onenand_readw>:
 *
 * Read OneNAND register
 */
static unsigned short onenand_readw(void __iomem * addr)
{
	return readw(addr);
34814858:	e1d000b0 	ldrh	r0, [r0]
}
3481485c:	e12fff1e 	bx	lr

34814860 <onenand_writew>:
 *
 * Write OneNAND register with value
 */
static void onenand_writew(unsigned short value, void __iomem * addr)
{
	writew(value, addr);
34814860:	e1c100b0 	strh	r0, [r1]
}
34814864:	e12fff1e 	bx	lr

34814868 <onenand_read_bufferram>:
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
	struct onenand_chip *this = mtd->priv;
34814868:	e5902094 	ldr	r2, [r0, #148]	; 0x94
 * Read the BufferRAM area
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
3481486c:	e92d4008 	push	{r3, lr}
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814870:	e5921044 	ldr	r1, [r2, #68]	; 0x44
 * Read the BufferRAM area
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
34814874:	e59d3008 	ldr	r3, [sp, #8]
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34814878:	e592c000 	ldr	ip, [r2]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
3481487c:	e3510000 	cmp	r1, #0
				  size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34814880:	e08cc003 	add	ip, ip, r3
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814884:	0a000006 	beq	348148a4 <onenand_read_bufferram+0x3c>
		if (area == ONENAND_DATARAM)
34814888:	e3530b01 	cmp	r3, #1024	; 0x400
			return mtd->writesize;
3481488c:	05901014 	ldreq	r1, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
34814890:	0a000003 	beq	348148a4 <onenand_read_bufferram+0x3c>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
34814894:	e59f2028 	ldr	r2, [pc, #40]	; 348148c4 <onenand_read_bufferram+0x5c>
34814898:	e1530002 	cmp	r3, r2
			return mtd->oobsize;
3481489c:	05901018 	ldreq	r1, [r0, #24]
	}

	return 0;
348148a0:	13a01000 	movne	r1, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	memcpy_16(buffer, bufferram + offset, count);
348148a4:	e59d3010 	ldr	r3, [sp, #16]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
348148a8:	e08c1001 	add	r1, ip, r1

	memcpy_16(buffer, bufferram + offset, count);
348148ac:	e59d000c 	ldr	r0, [sp, #12]
348148b0:	e0811003 	add	r1, r1, r3
348148b4:	e59d2014 	ldr	r2, [sp, #20]
348148b8:	ebffffdc 	bl	34814830 <memcpy_16>

	return 0;
}
348148bc:	e3a00000 	mov	r0, #0
348148c0:	e8bd8008 	pop	{r3, pc}
348148c4:	00010020 	.word	0x00010020

348148c8 <onenand_sync_read_bufferram>:
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
348148c8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct onenand_chip *this = mtd->priv;
348148cc:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
348148d0:	e59d3018 	ldr	r3, [sp, #24]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
348148d4:	e5956044 	ldr	r6, [r5, #68]	; 0x44
				       size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
348148d8:	e5957000 	ldr	r7, [r5]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
348148dc:	e3560000 	cmp	r6, #0
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
348148e0:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
348148e4:	e0877003 	add	r7, r7, r3
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
348148e8:	0a000006 	beq	34814908 <onenand_sync_read_bufferram+0x40>
		if (area == ONENAND_DATARAM)
348148ec:	e3530b01 	cmp	r3, #1024	; 0x400
			return mtd->writesize;
348148f0:	05906014 	ldreq	r6, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
348148f4:	0a000003 	beq	34814908 <onenand_sync_read_bufferram+0x40>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
348148f8:	e59f2048 	ldr	r2, [pc, #72]	; 34814948 <onenand_sync_read_bufferram+0x80>
348148fc:	e1530002 	cmp	r3, r2
			return mtd->oobsize;
34814900:	05906018 	ldreq	r6, [r0, #24]
	}

	return 0;
34814904:	13a06000 	movne	r6, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
34814908:	e5953074 	ldr	r3, [r5, #116]	; 0x74
3481490c:	e1a00004 	mov	r0, r4
34814910:	e3a01902 	mov	r1, #32768	; 0x8000
34814914:	e12fff33 	blx	r3

	memcpy_16(buffer, bufferram + offset, count);
34814918:	e59d3020 	ldr	r3, [sp, #32]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
3481491c:	e0876006 	add	r6, r7, r6

	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);

	memcpy_16(buffer, bufferram + offset, count);
34814920:	e0861003 	add	r1, r6, r3
34814924:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34814928:	e59d001c 	ldr	r0, [sp, #28]
3481492c:	ebffffbf 	bl	34814830 <memcpy_16>

	this->mmcontrol(mtd, 0);
34814930:	e1a00004 	mov	r0, r4
34814934:	e5953074 	ldr	r3, [r5, #116]	; 0x74
34814938:	e3a01000 	mov	r1, #0
3481493c:	e12fff33 	blx	r3

	return 0;
}
34814940:	e3a00000 	mov	r0, #0
34814944:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34814948:	00010020 	.word	0x00010020

3481494c <onenand_write_bufferram>:
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
	struct onenand_chip *this = mtd->priv;
3481494c:	e5901094 	ldr	r1, [r0, #148]	; 0x94
 * Write the BufferRAM area
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34814950:	e92d4008 	push	{r3, lr}
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814954:	e5913044 	ldr	r3, [r1, #68]	; 0x44
 * Write the BufferRAM area
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34814958:	e59d2008 	ldr	r2, [sp, #8]
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
3481495c:	e591c000 	ldr	ip, [r1]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814960:	e3530000 	cmp	r3, #0
				   size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34814964:	e08cc002 	add	ip, ip, r2
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34814968:	0a000006 	beq	34814988 <onenand_write_bufferram+0x3c>
		if (area == ONENAND_DATARAM)
3481496c:	e3520b01 	cmp	r2, #1024	; 0x400
			return mtd->writesize;
34814970:	05903014 	ldreq	r3, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
34814974:	0a000003 	beq	34814988 <onenand_write_bufferram+0x3c>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
34814978:	e59f3028 	ldr	r3, [pc, #40]	; 348149a8 <onenand_write_bufferram+0x5c>
3481497c:	e1520003 	cmp	r2, r3
			return mtd->oobsize;
34814980:	05903018 	ldreq	r3, [r0, #24]
	}

	return 0;
34814984:	13a03000 	movne	r3, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	memcpy_16(bufferram + offset, buffer, count);
34814988:	e59d2010 	ldr	r2, [sp, #16]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
3481498c:	e08c3003 	add	r3, ip, r3

	memcpy_16(bufferram + offset, buffer, count);
34814990:	e0830002 	add	r0, r3, r2
34814994:	e59d100c 	ldr	r1, [sp, #12]
34814998:	e59d2014 	ldr	r2, [sp, #20]
3481499c:	ebffffa3 	bl	34814830 <memcpy_16>

	return 0;
}
348149a0:	e3a00000 	mov	r0, #0
348149a4:	e8bd8008 	pop	{r3, pc}
348149a8:	00010020 	.word	0x00010020

348149ac <onenand_sync>:
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_SYNCING);

	/* Release it and go back */
	onenand_release_device(mtd);
}
348149ac:	e12fff1e 	bx	lr

348149b0 <onenand_block_isbad>:
 * @param ofs		offset relative to mtd start
 *
 * Check whether the block is bad
 */
int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
348149b0:	e92d4007 	push	{r0, r1, r2, lr}
	int ret;

	/* Check for invalid offset */
	if (ofs > mtd->size)
348149b4:	e590100c 	ldr	r1, [r0, #12]
348149b8:	e1510003 	cmp	r1, r3
348149bc:	3a00000a 	bcc	348149ec <onenand_block_isbad+0x3c>
348149c0:	1a000002 	bne	348149d0 <onenand_block_isbad+0x20>
348149c4:	e5901008 	ldr	r1, [r0, #8]
348149c8:	e1510002 	cmp	r1, r2
348149cc:	3a000006 	bcc	348149ec <onenand_block_isbad+0x3c>
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348149d0:	e5901094 	ldr	r1, [r0, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
348149d4:	e3a0c000 	mov	ip, #0
348149d8:	e59110a0 	ldr	r1, [r1, #160]	; 0xa0
348149dc:	e58dc000 	str	ip, [sp]
348149e0:	e5911010 	ldr	r1, [r1, #16]
348149e4:	e12fff31 	blx	r1
		return -EINVAL;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
	onenand_release_device(mtd);
	return ret;
348149e8:	ea000000 	b	348149f0 <onenand_block_isbad+0x40>
{
	int ret;

	/* Check for invalid offset */
	if (ofs > mtd->size)
		return -EINVAL;
348149ec:	e3e00015 	mvn	r0, #21

	onenand_get_device(mtd, FL_READING);
	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
	onenand_release_device(mtd);
	return ret;
}
348149f0:	e8bd800e 	pop	{r1, r2, r3, pc}

348149f4 <onenand_block_markbad>:
 * @param ofs		offset relative to mtd start
 *
 * Mark the block as bad
 */
int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
348149f4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348149f8:	e1a06000 	mov	r6, r0
348149fc:	e1a04002 	mov	r4, r2
34814a00:	e1a05003 	mov	r5, r3
	struct onenand_chip *this = mtd->priv;
34814a04:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int ret;

	ret = onenand_block_isbad(mtd, ofs);
34814a08:	ebffffe8 	bl	348149b0 <onenand_block_isbad>
	if (ret) {
34814a0c:	e3500000 	cmp	r0, #0
34814a10:	10000fc0 	andne	r0, r0, r0, asr #31
34814a14:	18bd80f8 	popne	{r3, r4, r5, r6, r7, pc}
		if (ret > 0)
			return 0;
		return ret;
	}

	ret = this->block_markbad(mtd, ofs);
34814a18:	e5971078 	ldr	r1, [r7, #120]	; 0x78
34814a1c:	e1a00006 	mov	r0, r6
34814a20:	e1a02004 	mov	r2, r4
34814a24:	e1a03005 	mov	r3, r5
34814a28:	e12fff31 	blx	r1
	return ret;
}
34814a2c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34814a30 <onenand_chip_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
static int onenand_chip_probe(struct mtd_info *mtd)
{
34814a30:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
34814a34:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
static int onenand_chip_probe(struct mtd_info *mtd)
{
34814a38:	e1a0a000 	mov	sl, r0
	struct onenand_chip *this = mtd->priv;
	int bram_maf_id, bram_dev_id, maf_id, dev_id;
	int syscfg;

	/* Save system configuration 1 */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814a3c:	e5940000 	ldr	r0, [r4]
34814a40:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814a44:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814a48:	e2800042 	add	r0, r0, #66	; 0x42
34814a4c:	e12fff33 	blx	r3

	/* Clear Sync. Burst Read mode to read BootRAM */
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
34814a50:	e5941000 	ldr	r1, [r4]
	struct onenand_chip *this = mtd->priv;
	int bram_maf_id, bram_dev_id, maf_id, dev_id;
	int syscfg;

	/* Save system configuration 1 */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814a54:	e1a07000 	mov	r7, r0

	/* Clear Sync. Burst Read mode to read BootRAM */
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
34814a58:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814a5c:	e1a00880 	lsl	r0, r0, #17
34814a60:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814a64:	e1a008a0 	lsr	r0, r0, #17
34814a68:	e2811042 	add	r1, r1, #66	; 0x42
34814a6c:	e12fff33 	blx	r3
			 this->base + ONENAND_REG_SYS_CFG1);

	/* Send the command for reading device ID from BootRAM */
	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
34814a70:	e5941000 	ldr	r1, [r4]
34814a74:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814a78:	e3a00090 	mov	r0, #144	; 0x90
34814a7c:	e12fff33 	blx	r3

	/* Read manufacturer and device IDs from BootRAM */
	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
34814a80:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814a84:	e5940000 	ldr	r0, [r4]
34814a88:	e12fff33 	blx	r3
34814a8c:	e1a05000 	mov	r5, r0
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
34814a90:	e5940000 	ldr	r0, [r4]
34814a94:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814a98:	e2800002 	add	r0, r0, #2
34814a9c:	e12fff33 	blx	r3

	/* Reset OneNAND to read default register values */
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
34814aa0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814aa4:	e5941000 	ldr	r1, [r4]
	/* Send the command for reading device ID from BootRAM */
	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);

	/* Read manufacturer and device IDs from BootRAM */
	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
34814aa8:	e1a06000 	mov	r6, r0

	/* Reset OneNAND to read default register values */
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
34814aac:	e3a000f0 	mov	r0, #240	; 0xf0
34814ab0:	e12fff33 	blx	r3

	/* Wait reset */
	this->wait(mtd, FL_RESETING);
34814ab4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814ab8:	e3a01006 	mov	r1, #6
34814abc:	e1a0000a 	mov	r0, sl
34814ac0:	e12fff33 	blx	r3

	/* Restore system configuration 1 */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
34814ac4:	e5941000 	ldr	r1, [r4]
34814ac8:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814acc:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814ad0:	e1a00007 	mov	r0, r7
34814ad4:	e2811042 	add	r1, r1, #66	; 0x42
34814ad8:	e12fff33 	blx	r3
#ifdef ONENAND_DEBUG
	char *name;
#endif

	for (i = 0; i < size; i++)
		if (manuf == onenand_manuf_ids[i].id)
34814adc:	e3550020 	cmp	r5, #32
34814ae0:	0a000001 	beq	34814aec <onenand_chip_probe+0xbc>
34814ae4:	e35500ec 	cmp	r5, #236	; 0xec
34814ae8:	1a00000f 	bne	34814b2c <onenand_chip_probe+0xfc>
	/* Check manufacturer ID */
	if (onenand_check_maf(bram_maf_id))
		return -ENXIO;

	/* Read manufacturer and device IDs from Register */
	maf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);
34814aec:	e5940000 	ldr	r0, [r4]
34814af0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814af4:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34814af8:	e12fff33 	blx	r3
34814afc:	e1a07000 	mov	r7, r0
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
34814b00:	e5940000 	ldr	r0, [r4]
34814b04:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814b08:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34814b0c:	e2800002 	add	r0, r0, #2
34814b10:	e12fff33 	blx	r3

	/* Check OneNAND device */
	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
34814b14:	e1570005 	cmp	r7, r5
34814b18:	01500006 	cmpeq	r0, r6
34814b1c:	03a00000 	moveq	r0, #0
34814b20:	13a00001 	movne	r0, #1
		return -ENXIO;
34814b24:	13e00005 	mvnne	r0, #5
34814b28:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* Restore system configuration 1 */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);

	/* Check manufacturer ID */
	if (onenand_check_maf(bram_maf_id))
		return -ENXIO;
34814b2c:	e3e00005 	mvn	r0, #5
	/* Check OneNAND device */
	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
		return -ENXIO;

	return 0;
}
34814b30:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34814b34 <flexonenand_get_size>:
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
34814b34:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34814b38:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814b3c:	e3a01010 	mov	r1, #16
	struct onenand_chip *this = mtd->priv;
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
34814b40:	e594701c 	ldr	r7, [r4, #28]
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814b44:	e5946030 	ldr	r6, [r4, #48]	; 0x30
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34814b48:	e7e33257 	ubfx	r3, r7, #4, #4
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814b4c:	e1a01311 	lsl	r1, r1, r3
34814b50:	e1a02001 	mov	r2, r1
34814b54:	e1a03fc2 	asr	r3, r2, #31
34814b58:	e1a03a03 	lsl	r3, r3, #20
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
34814b5c:	e24dd018 	sub	sp, sp, #24
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814b60:	e1a02006 	mov	r2, r6
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
34814b64:	e1a05000 	mov	r5, r0
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814b68:	e1a00a01 	lsl	r0, r1, #20
34814b6c:	e1831621 	orr	r1, r3, r1, lsr #12
34814b70:	eb002de7 	bl	34820314 <__ashrdi3>
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34814b74:	e7e071d7 	ubfx	r7, r7, #3, #1
34814b78:	e1a07750 	asr	r7, r0, r7
	maxbdry = blksperdie - 1;
34814b7c:	e2473001 	sub	r3, r7, #1
34814b80:	e58d300c 	str	r3, [sp, #12]
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814b84:	e8940009 	ldm	r4, {r0, r3}
34814b88:	e2800b79 	add	r0, r0, #123904	; 0x1e400
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;

	mtd->numeraseregions = this->dies << 1;
34814b8c:	e1a03083 	lsl	r3, r3, #1
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34814b90:	e58d7010 	str	r7, [sp, #16]
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;

	mtd->numeraseregions = this->dies << 1;
34814b94:	e585302c 	str	r3, [r5, #44]	; 0x2c
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814b98:	e2800042 	add	r0, r0, #66	; 0x42
34814b9c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814ba0:	e12fff33 	blx	r3
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
34814ba4:	e5941000 	ldr	r1, [r4]
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814ba8:	e58d0008 	str	r0, [sp, #8]
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
34814bac:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814bb0:	e3800c01 	orr	r0, r0, #256	; 0x100
34814bb4:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814bb8:	e6ff0070 	uxth	r0, r0
34814bbc:	e2811042 	add	r1, r1, #66	; 0x42

	for (die = 0; die < this->dies; die++) {
34814bc0:	e3a07000 	mov	r7, #0

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;
34814bc4:	e2466001 	sub	r6, r6, #1
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
34814bc8:	e12fff33 	blx	r3

	for (die = 0; die < this->dies; die++) {
		this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
34814bcc:	e1a0a007 	mov	sl, r7
34814bd0:	ea000034 	b	34814ca8 <flexonenand_get_size+0x174>
34814bd4:	e58da000 	str	sl, [sp]
34814bd8:	e1a02007 	mov	r2, r7
34814bdc:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34814be0:	e3a01066 	mov	r1, #102	; 0x66
34814be4:	e1a0300a 	mov	r3, sl
34814be8:	e1a00005 	mov	r0, r5
34814bec:	e12fff3c 	blx	ip
		this->wait(mtd, FL_SYNCING);
34814bf0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814bf4:	e3a01004 	mov	r1, #4
34814bf8:	e1a00005 	mov	r0, r5
34814bfc:	e12fff33 	blx	r3

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
34814c00:	e58da000 	str	sl, [sp]
34814c04:	e1a02007 	mov	r2, r7
34814c08:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34814c0c:	e3011985 	movw	r1, #6533	; 0x1985
34814c10:	e1a0300a 	mov	r3, sl
34814c14:	e1a00005 	mov	r0, r5
34814c18:	e12fff3c 	blx	ip
		this->wait(mtd, FL_READING);
34814c1c:	e3a01001 	mov	r1, #1
34814c20:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814c24:	e1a00005 	mov	r0, r5
34814c28:	e12fff33 	blx	r3

		bdry = this->read_word(this->base + ONENAND_DATARAM);
34814c2c:	e5940000 	ldr	r0, [r4]
34814c30:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814c34:	e2800b01 	add	r0, r0, #1024	; 0x400
34814c38:	e12fff33 	blx	r3
		if ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)
			locked = 0;
		else
			locked = 1;
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;
34814c3c:	e1a03b00 	lsl	r3, r0, #22
34814c40:	e287b002 	add	fp, r7, #2
34814c44:	e1a03b23 	lsr	r3, r3, #22
34814c48:	e784310b 	str	r3, [r4, fp, lsl #2]

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
34814c4c:	e58da000 	str	sl, [sp]
		this->wait(mtd, FL_SYNCING);

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
		this->wait(mtd, FL_READING);

		bdry = this->read_word(this->base + ONENAND_DATARAM);
34814c50:	e1a09000 	mov	r9, r0
			locked = 0;
		else
			locked = 1;
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
34814c54:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34814c58:	e3a02000 	mov	r2, #0
34814c5c:	e3a010f0 	mov	r1, #240	; 0xf0
34814c60:	e3a03000 	mov	r3, #0
34814c64:	e1a00005 	mov	r0, r5
34814c68:	e12fff3c 	blx	ip
		this->wait(mtd, FL_RESETING);
34814c6c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814c70:	e3a01006 	mov	r1, #6
34814c74:	e1a00005 	mov	r0, r5
34814c78:	e12fff33 	blx	r3

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
		this->wait(mtd, FL_READING);

		bdry = this->read_word(this->base + ONENAND_DATARAM);
		if ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)
34814c7c:	e1a03729 	lsr	r3, r9, #14
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
		this->wait(mtd, FL_RESETING);

		printk(KERN_INFO "Die %d boundary: %d%s\n", die,
34814c80:	e794210b 	ldr	r2, [r4, fp, lsl #2]
34814c84:	e59fb240 	ldr	fp, [pc, #576]	; 34814ecc <flexonenand_get_size+0x398>
34814c88:	e3530003 	cmp	r3, #3
34814c8c:	e59f923c 	ldr	r9, [pc, #572]	; 34814ed0 <flexonenand_get_size+0x39c>
34814c90:	11a0900b 	movne	r9, fp
34814c94:	e1a01007 	mov	r1, r7
34814c98:	e59f0234 	ldr	r0, [pc, #564]	; 34814ed4 <flexonenand_get_size+0x3a0>
34814c9c:	e1a03009 	mov	r3, r9
34814ca0:	ebffd3c4 	bl	34809bb8 <printf>

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);

	for (die = 0; die < this->dies; die++) {
34814ca4:	e2877001 	add	r7, r7, #1
34814ca8:	e5943004 	ldr	r3, [r4, #4]
34814cac:	e1570003 	cmp	r7, r3
34814cb0:	3affffc7 	bcc	34814bd4 <flexonenand_get_size+0xa0>
		printk(KERN_INFO "Die %d boundary: %d%s\n", die,
		       this->boundary[die], locked ? "(Locked)" : "(Unlocked)");
	}

	/* Enable ECC */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
34814cb4:	e5941000 	ldr	r1, [r4]
34814cb8:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814cbc:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814cc0:	e59d0008 	ldr	r0, [sp, #8]
34814cc4:	e2811042 	add	r1, r1, #66	; 0x42
34814cc8:	e12fff33 	blx	r3
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814ccc:	e594c004 	ldr	ip, [r4, #4]
34814cd0:	e2847004 	add	r7, r4, #4
34814cd4:	e58dc014 	str	ip, [sp, #20]
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
34814cd8:	e1a00007 	mov	r0, r7
	mtd->numeraseregions = this->dies << 1;

	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
34814cdc:	e3a02000 	mov	r2, #0
34814ce0:	e3a03000 	mov	r3, #0
	i = -1;
34814ce4:	e3e01000 	mvn	r1, #0

	mtd->numeraseregions = this->dies << 1;

	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
34814ce8:	e3a0c000 	mov	ip, #0
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
		if (!die || this->boundary[die-1] != maxbdry) {
			i++;
			mtd->eraseregions[i].offset = ofs;
34814cec:	e3a0e018 	mov	lr, #24
34814cf0:	e58d4008 	str	r4, [sp, #8]
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
34814cf4:	ea00003c 	b	34814dec <flexonenand_get_size+0x2b8>
		if (!die || this->boundary[die-1] != maxbdry) {
34814cf8:	e35c0000 	cmp	ip, #0
34814cfc:	0a000003 	beq	34814d10 <flexonenand_get_size+0x1dc>
34814d00:	e590a000 	ldr	sl, [r0]
34814d04:	e59d400c 	ldr	r4, [sp, #12]
34814d08:	e15a0004 	cmp	sl, r4
34814d0c:	0a00000f 	beq	34814d50 <flexonenand_get_size+0x21c>
			i++;
34814d10:	e2811001 	add	r1, r1, #1
			mtd->eraseregions[i].offset = ofs;
34814d14:	e009019e 	mul	r9, lr, r1
34814d18:	e595b030 	ldr	fp, [r5, #48]	; 0x30
34814d1c:	e08ba009 	add	sl, fp, r9
34814d20:	e18b20f9 	strd	r2, [fp, r9]
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
34814d24:	e3a0b001 	mov	fp, #1
34814d28:	e1a0961b 	lsl	r9, fp, r6
34814d2c:	e58a9008 	str	r9, [sl, #8]
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
34814d30:	e5909004 	ldr	r9, [r0, #4]
34814d34:	e089900b 	add	r9, r9, fp
	for (; die < this->dies; die++) {
		if (!die || this->boundary[die-1] != maxbdry) {
			i++;
			mtd->eraseregions[i].offset = ofs;
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
			mtd->eraseregions[i].numblocks =
34814d38:	e58a900c 	str	r9, [sl, #12]
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814d3c:	e1a09619 	lsl	r9, r9, r6
34814d40:	e0922009 	adds	r2, r2, r9
34814d44:	e2a33000 	adc	r3, r3, #0
			eraseshift++;
34814d48:	e086600b 	add	r6, r6, fp
34814d4c:	ea00000e 	b	34814d8c <flexonenand_get_size+0x258>
		} else {
			mtd->numeraseregions -= 1;
			mtd->eraseregions[i].numblocks +=
34814d50:	e5959030 	ldr	r9, [r5, #48]	; 0x30
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
34814d54:	e595a02c 	ldr	sl, [r5, #44]	; 0x2c
			mtd->eraseregions[i].numblocks +=
34814d58:	e029919e 	mla	r9, lr, r1, r9
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
34814d5c:	e24aa001 	sub	sl, sl, #1
34814d60:	e585a02c 	str	sl, [r5, #44]	; 0x2c
			mtd->eraseregions[i].numblocks +=
							this->boundary[die] + 1;
34814d64:	e590a004 	ldr	sl, [r0, #4]
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
			mtd->eraseregions[i].numblocks +=
34814d68:	e599b00c 	ldr	fp, [r9, #12]
34814d6c:	e08ab00b 	add	fp, sl, fp
34814d70:	e28bb001 	add	fp, fp, #1
34814d74:	e589b00c 	str	fp, [r9, #12]
							this->boundary[die] + 1;
			ofs += (this->boundary[die] + 1) << (eraseshift - 1);
34814d78:	e28aa001 	add	sl, sl, #1
34814d7c:	e2469001 	sub	r9, r6, #1
34814d80:	e1a0a91a 	lsl	sl, sl, r9
34814d84:	e092200a 	adds	r2, r2, sl
34814d88:	e2a33000 	adc	r3, r3, #0
		}
		if (this->boundary[die] != maxbdry) {
34814d8c:	e5b09004 	ldr	r9, [r0, #4]!
34814d90:	e59d400c 	ldr	r4, [sp, #12]
34814d94:	e1590004 	cmp	r9, r4
34814d98:	0a00000f 	beq	34814ddc <flexonenand_get_size+0x2a8>
			i++;
34814d9c:	e2811001 	add	r1, r1, #1
			mtd->eraseregions[i].offset = ofs;
34814da0:	e00b019e 	mul	fp, lr, r1
34814da4:	e5954030 	ldr	r4, [r5, #48]	; 0x30
34814da8:	e084a00b 	add	sl, r4, fp
34814dac:	e18420fb 	strd	r2, [r4, fp]
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
34814db0:	e3a04001 	mov	r4, #1
34814db4:	e1a0b614 	lsl	fp, r4, r6
34814db8:	e58ab008 	str	fp, [sl, #8]
			mtd->eraseregions[i].numblocks = maxbdry ^
34814dbc:	e59db00c 	ldr	fp, [sp, #12]
34814dc0:	e02b9009 	eor	r9, fp, r9
34814dc4:	e58a900c 	str	r9, [sl, #12]
							 this->boundary[die];
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814dc8:	e1a09619 	lsl	r9, r9, r6
34814dcc:	e0922009 	adds	r2, r2, r9
34814dd0:	e2a33000 	adc	r3, r3, #0
			eraseshift--;
34814dd4:	e2466001 	sub	r6, r6, #1
34814dd8:	ea000002 	b	34814de8 <flexonenand_get_size+0x2b4>
		} else
			mtd->numeraseregions -= 1;
34814ddc:	e595a02c 	ldr	sl, [r5, #44]	; 0x2c
34814de0:	e24aa001 	sub	sl, sl, #1
34814de4:	e585a02c 	str	sl, [r5, #44]	; 0x2c
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
34814de8:	e28cc001 	add	ip, ip, #1
34814dec:	e59d4014 	ldr	r4, [sp, #20]
34814df0:	e15c0004 	cmp	ip, r4
34814df4:	1affffbf 	bne	34814cf8 <flexonenand_get_size+0x1c4>
34814df8:	e59d4008 	ldr	r4, [sp, #8]
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
34814dfc:	e3a02001 	mov	r2, #1
34814e00:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	if (mtd->numeraseregions == 1)
34814e04:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
34814e08:	e1a03312 	lsl	r3, r2, r3
	if (mtd->numeraseregions == 1)
34814e0c:	e1510002 	cmp	r1, r2
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
34814e10:	e5853010 	str	r3, [r5, #16]
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;
34814e14:	01a03233 	lsreq	r3, r3, r2

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
34814e18:	e59f00b8 	ldr	r0, [pc, #184]	; 34814ed8 <flexonenand_get_size+0x3a4>
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;
34814e1c:	05853010 	streq	r3, [r5, #16]

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814e20:	e3a06000 	mov	r6, #0
	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
34814e24:	ebffd363 	bl	34809bb8 <printf>
	for (i = 0; i < mtd->numeraseregions; i++)
34814e28:	e1a0a006 	mov	sl, r6
34814e2c:	ea00000a 	b	34814e5c <flexonenand_get_size+0x328>
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
34814e30:	e5953030 	ldr	r3, [r5, #48]	; 0x30
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814e34:	e59f00a0 	ldr	r0, [pc, #160]	; 34814edc <flexonenand_get_size+0x3a8>
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
34814e38:	e0832006 	add	r2, r3, r6
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814e3c:	e5921008 	ldr	r1, [r2, #8]
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814e40:	e28aa001 	add	sl, sl, #1
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814e44:	e58d1000 	str	r1, [sp]
34814e48:	e592200c 	ldr	r2, [r2, #12]
34814e4c:	e58d2004 	str	r2, [sp, #4]
34814e50:	e18320d6 	ldrd	r2, [r3, r6]
34814e54:	ebffd357 	bl	34809bb8 <printf>
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814e58:	e2866018 	add	r6, r6, #24
34814e5c:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
34814e60:	e15a0003 	cmp	sl, r3
34814e64:	bafffff1 	blt	34814e30 <flexonenand_get_size+0x2fc>
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814e68:	e5946004 	ldr	r6, [r4, #4]
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814e6c:	e3a02000 	mov	r2, #0
34814e70:	e3a03000 	mov	r3, #0
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814e74:	e0846106 	add	r6, r4, r6, lsl #2
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814e78:	e1c520f8 	strd	r2, [r5, #8]
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814e7c:	e2866004 	add	r6, r6, #4
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814e80:	ea00000d 	b	34814ebc <flexonenand_get_size+0x388>
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814e84:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814e88:	e5b70004 	ldr	r0, [r7, #4]!
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814e8c:	e59d9010 	ldr	r9, [sp, #16]
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
34814e90:	e2800001 	add	r0, r0, #1
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814e94:	e1a0a219 	lsl	sl, r9, r2
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
34814e98:	e3a01000 	mov	r1, #0
34814e9c:	e2422001 	sub	r2, r2, #1
34814ea0:	eb002d22 	bl	34820330 <__ashldi3>
		mtd->size += this->diesize[die];
34814ea4:	e1c520d8 	ldrd	r2, [r5, #8]
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814ea8:	e060000a 	rsb	r0, r0, sl
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
34814eac:	e0922000 	adds	r2, r2, r0
34814eb0:	e2a33000 	adc	r3, r3, #0
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814eb4:	e5870008 	str	r0, [r7, #8]
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
34814eb8:	e1c520f8 	strd	r2, [r5, #8]
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814ebc:	e1570006 	cmp	r7, r6
34814ec0:	1affffef 	bne	34814e84 <flexonenand_get_size+0x350>
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
	}
}
34814ec4:	e28dd018 	add	sp, sp, #24
34814ec8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814ecc:	34827756 	.word	0x34827756
34814ed0:	3482775f 	.word	0x3482775f
34814ed4:	3482776a 	.word	0x3482776a
34814ed8:	34827781 	.word	0x34827781
34814edc:	3482779d 	.word	0x3482779d

34814ee0 <onenand_read_ecc>:
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
	int ecc, i;

	if (!FLEXONENAND(this))
34814ee0:	e590301c 	ldr	r3, [r0, #28]
/**
 * onenand_read_ecc - return ecc status
 * @param this		onenand chip structure
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
34814ee4:	e92d4070 	push	{r4, r5, r6, lr}
	int ecc, i;

	if (!FLEXONENAND(this))
34814ee8:	e3130c02 	tst	r3, #512	; 0x200
/**
 * onenand_read_ecc - return ecc status
 * @param this		onenand chip structure
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
34814eec:	e1a04000 	mov	r4, r0
	int ecc, i;

	if (!FLEXONENAND(this))
34814ef0:	1a000005 	bne	34814f0c <onenand_read_ecc+0x2c>
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);
34814ef4:	e5900000 	ldr	r0, [r0]
34814ef8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814efc:	e2800b7f 	add	r0, r0, #130048	; 0x1fc00
34814f00:	e2800c02 	add	r0, r0, #512	; 0x200
34814f04:	e12fff33 	blx	r3
34814f08:	e8bd8070 	pop	{r4, r5, r6, pc}
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
	int ecc, i;

	if (!FLEXONENAND(this))
34814f0c:	e59f5044 	ldr	r5, [pc, #68]	; 34814f58 <onenand_read_ecc+0x78>
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);

	for (i = 0; i < 4; i++) {
34814f10:	e59f6044 	ldr	r6, [pc, #68]	; 34814f5c <onenand_read_ecc+0x7c>
		ecc = this->read_word(this->base
34814f14:	e5940000 	ldr	r0, [r4]
34814f18:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814f1c:	e0800085 	add	r0, r0, r5, lsl #1
34814f20:	e12fff33 	blx	r3
				+ ((ONENAND_REG_ECC_STATUS + i) << 1));
		if (likely(!ecc))
34814f24:	e3500000 	cmp	r0, #0
34814f28:	0a000003 	beq	34814f3c <onenand_read_ecc+0x5c>
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
34814f2c:	e3013010 	movw	r3, #4112	; 0x1010
34814f30:	e0003003 	and	r3, r0, r3
34814f34:	e3530000 	cmp	r3, #0
34814f38:	1a000004 	bne	34814f50 <onenand_read_ecc+0x70>
34814f3c:	e2855001 	add	r5, r5, #1
	int ecc, i;

	if (!FLEXONENAND(this))
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);

	for (i = 0; i < 4; i++) {
34814f40:	e1550006 	cmp	r5, r6
34814f44:	1afffff2 	bne	34814f14 <onenand_read_ecc+0x34>
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
			return ONENAND_ECC_2BIT_ALL;
	}

	return 0;
34814f48:	e3a00000 	mov	r0, #0
34814f4c:	e8bd8070 	pop	{r4, r5, r6, pc}
		ecc = this->read_word(this->base
				+ ((ONENAND_REG_ECC_STATUS + i) << 1));
		if (likely(!ecc))
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
			return ONENAND_ECC_2BIT_ALL;
34814f50:	e30a0aaa 	movw	r0, #43690	; 0xaaaa
	}

	return 0;
}
34814f54:	e8bd8070 	pop	{r4, r5, r6, pc}
34814f58:	0001fe00 	.word	0x0001fe00
34814f5c:	0001fe04 	.word	0x0001fe04

34814f60 <onenand_bbt_wait>:
 * @param state		state to select the max. timeout value
 *
 * Wait for command done.
 */
static int onenand_bbt_wait(struct mtd_info *mtd, int state)
{
34814f60:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34814f64:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814f68:	e5960000 	ldr	r0, [r6]
34814f6c:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814f70:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814f74:	e2800082 	add	r0, r0, #130	; 0x82
34814f78:	e12fff33 	blx	r3
		if (interrupt & flags)
34814f7c:	e3100902 	tst	r0, #32768	; 0x8000
34814f80:	0afffff8 	beq	34814f68 <onenand_bbt_wait+0x8>
			break;
	}

	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814f84:	e5960000 	ldr	r0, [r6]
34814f88:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814f8c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814f90:	e2800082 	add	r0, r0, #130	; 0x82
34814f94:	e12fff33 	blx	r3
34814f98:	e1a05000 	mov	r5, r0
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814f9c:	e5960000 	ldr	r0, [r6]
34814fa0:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814fa4:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814fa8:	e2800080 	add	r0, r0, #128	; 0x80
34814fac:	e12fff33 	blx	r3

	if (interrupt & ONENAND_INT_READ) {
34814fb0:	e3150080 	tst	r5, #128	; 0x80
			break;
	}

	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814fb4:	e1a04000 	mov	r4, r0

	if (interrupt & ONENAND_INT_READ) {
34814fb8:	0a00000b 	beq	34814fec <onenand_bbt_wait+0x8c>
		int ecc = onenand_read_ecc(this);
34814fbc:	e1a00006 	mov	r0, r6
34814fc0:	ebffffc6 	bl	34814ee0 <onenand_read_ecc>
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814fc4:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
34814fc8:	e0003003 	and	r3, r0, r3
34814fcc:	e3530000 	cmp	r3, #0
	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);

	if (interrupt & ONENAND_INT_READ) {
		int ecc = onenand_read_ecc(this);
34814fd0:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814fd4:	0a00000a 	beq	34815004 <onenand_bbt_wait+0xa4>
			printk(KERN_INFO "onenand_bbt_wait: ecc error = 0x%04x"
34814fd8:	e59f0040 	ldr	r0, [pc, #64]	; 34815020 <onenand_bbt_wait+0xc0>
34814fdc:	e1a02004 	mov	r2, r4
34814fe0:	ebffd2f4 	bl	34809bb8 <printf>
				", controller = 0x%04x\n", ecc, ctrl);
			return ONENAND_BBT_READ_ERROR;
34814fe4:	e3a00001 	mov	r0, #1
34814fe8:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	} else {
		printk(KERN_ERR "onenand_bbt_wait: read timeout!"
34814fec:	e59f0030 	ldr	r0, [pc, #48]	; 34815024 <onenand_bbt_wait+0xc4>
34814ff0:	e1a01004 	mov	r1, r4
34814ff4:	e1a02005 	mov	r2, r5
34814ff8:	ebffd2ee 	bl	34809bb8 <printf>
				"ctrl=0x%04x intr=0x%04x\n", ctrl, interrupt);
		return ONENAND_BBT_READ_FATAL_ERROR;
34814ffc:	e3a00004 	mov	r0, #4
34815000:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* Initial bad block case: 0x2400 or 0x0400 */
	if (ctrl & ONENAND_CTRL_ERROR) {
34815004:	e2140b01 	ands	r0, r4, #1024	; 0x400
34815008:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
3481500c:	e1a01004 	mov	r1, r4
34815010:	e59f0010 	ldr	r0, [pc, #16]	; 34815028 <onenand_bbt_wait+0xc8>
34815014:	ebffd2e7 	bl	34809bb8 <printf>
		return ONENAND_BBT_READ_ERROR;
34815018:	e3a00001 	mov	r0, #1
	}

	return 0;
}
3481501c:	e8bd8070 	pop	{r4, r5, r6, pc}
34815020:	348277d5 	.word	0x348277d5
34815024:	34827810 	.word	0x34827810
34815028:	34827848 	.word	0x34827848

3481502c <onenand_wait>:
 * Wait for command done. This applies to all OneNAND command
 * Read can take up to 30us, erase up to 2ms and program up to 350us
 * according to general OneNAND specs
 */
static int onenand_wait(struct mtd_info *mtd, int state)
{
3481502c:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34815030:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt = 0;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34815034:	e5950000 	ldr	r0, [r5]
34815038:	e5953068 	ldr	r3, [r5, #104]	; 0x68
3481503c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34815040:	e2800082 	add	r0, r0, #130	; 0x82
34815044:	e12fff33 	blx	r3
		if (interrupt & flags)
34815048:	e3100902 	tst	r0, #32768	; 0x8000
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt = 0;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
3481504c:	e1a06000 	mov	r6, r0
		if (interrupt & flags)
34815050:	0afffff7 	beq	34815034 <onenand_wait+0x8>
			break;
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34815054:	e5950000 	ldr	r0, [r5]
34815058:	e5953068 	ldr	r3, [r5, #104]	; 0x68
3481505c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34815060:	e2800080 	add	r0, r0, #128	; 0x80
34815064:	e12fff33 	blx	r3

	if (interrupt & ONENAND_INT_READ) {
34815068:	e3160080 	tst	r6, #128	; 0x80
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
		if (interrupt & flags)
			break;
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
3481506c:	e1a04000 	mov	r4, r0

	if (interrupt & ONENAND_INT_READ) {
34815070:	0a00000a 	beq	348150a0 <onenand_wait+0x74>
		int ecc = onenand_read_ecc(this);
34815074:	e1a00005 	mov	r0, r5
34815078:	ebffff98 	bl	34814ee0 <onenand_read_ecc>
		if (ecc & ONENAND_ECC_2BIT_ALL) {
3481507c:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
34815080:	e0003003 	and	r3, r0, r3
34815084:	e3530000 	cmp	r3, #0
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);

	if (interrupt & ONENAND_INT_READ) {
		int ecc = onenand_read_ecc(this);
34815088:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
3481508c:	0a000003 	beq	348150a0 <onenand_wait+0x74>
			printk("onenand_wait: ECC error = 0x%04x\n", ecc);
34815090:	e59f0040 	ldr	r0, [pc, #64]	; 348150d8 <onenand_wait+0xac>
34815094:	ebffd2c7 	bl	34809bb8 <printf>
			return -EBADMSG;
34815098:	e3e00049 	mvn	r0, #73	; 0x49
3481509c:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	if (ctrl & ONENAND_CTRL_ERROR) {
348150a0:	e2140b01 	ands	r0, r4, #1024	; 0x400
348150a4:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk("onenand_wait: controller error = 0x%04x\n", ctrl);
348150a8:	e59f002c 	ldr	r0, [pc, #44]	; 348150dc <onenand_wait+0xb0>
348150ac:	e1a01004 	mov	r1, r4
348150b0:	ebffd2c0 	bl	34809bb8 <printf>
		if (ctrl & ONENAND_CTRL_LOCK)
348150b4:	e3140901 	tst	r4, #16384	; 0x4000
348150b8:	0a000004 	beq	348150d0 <onenand_wait+0xa4>
			printk("onenand_wait: it's locked error = 0x%04x\n",
348150bc:	e59f001c 	ldr	r0, [pc, #28]	; 348150e0 <onenand_wait+0xb4>
348150c0:	e1a01004 	mov	r1, r4
348150c4:	ebffd2bb 	bl	34809bb8 <printf>
				ctrl);

		return -EIO;
348150c8:	e3e00004 	mvn	r0, #4
348150cc:	e8bd8070 	pop	{r4, r5, r6, pc}
348150d0:	e3e00004 	mvn	r0, #4
	}


	return 0;
}
348150d4:	e8bd8070 	pop	{r4, r5, r6, pc}
348150d8:	34827875 	.word	0x34827875
348150dc:	34827897 	.word	0x34827897
348150e0:	348278c0 	.word	0x348278c0

348150e4 <onenand_transfer_auto_oob>:
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
348150e4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
348150e8:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
348150ec:	e0835002 	add	r5, r3, r2
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;
348150f0:	e5973090 	ldr	r3, [r7, #144]	; 0x90
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
348150f4:	e24dd018 	sub	sp, sp, #24
348150f8:	e1a09001 	mov	r9, r1
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
348150fc:	e597109c 	ldr	r1, [r7, #156]	; 0x9c
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;
34815100:	e58d3014 	str	r3, [sp, #20]

	free = this->ecclayout->oobfree;
34815104:	e3a03000 	mov	r3, #0
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
34815108:	e1a06002 	mov	r6, r2
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int readcol = column;
3481510c:	e1a04002 	mov	r4, r2
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
34815110:	e2811f82 	add	r1, r1, #520	; 0x208
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
	int lastgap = 0;
34815114:	e1a02003 	mov	r2, r3
34815118:	ea00000c 	b	34815150 <onenand_transfer_auto_oob+0x6c>
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		if (readcol >= lastgap)
3481511c:	e1540002 	cmp	r4, r2
			readcol += free->offset - lastgap;
34815120:	a791e003 	ldrge	lr, [r1, r3]
34815124:	a084400e 	addge	r4, r4, lr
34815128:	a0624004 	rsbge	r4, r2, r4
		if (readend >= lastgap)
3481512c:	e1550002 	cmp	r5, r2
			readend += free->offset - lastgap;
34815130:	a791e003 	ldrge	lr, [r1, r3]
34815134:	a085500e 	addge	r5, r5, lr
34815138:	a0625005 	rsbge	r5, r2, r5
		lastgap = free->offset + free->length;
3481513c:	e7912003 	ldr	r2, [r1, r3]
34815140:	e2833008 	add	r3, r3, #8
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34815144:	e3530040 	cmp	r3, #64	; 0x40
34815148:	0a000004 	beq	34815160 <onenand_transfer_auto_oob+0x7c>
		if (readcol >= lastgap)
			readcol += free->offset - lastgap;
		if (readend >= lastgap)
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
3481514c:	e082200c 	add	r2, r2, ip
 * @param mtd		MTD device structure
 * @param buf		destination address
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
34815150:	e081c003 	add	ip, r1, r3
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34815154:	e59cc004 	ldr	ip, [ip, #4]
34815158:	e35c0000 	cmp	ip, #0
3481515c:	1affffee 	bne	3481511c <onenand_transfer_auto_oob+0x38>
			readcol += free->offset - lastgap;
		if (readend >= lastgap)
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
34815160:	e59f30bc 	ldr	r3, [pc, #188]	; 34815224 <onenand_transfer_auto_oob+0x140>
34815164:	e3a0a000 	mov	sl, #0
34815168:	e58d3000 	str	r3, [sp]
3481516c:	e59d3014 	ldr	r3, [sp, #20]
34815170:	e98d0408 	stmib	sp, {r3, sl}
34815174:	e5903018 	ldr	r3, [r0, #24]
34815178:	e3a02000 	mov	r2, #0
3481517c:	e58d300c 	str	r3, [sp, #12]
34815180:	e5971060 	ldr	r1, [r7, #96]	; 0x60
34815184:	e3a03000 	mov	r3, #0
34815188:	e12fff31 	blx	r1
	free = this->ecclayout->oobfree;
3481518c:	e597b09c 	ldr	fp, [r7, #156]	; 0x9c
34815190:	e1a0700a 	mov	r7, sl
34815194:	e28bbf82 	add	fp, fp, #520	; 0x208
34815198:	ea00001a 	b	34815208 <onenand_transfer_auto_oob+0x124>
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
3481519c:	e79b1007 	ldr	r1, [fp, r7]
348151a0:	e081a00a 	add	sl, r1, sl
		if (free->offset < readend && free_end > readcol) {
348151a4:	e1510005 	cmp	r1, r5
348151a8:	23a03000 	movcs	r3, #0
348151ac:	33a03001 	movcc	r3, #1
348151b0:	e15a0004 	cmp	sl, r4
348151b4:	d3a03000 	movle	r3, #0
348151b8:	e3530000 	cmp	r3, #0
348151bc:	0a00000c 	beq	348151f4 <onenand_transfer_auto_oob+0x110>
			int st = max_t(int,free->offset,readcol);
348151c0:	e1540001 	cmp	r4, r1
348151c4:	a1a01004 	movge	r1, r4
348151c8:	b1a01001 	movlt	r1, r1
			int ed = min_t(int,free_end,readend);
			int n = ed - st;
			memcpy(buf, oob_buf + st, n);
348151cc:	e59d3014 	ldr	r3, [sp, #20]
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
		if (free->offset < readend && free_end > readcol) {
			int st = max_t(int,free->offset,readcol);
			int ed = min_t(int,free_end,readend);
			int n = ed - st;
348151d0:	e155000a 	cmp	r5, sl
348151d4:	d061a005 	rsble	sl, r1, r5
348151d8:	c061a00a 	rsbgt	sl, r1, sl
			memcpy(buf, oob_buf + st, n);
348151dc:	e1a00009 	mov	r0, r9
348151e0:	e0831001 	add	r1, r3, r1
348151e4:	e1a0200a 	mov	r2, sl
348151e8:	eb001de7 	bl	3481c98c <memcpy>
			buf += n;
348151ec:	e089900a 	add	r9, r9, sl
348151f0:	ea000001 	b	348151fc <onenand_transfer_auto_oob+0x118>
		} else if (column == 0)
348151f4:	e3560000 	cmp	r6, #0
348151f8:	0a000006 	beq	34815218 <onenand_transfer_auto_oob+0x134>
348151fc:	e2877008 	add	r7, r7, #8
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34815200:	e3570040 	cmp	r7, #64	; 0x40
34815204:	0a000003 	beq	34815218 <onenand_transfer_auto_oob+0x134>
 * @param mtd		MTD device structure
 * @param buf		destination address
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
34815208:	e08b3007 	add	r3, fp, r7
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481520c:	e593a004 	ldr	sl, [r3, #4]
34815210:	e35a0000 	cmp	sl, #0
34815214:	1affffe0 	bne	3481519c <onenand_transfer_auto_oob+0xb8>
			buf += n;
		} else if (column == 0)
			break;
	}
	return 0;
}
34815218:	e3a00000 	mov	r0, #0
3481521c:	e28dd018 	add	sp, sp, #24
34815220:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34815224:	00010020 	.word	0x00010020

34815228 <onenand_update_bufferram.clone.2>:
 * @param addr		address to update
 * @param valid		valid flag
 *
 * Update BufferRAM information
 */
static int onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,
34815228:	e92d4010 	push	{r4, lr}
3481522c:	e1a04000 	mov	r4, r0
	unsigned int i;

	if (ONENAND_IS_2PLANE(this))
		blockpage = onenand_get_2x_blockpage(mtd, addr);
	else
		blockpage = (int)(addr >> this->page_shift);
34815230:	e1a01003 	mov	r1, r3
34815234:	e1a00002 	mov	r0, r2
34815238:	e5942034 	ldr	r2, [r4, #52]	; 0x34
3481523c:	eb002c34 	bl	34820314 <__ashrdi3>

	/* Invalidate another BufferRAM */
	i = ONENAND_NEXT_BUFFERRAM(this);
34815240:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34815244:	e2232001 	eor	r2, r3, #1
	if (this->bufferram[i].blockpage == blockpage)
34815248:	e2822012 	add	r2, r2, #18
3481524c:	e7941102 	ldr	r1, [r4, r2, lsl #2]
34815250:	e2833012 	add	r3, r3, #18
34815254:	e1510000 	cmp	r1, r0
		this->bufferram[i].blockpage = -1;
34815258:	03e01000 	mvneq	r1, #0
3481525c:	07841102 	streq	r1, [r4, r2, lsl #2]

	/* Update BufferRAM */
	i = ONENAND_CURRENT_BUFFERRAM(this);
	if (valid)
34815260:	e59d2008 	ldr	r2, [sp, #8]
34815264:	e3520000 	cmp	r2, #0
		this->bufferram[i].blockpage = blockpage;
	else
		this->bufferram[i].blockpage = -1;
34815268:	03e02000 	mvneq	r2, #0
		this->bufferram[i].blockpage = -1;

	/* Update BufferRAM */
	i = ONENAND_CURRENT_BUFFERRAM(this);
	if (valid)
		this->bufferram[i].blockpage = blockpage;
3481526c:	17840103 	strne	r0, [r4, r3, lsl #2]
	else
		this->bufferram[i].blockpage = -1;
34815270:	07842103 	streq	r2, [r4, r3, lsl #2]

	return 0;
}
34815274:	e3a00000 	mov	r0, #0
34815278:	e8bd8010 	pop	{r4, pc}

3481527c <onenand_fill_auto_oob.clone.7>:
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
3481527c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
34815280:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
34815284:	e590409c 	ldr	r4, [r0, #156]	; 0x9c
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34815288:	e1a09003 	mov	r9, r3
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
3481528c:	e0877003 	add	r7, r7, r3
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
34815290:	e1a06003 	mov	r6, r3
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
34815294:	e3a03000 	mov	r3, #0
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34815298:	e1a0b002 	mov	fp, r2
3481529c:	e1a0c001 	mov	ip, r1
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
348152a0:	e2844f82 	add	r4, r4, #520	; 0x208
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
348152a4:	e1a02003 	mov	r2, r3
348152a8:	ea00000c 	b	348152e0 <onenand_fill_auto_oob.clone.7+0x64>
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		if (writecol >= lastgap)
348152ac:	e1560002 	cmp	r6, r2
			writecol += free->offset - lastgap;
348152b0:	a7940003 	ldrge	r0, [r4, r3]
348152b4:	a0866000 	addge	r6, r6, r0
348152b8:	a0626006 	rsbge	r6, r2, r6
		if (writeend >= lastgap)
348152bc:	e1570002 	cmp	r7, r2
			writeend += free->offset - lastgap;
348152c0:	a7940003 	ldrge	r0, [r4, r3]
348152c4:	a0877000 	addge	r7, r7, r0
348152c8:	a0627007 	rsbge	r7, r2, r7
		lastgap = free->offset + free->length;
348152cc:	e7942003 	ldr	r2, [r4, r3]
348152d0:	e2833008 	add	r3, r3, #8
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
348152d4:	e3530040 	cmp	r3, #64	; 0x40
348152d8:	0a000004 	beq	348152f0 <onenand_fill_auto_oob.clone.7+0x74>
		if (writecol >= lastgap)
			writecol += free->offset - lastgap;
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
348152dc:	e0812002 	add	r2, r1, r2
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
348152e0:	e0841003 	add	r1, r4, r3
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
348152e4:	e5911004 	ldr	r1, [r1, #4]
348152e8:	e3510000 	cmp	r1, #0
348152ec:	1affffee 	bne	348152ac <onenand_fill_auto_oob.clone.7+0x30>
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
348152f0:	e3a05000 	mov	r5, #0
348152f4:	ea00001b 	b	34815368 <onenand_fill_auto_oob.clone.7+0xec>
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
348152f8:	e7940005 	ldr	r0, [r4, r5]
348152fc:	e08aa000 	add	sl, sl, r0
		if (free->offset < writeend && free_end > writecol) {
34815300:	e1500007 	cmp	r0, r7
34815304:	23a03000 	movcs	r3, #0
34815308:	33a03001 	movcc	r3, #1
3481530c:	e15a0006 	cmp	sl, r6
34815310:	d3a03000 	movle	r3, #0
34815314:	e3530000 	cmp	r3, #0
34815318:	0a00000d 	beq	34815354 <onenand_fill_auto_oob.clone.7+0xd8>
			int st = max_t(int,free->offset,writecol);
3481531c:	e1560000 	cmp	r6, r0
34815320:	a1a00006 	movge	r0, r6
34815324:	b1a00000 	movlt	r0, r0
			int ed = min_t(int,free_end,writeend);
			int n = ed - st;
34815328:	e157000a 	cmp	r7, sl
3481532c:	d060a007 	rsble	sl, r0, r7
34815330:	c060a00a 	rsbgt	sl, r0, sl
			memcpy(oob_buf + st, buf, n);
34815334:	e1a0100b 	mov	r1, fp
34815338:	e08c0000 	add	r0, ip, r0
3481533c:	e1a0200a 	mov	r2, sl
34815340:	e58dc004 	str	ip, [sp, #4]
			buf += n;
34815344:	e08bb00a 	add	fp, fp, sl
		int free_end = free->offset + free->length;
		if (free->offset < writeend && free_end > writecol) {
			int st = max_t(int,free->offset,writecol);
			int ed = min_t(int,free_end,writeend);
			int n = ed - st;
			memcpy(oob_buf + st, buf, n);
34815348:	eb001d8f 	bl	3481c98c <memcpy>
3481534c:	e59dc004 	ldr	ip, [sp, #4]
34815350:	ea000001 	b	3481535c <onenand_fill_auto_oob.clone.7+0xe0>
			buf += n;
		} else if (column == 0)
34815354:	e3590000 	cmp	r9, #0
34815358:	0a000006 	beq	34815378 <onenand_fill_auto_oob.clone.7+0xfc>
3481535c:	e2855008 	add	r5, r5, #8
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34815360:	e3550040 	cmp	r5, #64	; 0x40
34815364:	0a000003 	beq	34815378 <onenand_fill_auto_oob.clone.7+0xfc>
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34815368:	e0843005 	add	r3, r4, r5
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481536c:	e593a004 	ldr	sl, [r3, #4]
34815370:	e35a0000 	cmp	sl, #0
34815374:	1affffdf 	bne	348152f8 <onenand_fill_auto_oob.clone.7+0x7c>
			buf += n;
		} else if (column == 0)
			break;
	}
	return 0;
}
34815378:	e3a00000 	mov	r0, #0
3481537c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

34815380 <onenand_write_oob_nolock>:
 *
 * OneNAND write out-of-band
 */
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34815380:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815384:	e24dd038 	sub	sp, sp, #56	; 0x38
34815388:	e59db058 	ldr	fp, [sp, #88]	; 0x58
	struct onenand_chip *this = mtd->priv;
3481538c:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
34815390:	e59b101c 	ldr	r1, [fp, #28]
	mtd_oob_mode_t mode = ops->mode;
34815394:	e59b4000 	ldr	r4, [fp]
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
34815398:	e58d1028 	str	r1, [sp, #40]	; 0x28
	mtd_oob_mode_t mode = ops->mode;

	to += ops->ooboffs;
3481539c:	e59b1014 	ldr	r1, [fp, #20]
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
	mtd_oob_mode_t mode = ops->mode;
348153a0:	e58d4030 	str	r4, [sp, #48]	; 0x30

	to += ops->ooboffs;
348153a4:	e0924001 	adds	r4, r2, r1
348153a8:	e2a35000 	adc	r5, r3, #0
348153ac:	e1cd41f8 	strd	r4, [sp, #24]
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
348153b0:	e59d5030 	ldr	r5, [sp, #48]	; 0x30
 *
 * OneNAND write out-of-band
 */
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
348153b4:	e1a06000 	mov	r6, r0
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
348153b8:	e3550001 	cmp	r5, #1
	to += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;
348153bc:	e3a03000 	mov	r3, #0
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
348153c0:	e59b000c 	ldr	r0, [fp, #12]
	to += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;
348153c4:	e58b3010 	str	r3, [fp, #16]
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);
348153c8:	e5969018 	ldr	r9, [r6, #24]

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
348153cc:	0597309c 	ldreq	r3, [r7, #156]	; 0x9c
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
348153d0:	e58d002c 	str	r0, [sp, #44]	; 0x2c
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);
348153d4:	e59d0018 	ldr	r0, [sp, #24]

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
348153d8:	0593a204 	ldreq	sl, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
348153dc:	1596a018 	ldrne	sl, [r6, #24]

	column = to & (mtd->oobsize - 1);
348153e0:	e2499001 	sub	r9, r9, #1
348153e4:	e0099000 	and	r9, r9, r0

	if (unlikely(column >= oobsize)) {
348153e8:	e159000a 	cmp	r9, sl
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
348153ec:	a59f0280 	ldrge	r0, [pc, #640]	; 34815674 <onenand_write_oob_nolock+0x2f4>
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);

	if (unlikely(column >= oobsize)) {
348153f0:	aa000004 	bge	34815408 <onenand_write_oob_nolock+0x88>
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
		return -EINVAL;
	}

	/* For compatibility with NAND: Do not allow write past end of page */
	if (unlikely(column + len > oobsize)) {
348153f4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
348153f8:	e089c001 	add	ip, r9, r1
348153fc:	e15c000a 	cmp	ip, sl
34815400:	9a000003 	bls	34815414 <onenand_write_oob_nolock+0x94>
		printk(KERN_ERR "onenand_write_oob_nolock: "
34815404:	e59f026c 	ldr	r0, [pc, #620]	; 34815678 <onenand_write_oob_nolock+0x2f8>
34815408:	ebffd1ea 	bl	34809bb8 <printf>
				"Attempt to write past end of page\n");
		return -EINVAL;
3481540c:	e3e09015 	mvn	r9, #21
34815410:	ea000094 	b	34815668 <onenand_write_oob_nolock+0x2e8>
	}

	/* Do not allow reads past end of device */
	if (unlikely(to >= mtd->size ||
34815414:	e596100c 	ldr	r1, [r6, #12]
34815418:	e59d201c 	ldr	r2, [sp, #28]
3481541c:	e5960008 	ldr	r0, [r6, #8]
34815420:	e1510002 	cmp	r1, r2
34815424:	8a000003 	bhi	34815438 <onenand_write_oob_nolock+0xb8>
34815428:	1a00001c 	bne	348154a0 <onenand_write_oob_nolock+0x120>
3481542c:	e59d3018 	ldr	r3, [sp, #24]
34815430:	e1500003 	cmp	r0, r3
34815434:	9a000019 	bls	348154a0 <onenand_write_oob_nolock+0x120>
34815438:	e5973034 	ldr	r3, [r7, #52]	; 0x34
3481543c:	e1a0400a 	mov	r4, sl
34815440:	e1a05fc4 	asr	r5, r4, #31
34815444:	e1a02003 	mov	r2, r3
34815448:	e1cd42f0 	strd	r4, [sp, #32]
3481544c:	e58dc010 	str	ip, [sp, #16]
34815450:	e58d3014 	str	r3, [sp, #20]
34815454:	eb002ba7 	bl	348202f8 <__lshrdi3>
34815458:	e59d3014 	ldr	r3, [sp, #20]
3481545c:	e1a04000 	mov	r4, r0
34815460:	e1a05001 	mov	r5, r1
34815464:	e1a02003 	mov	r2, r3
34815468:	e1cd01d8 	ldrd	r0, [sp, #24]
3481546c:	eb002ba8 	bl	34820314 <__ashrdi3>
34815470:	e0544000 	subs	r4, r4, r0
34815474:	e0c55001 	sbc	r5, r5, r1
34815478:	e003059a 	mul	r3, sl, r5
3481547c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34815480:	e59dc010 	ldr	ip, [sp, #16]
34815484:	e0233094 	mla	r3, r4, r0, r3
34815488:	e085449a 	umull	r4, r5, sl, r4
3481548c:	e0835005 	add	r5, r3, r5
34815490:	e3550000 	cmp	r5, #0
34815494:	1a000003 	bne	348154a8 <onenand_write_oob_nolock+0x128>
34815498:	e15c0004 	cmp	ip, r4
3481549c:	9a000001 	bls	348154a8 <onenand_write_oob_nolock+0x128>
				column + len > ((mtd->size >> this->page_shift) -
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
348154a0:	e59f01d4 	ldr	r0, [pc, #468]	; 3481567c <onenand_write_oob_nolock+0x2fc>
348154a4:	eaffffd7 	b	34815408 <onenand_write_oob_nolock+0x88>
		return -EINVAL;
	}

	oobbuf = this->oob_buf;

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
348154a8:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
		return -EINVAL;
	}

	oobbuf = this->oob_buf;
348154ac:	e5971090 	ldr	r1, [r7, #144]	; 0x90

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;
348154b0:	e3130008 	tst	r3, #8
348154b4:	03a0201a 	moveq	r2, #26
348154b8:	13a02080 	movne	r2, #128	; 0x80
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
		return -EINVAL;
	}

	oobbuf = this->oob_buf;
348154bc:	e58d1020 	str	r1, [sp, #32]

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;
348154c0:	e58d2034 	str	r2, [sp, #52]	; 0x34
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
348154c4:	e3a04000 	mov	r4, #0

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
348154c8:	ea000061 	b	34815654 <onenand_write_oob_nolock+0x2d4>
		int thislen = min_t(int, oobsize, len - written);
348154cc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
348154d0:	e3011978 	movw	r1, #6520	; 0x1978
	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
		int thislen = min_t(int, oobsize, len - written);
348154d4:	e0645003 	rsb	r5, r4, r3

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
348154d8:	e5963018 	ldr	r3, [r6, #24]
348154dc:	e1a00006 	mov	r0, r6
348154e0:	e58d3000 	str	r3, [sp]
348154e4:	e597c050 	ldr	ip, [r7, #80]	; 0x50
348154e8:	e1cd21d8 	ldrd	r2, [sp, #24]
348154ec:	e12fff3c 	blx	ip

		/* We send data to spare ram with oobsize
		 * to prevent byte access */
		memset(oobbuf, 0xff, mtd->oobsize);
348154f0:	e59d0020 	ldr	r0, [sp, #32]
348154f4:	e3a010ff 	mov	r1, #255	; 0xff
348154f8:	e5962018 	ldr	r2, [r6, #24]
348154fc:	eb001cfe 	bl	3481c8fc <memset>
		if (mode == MTD_OOB_AUTO)
34815500:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
		int thislen = min_t(int, oobsize, len - written);
34815504:	e155000a 	cmp	r5, sl
34815508:	a1a0500a 	movge	r5, sl
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);

		/* We send data to spare ram with oobsize
		 * to prevent byte access */
		memset(oobbuf, 0xff, mtd->oobsize);
		if (mode == MTD_OOB_AUTO)
3481550c:	e3500001 	cmp	r0, #1
34815510:	1a000006 	bne	34815530 <onenand_write_oob_nolock+0x1b0>
			onenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);
34815514:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34815518:	e59d1020 	ldr	r1, [sp, #32]
3481551c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
34815520:	e1a03009 	mov	r3, r9
34815524:	e58d5000 	str	r5, [sp]
34815528:	ebffff53 	bl	3481527c <onenand_fill_auto_oob.clone.7>
3481552c:	ea000004 	b	34815544 <onenand_write_oob_nolock+0x1c4>
		else
			memcpy(oobbuf + column, buf, thislen);
34815530:	e59d1020 	ldr	r1, [sp, #32]
34815534:	e1a02005 	mov	r2, r5
34815538:	e0810009 	add	r0, r1, r9
3481553c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34815540:	eb001d11 	bl	3481c98c <memcpy>
		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
34815544:	e59d3020 	ldr	r3, [sp, #32]
34815548:	e59f2130 	ldr	r2, [pc, #304]	; 34815680 <onenand_write_oob_nolock+0x300>
3481554c:	e58d3004 	str	r3, [sp, #4]
34815550:	e5963018 	ldr	r3, [r6, #24]
34815554:	e3a00000 	mov	r0, #0
34815558:	e58d2000 	str	r2, [sp]
3481555c:	e58d0008 	str	r0, [sp, #8]
34815560:	e58d300c 	str	r3, [sp, #12]
34815564:	e5971064 	ldr	r1, [r7, #100]	; 0x64
34815568:	e3a03000 	mov	r3, #0
3481556c:	e1a00006 	mov	r0, r6
34815570:	e3a02000 	mov	r2, #0
34815574:	e12fff31 	blx	r1

		if (ONENAND_IS_4KB_PAGE(this)) {
34815578:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
3481557c:	e3130008 	tst	r3, #8
34815580:	0a000010 	beq	348155c8 <onenand_write_oob_nolock+0x248>
			/* Set main area of DataRAM to 0xff*/
			memset(this->page_buf, 0xff, mtd->writesize);
34815584:	e3a010ff 	mov	r1, #255	; 0xff
34815588:	e5962014 	ldr	r2, [r6, #20]
3481558c:	e597008c 	ldr	r0, [r7, #140]	; 0x8c
34815590:	eb001cd9 	bl	3481c8fc <memset>
			this->write_bufferram(mtd, 0, ONENAND_DATARAM,
34815594:	e3a01b01 	mov	r1, #1024	; 0x400
34815598:	e58d1000 	str	r1, [sp]
3481559c:	e597308c 	ldr	r3, [r7, #140]	; 0x8c
348155a0:	e3a02000 	mov	r2, #0
348155a4:	e58d3004 	str	r3, [sp, #4]
348155a8:	e5963014 	ldr	r3, [r6, #20]
348155ac:	e58d2008 	str	r2, [sp, #8]
348155b0:	e58d300c 	str	r3, [sp, #12]
348155b4:	e5971064 	ldr	r1, [r7, #100]	; 0x64
348155b8:	e1a00006 	mov	r0, r6
348155bc:	e3a02000 	mov	r2, #0
348155c0:	e3a03000 	mov	r3, #0
348155c4:	e12fff31 	blx	r1
				this->page_buf,	0, mtd->writesize);
		}

		this->command(mtd, oobcmd, to, mtd->oobsize);
348155c8:	e5963018 	ldr	r3, [r6, #24]
348155cc:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
348155d0:	e58d3000 	str	r3, [sp]
348155d4:	e597c050 	ldr	ip, [r7, #80]	; 0x50
348155d8:	e1cd21d8 	ldrd	r2, [sp, #24]
348155dc:	e1a00006 	mov	r0, r6
348155e0:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, to, 0);
348155e4:	e3a03000 	mov	r3, #0
348155e8:	e58d3000 	str	r3, [sp]
348155ec:	e5960094 	ldr	r0, [r6, #148]	; 0x94
348155f0:	e1cd21d8 	ldrd	r2, [sp, #24]
348155f4:	ebffff0b 	bl	34815228 <onenand_update_bufferram.clone.2>
		if (ONENAND_IS_2PLANE(this)) {
			ONENAND_SET_BUFFERRAM1(this);
			onenand_update_bufferram(mtd, to + this->writesize, 0);
		}

		ret = this->wait(mtd, FL_WRITING);
348155f8:	e5973054 	ldr	r3, [r7, #84]	; 0x54
348155fc:	e1a00006 	mov	r0, r6
34815600:	e3a01002 	mov	r1, #2
34815604:	e12fff33 	blx	r3
		if (ret) {
34815608:	e2509000 	subs	r9, r0, #0
3481560c:	0a000003 	beq	34815620 <onenand_write_oob_nolock+0x2a0>
			printk(KERN_ERR "onenand_write_oob_nolock: write failed %d\n", ret);
34815610:	e1a01009 	mov	r1, r9
34815614:	e59f0068 	ldr	r0, [pc, #104]	; 34815684 <onenand_write_oob_nolock+0x304>
34815618:	ebffd166 	bl	34809bb8 <printf>
			break;
3481561c:	ea000010 	b	34815664 <onenand_write_oob_nolock+0x2e4>
			printk(KERN_ERR "onenand_write_oob_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
		if (written == len)
34815620:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
		if (ret) {
			printk(KERN_ERR "onenand_write_oob_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
34815624:	e0844005 	add	r4, r4, r5
		if (written == len)
34815628:	e1540000 	cmp	r4, r0
3481562c:	0a00000c 	beq	34815664 <onenand_write_oob_nolock+0x2e4>
			break;

		to += mtd->writesize;
34815630:	e5963014 	ldr	r3, [r6, #20]
34815634:	e1cd01d8 	ldrd	r0, [sp, #24]
34815638:	e0900003 	adds	r0, r0, r3
3481563c:	e2a11000 	adc	r1, r1, #0
34815640:	e1cd01f8 	strd	r0, [sp, #24]
		buf += thislen;
34815644:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
		column = 0;
34815648:	e3a09000 	mov	r9, #0
		written += thislen;
		if (written == len)
			break;

		to += mtd->writesize;
		buf += thislen;
3481564c:	e0811005 	add	r1, r1, r5
34815650:	e58d1028 	str	r1, [sp, #40]	; 0x28

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
34815654:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34815658:	e1540002 	cmp	r4, r2
3481565c:	3affff9a 	bcc	348154cc <onenand_write_oob_nolock+0x14c>
34815660:	e3a09000 	mov	r9, #0
		to += mtd->writesize;
		buf += thislen;
		column = 0;
	}

	ops->oobretlen = written;
34815664:	e58b4010 	str	r4, [fp, #16]

	return ret;
}
34815668:	e1a00009 	mov	r0, r9
3481566c:	e28dd038 	add	sp, sp, #56	; 0x38
34815670:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34815674:	348278ea 	.word	0x348278ea
34815678:	3482792a 	.word	0x3482792a
3481567c:	34827967 	.word	0x34827967
34815680:	00010020 	.word	0x00010020
34815684:	348279a8 	.word	0x348279a8

34815688 <onenand_write_ops_nolock>:
 *
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34815688:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481568c:	e24dd038 	sub	sp, sp, #56	; 0x38
34815690:	e59d6058 	ldr	r6, [sp, #88]	; 0x58
34815694:	e1cd21f0 	strd	r2, [sp, #16]
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
	const u_char *buf = ops->datbuf;
	const u_char *oob = ops->oobbuf;
34815698:	e596301c 	ldr	r3, [r6, #28]
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
3481569c:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 *
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
348156a0:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
348156a4:	e596100c 	ldr	r1, [r6, #12]
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
348156a8:	e5960004 	ldr	r0, [r6, #4]
	size_t ooblen = ops->ooblen;
	const u_char *buf = ops->datbuf;
348156ac:	e5962018 	ldr	r2, [r6, #24]
	const u_char *oob = ops->oobbuf;
348156b0:	e58d301c 	str	r3, [sp, #28]
	int ret = 0;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
348156b4:	e3a03000 	mov	r3, #0
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
348156b8:	e58d1034 	str	r1, [sp, #52]	; 0x34
	const u_char *buf = ops->datbuf;
348156bc:	e58d2028 	str	r2, [sp, #40]	; 0x28
	int ret = 0;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
348156c0:	e5863008 	str	r3, [r6, #8]
	ops->oobretlen = 0;
348156c4:	e5863010 	str	r3, [r6, #16]

	/* Do not allow writes past end of device */
	if (unlikely((to + len) > mtd->size)) {
348156c8:	e594100c 	ldr	r1, [r4, #12]
348156cc:	e1cd21d0 	ldrd	r2, [sp, #16]
348156d0:	e0922000 	adds	r2, r2, r0
348156d4:	e2a33000 	adc	r3, r3, #0
348156d8:	e1510003 	cmp	r1, r3
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
348156dc:	e58d0020 	str	r0, [sp, #32]
	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
	ops->oobretlen = 0;

	/* Do not allow writes past end of device */
	if (unlikely((to + len) > mtd->size)) {
348156e0:	3a000003 	bcc	348156f4 <onenand_write_ops_nolock+0x6c>
348156e4:	1a000004 	bne	348156fc <onenand_write_ops_nolock+0x74>
348156e8:	e5941008 	ldr	r1, [r4, #8]
348156ec:	e1510002 	cmp	r1, r2
348156f0:	2a000001 	bcs	348156fc <onenand_write_ops_nolock+0x74>
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt write to past end of device\n");
348156f4:	e59f02c0 	ldr	r0, [pc, #704]	; 348159bc <onenand_write_ops_nolock+0x334>
348156f8:	ea00000a 	b	34815728 <onenand_write_ops_nolock+0xa0>
		return -EINVAL;
	}

	/* Reject writes, which are not page aligned */
	if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
348156fc:	e5951098 	ldr	r1, [r5, #152]	; 0x98
34815700:	e1cd21d0 	ldrd	r2, [sp, #16]
34815704:	e2411001 	sub	r1, r1, #1
34815708:	e0022001 	and	r2, r2, r1
3481570c:	e0033fc1 	and	r3, r3, r1, asr #31
34815710:	e1920003 	orrs	r0, r2, r3
34815714:	1a000002 	bne	34815724 <onenand_write_ops_nolock+0x9c>
34815718:	e59d2020 	ldr	r2, [sp, #32]
3481571c:	e1110002 	tst	r1, r2
34815720:	0a000003 	beq	34815734 <onenand_write_ops_nolock+0xac>
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
34815724:	e59f0294 	ldr	r0, [pc, #660]	; 348159c0 <onenand_write_ops_nolock+0x338>
34815728:	ebffd122 	bl	34809bb8 <printf>
		return -EINVAL;
3481572c:	e3e07015 	mvn	r7, #21
34815730:	ea00009e 	b	348159b0 <onenand_write_ops_nolock+0x328>
	}

	if (ops->mode == MTD_OOB_AUTO)
34815734:	e5963000 	ldr	r3, [r6]
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34815738:	e5942018 	ldr	r2, [r4, #24]
	if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
		return -EINVAL;
	}

	if (ops->mode == MTD_OOB_AUTO)
3481573c:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
34815740:	0595309c 	ldreq	r3, [r5, #156]	; 0x9c
	else
		oobsize = mtd->oobsize;
34815744:	15943018 	ldrne	r3, [r4, #24]
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
		return -EINVAL;
	}

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815748:	05933204 	ldreq	r3, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);
3481574c:	e5947014 	ldr	r7, [r4, #20]
	}

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;
34815750:	e58d302c 	str	r3, [sp, #44]	; 0x2c

	oobcolumn = to & (mtd->oobsize - 1);
34815754:	e59d3010 	ldr	r3, [sp, #16]
34815758:	e2422001 	sub	r2, r2, #1
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
3481575c:	e3a00000 	mov	r0, #0
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34815760:	e0032002 	and	r2, r3, r2

	column = to & (mtd->writesize - 1);
34815764:	e2477001 	sub	r7, r7, #1
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34815768:	e58d2024 	str	r2, [sp, #36]	; 0x24

	column = to & (mtd->writesize - 1);
3481576c:	e0037007 	and	r7, r3, r7
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
34815770:	e58d0018 	str	r0, [sp, #24]
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
34815774:	e1a0b000 	mov	fp, r0
34815778:	e1a09006 	mov	r9, r6
	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
3481577c:	ea000083 	b	34815990 <onenand_write_ops_nolock+0x308>
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
34815780:	e59d1020 	ldr	r1, [sp, #32]
34815784:	e594a014 	ldr	sl, [r4, #20]
34815788:	e06b3001 	rsb	r3, fp, r1
3481578c:	e067a00a 	rsb	sl, r7, sl
34815790:	e153000a 	cmp	r3, sl
34815794:	b1a0a003 	movlt	sl, r3
34815798:	a1a0a00a 	movge	sl, sl
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
3481579c:	e58da000 	str	sl, [sp]
348157a0:	e1cd21d0 	ldrd	r2, [sp, #16]
348157a4:	e595c050 	ldr	ip, [r5, #80]	; 0x50
348157a8:	e1a00004 	mov	r0, r4
348157ac:	e3011978 	movw	r1, #6520	; 0x1978
348157b0:	e12fff3c 	blx	ip

		/* Partial page write */
		subpage = thislen < mtd->writesize;
348157b4:	e5942014 	ldr	r2, [r4, #20]
348157b8:	e15a0002 	cmp	sl, r2
348157bc:	23a03000 	movcs	r3, #0
348157c0:	33a03001 	movcc	r3, #1
		if (subpage) {
348157c4:	e3530000 	cmp	r3, #0
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);

		/* Partial page write */
		subpage = thislen < mtd->writesize;
348157c8:	e58d3030 	str	r3, [sp, #48]	; 0x30

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;
348157cc:	059d3028 	ldreq	r3, [sp, #40]	; 0x28

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);

		/* Partial page write */
		subpage = thislen < mtd->writesize;
		if (subpage) {
348157d0:	0a000008 	beq	348157f8 <onenand_write_ops_nolock+0x170>
			memset(this->page_buf, 0xff, mtd->writesize);
348157d4:	e3a010ff 	mov	r1, #255	; 0xff
348157d8:	e595008c 	ldr	r0, [r5, #140]	; 0x8c
348157dc:	eb001c46 	bl	3481c8fc <memset>
			memcpy(this->page_buf + column, buf, thislen);
348157e0:	e595008c 	ldr	r0, [r5, #140]	; 0x8c
348157e4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
348157e8:	e0800007 	add	r0, r0, r7
348157ec:	e1a0200a 	mov	r2, sl
348157f0:	eb001c65 	bl	3481c98c <memcpy>
			wbuf = this->page_buf;
348157f4:	e595308c 	ldr	r3, [r5, #140]	; 0x8c
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
348157f8:	e58d3004 	str	r3, [sp, #4]
348157fc:	e5943014 	ldr	r3, [r4, #20]
34815800:	e3a00b01 	mov	r0, #1024	; 0x400
34815804:	e3a01000 	mov	r1, #0
34815808:	e58d0000 	str	r0, [sp]
3481580c:	e58d300c 	str	r3, [sp, #12]
34815810:	e58d1008 	str	r1, [sp, #8]
34815814:	e1cd21d0 	ldrd	r2, [sp, #16]
34815818:	e5951064 	ldr	r1, [r5, #100]	; 0x64
3481581c:	e1a00004 	mov	r0, r4
34815820:	e12fff31 	blx	r1

		if (oob) {
34815824:	e59d201c 	ldr	r2, [sp, #28]
34815828:	e3520000 	cmp	r2, #0

			oobwritten += thisooblen;
			oob += thisooblen;
			oobcolumn = 0;
		} else
			oobbuf = (u_char *) ffchars;
3481582c:	059f6190 	ldreq	r6, [pc, #400]	; 348159c4 <onenand_write_ops_nolock+0x33c>
			wbuf = this->page_buf;
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);

		if (oob) {
34815830:	0a000023 	beq	348158c4 <onenand_write_ops_nolock+0x23c>
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34815834:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
34815838:	e59d0018 	ldr	r0, [sp, #24]
3481583c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34815840:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);

		if (oob) {
			oobbuf = this->oob_buf;
34815844:	e5956090 	ldr	r6, [r5, #144]	; 0x90
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34815848:	e0607003 	rsb	r7, r0, r3
3481584c:	e0623001 	rsb	r3, r2, r1
		if (oob) {
			oobbuf = this->oob_buf;

			/* We send data to spare ram with oobsize
			 *                          * to prevent byte access */
			memset(oobbuf, 0xff, mtd->oobsize);
34815850:	e1a00006 	mov	r0, r6
34815854:	e3a010ff 	mov	r1, #255	; 0xff
34815858:	e5942018 	ldr	r2, [r4, #24]
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
3481585c:	e1570003 	cmp	r7, r3
34815860:	a1a07003 	movge	r7, r3
		if (oob) {
			oobbuf = this->oob_buf;

			/* We send data to spare ram with oobsize
			 *                          * to prevent byte access */
			memset(oobbuf, 0xff, mtd->oobsize);
34815864:	eb001c24 	bl	3481c8fc <memset>
			if (ops->mode == MTD_OOB_AUTO)
34815868:	e5993000 	ldr	r3, [r9]
3481586c:	e3530001 	cmp	r3, #1
34815870:	1a000006 	bne	34815890 <onenand_write_ops_nolock+0x208>
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
34815874:	e5940094 	ldr	r0, [r4, #148]	; 0x94
34815878:	e1a01006 	mov	r1, r6
3481587c:	e59d201c 	ldr	r2, [sp, #28]
34815880:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34815884:	e58d7000 	str	r7, [sp]
34815888:	ebfffe7b 	bl	3481527c <onenand_fill_auto_oob.clone.7>
3481588c:	ea000004 	b	348158a4 <onenand_write_ops_nolock+0x21c>
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);
34815890:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34815894:	e59d101c 	ldr	r1, [sp, #28]
34815898:	e0860003 	add	r0, r6, r3
3481589c:	e1a02007 	mov	r2, r7
348158a0:	eb001c39 	bl	3481c98c <memcpy>

			oobwritten += thisooblen;
348158a4:	e59d0018 	ldr	r0, [sp, #24]
			oob += thisooblen;
348158a8:	e59d101c 	ldr	r1, [sp, #28]
			if (ops->mode == MTD_OOB_AUTO)
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);

			oobwritten += thisooblen;
348158ac:	e0800007 	add	r0, r0, r7
			oob += thisooblen;
348158b0:	e0811007 	add	r1, r1, r7
			oobcolumn = 0;
348158b4:	e3a02000 	mov	r2, #0
			if (ops->mode == MTD_OOB_AUTO)
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);

			oobwritten += thisooblen;
348158b8:	e58d0018 	str	r0, [sp, #24]
			oob += thisooblen;
348158bc:	e58d101c 	str	r1, [sp, #28]
			oobcolumn = 0;
348158c0:	e58d2024 	str	r2, [sp, #36]	; 0x24
		} else
			oobbuf = (u_char *) ffchars;

		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
348158c4:	e59f30fc 	ldr	r3, [pc, #252]	; 348159c8 <onenand_write_ops_nolock+0x340>
348158c8:	e3a00000 	mov	r0, #0
348158cc:	e58d3000 	str	r3, [sp]
348158d0:	e5943018 	ldr	r3, [r4, #24]
348158d4:	e58d0008 	str	r0, [sp, #8]
348158d8:	e58d300c 	str	r3, [sp, #12]
348158dc:	e58d6004 	str	r6, [sp, #4]
348158e0:	e5951064 	ldr	r1, [r5, #100]	; 0x64
348158e4:	e3a02000 	mov	r2, #0
348158e8:	e3a03000 	mov	r3, #0
348158ec:	e1a00004 	mov	r0, r4
348158f0:	e12fff31 	blx	r1

		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
348158f4:	e5943014 	ldr	r3, [r4, #20]
348158f8:	e3a01080 	mov	r1, #128	; 0x80
348158fc:	e58d3000 	str	r3, [sp]
34815900:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34815904:	e1cd21d0 	ldrd	r2, [sp, #16]
34815908:	e1a00004 	mov	r0, r4
3481590c:	e12fff3c 	blx	ip

		ret = this->wait(mtd, FL_WRITING);
34815910:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34815914:	e3a01002 	mov	r1, #2
34815918:	e1a00004 	mov	r0, r4
3481591c:	e12fff33 	blx	r3

		/* In partial page write we don't update bufferram */
		onenand_update_bufferram(mtd, to, !ret && !subpage);
34815920:	e59d1030 	ldr	r1, [sp, #48]	; 0x30

		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);

		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);

		ret = this->wait(mtd, FL_WRITING);
34815924:	e1a07000 	mov	r7, r0

		/* In partial page write we don't update bufferram */
		onenand_update_bufferram(mtd, to, !ret && !subpage);
34815928:	e1901001 	orrs	r1, r0, r1
3481592c:	13a03000 	movne	r3, #0
34815930:	03a03001 	moveq	r3, #1
34815934:	e58d3000 	str	r3, [sp]
34815938:	e5940094 	ldr	r0, [r4, #148]	; 0x94
3481593c:	e1cd21d0 	ldrd	r2, [sp, #16]
34815940:	ebfffe38 	bl	34815228 <onenand_update_bufferram.clone.2>
		if (ONENAND_IS_2PLANE(this)) {
			ONENAND_SET_BUFFERRAM1(this);
			onenand_update_bufferram(mtd, to + this->writesize, !ret && !subpage);
		}

		if (ret) {
34815944:	e3570000 	cmp	r7, #0
34815948:	0a000004 	beq	34815960 <onenand_write_ops_nolock+0x2d8>
			printk(KERN_ERR "onenand_write_ops_nolock: write filaed %d\n", ret);
3481594c:	e1a01007 	mov	r1, r7
34815950:	e59f0074 	ldr	r0, [pc, #116]	; 348159cc <onenand_write_ops_nolock+0x344>
34815954:	e1a06009 	mov	r6, r9
34815958:	ebffd096 	bl	34809bb8 <printf>
			break;
3481595c:	ea000012 	b	348159ac <onenand_write_ops_nolock+0x324>
			break;
		}

		written += thislen;

		if (written == len)
34815960:	e59d2020 	ldr	r2, [sp, #32]
		if (ret) {
			printk(KERN_ERR "onenand_write_ops_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
34815964:	e08bb00a 	add	fp, fp, sl

		if (written == len)
34815968:	e15b0002 	cmp	fp, r2
3481596c:	0a00000d 	beq	348159a8 <onenand_write_ops_nolock+0x320>
			break;

		column = 0;
		to += thislen;
34815970:	e1cd01d0 	ldrd	r0, [sp, #16]
34815974:	e090000a 	adds	r0, r0, sl
34815978:	e0a11fca 	adc	r1, r1, sl, asr #31
3481597c:	e1cd01f0 	strd	r0, [sp, #16]
		buf += thislen;
34815980:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
		written += thislen;

		if (written == len)
			break;

		column = 0;
34815984:	e3a07000 	mov	r7, #0
		to += thislen;
		buf += thislen;
34815988:	e081100a 	add	r1, r1, sl
3481598c:	e58d1028 	str	r1, [sp, #40]	; 0x28
	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
34815990:	e59d2020 	ldr	r2, [sp, #32]
34815994:	e15b0002 	cmp	fp, r2
34815998:	3affff78 	bcc	34815780 <onenand_write_ops_nolock+0xf8>
3481599c:	e1a06009 	mov	r6, r9
348159a0:	e3a07000 	mov	r7, #0
348159a4:	ea000000 	b	348159ac <onenand_write_ops_nolock+0x324>
348159a8:	e1a06009 	mov	r6, r9
		column = 0;
		to += thislen;
		buf += thislen;
	}

	ops->retlen = written;
348159ac:	e586b008 	str	fp, [r6, #8]

	return ret;
}
348159b0:	e1a00007 	mov	r0, r7
348159b4:	e28dd038 	add	sp, sp, #56	; 0x38
348159b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348159bc:	348279d3 	.word	0x348279d3
348159c0:	34827a12 	.word	0x34827a12
348159c4:	348217ac 	.word	0x348217ac
348159c8:	00010020 	.word	0x00010020
348159cc:	34827a54 	.word	0x34827a54

348159d0 <onenand_write_oob>:
 *
 * OneNAND write main and/or out-of-band
 */
int onenand_write_oob(struct mtd_info *mtd, loff_t to,
			struct mtd_oob_ops *ops)
{
348159d0:	e59d1000 	ldr	r1, [sp]
	int ret;

	switch (ops->mode) {
348159d4:	e591c000 	ldr	ip, [r1]
348159d8:	e35c0001 	cmp	ip, #1
348159dc:	8a000005 	bhi	348159f8 <onenand_write_oob+0x28>
	default:
		return -EINVAL;
	}

	onenand_get_device(mtd, FL_WRITING);
	if (ops->datbuf)
348159e0:	e591c018 	ldr	ip, [r1, #24]
348159e4:	e35c0000 	cmp	ip, #0
348159e8:	0a000000 	beq	348159f0 <onenand_write_oob+0x20>
		ret = onenand_write_ops_nolock(mtd, to, ops);
348159ec:	eaffff25 	b	34815688 <onenand_write_ops_nolock>
	else
		ret = onenand_write_oob_nolock(mtd, to, ops);
348159f0:	e58d1000 	str	r1, [sp]
348159f4:	eafffe61 	b	34815380 <onenand_write_oob_nolock>
	onenand_release_device(mtd);

	return ret;

}
348159f8:	e3e00015 	mvn	r0, #21
348159fc:	e12fff1e 	bx	lr

34815a00 <onenand_write>:
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
34815a00:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34815a04:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
34815a08:	e28d7008 	add	r7, sp, #8
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
34815a0c:	e1a06000 	mov	r6, r0
34815a10:	e1a04002 	mov	r4, r2
	struct mtd_oob_ops ops = {
34815a14:	e3a01000 	mov	r1, #0
34815a18:	e1a00007 	mov	r0, r7
34815a1c:	e3a02020 	mov	r2, #32
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
34815a20:	e1a05003 	mov	r5, r3
	struct mtd_oob_ops ops = {
34815a24:	eb001bb4 	bl	3481c8fc <memset>
34815a28:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34815a2c:	e1a02004 	mov	r2, r4
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
	struct mtd_oob_ops ops = {
34815a30:	e58d300c 	str	r3, [sp, #12]
34815a34:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34815a38:	e1a00006 	mov	r0, r6
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
	struct mtd_oob_ops ops = {
34815a3c:	e58d3020 	str	r3, [sp, #32]
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34815a40:	e1a03005 	mov	r3, r5
34815a44:	e58d7000 	str	r7, [sp]
34815a48:	ebffff0e 	bl	34815688 <onenand_write_ops_nolock>
	onenand_release_device(mtd);

	*retlen = ops.retlen;
34815a4c:	e59d2010 	ldr	r2, [sp, #16]
34815a50:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
34815a54:	e5832000 	str	r2, [r3]
	return ret;
}
34815a58:	e28dd02c 	add	sp, sp, #44	; 0x2c
34815a5c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

34815a60 <onenand_block>:
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
34815a60:	e92d4070 	push	{r4, r5, r6, lr}
34815a64:	e1a04000 	mov	r4, r0
	if (!FLEXONENAND(this))
34815a68:	e594501c 	ldr	r5, [r4, #28]
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
34815a6c:	e1a00002 	mov	r0, r2
	if (!FLEXONENAND(this))
34815a70:	e3150c02 	tst	r5, #512	; 0x200
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
34815a74:	e1a01003 	mov	r1, r3
	if (!FLEXONENAND(this))
34815a78:	1a000002 	bne	34815a88 <onenand_block+0x28>
		return addr >> this->erase_shift;
34815a7c:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34815a80:	eb002a23 	bl	34820314 <__ashrdi3>
34815a84:	e8bd8070 	pop	{r4, r5, r6, pc}
 */
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;

	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
34815a88:	e2155008 	ands	r5, r5, #8
34815a8c:	0a00000b 	beq	34815ac0 <onenand_block+0x60>
34815a90:	e5942010 	ldr	r2, [r4, #16]
34815a94:	e3a03000 	mov	r3, #0
34815a98:	e1530001 	cmp	r3, r1
34815a9c:	ca000006 	bgt	34815abc <onenand_block+0x5c>
34815aa0:	1a000001 	bne	34815aac <onenand_block+0x4c>
34815aa4:	e1520000 	cmp	r2, r0
34815aa8:	8a000003 	bhi	34815abc <onenand_block+0x5c>
		die = 1;
		addr -= this->diesize[0];
34815aac:	e0500002 	subs	r0, r0, r2
34815ab0:	e0c11003 	sbc	r1, r1, r3
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;

	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
34815ab4:	e3a05001 	mov	r5, #1
34815ab8:	ea000000 	b	34815ac0 <onenand_block+0x60>
 * @param this		- OneNAND device structure
 * @param addr		- Address for which block number is needed
 */
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;
34815abc:	e3a05000 	mov	r5, #0
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];

	blk = addr >> (this->erase_shift - 1);
34815ac0:	e5942030 	ldr	r2, [r4, #48]	; 0x30
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];
34815ac4:	e2853002 	add	r3, r5, #2

	blk = addr >> (this->erase_shift - 1);
34815ac8:	e2422001 	sub	r2, r2, #1
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];
34815acc:	e7946103 	ldr	r6, [r4, r3, lsl #2]

	blk = addr >> (this->erase_shift - 1);
34815ad0:	eb002a0f 	bl	34820314 <__ashrdi3>
	if (blk > boundary)
34815ad4:	e1500006 	cmp	r0, r6
		blk = (blk + boundary + 1) >> 1;
34815ad8:	82866001 	addhi	r6, r6, #1
34815adc:	80860000 	addhi	r0, r6, r0
34815ae0:	81a000a0 	lsrhi	r0, r0, #1

	blk += die ? this->density_mask : 0;
34815ae4:	e3550000 	cmp	r5, #0
34815ae8:	15945028 	ldrne	r5, [r4, #40]	; 0x28
34815aec:	e0850000 	add	r0, r5, r0
unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
	if (!FLEXONENAND(this))
		return addr >> this->erase_shift;
	return flexonenand_block(this, addr);
}
34815af0:	e8bd8070 	pop	{r4, r5, r6, pc}

34815af4 <onenand_default_block_markbad>:
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815af4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
34815af8:	e590a094 	ldr	sl, [r0, #148]	; 0x94
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815afc:	e24dd030 	sub	sp, sp, #48	; 0x30
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	u_char buf[2] = {0, 0};
34815b00:	e3a01000 	mov	r1, #0
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815b04:	e1a06002 	mov	r6, r2
34815b08:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	u_char buf[2] = {0, 0};
	struct mtd_oob_ops ops = {
34815b0c:	e3a02020 	mov	r2, #32
34815b10:	e28d000c 	add	r0, sp, #12
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34815b14:	e1a07003 	mov	r7, r3
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34815b18:	e59a50a0 	ldr	r5, [sl, #160]	; 0xa0
	u_char buf[2] = {0, 0};
34815b1c:	e5cd102c 	strb	r1, [sp, #44]	; 0x2c
34815b20:	e5cd102d 	strb	r1, [sp, #45]	; 0x2d
	struct mtd_oob_ops ops = {
34815b24:	eb001b74 	bl	3481c8fc <memset>
34815b28:	e3a03002 	mov	r3, #2
34815b2c:	e58d3018 	str	r3, [sp, #24]
34815b30:	e28d302c 	add	r3, sp, #44	; 0x2c
34815b34:	e58d3028 	str	r3, [sp, #40]	; 0x28
		.ooboffs = 0,
	};
	int block;

	/* Get block number */
	block = onenand_block(this, ofs);
34815b38:	e1a0000a 	mov	r0, sl
34815b3c:	e1a03007 	mov	r3, r7
34815b40:	e1a02006 	mov	r2, r6
34815b44:	ebffffc5 	bl	34815a60 <onenand_block>
	if (bbm->bbt)
34815b48:	e595300c 	ldr	r3, [r5, #12]
34815b4c:	e3530000 	cmp	r3, #0
34815b50:	0a000005 	beq	34815b6c <onenand_default_block_markbad+0x78>
		bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
34815b54:	e7d31140 	ldrb	r1, [r3, r0, asr #2]
34815b58:	e2002003 	and	r2, r0, #3
34815b5c:	e1a02082 	lsl	r2, r2, #1
34815b60:	e3a0c001 	mov	ip, #1
34815b64:	e181221c 	orr	r2, r1, ip, lsl r2
34815b68:	e7c32140 	strb	r2, [r3, r0, asr #2]

	/* We write two bytes, so we dont have to mess with 16 bit access */
	ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
34815b6c:	e5952004 	ldr	r2, [r5, #4]
34815b70:	e5943018 	ldr	r3, [r4, #24]
34815b74:	e3c22001 	bic	r2, r2, #1
34815b78:	e0822003 	add	r2, r2, r3
	return onenand_write_oob_nolock(mtd, ofs, &ops);
34815b7c:	e1a00004 	mov	r0, r4
34815b80:	e0964002 	adds	r4, r6, r2
34815b84:	e28d300c 	add	r3, sp, #12
34815b88:	e2a75000 	adc	r5, r7, #0
34815b8c:	e58d3000 	str	r3, [sp]
34815b90:	e1a02004 	mov	r2, r4
34815b94:	e1a03005 	mov	r3, r5
34815b98:	ebfffdf8 	bl	34815380 <onenand_write_oob_nolock>
}
34815b9c:	e28dd030 	add	sp, sp, #48	; 0x30
34815ba0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34815ba4 <onenand_addr>:
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
	if (!FLEXONENAND(this))
34815ba4:	e590201c 	ldr	r2, [r0, #28]
			<< (this->erase_shift - 1);
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
34815ba8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	if (!FLEXONENAND(this))
34815bac:	e3120c02 	tst	r2, #512	; 0x200
			<< (this->erase_shift - 1);
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
34815bb0:	e1a03000 	mov	r3, r0
34815bb4:	e1a06001 	mov	r6, r1
	if (!FLEXONENAND(this))
34815bb8:	1a000006 	bne	34815bd8 <onenand_addr+0x34>
		return (loff_t) block << this->erase_shift;
34815bbc:	e1a00001 	mov	r0, r1
34815bc0:	e1a01fc0 	asr	r1, r0, #31
34815bc4:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34815bc8:	eb0029d8 	bl	34820330 <__ashldi3>
34815bcc:	e1a04000 	mov	r4, r0
34815bd0:	e1a05001 	mov	r5, r1
34815bd4:	ea000020 	b	34815c5c <onenand_addr+0xb8>
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
34815bd8:	e2122008 	ands	r2, r2, #8
34815bdc:	0a000007 	beq	34815c00 <onenand_addr+0x5c>
34815be0:	e5902028 	ldr	r2, [r0, #40]	; 0x28
34815be4:	e1510002 	cmp	r1, r2
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;
34815be8:	33a02000 	movcc	r2, #0

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
34815bec:	25904010 	ldrcs	r4, [r0, #16]
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
34815bf0:	20626001 	rsbcs	r6, r2, r1
		die = 1;
		ofs = this->diesize[0];
34815bf4:	23a05000 	movcs	r5, #0
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
34815bf8:	23a02001 	movcs	r2, #1
34815bfc:	2a000001 	bcs	34815c08 <onenand_addr+0x64>
 *
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
34815c00:	e3a04000 	mov	r4, #0
34815c04:	e3a05000 	mov	r5, #0
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
34815c08:	e5937030 	ldr	r7, [r3, #48]	; 0x30
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
34815c0c:	e2822002 	add	r2, r2, #2
	ofs += (loff_t) block << (this->erase_shift - 1);
34815c10:	e2477001 	sub	r7, r7, #1
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
34815c14:	e793a102 	ldr	sl, [r3, r2, lsl #2]
	ofs += (loff_t) block << (this->erase_shift - 1);
34815c18:	e1a00006 	mov	r0, r6
34815c1c:	e1a01fc0 	asr	r1, r0, #31
34815c20:	e1a02007 	mov	r2, r7
34815c24:	eb0029c1 	bl	34820330 <__ashldi3>
	if (block > (boundary + 1))
34815c28:	e28a3001 	add	r3, sl, #1
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
34815c2c:	e0944000 	adds	r4, r4, r0
34815c30:	e0a55001 	adc	r5, r5, r1
	if (block > (boundary + 1))
34815c34:	e1560003 	cmp	r6, r3
34815c38:	da000007 	ble	34815c5c <onenand_addr+0xb8>
		ofs += (loff_t) (block - boundary - 1)
34815c3c:	e2466001 	sub	r6, r6, #1
34815c40:	e06aa006 	rsb	sl, sl, r6
			<< (this->erase_shift - 1);
34815c44:	e1a0000a 	mov	r0, sl
34815c48:	e1a01fc0 	asr	r1, r0, #31
34815c4c:	e1a02007 	mov	r2, r7
34815c50:	eb0029b6 	bl	34820330 <__ashldi3>
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
	if (block > (boundary + 1))
		ofs += (loff_t) (block - boundary - 1)
34815c54:	e0944000 	adds	r4, r4, r0
34815c58:	e0a55001 	adc	r5, r5, r1
loff_t onenand_addr(struct onenand_chip *this, int block)
{
	if (!FLEXONENAND(this))
		return (loff_t) block << this->erase_shift;
	return flexonenand_addr(this, block);
}
34815c5c:	e1a00004 	mov	r0, r4
34815c60:	e1a01005 	mov	r1, r5
34815c64:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34815c68 <onenand_command>:

	/* Now we use page size operation */
	int sectors = 0, count = 0;

	/* Address translation */
	switch (cmd) {
34815c68:	e351002c 	cmp	r1, #44	; 0x2c
 * Send command to OneNAND device. This function is used for middle/large page
 * devices (1KB/2KB Bytes per page)
 */
static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
			   size_t len)
{
34815c6c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34815c70:	e1a05001 	mov	r5, r1
34815c74:	e1a06002 	mov	r6, r2
	struct onenand_chip *this = mtd->priv;
34815c78:	e5904094 	ldr	r4, [r0, #148]	; 0x94

	/* Now we use page size operation */
	int sectors = 0, count = 0;

	/* Address translation */
	switch (cmd) {
34815c7c:	0a000079 	beq	34815e68 <onenand_command+0x200>
34815c80:	ca000006 	bgt	34815ca0 <onenand_command+0x38>
34815c84:	e3510027 	cmp	r1, #39	; 0x27
34815c88:	0a000076 	beq	34815e68 <onenand_command+0x200>
34815c8c:	e351002a 	cmp	r1, #42	; 0x2a
34815c90:	0a000074 	beq	34815e68 <onenand_command+0x200>
34815c94:	e3510023 	cmp	r1, #35	; 0x23
34815c98:	1a00001c 	bne	34815d10 <onenand_command+0xa8>
34815c9c:	ea000071 	b	34815e68 <onenand_command+0x200>
34815ca0:	e3510094 	cmp	r1, #148	; 0x94
34815ca4:	0a00000e 	beq	34815ce4 <onenand_command+0x7c>
34815ca8:	ca000002 	bgt	34815cb8 <onenand_command+0x50>
34815cac:	e3510066 	cmp	r1, #102	; 0x66
34815cb0:	1a000016 	bne	34815d10 <onenand_command+0xa8>
34815cb4:	ea000006 	b	34815cd4 <onenand_command+0x6c>
34815cb8:	e3012978 	movw	r2, #6520	; 0x1978
34815cbc:	e1510002 	cmp	r1, r2
34815cc0:	0a000007 	beq	34815ce4 <onenand_command+0x7c>
34815cc4:	e282200d 	add	r2, r2, #13
34815cc8:	e1510002 	cmp	r1, r2
34815ccc:	1a00000f 	bne	34815d10 <onenand_command+0xa8>
34815cd0:	ea000009 	b	34815cfc <onenand_command+0x94>
		page = -1;
		break;

	case FLEXONENAND_CMD_PI_ACCESS:
		/* addr contains die index */
		block = addr * this->density_mask;
34815cd4:	e5947028 	ldr	r7, [r4, #40]	; 0x28
		page = -1;
34815cd8:	e3e06000 	mvn	r6, #0
		page = -1;
		break;

	case FLEXONENAND_CMD_PI_ACCESS:
		/* addr contains die index */
		block = addr * this->density_mask;
34815cdc:	e0070792 	mul	r7, r2, r7
		page = -1;
		break;
34815ce0:	ea000029 	b	34815d8c <onenand_command+0x124>

	case ONENAND_CMD_ERASE:
	case ONENAND_CMD_BUFFERRAM:
		block = onenand_block(this, addr);
34815ce4:	e1a02006 	mov	r2, r6
34815ce8:	e1a00004 	mov	r0, r4
34815cec:	ebffff5b 	bl	34815a60 <onenand_block>
		page = -1;
34815cf0:	e3e06000 	mvn	r6, #0
		page = -1;
		break;

	case ONENAND_CMD_ERASE:
	case ONENAND_CMD_BUFFERRAM:
		block = onenand_block(this, addr);
34815cf4:	e1a07000 	mov	r7, r0
		page = -1;
		break;
34815cf8:	ea00000f 	b	34815d3c <onenand_command+0xd4>

	case FLEXONENAND_CMD_READ_PI:
		cmd = ONENAND_CMD_READ;
		block = addr * this->density_mask;
34815cfc:	e5947028 	ldr	r7, [r4, #40]	; 0x28
34815d00:	e0070796 	mul	r7, r6, r7
		page = 0;
34815d04:	e3a06000 	mov	r6, #0
		block = onenand_block(this, addr);
		page = -1;
		break;

	case FLEXONENAND_CMD_READ_PI:
		cmd = ONENAND_CMD_READ;
34815d08:	e1a05006 	mov	r5, r6
		block = addr * this->density_mask;
		page = 0;
		break;
34815d0c:	ea00001e 	b	34815d8c <onenand_command+0x124>

	default:
		block = onenand_block(this, addr);
34815d10:	e1a02006 	mov	r2, r6
34815d14:	e1a00004 	mov	r0, r4
34815d18:	ebffff50 	bl	34815a60 <onenand_block>
34815d1c:	e1a07000 	mov	r7, r0
		page = (int) (addr
			- onenand_addr(this, block)) >> this->page_shift;
34815d20:	e1a01007 	mov	r1, r7
34815d24:	e1a00004 	mov	r0, r4
34815d28:	ebffff9d 	bl	34815ba4 <onenand_addr>
		page = 0;
		break;

	default:
		block = onenand_block(this, addr);
		page = (int) (addr
34815d2c:	e5942034 	ldr	r2, [r4, #52]	; 0x34
			- onenand_addr(this, block)) >> this->page_shift;
		page &= this->page_mask;
34815d30:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
		page = 0;
		break;

	default:
		block = onenand_block(this, addr);
		page = (int) (addr
34815d34:	e0606006 	rsb	r6, r0, r6
			- onenand_addr(this, block)) >> this->page_shift;
		page &= this->page_mask;
34815d38:	e0036256 	and	r6, r3, r6, asr r2
		break;
	}

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
34815d3c:	e3013978 	movw	r3, #6520	; 0x1978
34815d40:	e1550003 	cmp	r5, r3
34815d44:	1a000010 	bne	34815d8c <onenand_command+0x124>
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34815d48:	e5943028 	ldr	r3, [r4, #40]	; 0x28

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815d4c:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815d50:	e0177003 	ands	r7, r7, r3

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815d54:	e59f1144 	ldr	r1, [pc, #324]	; 34815ea0 <onenand_command+0x238>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815d58:	01a00007 	moveq	r0, r7
34815d5c:	13a00902 	movne	r0, #32768	; 0x8000

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815d60:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815d64:	e6ff0070 	uxth	r0, r0
34815d68:	e0821001 	add	r1, r2, r1
34815d6c:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS2);

		if (ONENAND_IS_4KB_PAGE(this))
34815d70:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34815d74:	e3130008 	tst	r3, #8
			ONENAND_SET_BUFFERRAM0(this);
		else
			/* Switch to the next data buffer */
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815d78:	05943044 	ldreq	r3, [r4, #68]	; 0x44
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS2);

		if (ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_BUFFERRAM0(this);
34815d7c:	13a03000 	movne	r3, #0
		else
			/* Switch to the next data buffer */
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815d80:	02233001 	eoreq	r3, r3, #1
34815d84:	e5843044 	str	r3, [r4, #68]	; 0x44
34815d88:	ea000042 	b	34815e98 <onenand_command+0x230>

		return 0;
	}

	if (block != -1) {
34815d8c:	e3770001 	cmn	r7, #1
34815d90:	0a000014 	beq	34815de8 <onenand_command+0x180>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34815d94:	e5940028 	ldr	r0, [r4, #40]	; 0x28
	}

	if (block != -1) {
		/* Write 'DFS, FBA' of Flash */
		value = onenand_block_address(this, block);
		this->write_word(value,
34815d98:	e5941000 	ldr	r1, [r4]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34815d9c:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34815da0:	10270000 	eorne	r0, r7, r0
34815da4:	13800902 	orrne	r0, r0, #32768	; 0x8000
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34815da8:	01a00007 	moveq	r0, r7
	}

	if (block != -1) {
		/* Write 'DFS, FBA' of Flash */
		value = onenand_block_address(this, block);
		this->write_word(value,
34815dac:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34815db0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815db4:	e6ff0070 	uxth	r0, r0
34815db8:	e2811c02 	add	r1, r1, #512	; 0x200
34815dbc:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34815dc0:	e5943028 	ldr	r3, [r4, #40]	; 0x28
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815dc4:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815dc8:	e0177003 	ands	r7, r7, r3
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815dcc:	e59f10cc 	ldr	r1, [pc, #204]	; 34815ea0 <onenand_command+0x238>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815dd0:	01a00007 	moveq	r0, r7
34815dd4:	13a00902 	movne	r0, #32768	; 0x8000
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815dd8:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815ddc:	e6ff0070 	uxth	r0, r0
34815de0:	e0821001 	add	r1, r2, r1
34815de4:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS2);
	}

	if (page != -1) {
34815de8:	e3760001 	cmn	r6, #1
34815dec:	0a00001d 	beq	34815e68 <onenand_command+0x200>
		int dataram;

		switch (cmd) {
34815df0:	e3550013 	cmp	r5, #19
34815df4:	8a00000c 	bhi	34815e2c <onenand_command+0x1c4>
34815df8:	e3a02001 	mov	r2, #1
34815dfc:	e1a02512 	lsl	r2, r2, r5
34815e00:	e59f309c 	ldr	r3, [pc, #156]	; 34815ea4 <onenand_command+0x23c>
34815e04:	e0023003 	and	r3, r2, r3
34815e08:	e3530000 	cmp	r3, #0
34815e0c:	0a000006 	beq	34815e2c <onenand_command+0x1c4>
		case FLEXONENAND_CMD_RECOVER_LSB:
		case ONENAND_CMD_READ:
		case ONENAND_CMD_READOOB:
			if (ONENAND_IS_4KB_PAGE(this))
34815e10:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34815e14:	e3130008 	tst	r3, #8
				dataram = ONENAND_SET_BUFFERRAM0(this);
			else
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
34815e18:	05947044 	ldreq	r7, [r4, #68]	; 0x44
		switch (cmd) {
		case FLEXONENAND_CMD_RECOVER_LSB:
		case ONENAND_CMD_READ:
		case ONENAND_CMD_READOOB:
			if (ONENAND_IS_4KB_PAGE(this))
				dataram = ONENAND_SET_BUFFERRAM0(this);
34815e1c:	13a07000 	movne	r7, #0
			else
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
34815e20:	02277001 	eoreq	r7, r7, #1
34815e24:	e5847044 	str	r7, [r4, #68]	; 0x44
34815e28:	ea000000 	b	34815e30 <onenand_command+0x1c8>

			break;

		default:
			dataram = ONENAND_CURRENT_BUFFERRAM(this);
34815e2c:	e5947044 	ldr	r7, [r4, #68]	; 0x44
			break;
		}

		/* Write 'FPA, FSA' of Flash */
		value = onenand_page_address(page, sectors);
		this->write_word(value,
34815e30:	e5942000 	ldr	r2, [r4]
34815e34:	e59f106c 	ldr	r1, [pc, #108]	; 34815ea8 <onenand_command+0x240>
static int onenand_page_address(int page, int sector)
{
	/* Flash Page Address, Flash Sector Address */
	int fpa, fsa;

	fpa = page & ONENAND_FPA_MASK;
34815e38:	e206607f 	and	r6, r6, #127	; 0x7f
			break;
		}

		/* Write 'FPA, FSA' of Flash */
		value = onenand_page_address(page, sectors);
		this->write_word(value,
34815e3c:	e1a00106 	lsl	r0, r6, #2
34815e40:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815e44:	e0821001 	add	r1, r2, r1
34815e48:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS8);

		/* Write 'BSA, BSC' of DataRAM */
		value = onenand_buffer_address(dataram, sectors, count);
		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
34815e4c:	e5941000 	ldr	r1, [r4]
34815e50:	e3570000 	cmp	r7, #0
34815e54:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815e58:	13a00b03 	movne	r0, #3072	; 0xc00
34815e5c:	03a00b02 	moveq	r0, #2048	; 0x800
34815e60:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815e64:	e12fff33 	blx	r3
	}

	/* Interrupt clear */
	this->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);
34815e68:	e5941000 	ldr	r1, [r4]
34815e6c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815e70:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815e74:	e3a00000 	mov	r0, #0
34815e78:	e2811082 	add	r1, r1, #130	; 0x82
34815e7c:	e12fff33 	blx	r3
	/* Write command */
	this->write_word(cmd, this->base + ONENAND_REG_COMMAND);
34815e80:	e5941000 	ldr	r1, [r4]
34815e84:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815e88:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815e8c:	e6ff0075 	uxth	r0, r5
34815e90:	e2811040 	add	r1, r1, #64	; 0x40
34815e94:	e12fff33 	blx	r3

	return 0;
}
34815e98:	e3a00000 	mov	r0, #0
34815e9c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34815ea0:	0001e202 	.word	0x0001e202
34815ea4:	00080021 	.word	0x00080021
34815ea8:	0001e20e 	.word	0x0001e20e

34815eac <flexonenand_region>:
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
34815eac:	e3a0c000 	mov	ip, #0
 * flexonenand_region - [Flex-OneNAND] Return erase region of addr
 * @param mtd		MTD device structure
 * @param addr		address whose erase region needs to be identified
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
34815eb0:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
34815eb4:	e1a0100c 	mov	r1, ip
34815eb8:	e590502c 	ldr	r5, [r0, #44]	; 0x2c
34815ebc:	ea000009 	b	34815ee8 <flexonenand_region+0x3c>
		if (addr < mtd->eraseregions[i].offset)
34815ec0:	e5904030 	ldr	r4, [r0, #48]	; 0x30
34815ec4:	e7b4600c 	ldr	r6, [r4, ip]!
34815ec8:	e28cc018 	add	ip, ip, #24
34815ecc:	e5944004 	ldr	r4, [r4, #4]
34815ed0:	e1540003 	cmp	r4, r3
34815ed4:	8a000005 	bhi	34815ef0 <flexonenand_region+0x44>
34815ed8:	1a000001 	bne	34815ee4 <flexonenand_region+0x38>
34815edc:	e1560002 	cmp	r6, r2
34815ee0:	8a000002 	bhi	34815ef0 <flexonenand_region+0x44>
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
34815ee4:	e2811001 	add	r1, r1, #1
34815ee8:	e1510005 	cmp	r1, r5
34815eec:	bafffff3 	blt	34815ec0 <flexonenand_region+0x14>
		if (addr < mtd->eraseregions[i].offset)
			break;
	return i - 1;
}
34815ef0:	e2410001 	sub	r0, r1, #1
34815ef4:	e8bd8070 	pop	{r4, r5, r6, pc}

34815ef8 <onenand_recover_lsb>:
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815ef8:	e92d4c73 	push	{r0, r1, r4, r5, r6, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34815efc:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815f00:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
34815f04:	e594101c 	ldr	r1, [r4, #28]
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815f08:	e1a0a002 	mov	sl, r2
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
34815f0c:	e3110c02 	tst	r1, #512	; 0x200
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
34815f10:	e1a0b003 	mov	fp, r3
34815f14:	e59d6020 	ldr	r6, [sp, #32]
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
34815f18:	0a000019 	beq	34815f84 <onenand_recover_lsb+0x8c>
		return status;

	/* check if we failed due to uncorrectable error */
	if (status != -EBADMSG && status != ONENAND_BBT_READ_ECC_ERROR)
34815f1c:	e3560002 	cmp	r6, #2
34815f20:	1376004a 	cmnne	r6, #74	; 0x4a
34815f24:	1a000016 	bne	34815f84 <onenand_recover_lsb+0x8c>
		return status;

	/* check if address lies in MLC region */
	i = flexonenand_region(mtd, addr);
34815f28:	ebffffdf 	bl	34815eac <flexonenand_region>
	if (mtd->eraseregions[i].erasesize < (1 << this->erase_shift))
34815f2c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
34815f30:	e3a02018 	mov	r2, #24
34815f34:	e0233092 	mla	r3, r2, r0, r3
34815f38:	e5932008 	ldr	r2, [r3, #8]
34815f3c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34815f40:	e1b03332 	lsrs	r3, r2, r3
34815f44:	0a00000e 	beq	34815f84 <onenand_recover_lsb+0x8c>
		return status;

	printk("onenand_recover_lsb:"
34815f48:	e59f003c 	ldr	r0, [pc, #60]	; 34815f8c <onenand_recover_lsb+0x94>
34815f4c:	ebffcf19 	bl	34809bb8 <printf>
		"Attempting to recover from uncorrectable read\n");

	/* Issue the LSB page recovery command */
	this->command(mtd, FLEXONENAND_CMD_RECOVER_LSB, addr, this->writesize);
34815f50:	e5943040 	ldr	r3, [r4, #64]	; 0x40
34815f54:	e3a01005 	mov	r1, #5
34815f58:	e58d3000 	str	r3, [sp]
34815f5c:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34815f60:	e1a0200a 	mov	r2, sl
34815f64:	e1a0300b 	mov	r3, fp
34815f68:	e1a00005 	mov	r0, r5
34815f6c:	e12fff3c 	blx	ip
	return this->wait(mtd, FL_READING);
34815f70:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815f74:	e1a00005 	mov	r0, r5
34815f78:	e3a01001 	mov	r1, #1
34815f7c:	e12fff33 	blx	r3
34815f80:	e1a06000 	mov	r6, r0
}
34815f84:	e1a00006 	mov	r0, r6
34815f88:	e8bd8c7c 	pop	{r2, r3, r4, r5, r6, sl, fp, pc}
34815f8c:	34827a7f 	.word	0x34827a7f

34815f90 <onenand_read_oob_nolock>:
 *
 * OneNAND read out-of-band data from the spare area
 */
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34815f90:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815f94:	e24dd040 	sub	sp, sp, #64	; 0x40
34815f98:	e59db060 	ldr	fp, [sp, #96]	; 0x60
	struct onenand_chip *this = mtd->priv;
34815f9c:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
34815fa0:	e59b1000 	ldr	r1, [fp]
	u_char *buf = ops->oobbuf;
34815fa4:	e59b401c 	ldr	r4, [fp, #28]
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
34815fa8:	e58d1034 	str	r1, [sp, #52]	; 0x34
	u_char *buf = ops->oobbuf;
	int ret = 0, readcmd;

	from += ops->ooboffs;
34815fac:	e59b1014 	ldr	r1, [fp, #20]
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
	u_char *buf = ops->oobbuf;
34815fb0:	e58d4024 	str	r4, [sp, #36]	; 0x24
	int ret = 0, readcmd;

	from += ops->ooboffs;
34815fb4:	e0924001 	adds	r4, r2, r1
34815fb8:	e2a35000 	adc	r5, r3, #0
34815fbc:	e1cd41f8 	strd	r4, [sp, #24]
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34815fc0:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
 *
 * OneNAND read out-of-band data from the spare area
 */
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34815fc4:	e1a06000 	mov	r6, r0
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34815fc8:	e3550001 	cmp	r5, #1
	from += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;
34815fcc:	e3a03000 	mov	r3, #0
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
34815fd0:	e59b000c 	ldr	r0, [fp, #12]
	from += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;
34815fd4:	e58b3010 	str	r3, [fp, #16]
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);
34815fd8:	e5969018 	ldr	r9, [r6, #24]

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815fdc:	0597309c 	ldreq	r3, [r7, #156]	; 0x9c
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
34815fe0:	e58d0030 	str	r0, [sp, #48]	; 0x30
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);
34815fe4:	e59d0018 	ldr	r0, [sp, #24]

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815fe8:	0593a204 	ldreq	sl, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
34815fec:	1596a018 	ldrne	sl, [r6, #24]

	column = from & (mtd->oobsize - 1);
34815ff0:	e2499001 	sub	r9, r9, #1
34815ff4:	e0099000 	and	r9, r9, r0

	if (unlikely(column >= oobsize)) {
34815ff8:	e159000a 	cmp	r9, sl
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
34815ffc:	a59f0220 	ldrge	r0, [pc, #544]	; 34816224 <onenand_read_oob_nolock+0x294>
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);

	if (unlikely(column >= oobsize)) {
34816000:	aa000025 	bge	3481609c <onenand_read_oob_nolock+0x10c>
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
		return -EINVAL;
	}

	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
34816004:	e596100c 	ldr	r1, [r6, #12]
34816008:	e59d201c 	ldr	r2, [sp, #28]
3481600c:	e5960008 	ldr	r0, [r6, #8]
34816010:	e1510002 	cmp	r1, r2
34816014:	8a000003 	bhi	34816028 <onenand_read_oob_nolock+0x98>
34816018:	1a00001e 	bne	34816098 <onenand_read_oob_nolock+0x108>
3481601c:	e59d3018 	ldr	r3, [sp, #24]
34816020:	e1500003 	cmp	r0, r3
34816024:	9a00001b 	bls	34816098 <onenand_read_oob_nolock+0x108>
34816028:	e5973034 	ldr	r3, [r7, #52]	; 0x34
3481602c:	e59d4030 	ldr	r4, [sp, #48]	; 0x30
34816030:	e1a02003 	mov	r2, r3
34816034:	e089c004 	add	ip, r9, r4
34816038:	e1a0400a 	mov	r4, sl
3481603c:	e1a05fc4 	asr	r5, r4, #31
34816040:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
34816044:	e58dc010 	str	ip, [sp, #16]
34816048:	e58d3014 	str	r3, [sp, #20]
3481604c:	eb0028a9 	bl	348202f8 <__lshrdi3>
34816050:	e59d3014 	ldr	r3, [sp, #20]
34816054:	e1a04000 	mov	r4, r0
34816058:	e1a05001 	mov	r5, r1
3481605c:	e1a02003 	mov	r2, r3
34816060:	e1cd01d8 	ldrd	r0, [sp, #24]
34816064:	eb0028aa 	bl	34820314 <__ashrdi3>
34816068:	e0544000 	subs	r4, r4, r0
3481606c:	e0c55001 	sbc	r5, r5, r1
34816070:	e003059a 	mul	r3, sl, r5
34816074:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
34816078:	e59dc010 	ldr	ip, [sp, #16]
3481607c:	e0233094 	mla	r3, r4, r0, r3
34816080:	e085449a 	umull	r4, r5, sl, r4
34816084:	e0835005 	add	r5, r3, r5
34816088:	e3550000 	cmp	r5, #0
3481608c:	1a000005 	bne	348160a8 <onenand_read_oob_nolock+0x118>
34816090:	e15c0004 	cmp	ip, r4
34816094:	9a000003 	bls	348160a8 <onenand_read_oob_nolock+0x118>
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
34816098:	e59f0188 	ldr	r0, [pc, #392]	; 34816228 <onenand_read_oob_nolock+0x298>
3481609c:	ebffcec5 	bl	34809bb8 <printf>
		return -EINVAL;
348160a0:	e3e04015 	mvn	r4, #21
348160a4:	ea00005b 	b	34816218 <onenand_read_oob_nolock+0x288>
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
348160a8:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
		return -EINVAL;
348160ac:	e5961084 	ldr	r1, [r6, #132]	; 0x84
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
348160b0:	e3130008 	tst	r3, #8
348160b4:	03a02013 	moveq	r2, #19
348160b8:	13a02000 	movne	r2, #0
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
	u_char *buf = ops->oobbuf;
	int ret = 0, readcmd;
348160bc:	e3a04000 	mov	r4, #0
348160c0:	e58db028 	str	fp, [sp, #40]	; 0x28
	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
		return -EINVAL;
348160c4:	e58d103c 	str	r1, [sp, #60]	; 0x3c
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
348160c8:	e58d2038 	str	r2, [sp, #56]	; 0x38
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
348160cc:	e1a05004 	mov	r5, r4
348160d0:	e1a0b00a 	mov	fp, sl
	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
348160d4:	ea000043 	b	348161e8 <onenand_read_oob_nolock+0x258>
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
348160d8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
		this->command(mtd, readcmd, from, mtd->oobsize);
348160dc:	e59d1038 	ldr	r1, [sp, #56]	; 0x38

	while (read < len) {
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
348160e0:	e5873084 	str	r3, [r7, #132]	; 0x84
		this->command(mtd, readcmd, from, mtd->oobsize);
348160e4:	e5963018 	ldr	r3, [r6, #24]
348160e8:	e1a00006 	mov	r0, r6
348160ec:	e58d3000 	str	r3, [sp]
348160f0:	e597c050 	ldr	ip, [r7, #80]	; 0x50
348160f4:	e1cd21d8 	ldrd	r2, [sp, #24]
348160f8:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, from, 0);
348160fc:	e1cd21d8 	ldrd	r2, [sp, #24]
34816100:	e3a04000 	mov	r4, #0
34816104:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34816108:	e58d4000 	str	r4, [sp]
3481610c:	ebfffc45 	bl	34815228 <onenand_update_bufferram.clone.2>

		ret = this->wait(mtd, FL_READING);
34816110:	e5973054 	ldr	r3, [r7, #84]	; 0x54
34816114:	e1a00006 	mov	r0, r6
34816118:	e3a01001 	mov	r1, #1
3481611c:	e12fff33 	blx	r3
		if (unlikely(ret))
34816120:	e2504000 	subs	r4, r0, #0
34816124:	0a000004 	beq	3481613c <onenand_read_oob_nolock+0x1ac>
			ret = onenand_recover_lsb(mtd, from, ret);
34816128:	e1a00006 	mov	r0, r6
3481612c:	e1cd21d8 	ldrd	r2, [sp, #24]
34816130:	e58d4000 	str	r4, [sp]
34816134:	ebffff6f 	bl	34815ef8 <onenand_recover_lsb>
34816138:	e1a04000 	mov	r4, r0

		if (ret && ret != -EBADMSG) {
3481613c:	e3540000 	cmp	r4, #0
34816140:	1374004a 	cmnne	r4, #74	; 0x4a
34816144:	0a000004 	beq	3481615c <onenand_read_oob_nolock+0x1cc>
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
34816148:	e1a01004 	mov	r1, r4
3481614c:	e59f00d8 	ldr	r0, [pc, #216]	; 3481622c <onenand_read_oob_nolock+0x29c>
34816150:	e59db028 	ldr	fp, [sp, #40]	; 0x28
34816154:	ebffce97 	bl	34809bb8 <printf>
			break;
34816158:	ea000026 	b	348161f8 <onenand_read_oob_nolock+0x268>
	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);
3481615c:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
		if (ret && ret != -EBADMSG) {
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
			break;
		}

		if (mode == MTD_OOB_AUTO)
34816160:	e59d1034 	ldr	r1, [sp, #52]	; 0x34

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
		thislen = oobsize - column;
34816164:	e069a00b 	rsb	sl, r9, fp
		thislen = min_t(int, thislen, len);
34816168:	e15a0000 	cmp	sl, r0
3481616c:	a1a0a000 	movge	sl, r0
		if (ret && ret != -EBADMSG) {
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
			break;
		}

		if (mode == MTD_OOB_AUTO)
34816170:	e3510001 	cmp	r1, #1
34816174:	1a000005 	bne	34816190 <onenand_read_oob_nolock+0x200>
			onenand_transfer_auto_oob(mtd, buf, column, thislen);
34816178:	e1a00006 	mov	r0, r6
3481617c:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34816180:	e1a02009 	mov	r2, r9
34816184:	e1a0300a 	mov	r3, sl
34816188:	ebfffbd5 	bl	348150e4 <onenand_transfer_auto_oob>
3481618c:	ea000007 	b	348161b0 <onenand_read_oob_nolock+0x220>
		else
			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34816190:	e59f2098 	ldr	r2, [pc, #152]	; 34816230 <onenand_read_oob_nolock+0x2a0>
34816194:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34816198:	e88d060c 	stm	sp, {r2, r3, r9, sl}
3481619c:	e5971060 	ldr	r1, [r7, #96]	; 0x60
348161a0:	e1a00006 	mov	r0, r6
348161a4:	e3a02000 	mov	r2, #0
348161a8:	e3a03000 	mov	r3, #0
348161ac:	e12fff31 	blx	r1

		read += thislen;

		if (read == len)
348161b0:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
		if (mode == MTD_OOB_AUTO)
			onenand_transfer_auto_oob(mtd, buf, column, thislen);
		else
			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);

		read += thislen;
348161b4:	e085500a 	add	r5, r5, sl

		if (read == len)
348161b8:	e1550000 	cmp	r5, r0
348161bc:	0a00000c 	beq	348161f4 <onenand_read_oob_nolock+0x264>
			break;

		buf += thislen;
348161c0:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
348161c4:	e081100a 	add	r1, r1, sl
348161c8:	e58d1024 	str	r1, [sp, #36]	; 0x24

		/* Read more? */
		if (read < len) {
348161cc:	2a000005 	bcs	348161e8 <onenand_read_oob_nolock+0x258>
			/* Page size */
			from += mtd->writesize;
348161d0:	e5963014 	ldr	r3, [r6, #20]
348161d4:	e1cd01d8 	ldrd	r0, [sp, #24]
348161d8:	e0900003 	adds	r0, r0, r3
348161dc:	e2a11000 	adc	r1, r1, #0
348161e0:	e1cd01f8 	strd	r0, [sp, #24]
			column = 0;
348161e4:	e3a09000 	mov	r9, #0
	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
348161e8:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
348161ec:	e1550001 	cmp	r5, r1
348161f0:	3affffb8 	bcc	348160d8 <onenand_read_oob_nolock+0x148>
348161f4:	e59db028 	ldr	fp, [sp, #40]	; 0x28
		}
	}

	ops->oobretlen = read;

	if (ret)
348161f8:	e3540000 	cmp	r4, #0
			from += mtd->writesize;
			column = 0;
		}
	}

	ops->oobretlen = read;
348161fc:	e58b5010 	str	r5, [fp, #16]

	if (ret)
34816200:	1a000004 	bne	34816218 <onenand_read_oob_nolock+0x288>
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
34816204:	e5963084 	ldr	r3, [r6, #132]	; 0x84
		return -EBADMSG;
34816208:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
3481620c:	e1530002 	cmp	r3, r2
34816210:	03a04000 	moveq	r4, #0
34816214:	13e04049 	mvnne	r4, #73	; 0x49

	return 0;
}
34816218:	e1a00004 	mov	r0, r4
3481621c:	e28dd040 	add	sp, sp, #64	; 0x40
34816220:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816224:	34827ac2 	.word	0x34827ac2
34816228:	34827b00 	.word	0x34827b00
3481622c:	34827b41 	.word	0x34827b41
34816230:	00010020 	.word	0x00010020

34816234 <onenand_read_ops_nolock>:
 *
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34816234:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34816238:	e24dd058 	sub	sp, sp, #88	; 0x58
3481623c:	e59d7078 	ldr	r7, [sp, #120]	; 0x78
34816240:	e1cd21f8 	strd	r2, [sp, #24]
	int ret = 0, boundary = 0;
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
34816244:	e5973000 	ldr	r3, [r7]
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
34816248:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int ret = 0, boundary = 0;
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
3481624c:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
34816250:	0594309c 	ldreq	r3, [r4, #156]	; 0x9c
 *
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34816254:	e1a05000 	mov	r5, r0
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34816258:	05933204 	ldreq	r3, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
3481625c:	15953018 	ldrne	r3, [r5, #24]
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
34816260:	e5971018 	ldr	r1, [r7, #24]
	u_char *oobbuf = ops->oobbuf;
34816264:	e597201c 	ldr	r2, [r7, #28]
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
34816268:	e597b004 	ldr	fp, [r7, #4]
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
3481626c:	e58d1028 	str	r1, [sp, #40]	; 0x28
	u_char *oobbuf = ops->oobbuf;
34816270:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;
34816274:	e58d303c 	str	r3, [sp, #60]	; 0x3c

	oobcolumn = from & (mtd->oobsize - 1);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
34816278:	e595100c 	ldr	r1, [r5, #12]
3481627c:	e1cd21d8 	ldrd	r2, [sp, #24]
34816280:	e092200b 	adds	r2, r2, fp
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
34816284:	e597000c 	ldr	r0, [r7, #12]
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34816288:	e5956018 	ldr	r6, [r5, #24]

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
3481628c:	e2a33000 	adc	r3, r3, #0
34816290:	e1510003 	cmp	r1, r3
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
34816294:	e58d004c 	str	r0, [sp, #76]	; 0x4c
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
	int writesize = this->writesize;
34816298:	e5949040 	ldr	r9, [r4, #64]	; 0x40
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
3481629c:	e58d6020 	str	r6, [sp, #32]

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
348162a0:	3a000003 	bcc	348162b4 <onenand_read_ops_nolock+0x80>
348162a4:	1a000009 	bne	348162d0 <onenand_read_ops_nolock+0x9c>
348162a8:	e5951008 	ldr	r1, [r5, #8]
348162ac:	e1510002 	cmp	r1, r2
348162b0:	2a000006 	bcs	348162d0 <onenand_read_ops_nolock+0x9c>
		printk(KERN_ERR "onenand_read_ops_nolock: Attempt read beyond end of device\n");
348162b4:	e59f047c 	ldr	r0, [pc, #1148]	; 34816738 <onenand_read_ops_nolock+0x504>
348162b8:	ebffce3e 	bl	34809bb8 <printf>
		ops->retlen = 0;
348162bc:	e3a03000 	mov	r3, #0
348162c0:	e5873008 	str	r3, [r7, #8]
		ops->oobretlen = 0;
348162c4:	e5873010 	str	r3, [r7, #16]
		return -EINVAL;
348162c8:	e3e06015 	mvn	r6, #21
348162cc:	ea000114 	b	34816724 <onenand_read_ops_nolock+0x4f0>
348162d0:	e5950080 	ldr	r0, [r5, #128]	; 0x80
348162d4:	e5951084 	ldr	r1, [r5, #132]	; 0x84

	/* Read-while-load method */
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
348162d8:	e35b0000 	cmp	fp, #0
	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
		printk(KERN_ERR "onenand_read_ops_nolock: Attempt read beyond end of device\n");
		ops->retlen = 0;
		ops->oobretlen = 0;
		return -EINVAL;
348162dc:	e58d0054 	str	r0, [sp, #84]	; 0x54
348162e0:	e58d1050 	str	r1, [sp, #80]	; 0x50
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
348162e4:	01a0600b 	moveq	r6, fp

	/* Read-while-load method */
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
348162e8:	0a000038 	beq	348163d0 <onenand_read_ops_nolock+0x19c>
#endif

	if (ONENAND_IS_2PLANE(this))
		blockpage = onenand_get_2x_blockpage(mtd, addr);
	else
		blockpage = (int) (addr >> this->page_shift);
348162ec:	e5942034 	ldr	r2, [r4, #52]	; 0x34
348162f0:	e1cd01d8 	ldrd	r0, [sp, #24]
348162f4:	eb002806 	bl	34820314 <__ashrdi3>

	/* Is there valid data? */
	i = ONENAND_CURRENT_BUFFERRAM(this);
348162f8:	e5943044 	ldr	r3, [r4, #68]	; 0x44
	if (this->bufferram[i].blockpage == blockpage)
348162fc:	e2832012 	add	r2, r3, #18
34816300:	e7942102 	ldr	r2, [r4, r2, lsl #2]
34816304:	e1520000 	cmp	r2, r0
34816308:	0a000005 	beq	34816324 <onenand_read_ops_nolock+0xf0>
		found = 1;
	else {
		/* Check another BufferRAM */
		i = ONENAND_NEXT_BUFFERRAM(this);
3481630c:	e2233001 	eor	r3, r3, #1
		if (this->bufferram[i].blockpage == blockpage) {
34816310:	e2832012 	add	r2, r3, #18
34816314:	e7942102 	ldr	r2, [r4, r2, lsl #2]
34816318:	e1520000 	cmp	r2, r0
3481631c:	1a000010 	bne	34816364 <onenand_read_ops_nolock+0x130>
			ONENAND_SET_NEXT_BUFFERRAM(this);
34816320:	e5843044 	str	r3, [r4, #68]	; 0x44
			found = 1;
		}
	}

	if (found && ONENAND_IS_DDP(this)) {
34816324:	e594301c 	ldr	r3, [r4, #28]
34816328:	e3130008 	tst	r3, #8
3481632c:	0a0000ff 	beq	34816730 <onenand_read_ops_nolock+0x4fc>
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
34816330:	e1cd21d8 	ldrd	r2, [sp, #24]
34816334:	e1a00004 	mov	r0, r4
34816338:	ebfffdc8 	bl	34815a60 <onenand_block>
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
3481633c:	e5943028 	ldr	r3, [r4, #40]	; 0x28

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816340:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34816344:	e0100003 	ands	r0, r0, r3

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816348:	e59f13ec 	ldr	r1, [pc, #1004]	; 3481673c <onenand_read_ops_nolock+0x508>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
3481634c:	13a00902 	movne	r0, #32768	; 0x8000

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816350:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816354:	e6ff0070 	uxth	r0, r0
34816358:	e0821001 	add	r1, r2, r1
3481635c:	e12fff33 	blx	r3
34816360:	ea0000f2 	b	34816730 <onenand_read_ops_nolock+0x4fc>
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
		if (!onenand_check_bufferram(mtd, from)) {
			this->main_buf = buf;
34816364:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34816368:	e3a01000 	mov	r1, #0
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
		if (!onenand_check_bufferram(mtd, from)) {
			this->main_buf = buf;
3481636c:	e5842080 	str	r2, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34816370:	e58d9000 	str	r9, [sp]
34816374:	e1cd21d8 	ldrd	r2, [sp, #24]
34816378:	e594c050 	ldr	ip, [r4, #80]	; 0x50
3481637c:	e1a00005 	mov	r0, r5
34816380:	e12fff3c 	blx	ip
			ret = this->wait(mtd, FL_READING);
34816384:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816388:	e1a00005 	mov	r0, r5
3481638c:	e3a01001 	mov	r1, #1
34816390:	e12fff33 	blx	r3
			if (unlikely(ret))
34816394:	e2506000 	subs	r6, r0, #0
34816398:	0a000004 	beq	348163b0 <onenand_read_ops_nolock+0x17c>
				ret = onenand_recover_lsb(mtd, from, ret);
3481639c:	e1a00005 	mov	r0, r5
348163a0:	e1cd21d8 	ldrd	r2, [sp, #24]
348163a4:	e58d6000 	str	r6, [sp]
348163a8:	ebfffed2 	bl	34815ef8 <onenand_recover_lsb>
348163ac:	e1a06000 	mov	r6, r0
			onenand_update_bufferram(mtd, from, !ret);
348163b0:	e2763001 	rsbs	r3, r6, #1
348163b4:	33a03000 	movcc	r3, #0
348163b8:	e58d3000 	str	r3, [sp]
348163bc:	e5950094 	ldr	r0, [r5, #148]	; 0x94
348163c0:	e1cd21d8 	ldrd	r2, [sp, #24]
348163c4:	ebfffb97 	bl	34815228 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
348163c8:	e376004a 	cmn	r6, #74	; 0x4a
348163cc:	03a06000 	moveq	r6, #0
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
348163d0:	e59d2018 	ldr	r2, [sp, #24]
				ret = 0;
		}
	}

	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
348163d4:	e2493001 	sub	r3, r9, #1
			if (ret == -EBADMSG)
				ret = 0;
		}
	}

	thislen = min_t(int, writesize, len - read);
348163d8:	e15b0009 	cmp	fp, r9
348163dc:	b1a0a00b 	movlt	sl, fp
348163e0:	a1a0a009 	movge	sl, r9
	column = from & (writesize - 1);
348163e4:	e0023003 	and	r3, r2, r3
348163e8:	e58d3030 	str	r3, [sp, #48]	; 0x30
	if (column + thislen > writesize)
348163ec:	e083300a 	add	r3, r3, sl
348163f0:	e1530009 	cmp	r3, r9
		thislen = writesize - column;
348163f4:	c59d3030 	ldrgt	r3, [sp, #48]	; 0x30
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
348163f8:	e59d0020 	ldr	r0, [sp, #32]
	}

	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
	if (column + thislen > writesize)
		thislen = writesize - column;
348163fc:	c063a009 	rsbgt	sl, r3, r9
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34816400:	e2403001 	sub	r3, r0, #1
34816404:	e3a01000 	mov	r1, #0
34816408:	e0023003 	and	r3, r2, r3
3481640c:	e58d3038 	str	r3, [sp, #56]	; 0x38
34816410:	e58d1024 	str	r1, [sp, #36]	; 0x24
34816414:	e58d1034 	str	r1, [sp, #52]	; 0x34
34816418:	e58d1020 	str	r1, [sp, #32]
3481641c:	e58d7014 	str	r7, [sp, #20]
34816420:	ea0000ac 	b	348166d8 <onenand_read_ops_nolock+0x4a4>
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
34816424:	e1a0200a 	mov	r2, sl
34816428:	e1a03fc2 	asr	r3, r2, #31
3481642c:	e1cd01d8 	ldrd	r0, [sp, #24]
34816430:	e0900002 	adds	r0, r0, r2
34816434:	e0a11003 	adc	r1, r1, r3
34816438:	e1cd24f0 	strd	r2, [sp, #64]	; 0x40
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
3481643c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
34816440:	e1cd01f8 	strd	r0, [sp, #24]
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
34816444:	e3130008 	tst	r3, #8
34816448:	1a000025 	bne	348164e4 <onenand_read_ops_nolock+0x2b0>
3481644c:	e59d1020 	ldr	r1, [sp, #32]
34816450:	e08a3001 	add	r3, sl, r1
34816454:	e153000b 	cmp	r3, fp
34816458:	2a000021 	bcs	348164e4 <onenand_read_ops_nolock+0x2b0>
			this->main_buf = buf + thislen;
3481645c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34816460:	e1a00005 	mov	r0, r5

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
			this->main_buf = buf + thislen;
34816464:	e082300a 	add	r3, r2, sl
34816468:	e5843080 	str	r3, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
3481646c:	e58d9000 	str	r9, [sp]
34816470:	e1cd21d8 	ldrd	r2, [sp, #24]
34816474:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816478:	e1a01006 	mov	r1, r6
3481647c:	e12fff3c 	blx	ip
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
34816480:	e594301c 	ldr	r3, [r4, #28]
34816484:	e3130008 	tst	r3, #8
					unlikely(from == (this->chipsize >> 1))) {
				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
				boundary = 1;
			} else
				boundary = 0;
34816488:	058d6024 	streq	r6, [sp, #36]	; 0x24
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
3481648c:	0a000011 	beq	348164d8 <onenand_read_ops_nolock+0x2a4>
					unlikely(from == (this->chipsize >> 1))) {
34816490:	e5943018 	ldr	r3, [r4, #24]
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
34816494:	e59d6018 	ldr	r6, [sp, #24]
34816498:	e15600a3 	cmp	r6, r3, lsr #1
3481649c:	1a00000b 	bne	348164d0 <onenand_read_ops_nolock+0x29c>
348164a0:	e59d701c 	ldr	r7, [sp, #28]
348164a4:	e3570000 	cmp	r7, #0
348164a8:	1a000008 	bne	348164d0 <onenand_read_ops_nolock+0x29c>
					unlikely(from == (this->chipsize >> 1))) {
				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
348164ac:	e5942000 	ldr	r2, [r4]
348164b0:	e59f1284 	ldr	r1, [pc, #644]	; 3481673c <onenand_read_ops_nolock+0x508>
348164b4:	e1a00007 	mov	r0, r7
348164b8:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348164bc:	e0821001 	add	r1, r2, r1
348164c0:	e12fff33 	blx	r3
				boundary = 1;
348164c4:	e3a00001 	mov	r0, #1
348164c8:	e58d0024 	str	r0, [sp, #36]	; 0x24
348164cc:	ea000001 	b	348164d8 <onenand_read_ops_nolock+0x2a4>
			} else
				boundary = 0;
348164d0:	e3a01000 	mov	r1, #0
348164d4:	e58d1024 	str	r1, [sp, #36]	; 0x24
			ONENAND_SET_PREV_BUFFERRAM(this);
348164d8:	e5943044 	ldr	r3, [r4, #68]	; 0x44
348164dc:	e2233001 	eor	r3, r3, #1
348164e0:	e5843044 	str	r3, [r4, #68]	; 0x44
		}

		/* While load is going, read from last bufferRAM */
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);
348164e4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
348164e8:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
348164ec:	e3a02b01 	mov	r2, #1024	; 0x400
348164f0:	e88d044c 	stm	sp, {r2, r3, r6, sl}
348164f4:	e1cd64d0 	ldrd	r6, [sp, #64]	; 0x40
348164f8:	e1cd21d8 	ldrd	r2, [sp, #24]
348164fc:	e5941060 	ldr	r1, [r4, #96]	; 0x60
34816500:	e0522006 	subs	r2, r2, r6
34816504:	e0c33007 	sbc	r3, r3, r7
34816508:	e1a00005 	mov	r0, r5
3481650c:	e12fff31 	blx	r1

		/* Read oob area if needed */
		if (oobbuf) {
34816510:	e59d702c 	ldr	r7, [sp, #44]	; 0x2c
34816514:	e3570000 	cmp	r7, #0
34816518:	0a000022 	beq	348165a8 <onenand_read_ops_nolock+0x374>
			thisooblen = oobsize - oobcolumn;
3481651c:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
34816520:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
34816524:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
34816528:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
		/* While load is going, read from last bufferRAM */
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);

		/* Read oob area if needed */
		if (oobbuf) {
			thisooblen = oobsize - oobcolumn;
3481652c:	e0613000 	rsb	r3, r1, r0
			thisooblen = min_t(int, thisooblen, ooblen - oobread);

			if (ops->mode == MTD_OOB_AUTO)
34816530:	e59d0014 	ldr	r0, [sp, #20]
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);

		/* Read oob area if needed */
		if (oobbuf) {
			thisooblen = oobsize - oobcolumn;
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
34816534:	e0676002 	rsb	r6, r7, r2
34816538:	e1560003 	cmp	r6, r3
3481653c:	a1a06003 	movge	r6, r3

			if (ops->mode == MTD_OOB_AUTO)
34816540:	e5903000 	ldr	r3, [r0]
34816544:	e3530001 	cmp	r3, #1
34816548:	1a000005 	bne	34816564 <onenand_read_ops_nolock+0x330>
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
3481654c:	e1a00005 	mov	r0, r5
34816550:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34816554:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
34816558:	e1a03006 	mov	r3, r6
3481655c:	ebfffae0 	bl	348150e4 <onenand_transfer_auto_oob>
34816560:	ea000008 	b	34816588 <onenand_read_ops_nolock+0x354>
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
34816564:	e59f11d4 	ldr	r1, [pc, #468]	; 34816740 <onenand_read_ops_nolock+0x50c>
34816568:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
3481656c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34816570:	e88d004e 	stm	sp, {r1, r2, r3, r6}
34816574:	e5941060 	ldr	r1, [r4, #96]	; 0x60
34816578:	e1a00005 	mov	r0, r5
3481657c:	e3a02000 	mov	r2, #0
34816580:	e3a03000 	mov	r3, #0
34816584:	e12fff31 	blx	r1
			oobread += thisooblen;
34816588:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
			oobbuf += thisooblen;
3481658c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c

			if (ops->mode == MTD_OOB_AUTO)
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
			oobread += thisooblen;
34816590:	e0877006 	add	r7, r7, r6
			oobbuf += thisooblen;
34816594:	e0800006 	add	r0, r0, r6
			oobcolumn = 0;
34816598:	e3a01000 	mov	r1, #0

			if (ops->mode == MTD_OOB_AUTO)
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
			oobread += thisooblen;
3481659c:	e58d7034 	str	r7, [sp, #52]	; 0x34
			oobbuf += thisooblen;
348165a0:	e58d002c 	str	r0, [sp, #44]	; 0x2c
			oobcolumn = 0;
348165a4:	e58d1038 	str	r1, [sp, #56]	; 0x38
		}

		if (ONENAND_IS_4KB_PAGE(this) && (read + thislen < len)) {
348165a8:	e594602c 	ldr	r6, [r4, #44]	; 0x2c
348165ac:	e2166008 	ands	r6, r6, #8
348165b0:	0a00001d 	beq	3481662c <onenand_read_ops_nolock+0x3f8>
348165b4:	e59d2020 	ldr	r2, [sp, #32]
348165b8:	e08a3002 	add	r3, sl, r2
348165bc:	e153000b 	cmp	r3, fp
348165c0:	23a06000 	movcs	r6, #0
348165c4:	2a000018 	bcs	3481662c <onenand_read_ops_nolock+0x3f8>
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
348165c8:	e58d9000 	str	r9, [sp]
348165cc:	e1cd21d8 	ldrd	r2, [sp, #24]
348165d0:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348165d4:	e3a01000 	mov	r1, #0
348165d8:	e1a00005 	mov	r0, r5
348165dc:	e12fff3c 	blx	ip
			ret = this->wait(mtd, FL_READING);
348165e0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348165e4:	e1a00005 	mov	r0, r5
348165e8:	e3a01001 	mov	r1, #1
348165ec:	e12fff33 	blx	r3
			if (unlikely(ret))
348165f0:	e2506000 	subs	r6, r0, #0
348165f4:	0a000004 	beq	3481660c <onenand_read_ops_nolock+0x3d8>
				ret = onenand_recover_lsb(mtd, from, ret);
348165f8:	e1a00005 	mov	r0, r5
348165fc:	e1cd21d8 	ldrd	r2, [sp, #24]
34816600:	e58d6000 	str	r6, [sp]
34816604:	ebfffe3b 	bl	34815ef8 <onenand_recover_lsb>
34816608:	e1a06000 	mov	r6, r0
			onenand_update_bufferram(mtd, from, !ret);
3481660c:	e2763001 	rsbs	r3, r6, #1
34816610:	33a03000 	movcc	r3, #0
34816614:	e58d3000 	str	r3, [sp]
34816618:	e5950094 	ldr	r0, [r5, #148]	; 0x94
3481661c:	e1cd21d8 	ldrd	r2, [sp, #24]
34816620:	ebfffb00 	bl	34815228 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
34816624:	e376004a 	cmn	r6, #74	; 0x4a
34816628:	03a06000 	moveq	r6, #0
		}

		/* See if we are done */
		read += thislen;
3481662c:	e59d3020 	ldr	r3, [sp, #32]
34816630:	e083300a 	add	r3, r3, sl
		if (read == len)
34816634:	e153000b 	cmp	r3, fp
			if (ret == -EBADMSG)
				ret = 0;
		}

		/* See if we are done */
		read += thislen;
34816638:	e58d3020 	str	r3, [sp, #32]
		if (read == len)
3481663c:	0a000027 	beq	348166e0 <onenand_read_ops_nolock+0x4ac>
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
34816640:	e59d7024 	ldr	r7, [sp, #36]	; 0x24
34816644:	e3570000 	cmp	r7, #0
34816648:	0a000005 	beq	34816664 <onenand_read_ops_nolock+0x430>
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
3481664c:	e5942000 	ldr	r2, [r4]
34816650:	e59f10e4 	ldr	r1, [pc, #228]	; 3481673c <onenand_read_ops_nolock+0x508>
34816654:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816658:	e3a00902 	mov	r0, #32768	; 0x8000
3481665c:	e0821001 	add	r1, r2, r1
34816660:	e12fff33 	blx	r3
		if (!ONENAND_IS_4KB_PAGE(this))
34816664:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
			ONENAND_SET_NEXT_BUFFERRAM(this);
		buf += thislen;
34816668:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
		if (read == len)
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
3481666c:	e2133008 	ands	r3, r3, #8
			ONENAND_SET_NEXT_BUFFERRAM(this);
34816670:	05942044 	ldreq	r2, [r4, #68]	; 0x44
		buf += thislen;
		thislen = min_t(int, writesize, len - read);
34816674:	e59d1020 	ldr	r1, [sp, #32]
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
34816678:	02222001 	eoreq	r2, r2, #1
		buf += thislen;
3481667c:	e080000a 	add	r0, r0, sl
		thislen = min_t(int, writesize, len - read);
34816680:	e061a00b 	rsb	sl, r1, fp
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
34816684:	05842044 	streq	r2, [r4, #68]	; 0x44
		buf += thislen;
		thislen = min_t(int, writesize, len - read);
34816688:	e15a0009 	cmp	sl, r9
3481668c:	a1a0a009 	movge	sl, r9
		column = 0;

		if (!ONENAND_IS_4KB_PAGE(this)) {
34816690:	e3530000 	cmp	r3, #0
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
		buf += thislen;
34816694:	e58d0028 	str	r0, [sp, #40]	; 0x28
		thislen = min_t(int, writesize, len - read);
		column = 0;

		if (!ONENAND_IS_4KB_PAGE(this)) {
34816698:	1a00000c 	bne	348166d0 <onenand_read_ops_nolock+0x49c>
			/* Now wait for load */
			ret = this->wait(mtd, FL_READING);
3481669c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348166a0:	e3a01001 	mov	r1, #1
348166a4:	e1a00005 	mov	r0, r5
348166a8:	e12fff33 	blx	r3
			onenand_update_bufferram(mtd, from, !ret);
348166ac:	e2703001 	rsbs	r3, r0, #1
348166b0:	33a03000 	movcc	r3, #0
348166b4:	e1a06000 	mov	r6, r0
348166b8:	e58d3000 	str	r3, [sp]
348166bc:	e5950094 	ldr	r0, [r5, #148]	; 0x94
348166c0:	e1cd21d8 	ldrd	r2, [sp, #24]
348166c4:	ebfffad7 	bl	34815228 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
348166c8:	e376004a 	cmn	r6, #74	; 0x4a
348166cc:	03a06000 	moveq	r6, #0

		if (!ONENAND_IS_4KB_PAGE(this)) {
			/* Now wait for load */
			ret = this->wait(mtd, FL_READING);
			onenand_update_bufferram(mtd, from, !ret);
			if (ret == -EBADMSG)
348166d0:	e3a02000 	mov	r2, #0
348166d4:	e58d2030 	str	r2, [sp, #48]	; 0x30
	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
348166d8:	e3560000 	cmp	r6, #0
348166dc:	0affff50 	beq	34816424 <onenand_read_ops_nolock+0x1f0>
348166e0:	e59d7014 	ldr	r7, [sp, #20]
	/*
	 * Return success, if no ECC failures, else -EBADMSG
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EBADMSG
	 */
	ops->retlen = read;
348166e4:	e59d3020 	ldr	r3, [sp, #32]
	ops->oobretlen = oobread;
348166e8:	e59d0034 	ldr	r0, [sp, #52]	; 0x34

	if (ret)
348166ec:	e3560000 	cmp	r6, #0
	/*
	 * Return success, if no ECC failures, else -EBADMSG
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EBADMSG
	 */
	ops->retlen = read;
348166f0:	e5873008 	str	r3, [r7, #8]
	ops->oobretlen = oobread;
348166f4:	e5870010 	str	r0, [r7, #16]

	if (ret)
348166f8:	1a000009 	bne	34816724 <onenand_read_ops_nolock+0x4f0>
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
348166fc:	e5953084 	ldr	r3, [r5, #132]	; 0x84
34816700:	e59d1050 	ldr	r1, [sp, #80]	; 0x50
34816704:	e1530001 	cmp	r3, r1
		return -EBADMSG;
34816708:	13e06049 	mvnne	r6, #73	; 0x49
	ops->oobretlen = oobread;

	if (ret)
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
3481670c:	1a000004 	bne	34816724 <onenand_read_ops_nolock+0x4f0>
		return -EBADMSG;

	return mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
34816710:	e5953080 	ldr	r3, [r5, #128]	; 0x80
34816714:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
34816718:	e1530002 	cmp	r3, r2
3481671c:	03a06000 	moveq	r6, #0
34816720:	13e06074 	mvnne	r6, #116	; 0x74
}
34816724:	e1a00006 	mov	r0, r6
34816728:	e28dd058 	add	sp, sp, #88	; 0x58
3481672c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
34816730:	e3a06000 	mov	r6, #0
34816734:	eaffff25 	b	348163d0 <onenand_read_ops_nolock+0x19c>
34816738:	34827b6e 	.word	0x34827b6e
3481673c:	0001e202 	.word	0x0001e202
34816740:	00010020 	.word	0x00010020

34816744 <onenand_read_oob>:
 *
 * OneNAND main and/or out-of-band
 */
int onenand_read_oob(struct mtd_info *mtd, loff_t from,
			struct mtd_oob_ops *ops)
{
34816744:	e59d1000 	ldr	r1, [sp]
	int ret;

	switch (ops->mode) {
34816748:	e591c000 	ldr	ip, [r1]
3481674c:	e35c0001 	cmp	ip, #1
34816750:	8a000005 	bhi	3481676c <onenand_read_oob+0x28>
	default:
		return -EINVAL;
	}

	onenand_get_device(mtd, FL_READING);
	if (ops->datbuf)
34816754:	e591c018 	ldr	ip, [r1, #24]
34816758:	e35c0000 	cmp	ip, #0
3481675c:	0a000000 	beq	34816764 <onenand_read_oob+0x20>
		ret = onenand_read_ops_nolock(mtd, from, ops);
34816760:	eafffeb3 	b	34816234 <onenand_read_ops_nolock>
	else
		ret = onenand_read_oob_nolock(mtd, from, ops);
34816764:	e58d1000 	str	r1, [sp]
34816768:	eafffe08 	b	34815f90 <onenand_read_oob_nolock>
	onenand_release_device(mtd);

	return ret;
}
3481676c:	e3e00015 	mvn	r0, #21
34816770:	e12fff1e 	bx	lr

34816774 <onenand_read>:
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
34816774:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34816778:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
3481677c:	e28d7008 	add	r7, sp, #8
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
34816780:	e1a06000 	mov	r6, r0
34816784:	e1a04002 	mov	r4, r2
	struct mtd_oob_ops ops = {
34816788:	e3a01000 	mov	r1, #0
3481678c:	e1a00007 	mov	r0, r7
34816790:	e3a02020 	mov	r2, #32
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
34816794:	e1a05003 	mov	r5, r3
	struct mtd_oob_ops ops = {
34816798:	eb001857 	bl	3481c8fc <memset>
3481679c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
348167a0:	e1a02004 	mov	r2, r4
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
	struct mtd_oob_ops ops = {
348167a4:	e58d300c 	str	r3, [sp, #12]
348167a8:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
348167ac:	e1a00006 	mov	r0, r6
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
	struct mtd_oob_ops ops = {
348167b0:	e58d3020 	str	r3, [sp, #32]
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
348167b4:	e1a03005 	mov	r3, r5
348167b8:	e58d7000 	str	r7, [sp]
348167bc:	ebfffe9c 	bl	34816234 <onenand_read_ops_nolock>
	onenand_release_device(mtd);

	*retlen = ops.retlen;
348167c0:	e59d2010 	ldr	r2, [sp, #16]
348167c4:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
348167c8:	e5832000 	str	r2, [r3]
	return ret;
}
348167cc:	e28dd02c 	add	sp, sp, #44	; 0x2c
348167d0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

348167d4 <onenand_erase>:
 * @param instr		erase instruction
 *
 * Erase one ore more blocks
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
348167d4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348167d8:	e1a06001 	mov	r6, r1
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
	unsigned int len = instr->len;
348167dc:	e5969010 	ldr	r9, [r6, #16]
 * @param instr		erase instruction
 *
 * Erase one ore more blocks
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
348167e0:	e24dd028 	sub	sp, sp, #40	; 0x28
348167e4:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
348167e8:	e590a094 	ldr	sl, [r0, #148]	; 0x94
	unsigned int block_size;
	loff_t addr = instr->addr;
348167ec:	e1c100d8 	ldrd	r0, [r1, #8]

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n",
			(unsigned int) addr, len);

	/* Do not allow erase past end of device */
	if (unlikely((len + addr) > mtd->size)) {
348167f0:	e0902009 	adds	r2, r0, r9
348167f4:	e2a13000 	adc	r3, r1, #0
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
348167f8:	e1cd01f0 	strd	r0, [sp, #16]
348167fc:	e1cd01f8 	strd	r0, [sp, #24]

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n",
			(unsigned int) addr, len);

	/* Do not allow erase past end of device */
	if (unlikely((len + addr) > mtd->size)) {
34816800:	e595100c 	ldr	r1, [r5, #12]
34816804:	e1510003 	cmp	r1, r3
34816808:	3a0000b4 	bcc	34816ae0 <onenand_erase+0x30c>
3481680c:	1a000002 	bne	3481681c <onenand_erase+0x48>
34816810:	e5951008 	ldr	r1, [r5, #8]
34816814:	e1510002 	cmp	r1, r2
34816818:	3a0000b0 	bcc	34816ae0 <onenand_erase+0x30c>
		MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
					"Erase past end of device\n");
		return -EINVAL;
	}

	if (FLEXONENAND(this)) {
3481681c:	e59a301c 	ldr	r3, [sl, #28]
34816820:	e3130c02 	tst	r3, #512	; 0x200
34816824:	0a000015 	beq	34816880 <onenand_erase+0xac>
		/* Find the eraseregion of this address */
		i = flexonenand_region(mtd, addr);
34816828:	e1cd21d0 	ldrd	r2, [sp, #16]
3481682c:	e1a00005 	mov	r0, r5
34816830:	ebfffd9d 	bl	34815eac <flexonenand_region>
		region = &mtd->eraseregions[i];
34816834:	e3a03018 	mov	r3, #24
34816838:	e0000093 	mul	r0, r3, r0
3481683c:	e5951030 	ldr	r1, [r5, #48]	; 0x30
34816840:	e0817000 	add	r7, r1, r0

		block_size = region->erasesize;
34816844:	e5974008 	ldr	r4, [r7, #8]
		region_end = region->offset
34816848:	e18120d0 	ldrd	r2, [r1, r0]
3481684c:	e1cd22f0 	strd	r2, [sp, #32]
			+ region->erasesize * region->numblocks;

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34816850:	e1cd02d0 	ldrd	r0, [sp, #32]
34816854:	e1cd21d0 	ldrd	r2, [sp, #16]
34816858:	e244c001 	sub	ip, r4, #1
3481685c:	e0522000 	subs	r2, r2, r0
34816860:	e0c33001 	sbc	r3, r3, r1
		i = flexonenand_region(mtd, addr);
		region = &mtd->eraseregions[i];

		block_size = region->erasesize;
		region_end = region->offset
			+ region->erasesize * region->numblocks;
34816864:	e597b00c 	ldr	fp, [r7, #12]

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34816868:	e002200c 	and	r2, r2, ip
3481686c:	e3a03000 	mov	r3, #0
34816870:	e1921003 	orrs	r1, r2, r3
		/* Find the eraseregion of this address */
		i = flexonenand_region(mtd, addr);
		region = &mtd->eraseregions[i];

		block_size = region->erasesize;
		region_end = region->offset
34816874:	002b0b94 	mlaeq	fp, r4, fp, r0
			+ region->erasesize * region->numblocks;

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34816878:	0a00000a 	beq	348168a8 <onenand_erase+0xd4>
3481687c:	ea000097 	b	34816ae0 <onenand_erase+0x30c>
			MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
				" Unaligned address\n");
			return -EINVAL;
		}
	} else {
		block_size = 1 << this->erase_shift;
34816880:	e59a3030 	ldr	r3, [sl, #48]	; 0x30
34816884:	e3a04001 	mov	r4, #1
34816888:	e1a04314 	lsl	r4, r4, r3

		/* Start address must align on block boundary */
		if (unlikely(addr & (block_size - 1))) {
3481688c:	e1cd21d0 	ldrd	r2, [sp, #16]
34816890:	e2441001 	sub	r1, r4, #1
34816894:	e0022001 	and	r2, r2, r1
34816898:	e3a03000 	mov	r3, #0
3481689c:	e192b003 	orrs	fp, r2, r3
348168a0:	1a00008e 	bne	34816ae0 <onenand_erase+0x30c>
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
	unsigned int len = instr->len;
	int ret = 0, i;
	struct mtd_erase_region_info *region = NULL;
348168a4:	e1a0700b 	mov	r7, fp
			return -EINVAL;
		}
	}

	/* Length must align on block boundary */
	if (unlikely(len & (block_size - 1))) {
348168a8:	e2443001 	sub	r3, r4, #1
348168ac:	e1130009 	tst	r3, r9
348168b0:	1a00008a 	bne	34816ae0 <onenand_erase+0x30c>
		MTDDEBUG (MTD_DEBUG_LEVEL0,
			 "onenand_erase: Length not block aligned\n");
		return -EINVAL;
	}

	instr->fail_addr = 0xffffffff;
348168b4:	e3a03000 	mov	r3, #0
348168b8:	e3e02000 	mvn	r2, #0
348168bc:	e1c621f8 	strd	r2, [r6, #24]

	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_ERASING);

	/* Loop throught the pages */
	instr->state = MTD_ERASING;
348168c0:	e3a03002 	mov	r3, #2
348168c4:	e5c63038 	strb	r3, [r6, #56]	; 0x38
348168c8:	e58db00c 	str	fp, [sp, #12]

	while (len) {
348168cc:	ea000077 	b	34816ab0 <onenand_erase+0x2dc>

		/* Check if we have a bad block, we do not erase bad blocks */
		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
348168d0:	e5963034 	ldr	r3, [r6, #52]	; 0x34
348168d4:	e3530000 	cmp	r3, #0
348168d8:	1a00000d 	bne	34816914 <onenand_erase+0x140>
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348168dc:	e5952094 	ldr	r2, [r5, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
348168e0:	e1a00005 	mov	r0, r5
348168e4:	e59220a0 	ldr	r2, [r2, #160]	; 0xa0
348168e8:	e58d3000 	str	r3, [sp]
348168ec:	e5921010 	ldr	r1, [r2, #16]
348168f0:	e1cd21d8 	ldrd	r2, [sp, #24]
348168f4:	e12fff31 	blx	r1
	instr->state = MTD_ERASING;

	while (len) {

		/* Check if we have a bad block, we do not erase bad blocks */
		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
348168f8:	e3500000 	cmp	r0, #0
348168fc:	0a000004 	beq	34816914 <onenand_erase+0x140>
			printk(KERN_WARNING "onenand_erase: attempt to erase"
34816900:	e59f01e4 	ldr	r0, [pc, #484]	; 34816aec <onenand_erase+0x318>
34816904:	e59d1018 	ldr	r1, [sp, #24]
34816908:	ebffccaa 	bl	34809bb8 <printf>
				" a bad block at addr 0x%08x\n",
				(unsigned int) addr);
			instr->state = MTD_ERASE_FAILED;
3481690c:	e3a03010 	mov	r3, #16
34816910:	ea000069 	b	34816abc <onenand_erase+0x2e8>
			goto erase_exit;
		}

		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);
34816914:	e58d4000 	str	r4, [sp]
34816918:	e1cd21d8 	ldrd	r2, [sp, #24]
3481691c:	e59ac050 	ldr	ip, [sl, #80]	; 0x50
34816920:	e3a01094 	mov	r1, #148	; 0x94
34816924:	e1a00005 	mov	r0, r5
34816928:	e12fff3c 	blx	ip
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
3481692c:	e1cd01d8 	ldrd	r0, [sp, #24]
 * Invalidate BufferRAM information
 */
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
34816930:	e5953094 	ldr	r3, [r5, #148]	; 0x94
	int i;
	loff_t end_addr = addr + len;
34816934:	e0900004 	adds	r0, r0, r4

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34816938:	e593c034 	ldr	ip, [r3, #52]	; 0x34
3481693c:	e5932048 	ldr	r2, [r3, #72]	; 0x48
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34816940:	e2a11000 	adc	r1, r1, #0

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34816944:	e1a02c12 	lsl	r2, r2, ip
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34816948:	e1cd01f0 	strd	r0, [sp, #16]

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;

		if (buf_addr >= addr && buf_addr < end_addr)
3481694c:	e59db014 	ldr	fp, [sp, #20]
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34816950:	e1a00002 	mov	r0, r2
34816954:	e1a01fc0 	asr	r1, r0, #31

		if (buf_addr >= addr && buf_addr < end_addr)
34816958:	e15b0001 	cmp	fp, r1
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
3481695c:	e1cd02f0 	strd	r0, [sp, #32]

		if (buf_addr >= addr && buf_addr < end_addr)
34816960:	e3a00001 	mov	r0, #1
34816964:	ca000004 	bgt	3481697c <onenand_erase+0x1a8>
34816968:	1a000002 	bne	34816978 <onenand_erase+0x1a4>
3481696c:	e59de010 	ldr	lr, [sp, #16]
34816970:	e15e0002 	cmp	lr, r2
34816974:	8a000000 	bhi	3481697c <onenand_erase+0x1a8>
34816978:	e3a00000 	mov	r0, #0
3481697c:	e59db01c 	ldr	fp, [sp, #28]
34816980:	e59de024 	ldr	lr, [sp, #36]	; 0x24
34816984:	e3a01001 	mov	r1, #1
34816988:	e15b000e 	cmp	fp, lr
3481698c:	ca000003 	bgt	348169a0 <onenand_erase+0x1cc>
34816990:	1a000003 	bne	348169a4 <onenand_erase+0x1d0>
34816994:	e59db018 	ldr	fp, [sp, #24]
34816998:	e15b0002 	cmp	fp, r2
3481699c:	9a000000 	bls	348169a4 <onenand_erase+0x1d0>
348169a0:	e3a01000 	mov	r1, #0
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
348169a4:	e593204c 	ldr	r2, [r3, #76]	; 0x4c

		if (buf_addr >= addr && buf_addr < end_addr)
348169a8:	e0001001 	and	r1, r0, r1
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
348169ac:	e1a0cc12 	lsl	ip, r2, ip

		if (buf_addr >= addr && buf_addr < end_addr)
348169b0:	e31100ff 	tst	r1, #255	; 0xff
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
348169b4:	e1a0000c 	mov	r0, ip
348169b8:	e1a01fc0 	asr	r1, r0, #31
348169bc:	e1cd02f0 	strd	r0, [sp, #32]

		if (buf_addr >= addr && buf_addr < end_addr)
348169c0:	e59d2014 	ldr	r2, [sp, #20]
348169c4:	e59db024 	ldr	fp, [sp, #36]	; 0x24
			this->bufferram[i].blockpage = -1;
348169c8:	13e0e000 	mvnne	lr, #0
348169cc:	1583e048 	strne	lr, [r3, #72]	; 0x48

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;

		if (buf_addr >= addr && buf_addr < end_addr)
348169d0:	e152000b 	cmp	r2, fp
348169d4:	e3a01001 	mov	r1, #1
348169d8:	ca000004 	bgt	348169f0 <onenand_erase+0x21c>
348169dc:	1a000002 	bne	348169ec <onenand_erase+0x218>
348169e0:	e59de010 	ldr	lr, [sp, #16]
348169e4:	e15e000c 	cmp	lr, ip
348169e8:	8a000000 	bhi	348169f0 <onenand_erase+0x21c>
348169ec:	e3a01000 	mov	r1, #0
348169f0:	e59d001c 	ldr	r0, [sp, #28]
348169f4:	e59db024 	ldr	fp, [sp, #36]	; 0x24
348169f8:	e3a02001 	mov	r2, #1
348169fc:	e150000b 	cmp	r0, fp
34816a00:	ca000003 	bgt	34816a14 <onenand_erase+0x240>
34816a04:	1a000003 	bne	34816a18 <onenand_erase+0x244>
34816a08:	e59de018 	ldr	lr, [sp, #24]
34816a0c:	e15e000c 	cmp	lr, ip
34816a10:	9a000000 	bls	34816a18 <onenand_erase+0x244>
34816a14:	e3a02000 	mov	r2, #0
34816a18:	e0012002 	and	r2, r1, r2
34816a1c:	e31200ff 	tst	r2, #255	; 0xff
			this->bufferram[i].blockpage = -1;
34816a20:	13e00000 	mvnne	r0, #0
34816a24:	1583004c 	strne	r0, [r3, #76]	; 0x4c

		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);

		onenand_invalidate_bufferram(mtd, addr, block_size);

		ret = this->wait(mtd, FL_ERASING);
34816a28:	e3a01003 	mov	r1, #3
34816a2c:	e59a3054 	ldr	r3, [sl, #84]	; 0x54
34816a30:	e1a00005 	mov	r0, r5
34816a34:	e12fff33 	blx	r3
		/* Check, if it is write protected */
		if (ret) {
34816a38:	e3500000 	cmp	r0, #0
					  "Device is write protected!!!\n");
			else
				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
					  "Failed erase, block %d\n",
					onenand_block(this, addr));
			instr->state = MTD_ERASE_FAILED;
34816a3c:	13a03010 	movne	r3, #16
34816a40:	15c63038 	strbne	r3, [r6, #56]	; 0x38
			instr->fail_addr = addr;
34816a44:	11cd21d8 	ldrdne	r2, [sp, #24]
34816a48:	11c621f8 	strdne	r2, [r6, #24]

			goto erase_exit;
34816a4c:	1a00001b 	bne	34816ac0 <onenand_erase+0x2ec>
		}

		len -= block_size;
		addr += block_size;

		if (addr == region_end) {
34816a50:	e59d3010 	ldr	r3, [sp, #16]
34816a54:	e59db00c 	ldr	fp, [sp, #12]
			instr->fail_addr = addr;

			goto erase_exit;
		}

		len -= block_size;
34816a58:	e0649009 	rsb	r9, r4, r9
		addr += block_size;

		if (addr == region_end) {
34816a5c:	e153000b 	cmp	r3, fp
34816a60:	1a000010 	bne	34816aa8 <onenand_erase+0x2d4>
34816a64:	e59d0014 	ldr	r0, [sp, #20]
34816a68:	e3500000 	cmp	r0, #0
34816a6c:	1a00000d 	bne	34816aa8 <onenand_erase+0x2d4>
			if (!len)
34816a70:	e3590000 	cmp	r9, #0
34816a74:	0a00000f 	beq	34816ab8 <onenand_erase+0x2e4>
				break;
			region++;
34816a78:	e2877018 	add	r7, r7, #24

			block_size = region->erasesize;
34816a7c:	e5974008 	ldr	r4, [r7, #8]
			region_end = region->offset
34816a80:	e5973000 	ldr	r3, [r7]
				+ region->erasesize * region->numblocks;

			if (len & (block_size - 1)) {
34816a84:	e2442001 	sub	r2, r4, #1
34816a88:	e1190002 	tst	r9, r2
				break;
			region++;

			block_size = region->erasesize;
			region_end = region->offset
				+ region->erasesize * region->numblocks;
34816a8c:	e597b00c 	ldr	fp, [r7, #12]
			if (!len)
				break;
			region++;

			block_size = region->erasesize;
			region_end = region->offset
34816a90:	00233b94 	mlaeq	r3, r4, fp, r3
34816a94:	058d300c 	streq	r3, [sp, #12]
34816a98:	0a000002 	beq	34816aa8 <onenand_erase+0x2d4>
				+ region->erasesize * region->numblocks;

			if (len & (block_size - 1)) {
				/* This has been checked at MTD
				 * partitioning level. */
				printk("onenand_erase: Unaligned address\n");
34816a9c:	e59f004c 	ldr	r0, [pc, #76]	; 34816af0 <onenand_erase+0x31c>
34816aa0:	ebffcc44 	bl	34809bb8 <printf>
				goto erase_exit;
34816aa4:	ea000005 	b	34816ac0 <onenand_erase+0x2ec>
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34816aa8:	e1cd21d0 	ldrd	r2, [sp, #16]
34816aac:	e1cd21f8 	strd	r2, [sp, #24]
	onenand_get_device(mtd, FL_ERASING);

	/* Loop throught the pages */
	instr->state = MTD_ERASING;

	while (len) {
34816ab0:	e3590000 	cmp	r9, #0
34816ab4:	1affff85 	bne	348168d0 <onenand_erase+0xfc>
				goto erase_exit;
			}
		}
	}

	instr->state = MTD_ERASE_DONE;
34816ab8:	e3a03008 	mov	r3, #8
34816abc:	e5c63038 	strb	r3, [r6, #56]	; 0x38

erase_exit:

	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
34816ac0:	e5d63038 	ldrb	r3, [r6, #56]	; 0x38
34816ac4:	e3530008 	cmp	r3, #8
34816ac8:	13e00004 	mvnne	r0, #4
34816acc:	1a000004 	bne	34816ae4 <onenand_erase+0x310>
	/* Do call back function */
	if (!ret)
		mtd_erase_callback(instr);
34816ad0:	e1a00006 	mov	r0, r6
34816ad4:	ebfff548 	bl	34813ffc <mtd_erase_callback>
34816ad8:	e3a00000 	mov	r0, #0
34816adc:	ea000000 	b	34816ae4 <onenand_erase+0x310>

	/* Length must align on block boundary */
	if (unlikely(len & (block_size - 1))) {
		MTDDEBUG (MTD_DEBUG_LEVEL0,
			 "onenand_erase: Length not block aligned\n");
		return -EINVAL;
34816ae0:	e3e00015 	mvn	r0, #21

	/* Deselect and wake up anyone waiting on the device */
	onenand_release_device(mtd);

	return ret;
}
34816ae4:	e28dd028 	add	sp, sp, #40	; 0x28
34816ae8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816aec:	34827baa 	.word	0x34827baa
34816af0:	34827be6 	.word	0x34827be6

34816af4 <onenand_bbt_read_oob>:
 *
 * OneNAND read out-of-band data from the spare area for bbt scan
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34816af4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34816af8:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 *
 * OneNAND read out-of-band data from the spare area for bbt scan
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34816afc:	e24dd020 	sub	sp, sp, #32
34816b00:	e1a04000 	mov	r4, r0
34816b04:	e1cd21f0 	strd	r2, [sp, #16]
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
34816b08:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
34816b0c:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
34816b10:	e590700c 	ldr	r7, [r0, #12]
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34816b14:	e3130008 	tst	r3, #8
34816b18:	03a01013 	moveq	r1, #19
34816b1c:	13a01000 	movne	r1, #0

	/* Initialize return value */
	ops->oobretlen = 0;
34816b20:	e3a03000 	mov	r3, #0
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34816b24:	e58d101c 	str	r1, [sp, #28]

	/* Initialize return value */
	ops->oobretlen = 0;
34816b28:	e5803010 	str	r3, [r0, #16]

	/* Do not allow reads past end of device */
	if (unlikely((from + len) > mtd->size)) {
34816b2c:	e594100c 	ldr	r1, [r4, #12]
34816b30:	e1cd21d0 	ldrd	r2, [sp, #16]
34816b34:	e0922007 	adds	r2, r2, r7
34816b38:	e2a33000 	adc	r3, r3, #0
34816b3c:	e1510003 	cmp	r1, r3
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
	u_char *buf = ops->oobbuf;
34816b40:	e590a01c 	ldr	sl, [r0, #28]

	/* Initialize return value */
	ops->oobretlen = 0;

	/* Do not allow reads past end of device */
	if (unlikely((from + len) > mtd->size)) {
34816b44:	3a000003 	bcc	34816b58 <onenand_bbt_read_oob+0x64>
34816b48:	1a000006 	bne	34816b68 <onenand_bbt_read_oob+0x74>
34816b4c:	e5941008 	ldr	r1, [r4, #8]
34816b50:	e1510002 	cmp	r1, r2
34816b54:	2a000003 	bcs	34816b68 <onenand_bbt_read_oob+0x74>
		printk(KERN_ERR "onenand_bbt_read_oob: Attempt read beyond end of device\n");
34816b58:	e59f00f8 	ldr	r0, [pc, #248]	; 34816c58 <onenand_bbt_read_oob+0x164>
34816b5c:	ebffcc15 	bl	34809bb8 <printf>
		return ONENAND_BBT_READ_FATAL_ERROR;
34816b60:	e3a00004 	mov	r0, #4
34816b64:	ea000039 	b	34816c50 <onenand_bbt_read_oob+0x15c>
	}

	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);
34816b68:	e594b018 	ldr	fp, [r4, #24]
34816b6c:	e59d2010 	ldr	r2, [sp, #16]
34816b70:	e24bb001 	sub	fp, fp, #1
34816b74:	e00bb002 	and	fp, fp, r2
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
34816b78:	e3a06000 	mov	r6, #0
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);

	while (read < len) {
34816b7c:	ea00002e 	b	34816c3c <onenand_bbt_read_oob+0x148>

		thislen = mtd->oobsize - column;
34816b80:	e5949018 	ldr	r9, [r4, #24]
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
34816b84:	e585a084 	str	sl, [r5, #132]	; 0x84
		this->command(mtd, readcmd, from, mtd->oobsize);
34816b88:	e58d9000 	str	r9, [sp]
34816b8c:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34816b90:	e59d101c 	ldr	r1, [sp, #28]
34816b94:	e1cd21d0 	ldrd	r2, [sp, #16]
34816b98:	e1a00004 	mov	r0, r4
34816b9c:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, from, 0);
34816ba0:	e3a03000 	mov	r3, #0
34816ba4:	e58d3000 	str	r3, [sp]
34816ba8:	e5940094 	ldr	r0, [r4, #148]	; 0x94
34816bac:	e1cd21d0 	ldrd	r2, [sp, #16]
34816bb0:	ebfff99c 	bl	34815228 <onenand_update_bufferram.clone.2>

		ret = this->bbt_wait(mtd, FL_READING);
34816bb4:	e5953058 	ldr	r3, [r5, #88]	; 0x58
34816bb8:	e1a00004 	mov	r0, r4
34816bbc:	e3a01001 	mov	r1, #1
34816bc0:	e12fff33 	blx	r3
		if (unlikely(ret))
34816bc4:	e3500000 	cmp	r0, #0
34816bc8:	0a000005 	beq	34816be4 <onenand_bbt_read_oob+0xf0>
			ret = onenand_recover_lsb(mtd, from, ret);
34816bcc:	e58d0000 	str	r0, [sp]
34816bd0:	e1cd21d0 	ldrd	r2, [sp, #16]
34816bd4:	e1a00004 	mov	r0, r4
34816bd8:	ebfffcc6 	bl	34815ef8 <onenand_recover_lsb>

		if (ret)
34816bdc:	e3500000 	cmp	r0, #0
34816be0:	1a000018 	bne	34816c48 <onenand_bbt_read_oob+0x154>
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34816be4:	e59f0070 	ldr	r0, [pc, #112]	; 34816c5c <onenand_bbt_read_oob+0x168>

	column = from & (mtd->oobsize - 1);

	while (read < len) {

		thislen = mtd->oobsize - column;
34816be8:	e06b9009 	rsb	r9, fp, r9
		thislen = min_t(int, thislen, len);
34816bec:	e1590007 	cmp	r9, r7
34816bf0:	a1a09007 	movge	r9, r7
			ret = onenand_recover_lsb(mtd, from, ret);

		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34816bf4:	e88d0c01 	stm	sp, {r0, sl, fp}
34816bf8:	e58d900c 	str	r9, [sp, #12]
34816bfc:	e5951060 	ldr	r1, [r5, #96]	; 0x60
34816c00:	e1a00004 	mov	r0, r4
34816c04:	e3a02000 	mov	r2, #0
34816c08:	e3a03000 	mov	r3, #0
		read += thislen;
34816c0c:	e0866009 	add	r6, r6, r9
			ret = onenand_recover_lsb(mtd, from, ret);

		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34816c10:	e12fff31 	blx	r1
		read += thislen;
		if (read == len)
34816c14:	e1560007 	cmp	r6, r7
34816c18:	0a000009 	beq	34816c44 <onenand_bbt_read_oob+0x150>
			break;

		buf += thislen;
34816c1c:	e08aa009 	add	sl, sl, r9

		/* Read more? */
		if (read < len) {
34816c20:	2a000005 	bcs	34816c3c <onenand_bbt_read_oob+0x148>
			/* Update Page size */
			from += this->writesize;
34816c24:	e5953040 	ldr	r3, [r5, #64]	; 0x40
34816c28:	e1cd01d0 	ldrd	r0, [sp, #16]
34816c2c:	e0900003 	adds	r0, r0, r3
34816c30:	e2a11000 	adc	r1, r1, #0
34816c34:	e1cd01f0 	strd	r0, [sp, #16]
			column = 0;
34816c38:	e3a0b000 	mov	fp, #0
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);

	while (read < len) {
34816c3c:	e1560007 	cmp	r6, r7
34816c40:	3affffce 	bcc	34816b80 <onenand_bbt_read_oob+0x8c>
		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
		read += thislen;
		if (read == len)
34816c44:	e3a00000 	mov	r0, #0
	}

	/* Deselect and wake up anyone waiting on the device */
	onenand_release_device(mtd);

	ops->oobretlen = read;
34816c48:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
34816c4c:	e5816010 	str	r6, [r1, #16]
	return ret;
}
34816c50:	e28dd020 	add	sp, sp, #32
34816c54:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816c58:	34827c08 	.word	0x34827c08
34816c5c:	00010020 	.word	0x00010020

34816c60 <onenand_print_device_info>:
 * @param device        device ID
 *
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
34816c60:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34816c64:	e1a06000 	mov	r6, r0
34816c68:	e24dd014 	sub	sp, sp, #20
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
34816c6c:	e3a00050 	mov	r0, #80	; 0x50
 * @param device        device ID
 *
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
34816c70:	e1a05001 	mov	r5, r1
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
34816c74:	ebffcd96 	bl	3480a2d4 <malloc>
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
34816c78:	e59f1080 	ldr	r1, [pc, #128]	; 34816d00 <onenand_print_device_info+0xa0>
34816c7c:	e59f2080 	ldr	r2, [pc, #128]	; 34816d04 <onenand_print_device_info+0xa4>
34816c80:	e3160004 	tst	r6, #4
34816c84:	e59f307c 	ldr	r3, [pc, #124]	; 34816d08 <onenand_print_device_info+0xa8>
34816c88:	11a02001 	movne	r2, r1
34816c8c:	e59fe078 	ldr	lr, [pc, #120]	; 34816d0c <onenand_print_device_info+0xac>
34816c90:	e3160c02 	tst	r6, #512	; 0x200
34816c94:	01a03001 	moveq	r3, r1
34816c98:	e3160008 	tst	r6, #8
34816c9c:	11a0100e 	movne	r1, lr
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816ca0:	e7e3c256 	ubfx	ip, r6, #4, #4
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
34816ca4:	e3a0e010 	mov	lr, #16
34816ca8:	e1a0ec1e 	lsl	lr, lr, ip
34816cac:	e59f705c 	ldr	r7, [pc, #92]	; 34816d10 <onenand_print_device_info+0xb0>
34816cb0:	e59fc05c 	ldr	ip, [pc, #92]	; 34816d14 <onenand_print_device_info+0xb4>
34816cb4:	e3160003 	tst	r6, #3
34816cb8:	01a0c007 	moveq	ip, r7
34816cbc:	e58d1000 	str	r1, [sp]
34816cc0:	e59f1050 	ldr	r1, [pc, #80]	; 34816d18 <onenand_print_device_info+0xb8>
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
34816cc4:	e1a04000 	mov	r4, r0
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
34816cc8:	e58de004 	str	lr, [sp, #4]
34816ccc:	e58dc008 	str	ip, [sp, #8]
34816cd0:	e58d600c 	str	r6, [sp, #12]
34816cd4:	eb001aa1 	bl	3481d760 <sprintf>
	       demuxed ? "" : "Muxed ",
	       flexonenand ? "Flex-" : "",
	       ddp ? "(DDP)" : "",
	       (16 << density), vcc ? "2.65/3.3" : "1.8", device);

	sprintf(p, "\nOneNAND version = 0x%04x", version);
34816cd8:	e1a02005 	mov	r2, r5
34816cdc:	e0840000 	add	r0, r4, r0
34816ce0:	e59f1034 	ldr	r1, [pc, #52]	; 34816d1c <onenand_print_device_info+0xbc>
34816ce4:	eb001a9d 	bl	3481d760 <sprintf>
	printk("%s\n", dev_info);
34816ce8:	e1a01004 	mov	r1, r4
34816cec:	e59f002c 	ldr	r0, [pc, #44]	; 34816d20 <onenand_print_device_info+0xc0>
34816cf0:	ebffcbb0 	bl	34809bb8 <printf>

	return dev_info;
}
34816cf4:	e1a00004 	mov	r0, r4
34816cf8:	e28dd014 	add	sp, sp, #20
34816cfc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34816d00:	34824003 	.word	0x34824003
34816d04:	34827c41 	.word	0x34827c41
34816d08:	34827746 	.word	0x34827746
34816d0c:	34827c48 	.word	0x34827c48
34816d10:	34827c57 	.word	0x34827c57
34816d14:	34827c4e 	.word	0x34827c4e
34816d18:	34827c5b 	.word	0x34827c5b
34816d1c:	34827c82 	.word	0x34827c82
34816d20:	34826164 	.word	0x34826164

34816d24 <flexonenand_set_boundary>:
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816d24:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34816d28:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816d2c:	e24dd048 	sub	sp, sp, #72	; 0x48
34816d30:	e58d3024 	str	r3, [sp, #36]	; 0x24
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816d34:	e5943004 	ldr	r3, [r4, #4]
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816d38:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816d3c:	e1510003 	cmp	r1, r3
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816d40:	e1a07001 	mov	r7, r1
34816d44:	e1a09002 	mov	r9, r2
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816d48:	2a0000d9 	bcs	348170b4 <flexonenand_set_boundary+0x390>
		return -EINVAL;

	if (boundary == this->boundary[die])
34816d4c:	e2813002 	add	r3, r1, #2
34816d50:	e7943103 	ldr	r3, [r4, r3, lsl #2]
34816d54:	e1520003 	cmp	r2, r3
		return 0;
34816d58:	03a0a000 	moveq	sl, #0
	loff_t addr;

	if (die >= this->dies)
		return -EINVAL;

	if (boundary == this->boundary[die])
34816d5c:	0a0000d5 	beq	348170b8 <flexonenand_set_boundary+0x394>
		return 0;

	density = onenand_get_density(this->device_id);
34816d60:	e594201c 	ldr	r2, [r4, #28]
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816d64:	e3a00401 	mov	r0, #16777216	; 0x1000000
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816d68:	e7e31252 	ubfx	r1, r2, #4, #4

	if (boundary == this->boundary[die])
		return 0;

	density = onenand_get_density(this->device_id);
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816d6c:	e1a01110 	lsl	r1, r0, r1
34816d70:	e5940030 	ldr	r0, [r4, #48]	; 0x30
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34816d74:	e7e021d2 	ubfx	r2, r2, #3, #1

	if (boundary == this->boundary[die])
		return 0;

	density = onenand_get_density(this->device_id);
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816d78:	e1a01051 	asr	r1, r1, r0
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;

	if (boundary >= blksperdie) {
34816d7c:	e1590251 	cmp	r9, r1, asr r2
34816d80:	ba000002 	blt	34816d90 <flexonenand_set_boundary+0x6c>
		printk("flexonenand_set_boundary:"
34816d84:	e59f03c0 	ldr	r0, [pc, #960]	; 3481714c <flexonenand_set_boundary+0x428>
34816d88:	ebffcb8a 	bl	34809bb8 <printf>
34816d8c:	ea0000c8 	b	348170b4 <flexonenand_set_boundary+0x390>
			"Boundary not changed.\n");
		return -EINVAL;
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
34816d90:	e5942028 	ldr	r2, [r4, #40]	; 0x28
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816d94:	e28da028 	add	sl, sp, #40	; 0x28
			"Boundary not changed.\n");
		return -EINVAL;
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
34816d98:	e0020792 	mul	r2, r2, r7
34816d9c:	e0823003 	add	r3, r2, r3
	new = boundary + (die * this->density_mask);
34816da0:	e0822009 	add	r2, r2, r9
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
34816da4:	e1520003 	cmp	r2, r3
34816da8:	b1a06002 	movlt	r6, r2
34816dac:	a1a06003 	movge	r6, r3
						+ 1, max(old, new));
34816db0:	e1520003 	cmp	r2, r3
34816db4:	b1a02003 	movlt	r2, r3
	struct mtd_oob_ops ops = {
		.mode = MTD_OOB_PLACE,
		.ooboffs = 0,
		.ooblen	= mtd->oobsize,
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
34816db8:	e5943090 	ldr	r3, [r4, #144]	; 0x90

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
						+ 1, max(old, new));
34816dbc:	e58d2018 	str	r2, [sp, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816dc0:	e3a01000 	mov	r1, #0
34816dc4:	e3a02020 	mov	r2, #32
34816dc8:	e1a0000a 	mov	r0, sl
		.mode = MTD_OOB_PLACE,
		.ooboffs = 0,
		.ooblen	= mtd->oobsize,
34816dcc:	e595b018 	ldr	fp, [r5, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816dd0:	e58d300c 	str	r3, [sp, #12]
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
34816dd4:	e2866001 	add	r6, r6, #1
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816dd8:	eb0016c7 	bl	3481c8fc <memset>
34816ddc:	e59d300c 	ldr	r3, [sp, #12]
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
34816de0:	e59f0368 	ldr	r0, [pc, #872]	; 34817150 <flexonenand_set_boundary+0x42c>
34816de4:	e1a01006 	mov	r1, r6
34816de8:	e59d2018 	ldr	r2, [sp, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816dec:	e58db034 	str	fp, [sp, #52]	; 0x34
34816df0:	e58d3044 	str	r3, [sp, #68]	; 0x44
34816df4:	e1a0b007 	mov	fp, r7
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
34816df8:	ebffcb6e 	bl	34809bb8 <printf>
34816dfc:	ea00004f 	b	34816f40 <flexonenand_set_boundary+0x21c>
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
34816e00:	e594301c 	ldr	r3, [r4, #28]
34816e04:	e2133008 	ands	r3, r3, #8
34816e08:	01a07006 	moveq	r7, r6
34816e0c:	0a00000b 	beq	34816e40 <flexonenand_set_boundary+0x11c>
34816e10:	e5947028 	ldr	r7, [r4, #40]	; 0x28
34816e14:	e1560007 	cmp	r6, r7
34816e18:	31a07006 	movcc	r7, r6
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;
34816e1c:	33a03000 	movcc	r3, #0

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
34816e20:	3a000006 	bcc	34816e40 <flexonenand_set_boundary+0x11c>
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
34816e24:	e5943010 	ldr	r3, [r4, #16]
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
34816e28:	e0677006 	rsb	r7, r7, r6
		die = 1;
		ofs = this->diesize[0];
34816e2c:	e1a00003 	mov	r0, r3
34816e30:	e3a01000 	mov	r1, #0
34816e34:	e1cd01f0 	strd	r0, [sp, #16]
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
34816e38:	e3a03001 	mov	r3, #1
34816e3c:	ea000002 	b	34816e4c <flexonenand_set_boundary+0x128>
 *
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
34816e40:	e3a00000 	mov	r0, #0
34816e44:	e3a01000 	mov	r1, #0
34816e48:	e1cd01f0 	strd	r0, [sp, #16]
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
34816e4c:	e2833002 	add	r3, r3, #2
34816e50:	e794a103 	ldr	sl, [r4, r3, lsl #2]
	ofs += (loff_t) block << (this->erase_shift - 1);
34816e54:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34816e58:	e1a00007 	mov	r0, r7
34816e5c:	e1a01fc0 	asr	r1, r0, #31
34816e60:	e243c001 	sub	ip, r3, #1
34816e64:	e1a0200c 	mov	r2, ip
34816e68:	e58dc00c 	str	ip, [sp, #12]
34816e6c:	eb00252f 	bl	34820330 <__ashldi3>
34816e70:	e1cd21d0 	ldrd	r2, [sp, #16]
34816e74:	e0922000 	adds	r2, r2, r0
34816e78:	e0a33001 	adc	r3, r3, r1
34816e7c:	e1cd21f0 	strd	r2, [sp, #16]
	if (block > (boundary + 1))
34816e80:	e28a2001 	add	r2, sl, #1
34816e84:	e1570002 	cmp	r7, r2
34816e88:	e59dc00c 	ldr	ip, [sp, #12]
34816e8c:	da000009 	ble	34816eb8 <flexonenand_set_boundary+0x194>
		ofs += (loff_t) (block - boundary - 1)
34816e90:	e2477001 	sub	r7, r7, #1
34816e94:	e06aa007 	rsb	sl, sl, r7
			<< (this->erase_shift - 1);
34816e98:	e1a0200c 	mov	r2, ip
34816e9c:	e1a0000a 	mov	r0, sl
34816ea0:	e1a01fc0 	asr	r1, r0, #31
34816ea4:	eb002521 	bl	34820330 <__ashldi3>
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
	if (block > (boundary + 1))
		ofs += (loff_t) (block - boundary - 1)
34816ea8:	e1cd21d0 	ldrd	r2, [sp, #16]
34816eac:	e0922000 	adds	r2, r2, r0
34816eb0:	e0a33001 	adc	r3, r3, r1
34816eb4:	e1cd21f0 	strd	r2, [sp, #16]
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34816eb8:	e5953094 	ldr	r3, [r5, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
34816ebc:	e3a0e000 	mov	lr, #0
34816ec0:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
34816ec4:	e58de000 	str	lr, [sp]
34816ec8:	e5931010 	ldr	r1, [r3, #16]
34816ecc:	e1a00005 	mov	r0, r5
34816ed0:	e1cd21d0 	ldrd	r2, [sp, #16]
34816ed4:	e12fff31 	blx	r1

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);

	for (block = start; block <= end; block++) {
		addr = flexonenand_addr(this, block);
		if (onenand_block_isbad_nolock(mtd, addr, 0))
34816ed8:	e3500000 	cmp	r0, #0
34816edc:	1a000016 	bne	34816f3c <flexonenand_set_boundary+0x218>

		/*
		 * Since main area write results in ECC write to spare,
		 * it is sufficient to check only ECC bytes for change.
		 */
		ret = onenand_read_oob_nolock(mtd, addr, &ops);
34816ee0:	e28d0028 	add	r0, sp, #40	; 0x28
34816ee4:	e58d0000 	str	r0, [sp]
34816ee8:	e1cd21d0 	ldrd	r2, [sp, #16]
34816eec:	e1a00005 	mov	r0, r5
34816ef0:	ebfffc26 	bl	34815f90 <onenand_read_oob_nolock>
		if (ret)
34816ef4:	e250a000 	subs	sl, r0, #0
34816ef8:	1a000014 	bne	34816f50 <flexonenand_set_boundary+0x22c>
			return ret;

		for (i = 0; i < mtd->oobsize; i++)
34816efc:	e5952018 	ldr	r2, [r5, #24]
34816f00:	e3a03000 	mov	r3, #0
34816f04:	ea000004 	b	34816f1c <flexonenand_set_boundary+0x1f8>
			if (this->oob_buf[i] != 0xff)
34816f08:	e5941090 	ldr	r1, [r4, #144]	; 0x90
34816f0c:	e7d11003 	ldrb	r1, [r1, r3]
34816f10:	e35100ff 	cmp	r1, #255	; 0xff
34816f14:	1a000003 	bne	34816f28 <flexonenand_set_boundary+0x204>
		 */
		ret = onenand_read_oob_nolock(mtd, addr, &ops);
		if (ret)
			return ret;

		for (i = 0; i < mtd->oobsize; i++)
34816f18:	e2833001 	add	r3, r3, #1
34816f1c:	e1530002 	cmp	r3, r2
34816f20:	3afffff8 	bcc	34816f08 <flexonenand_set_boundary+0x1e4>
			if (this->oob_buf[i] != 0xff)
				break;

		if (i != mtd->oobsize) {
34816f24:	0a000004 	beq	34816f3c <flexonenand_set_boundary+0x218>
			printk(KERN_WARNING "Block %d not erased.\n", block);
34816f28:	e59f0224 	ldr	r0, [pc, #548]	; 34817154 <flexonenand_set_boundary+0x430>
34816f2c:	e1a01006 	mov	r1, r6
34816f30:	ebffcb20 	bl	34809bb8 <printf>
			return 1;
34816f34:	e3a0a001 	mov	sl, #1
34816f38:	ea000004 	b	34816f50 <flexonenand_set_boundary+0x22c>
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);

	for (block = start; block <= end; block++) {
34816f3c:	e2866001 	add	r6, r6, #1
34816f40:	e59d1018 	ldr	r1, [sp, #24]
34816f44:	e1560001 	cmp	r6, r1
34816f48:	daffffac 	ble	34816e00 <flexonenand_set_boundary+0xdc>
34816f4c:	ea00005c 	b	348170c4 <flexonenand_set_boundary+0x3a0>
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
						+ 1, max(old, new));
	if (ret) {
		printk(KERN_ERR "flexonenand_set_boundary: Please erase blocks before boundary change\n");
34816f50:	e59f0200 	ldr	r0, [pc, #512]	; 34817158 <flexonenand_set_boundary+0x434>
34816f54:	ebffcb17 	bl	34809bb8 <printf>
		return ret;
34816f58:	ea000056 	b	348170b8 <flexonenand_set_boundary+0x394>
	this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
	ret = this->wait(mtd, FL_READING);

	thisboundary = this->read_word(this->base + ONENAND_DATARAM);
	if ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {
		printk(KERN_ERR "flexonenand_set_boundary: boundary locked\n");
34816f5c:	e59f01f8 	ldr	r0, [pc, #504]	; 3481715c <flexonenand_set_boundary+0x438>
34816f60:	ebffcb14 	bl	34809bb8 <printf>
		goto out;
34816f64:	ea000043 	b	34817078 <flexonenand_set_boundary+0x354>
	}

	printk(KERN_INFO "flexonenand_set_boundary: Changing die %d boundary: %d%s\n",
34816f68:	e59de024 	ldr	lr, [sp, #36]	; 0x24
34816f6c:	e59fc1ec 	ldr	ip, [pc, #492]	; 34817160 <flexonenand_set_boundary+0x43c>
34816f70:	e35e0000 	cmp	lr, #0
34816f74:	e59f31e8 	ldr	r3, [pc, #488]	; 34817164 <flexonenand_set_boundary+0x440>
34816f78:	e59f01e8 	ldr	r0, [pc, #488]	; 34817168 <flexonenand_set_boundary+0x444>
34816f7c:	01a0300c 	moveq	r3, ip
34816f80:	e1a01007 	mov	r1, r7
34816f84:	e1a02009 	mov	r2, r9
34816f88:	ebffcb0a 	bl	34809bb8 <printf>
			die, boundary, lock ? "(Locked)" : "(Unlocked)");

	boundary &= FLEXONENAND_PI_MASK;
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);
34816f8c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34816f90:	e3500000 	cmp	r0, #0
34816f94:	03a06903 	moveq	r6, #49152	; 0xc000
34816f98:	13a06000 	movne	r6, #0

	addr = die ? this->diesize[0] : 0;
34816f9c:	e3570000 	cmp	r7, #0
34816fa0:	15943010 	ldrne	r3, [r4, #16]
34816fa4:	11a00003 	movne	r0, r3
34816fa8:	13a01000 	movne	r1, #0
34816fac:	11cd01f0 	strdne	r0, [sp, #16]
34816fb0:	03a02000 	moveq	r2, #0
34816fb4:	03a03000 	moveq	r3, #0
34816fb8:	01cd21f0 	strdeq	r2, [sp, #16]
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
34816fbc:	e3a03000 	mov	r3, #0
34816fc0:	e58d3000 	str	r3, [sp]
34816fc4:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816fc8:	e1cd21d0 	ldrd	r2, [sp, #16]
34816fcc:	e3a01094 	mov	r1, #148	; 0x94
34816fd0:	e1a00005 	mov	r0, r5
34816fd4:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_ERASING);
34816fd8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816fdc:	e1a00005 	mov	r0, r5
34816fe0:	e3a01003 	mov	r1, #3
34816fe4:	e12fff33 	blx	r3
	if (ret) {
34816fe8:	e250a000 	subs	sl, r0, #0
		printk("flexonenand_set_boundary:"
34816fec:	159f0178 	ldrne	r0, [pc, #376]	; 3481716c <flexonenand_set_boundary+0x448>
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);

	addr = die ? this->diesize[0] : 0;
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
	ret = this->wait(mtd, FL_ERASING);
	if (ret) {
34816ff0:	1a000012 	bne	34817040 <flexonenand_set_boundary+0x31c>
		printk("flexonenand_set_boundary:"
			"Failed PI erase for Die %d\n", die);
		goto out;
	}

	this->write_word(boundary, this->base + ONENAND_DATARAM);
34816ff4:	e5941000 	ldr	r1, [r4]
	}

	printk(KERN_INFO "flexonenand_set_boundary: Changing die %d boundary: %d%s\n",
			die, boundary, lock ? "(Locked)" : "(Unlocked)");

	boundary &= FLEXONENAND_PI_MASK;
34816ff8:	e1a00b09 	lsl	r0, r9, #22
		printk("flexonenand_set_boundary:"
			"Failed PI erase for Die %d\n", die);
		goto out;
	}

	this->write_word(boundary, this->base + ONENAND_DATARAM);
34816ffc:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34817000:	e1860b20 	orr	r0, r6, r0, lsr #22
34817004:	e2811b01 	add	r1, r1, #1024	; 0x400
34817008:	e12fff33 	blx	r3
	this->command(mtd, ONENAND_CMD_PROG, addr, 0);
3481700c:	e1cd21d0 	ldrd	r2, [sp, #16]
34817010:	e58da000 	str	sl, [sp]
34817014:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34817018:	e3a01080 	mov	r1, #128	; 0x80
3481701c:	e1a00005 	mov	r0, r5
34817020:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_WRITING);
34817024:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34817028:	e1a00005 	mov	r0, r5
3481702c:	e3a01002 	mov	r1, #2
34817030:	e12fff33 	blx	r3
	if (ret) {
34817034:	e250a000 	subs	sl, r0, #0
34817038:	0a000003 	beq	3481704c <flexonenand_set_boundary+0x328>
		printk("flexonenand_set_boundary:"
3481703c:	e59f012c 	ldr	r0, [pc, #300]	; 34817170 <flexonenand_set_boundary+0x44c>
34817040:	e1a01007 	mov	r1, r7
34817044:	ebffcadb 	bl	34809bb8 <printf>
			"Failed PI write for Die %d\n", die);
		goto out;
34817048:	ea00000a 	b	34817078 <flexonenand_set_boundary+0x354>
	}

	this->command(mtd, FLEXONENAND_CMD_PI_UPDATE, die, 0);
3481704c:	e58da000 	str	sl, [sp]
34817050:	e1cd21d8 	ldrd	r2, [sp, #24]
34817054:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34817058:	e3a01005 	mov	r1, #5
3481705c:	e1a00005 	mov	r0, r5
34817060:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_WRITING);
34817064:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34817068:	e1a00005 	mov	r0, r5
3481706c:	e3a01002 	mov	r1, #2
34817070:	e12fff33 	blx	r3
34817074:	e1a0a000 	mov	sl, r0
out:
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_REG_COMMAND);
34817078:	e5941000 	ldr	r1, [r4]
3481707c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34817080:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34817084:	e3a000f0 	mov	r0, #240	; 0xf0
34817088:	e2811040 	add	r1, r1, #64	; 0x40
3481708c:	e12fff33 	blx	r3
	this->wait(mtd, FL_RESETING);
34817090:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34817094:	e1a00005 	mov	r0, r5
34817098:	e3a01006 	mov	r1, #6
3481709c:	e12fff33 	blx	r3
	if (!ret)
348170a0:	e35a0000 	cmp	sl, #0
348170a4:	1a000003 	bne	348170b8 <flexonenand_set_boundary+0x394>
		/* Recalculate device size on boundary change*/
		flexonenand_get_size(mtd);
348170a8:	e1a00005 	mov	r0, r5
348170ac:	ebfff6a0 	bl	34814b34 <flexonenand_get_size>
348170b0:	ea000000 	b	348170b8 <flexonenand_set_boundary+0x394>
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
		return -EINVAL;
348170b4:	e3e0a015 	mvn	sl, #21
	if (!ret)
		/* Recalculate device size on boundary change*/
		flexonenand_get_size(mtd);

	return ret;
}
348170b8:	e1a0000a 	mov	r0, sl
348170bc:	e28dd048 	add	sp, sp, #72	; 0x48
348170c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	if (ret) {
		printk(KERN_ERR "flexonenand_set_boundary: Please erase blocks before boundary change\n");
		return ret;
	}

	this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
348170c4:	e1a0000b 	mov	r0, fp
348170c8:	e1a01fc0 	asr	r1, r0, #31
348170cc:	e3a06000 	mov	r6, #0
348170d0:	e1cd01f8 	strd	r0, [sp, #24]
348170d4:	e1cd21d8 	ldrd	r2, [sp, #24]
348170d8:	e58d6000 	str	r6, [sp]
348170dc:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348170e0:	e3a01066 	mov	r1, #102	; 0x66
348170e4:	e1a00005 	mov	r0, r5
348170e8:	e12fff3c 	blx	ip
	this->wait(mtd, FL_SYNCING);
348170ec:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348170f0:	e3a01004 	mov	r1, #4
348170f4:	e1a00005 	mov	r0, r5
348170f8:	e12fff33 	blx	r3

	/* Check is boundary is locked */
	this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
348170fc:	e1cd21d8 	ldrd	r2, [sp, #24]
34817100:	e58d6000 	str	r6, [sp]
34817104:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34817108:	e3011985 	movw	r1, #6533	; 0x1985
3481710c:	e1a00005 	mov	r0, r5
34817110:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_READING);
34817114:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34817118:	e3a01001 	mov	r1, #1
3481711c:	e1a00005 	mov	r0, r5
34817120:	e12fff33 	blx	r3
34817124:	e1a0a000 	mov	sl, r0

	thisboundary = this->read_word(this->base + ONENAND_DATARAM);
34817128:	e5940000 	ldr	r0, [r4]
3481712c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34817130:	e2800b01 	add	r0, r0, #1024	; 0x400
34817134:	e12fff33 	blx	r3
	if ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {
34817138:	e1a00740 	asr	r0, r0, #14
3481713c:	e3500003 	cmp	r0, #3
34817140:	e1a0700b 	mov	r7, fp
34817144:	1affff84 	bne	34816f5c <flexonenand_set_boundary+0x238>
34817148:	eaffff86 	b	34816f68 <flexonenand_set_boundary+0x244>
3481714c:	34827c9c 	.word	0x34827c9c
34817150:	34827ce4 	.word	0x34827ce4
34817154:	34827d00 	.word	0x34827d00
34817158:	34827d16 	.word	0x34827d16
3481715c:	34827d5c 	.word	0x34827d5c
34817160:	3482775f 	.word	0x3482775f
34817164:	34827756 	.word	0x34827756
34817168:	34827d87 	.word	0x34827d87
3481716c:	34827dc1 	.word	0x34827dc1
34817170:	34827df6 	.word	0x34827df6

34817174 <onenand_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
int onenand_probe(struct mtd_info *mtd)
{
34817174:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34817178:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
int onenand_probe(struct mtd_info *mtd)
{
3481717c:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int dev_id, ver_id;
	int density;
	int ret;

	ret = this->chip_probe(mtd);
34817180:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34817184:	e12fff33 	blx	r3
	if (ret)
34817188:	e250a000 	subs	sl, r0, #0
3481718c:	1a0000b6 	bne	3481746c <onenand_probe+0x2f8>
		return ret;

	/* Read device IDs from Register */
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
34817190:	e5940000 	ldr	r0, [r4]
34817194:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34817198:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
3481719c:	e2800002 	add	r0, r0, #2
348171a0:	e12fff33 	blx	r3
348171a4:	e1a06000 	mov	r6, r0
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
348171a8:	e5940000 	ldr	r0, [r4]
348171ac:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348171b0:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348171b4:	e2800004 	add	r0, r0, #4
348171b8:	e12fff33 	blx	r3
348171bc:	e1a07000 	mov	r7, r0
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
348171c0:	e5940000 	ldr	r0, [r4]
348171c4:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348171c8:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348171cc:	e280000c 	add	r0, r0, #12
348171d0:	e12fff33 	blx	r3

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
348171d4:	e1a01007 	mov	r1, r7
		return ret;

	/* Read device IDs from Register */
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
348171d8:	e5840024 	str	r0, [r4, #36]	; 0x24

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
348171dc:	e1a00006 	mov	r0, r6
348171e0:	ebfffe9e 	bl	34816c60 <onenand_print_device_info>
348171e4:	e5850020 	str	r0, [r5, #32]
	this->device_id = dev_id;
	this->version_id = ver_id;
348171e8:	e5847020 	str	r7, [r4, #32]
 * - lock scheme
 * - two plane
 */
static void onenand_check_features(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
348171ec:	e5957094 	ldr	r7, [r5, #148]	; 0x94
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
	this->device_id = dev_id;
348171f0:	e584601c 	str	r6, [r4, #28]
{
	struct onenand_chip *this = mtd->priv;
	unsigned int density, process;

	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
348171f4:	e597301c 	ldr	r3, [r7, #28]
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
348171f8:	e5971020 	ldr	r1, [r7, #32]
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
348171fc:	e7e32253 	ubfx	r2, r3, #4, #4
	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;

	/* Lock scheme */
	switch (density) {
34817200:	e3520004 	cmp	r2, #4
	struct onenand_chip *this = mtd->priv;
	unsigned int density, process;

	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
34817204:	e1a01421 	lsr	r1, r1, #8

	/* Lock scheme */
	switch (density) {
34817208:	0a000009 	beq	34817234 <onenand_probe+0xc0>
3481720c:	e3520005 	cmp	r2, #5
34817210:	0a000002 	beq	34817220 <onenand_probe+0xac>
34817214:	e3520003 	cmp	r2, #3
34817218:	1a000011 	bne	34817264 <onenand_probe+0xf0>
3481721c:	ea00000b 	b	34817250 <onenand_probe+0xdc>
34817220:	e597202c 	ldr	r2, [r7, #44]	; 0x2c
	case ONENAND_DEVICE_DENSITY_4Gb:
		if (ONENAND_IS_DDP(this))
34817224:	e3130008 	tst	r3, #8
			this->options |= ONENAND_HAS_2PLANE;
34817228:	13822004 	orrne	r2, r2, #4
		else
			this->options |= ONENAND_HAS_4KB_PAGE;
3481722c:	03822008 	orreq	r2, r2, #8
34817230:	e587202c 	str	r2, [r7, #44]	; 0x2c

	case ONENAND_DEVICE_DENSITY_2Gb:
		/* 2Gb DDP don't have 2 plane */
		if (!ONENAND_IS_DDP(this))
34817234:	e3130008 	tst	r3, #8
			this->options |= ONENAND_HAS_2PLANE;
34817238:	0597302c 	ldreq	r3, [r7, #44]	; 0x2c
3481723c:	03833004 	orreq	r3, r3, #4
34817240:	0587302c 	streq	r3, [r7, #44]	; 0x2c
		this->options |= ONENAND_HAS_UNLOCK_ALL;
34817244:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34817248:	e3833002 	orr	r3, r3, #2
3481724c:	e587302c 	str	r3, [r7, #44]	; 0x2c

	case ONENAND_DEVICE_DENSITY_1Gb:
		/* A-Die has all block unlock */
		if (process)
34817250:	e3510000 	cmp	r1, #0
			this->options |= ONENAND_HAS_UNLOCK_ALL;
34817254:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
34817258:	13833002 	orrne	r3, r3, #2
			this->options |= ONENAND_HAS_2PLANE;
		this->options |= ONENAND_HAS_UNLOCK_ALL;

	case ONENAND_DEVICE_DENSITY_1Gb:
		/* A-Die has all block unlock */
		if (process)
3481725c:	1a000004 	bne	34817274 <onenand_probe+0x100>
34817260:	ea000004 	b	34817278 <onenand_probe+0x104>
			this->options |= ONENAND_HAS_UNLOCK_ALL;
		break;

	default:
		/* Some OneNAND has continuous lock scheme */
		if (!process)
34817264:	e3510000 	cmp	r1, #0
34817268:	1a000002 	bne	34817278 <onenand_probe+0x104>
			this->options |= ONENAND_HAS_CONT_LOCK;
3481726c:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34817270:	e3833001 	orr	r3, r3, #1
34817274:	e587302c 	str	r3, [r7, #44]	; 0x2c
		break;
	}

	if (ONENAND_IS_MLC(this))
34817278:	e5973024 	ldr	r3, [r7, #36]	; 0x24
3481727c:	e3130001 	tst	r3, #1
		this->options |= ONENAND_HAS_4KB_PAGE;
34817280:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
34817284:	13833008 	orrne	r3, r3, #8
34817288:	1587302c 	strne	r3, [r7, #44]	; 0x2c

	if (ONENAND_IS_4KB_PAGE(this))
3481728c:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34817290:	e3130008 	tst	r3, #8
		this->options &= ~ONENAND_HAS_2PLANE;
34817294:	13c33004 	bicne	r3, r3, #4
34817298:	1587302c 	strne	r3, [r7, #44]	; 0x2c

	if (FLEXONENAND(this)) {
3481729c:	e597301c 	ldr	r3, [r7, #28]
348172a0:	e3130c02 	tst	r3, #512	; 0x200
		this->options &= ~ONENAND_HAS_CONT_LOCK;
348172a4:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
348172a8:	13c33001 	bicne	r3, r3, #1
		this->options |= ONENAND_HAS_UNLOCK_ALL;
348172ac:	13833002 	orrne	r3, r3, #2
348172b0:	1587302c 	strne	r3, [r7, #44]	; 0x2c
	}

	if (this->options & ONENAND_HAS_CONT_LOCK)
348172b4:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
348172b8:	e3130001 	tst	r3, #1
348172bc:	0a000001 	beq	348172c8 <onenand_probe+0x154>
		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
348172c0:	e59f01ac 	ldr	r0, [pc, #428]	; 34817474 <onenand_probe+0x300>
348172c4:	ebffca3b 	bl	34809bb8 <printf>
	if (this->options & ONENAND_HAS_UNLOCK_ALL)
348172c8:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
348172cc:	e3130002 	tst	r3, #2
348172d0:	0a000001 	beq	348172dc <onenand_probe+0x168>
		printk(KERN_DEBUG "Chip support all block unlock\n");
348172d4:	e59f019c 	ldr	r0, [pc, #412]	; 34817478 <onenand_probe+0x304>
348172d8:	ebffca36 	bl	34809bb8 <printf>
	if (this->options & ONENAND_HAS_2PLANE)
348172dc:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
348172e0:	e3130004 	tst	r3, #4
348172e4:	0a000001 	beq	348172f0 <onenand_probe+0x17c>
		printk(KERN_DEBUG "Chip has 2 plane\n");
348172e8:	e59f018c 	ldr	r0, [pc, #396]	; 3481747c <onenand_probe+0x308>
348172ec:	ebffca31 	bl	34809bb8 <printf>
	if (this->options & ONENAND_HAS_4KB_PAGE)
348172f0:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
348172f4:	e3130008 	tst	r3, #8
348172f8:	0a000001 	beq	34817304 <onenand_probe+0x190>
		printk(KERN_DEBUG "Chip has 4KiB pagesize\n");
348172fc:	e59f017c 	ldr	r0, [pc, #380]	; 34817480 <onenand_probe+0x30c>
34817300:	ebffca2c 	bl	34809bb8 <printf>

	/* Check OneNAND features */
	onenand_check_features(mtd);

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
34817304:	e594301c 	ldr	r3, [r4, #28]
34817308:	e3130c02 	tst	r3, #512	; 0x200
3481730c:	0a00000c 	beq	34817344 <onenand_probe+0x1d0>
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
34817310:	e3130008 	tst	r3, #8
34817314:	03a03001 	moveq	r3, #1
34817318:	13a03002 	movne	r3, #2
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
3481731c:	e1a02083 	lsl	r2, r3, #1
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34817320:	e3a00030 	mov	r0, #48	; 0x30
	/* Check OneNAND features */
	onenand_check_features(mtd);

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
34817324:	e5843004 	str	r3, [r4, #4]
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34817328:	e0000390 	mul	r0, r0, r3

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
3481732c:	e585202c 	str	r2, [r5, #44]	; 0x2c
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34817330:	ebffcbe7 	bl	3480a2d4 <malloc>
					* (this->dies << 1));
		if (!mtd->eraseregions)
34817334:	e3500000 	cmp	r0, #0
	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34817338:	e5850030 	str	r0, [r5, #48]	; 0x30
					* (this->dies << 1));
		if (!mtd->eraseregions)
			return -ENOMEM;
3481733c:	03e0a00b 	mvneq	sl, #11
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
					* (this->dies << 1));
		if (!mtd->eraseregions)
34817340:	0a000049 	beq	3481746c <onenand_probe+0x2f8>

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
34817344:	e3a03401 	mov	r3, #16777216	; 0x1000000
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34817348:	e7e36256 	ubfx	r6, r6, #4, #4

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
3481734c:	e1a06613 	lsl	r6, r3, r6

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
34817350:	e5940000 	ldr	r0, [r4]

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
34817354:	e5846018 	str	r6, [r4, #24]

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
34817358:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
3481735c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34817360:	e2800006 	add	r0, r0, #6
34817364:	e12fff33 	blx	r3
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
34817368:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	 */
	this->chipsize = (16 << density) << 20;

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
3481736c:	e5850014 	str	r0, [r5, #20]
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
34817370:	e3130008 	tst	r3, #8
		mtd->writesize <<= 1;
34817374:	11a00080 	lslne	r0, r0, #1
34817378:	15850014 	strne	r0, [r5, #20]

	mtd->oobsize = mtd->writesize >> 5;
3481737c:	e5956014 	ldr	r6, [r5, #20]
	/*
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
34817380:	e594701c 	ldr	r7, [r4, #28]
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
		mtd->writesize <<= 1;

	mtd->oobsize = mtd->writesize >> 5;
34817384:	e1a032a6 	lsr	r3, r6, #5
	/*
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
34817388:	e2179c02 	ands	r9, r7, #512	; 0x200
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
		mtd->writesize <<= 1;

	mtd->oobsize = mtd->writesize >> 5;
3481738c:	e5853018 	str	r3, [r5, #24]
	/* Pagers per block is always 64 in OneNAND */
	mtd->erasesize = mtd->writesize << 6;
34817390:	e1a03306 	lsl	r3, r6, #6
34817394:	e5853010 	str	r3, [r5, #16]
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;
34817398:	11a03386 	lslne	r3, r6, #7
3481739c:	15853010 	strne	r3, [r5, #16]

	this->erase_shift = ffs(mtd->erasesize) - 1;
348173a0:	e5953010 	ldr	r3, [r5, #16]
348173a4:	e1a00003 	mov	r0, r3
348173a8:	e58d3000 	str	r3, [sp]
348173ac:	ebfff50a 	bl	348147dc <generic_ffs>
348173b0:	e2402001 	sub	r2, r0, #1
348173b4:	e1a0b000 	mov	fp, r0
348173b8:	e5842030 	str	r2, [r4, #48]	; 0x30
	this->page_shift = ffs(mtd->writesize) - 1;
348173bc:	e1a00006 	mov	r0, r6
348173c0:	e58d2004 	str	r2, [sp, #4]
348173c4:	ebfff504 	bl	348147dc <generic_ffs>
	this->ppb_shift = (this->erase_shift - this->page_shift);
348173c8:	e59d2004 	ldr	r2, [sp, #4]
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348173cc:	e59d3000 	ldr	r3, [sp]
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
348173d0:	e2400001 	sub	r0, r0, #1
	this->ppb_shift = (this->erase_shift - this->page_shift);
348173d4:	e0602002 	rsb	r2, r0, r2
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
348173d8:	e5840034 	str	r0, [r4, #52]	; 0x34
	this->ppb_shift = (this->erase_shift - this->page_shift);
348173dc:	e5842038 	str	r2, [r4, #56]	; 0x38
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348173e0:	e1a00003 	mov	r0, r3
348173e4:	e1a01006 	mov	r1, r6
348173e8:	eb0022af 	bl	3481feac <__udivsi3>
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
348173ec:	e3170008 	tst	r7, #8
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
348173f0:	15943018 	ldrne	r3, [r4, #24]
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
	this->ppb_shift = (this->erase_shift - this->page_shift);
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348173f4:	e2400001 	sub	r0, r0, #1
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
348173f8:	11a0bb33 	lsrne	fp, r3, fp
348173fc:	1584b028 	strne	fp, [r4, #40]	; 0x28
	/* It's real page size */
	this->writesize = mtd->writesize;

	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
34817400:	e3590000 	cmp	r9, #0
		flexonenand_get_size(mtd);
	else
		mtd->size = this->chipsize;
34817404:	05943018 	ldreq	r3, [r4, #24]
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
	this->ppb_shift = (this->erase_shift - this->page_shift);
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
34817408:	e584003c 	str	r0, [r4, #60]	; 0x3c
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
	/* It's real page size */
	this->writesize = mtd->writesize;
3481740c:	e5846040 	str	r6, [r4, #64]	; 0x40
	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
		flexonenand_get_size(mtd);
	else
		mtd->size = this->chipsize;
34817410:	05853008 	streq	r3, [r5, #8]
34817414:	0585900c 	streq	r9, [r5, #12]
	/* It's real page size */
	this->writesize = mtd->writesize;

	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
34817418:	0a000001 	beq	34817424 <onenand_probe+0x2b0>
		flexonenand_get_size(mtd);
3481741c:	e1a00005 	mov	r0, r5
34817420:	ebfff5c3 	bl	34814b34 <flexonenand_get_size>
	else
		mtd->size = this->chipsize;

	mtd->flags = MTD_CAP_NANDFLASH;
34817424:	e3a03b01 	mov	r3, #1024	; 0x400
34817428:	e5853004 	str	r3, [r5, #4]
	mtd->erase = onenand_erase;
3481742c:	e59f3050 	ldr	r3, [pc, #80]	; 34817484 <onenand_probe+0x310>
34817430:	e5853034 	str	r3, [r5, #52]	; 0x34
	mtd->read = onenand_read;
34817434:	e59f304c 	ldr	r3, [pc, #76]	; 34817488 <onenand_probe+0x314>
34817438:	e5853040 	str	r3, [r5, #64]	; 0x40
	mtd->write = onenand_write;
3481743c:	e59f3048 	ldr	r3, [pc, #72]	; 3481748c <onenand_probe+0x318>
34817440:	e5853044 	str	r3, [r5, #68]	; 0x44
	mtd->read_oob = onenand_read_oob;
34817444:	e59f3044 	ldr	r3, [pc, #68]	; 34817490 <onenand_probe+0x31c>
34817448:	e585304c 	str	r3, [r5, #76]	; 0x4c
	mtd->write_oob = onenand_write_oob;
3481744c:	e59f3040 	ldr	r3, [pc, #64]	; 34817494 <onenand_probe+0x320>
34817450:	e5853050 	str	r3, [r5, #80]	; 0x50
	mtd->sync = onenand_sync;
34817454:	e59f303c 	ldr	r3, [pc, #60]	; 34817498 <onenand_probe+0x324>
34817458:	e585306c 	str	r3, [r5, #108]	; 0x6c
	mtd->block_isbad = onenand_block_isbad;
3481745c:	e59f3038 	ldr	r3, [pc, #56]	; 3481749c <onenand_probe+0x328>
34817460:	e5853078 	str	r3, [r5, #120]	; 0x78
	mtd->block_markbad = onenand_block_markbad;
34817464:	e59f3034 	ldr	r3, [pc, #52]	; 348174a0 <onenand_probe+0x32c>
34817468:	e585307c 	str	r3, [r5, #124]	; 0x7c

	return 0;
}
3481746c:	e1a0000a 	mov	r0, sl
34817470:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34817474:	34827e2b 	.word	0x34827e2b
34817478:	34827e4b 	.word	0x34827e4b
3481747c:	34827e6a 	.word	0x34827e6a
34817480:	34827e7c 	.word	0x34827e7c
34817484:	348167d4 	.word	0x348167d4
34817488:	34816774 	.word	0x34816774
3481748c:	34815a00 	.word	0x34815a00
34817490:	34816744 	.word	0x34816744
34817494:	348159d0 	.word	0x348159d0
34817498:	348149ac 	.word	0x348149ac
3481749c:	348149b0 	.word	0x348149b0
348174a0:	348149f4 	.word	0x348149f4

348174a4 <onenand_scan>:
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
{
348174a4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	struct onenand_chip *this = mtd->priv;
348174a8:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
{
348174ac:	e1a06000 	mov	r6, r0
	int i;
	struct onenand_chip *this = mtd->priv;

	if (!this->read_word)
348174b0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348174b4:	e3530000 	cmp	r3, #0
		this->read_word = onenand_readw;
348174b8:	059f3568 	ldreq	r3, [pc, #1384]	; 34817a28 <onenand_scan+0x584>
348174bc:	05843068 	streq	r3, [r4, #104]	; 0x68
	if (!this->write_word)
348174c0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348174c4:	e3530000 	cmp	r3, #0
		this->write_word = onenand_writew;
348174c8:	059f355c 	ldreq	r3, [pc, #1372]	; 34817a2c <onenand_scan+0x588>
348174cc:	0584306c 	streq	r3, [r4, #108]	; 0x6c

	if (!this->command)
348174d0:	e5943050 	ldr	r3, [r4, #80]	; 0x50
348174d4:	e3530000 	cmp	r3, #0
		this->command = onenand_command;
348174d8:	059f3550 	ldreq	r3, [pc, #1360]	; 34817a30 <onenand_scan+0x58c>
348174dc:	05843050 	streq	r3, [r4, #80]	; 0x50
	if (!this->wait)
348174e0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348174e4:	e3530000 	cmp	r3, #0
		this->wait = onenand_wait;
348174e8:	059f3544 	ldreq	r3, [pc, #1348]	; 34817a34 <onenand_scan+0x590>
348174ec:	05843054 	streq	r3, [r4, #84]	; 0x54
	if (!this->bbt_wait)
348174f0:	e5943058 	ldr	r3, [r4, #88]	; 0x58
348174f4:	e3530000 	cmp	r3, #0
		this->bbt_wait = onenand_bbt_wait;
348174f8:	059f3538 	ldreq	r3, [pc, #1336]	; 34817a38 <onenand_scan+0x594>
348174fc:	05843058 	streq	r3, [r4, #88]	; 0x58

	if (!this->read_bufferram)
34817500:	e5943060 	ldr	r3, [r4, #96]	; 0x60
34817504:	e3530000 	cmp	r3, #0
		this->read_bufferram = onenand_read_bufferram;
34817508:	059f352c 	ldreq	r3, [pc, #1324]	; 34817a3c <onenand_scan+0x598>
3481750c:	05843060 	streq	r3, [r4, #96]	; 0x60
	if (!this->write_bufferram)
34817510:	e5943064 	ldr	r3, [r4, #100]	; 0x64
34817514:	e3530000 	cmp	r3, #0
		this->write_bufferram = onenand_write_bufferram;
34817518:	059f3520 	ldreq	r3, [pc, #1312]	; 34817a40 <onenand_scan+0x59c>
3481751c:	05843064 	streq	r3, [r4, #100]	; 0x64

	if (!this->chip_probe)
34817520:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34817524:	e3530000 	cmp	r3, #0
		this->chip_probe = onenand_chip_probe;
34817528:	059f3514 	ldreq	r3, [pc, #1300]	; 34817a44 <onenand_scan+0x5a0>
3481752c:	05843070 	streq	r3, [r4, #112]	; 0x70

	if (!this->block_markbad)
34817530:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34817534:	e3530000 	cmp	r3, #0
		this->block_markbad = onenand_default_block_markbad;
34817538:	059f3508 	ldreq	r3, [pc, #1288]	; 34817a48 <onenand_scan+0x5a4>
3481753c:	05843078 	streq	r3, [r4, #120]	; 0x78
	if (!this->scan_bbt)
34817540:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
34817544:	e3530000 	cmp	r3, #0
		this->scan_bbt = onenand_default_bbt;
34817548:	059f34fc 	ldreq	r3, [pc, #1276]	; 34817a4c <onenand_scan+0x5a8>
3481754c:	0584307c 	streq	r3, [r4, #124]	; 0x7c

	if (onenand_probe(mtd))
34817550:	ebffff07 	bl	34817174 <onenand_probe>
34817554:	e3500000 	cmp	r0, #0
		return -ENXIO;
34817558:	13e00005 	mvnne	r0, #5
	if (!this->block_markbad)
		this->block_markbad = onenand_default_block_markbad;
	if (!this->scan_bbt)
		this->scan_bbt = onenand_default_bbt;

	if (onenand_probe(mtd))
3481755c:	1a00012f 	bne	34817a20 <onenand_scan+0x57c>
		return -ENXIO;

	/* Set Sync. Burst Read after probing */
	if (this->mmcontrol) {
34817560:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34817564:	e3530000 	cmp	r3, #0
34817568:	0a000003 	beq	3481757c <onenand_scan+0xd8>
		printk(KERN_INFO "OneNAND Sync. Burst Read support\n");
3481756c:	e59f04dc 	ldr	r0, [pc, #1244]	; 34817a50 <onenand_scan+0x5ac>
34817570:	ebffc990 	bl	34809bb8 <printf>
		this->read_bufferram = onenand_sync_read_bufferram;
34817574:	e59f34d8 	ldr	r3, [pc, #1240]	; 34817a54 <onenand_scan+0x5b0>
34817578:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
3481757c:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
34817580:	e3530000 	cmp	r3, #0
34817584:	1a00000b 	bne	348175b8 <onenand_scan+0x114>
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
34817588:	e5960014 	ldr	r0, [r6, #20]
3481758c:	e3a01001 	mov	r1, #1
34817590:	ebffccbc 	bl	3480a888 <calloc>
		if (!this->page_buf) {
34817594:	e3500000 	cmp	r0, #0
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
34817598:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
		this->read_bufferram = onenand_sync_read_bufferram;
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
3481759c:	e584008c 	str	r0, [r4, #140]	; 0x8c
		if (!this->page_buf) {
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
348175a0:	13833a01 	orrne	r3, r3, #4096	; 0x1000
348175a4:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
		if (!this->page_buf) {
348175a8:	1a000002 	bne	348175b8 <onenand_scan+0x114>
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
348175ac:	e59f04a4 	ldr	r0, [pc, #1188]	; 34817a58 <onenand_scan+0x5b4>
348175b0:	ebffc980 	bl	34809bb8 <printf>
348175b4:	ea000118 	b	34817a1c <onenand_scan+0x578>
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
348175b8:	e5943090 	ldr	r3, [r4, #144]	; 0x90
348175bc:	e3530000 	cmp	r3, #0
348175c0:	1a000012 	bne	34817610 <onenand_scan+0x16c>
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
348175c4:	e5960018 	ldr	r0, [r6, #24]
348175c8:	e3a01001 	mov	r1, #1
348175cc:	ebffccad 	bl	3480a888 <calloc>
		if (!this->oob_buf) {
348175d0:	e3500000 	cmp	r0, #0
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
348175d4:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
348175d8:	e5840090 	str	r0, [r4, #144]	; 0x90
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
348175dc:	13833a02 	orrne	r3, r3, #8192	; 0x2000
348175e0:	1584302c 	strne	r3, [r4, #44]	; 0x2c
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
		if (!this->oob_buf) {
348175e4:	1a000009 	bne	34817610 <onenand_scan+0x16c>
			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
348175e8:	e59f046c 	ldr	r0, [pc, #1132]	; 34817a5c <onenand_scan+0x5b8>
348175ec:	ebffc971 	bl	34809bb8 <printf>
			if (this->options & ONENAND_PAGEBUF_ALLOC) {
348175f0:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
348175f4:	e3130a01 	tst	r3, #4096	; 0x1000
348175f8:	0a000107 	beq	34817a1c <onenand_scan+0x578>
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
348175fc:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
34817600:	e584302c 	str	r3, [r4, #44]	; 0x2c
				kfree(this->page_buf);
34817604:	e594008c 	ldr	r0, [r4, #140]	; 0x8c
34817608:	ebffcaa8 	bl	3480a0b0 <free>
3481760c:	ea000102 	b	34817a1c <onenand_scan+0x578>
	this->state = FL_READY;

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34817610:	e5961018 	ldr	r1, [r6, #24]
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
	}

	this->state = FL_READY;
34817614:	e3a05000 	mov	r5, #0

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34817618:	e3510040 	cmp	r1, #64	; 0x40
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
	}

	this->state = FL_READY;
3481761c:	e5845088 	str	r5, [r4, #136]	; 0x88

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34817620:	0a000009 	beq	3481764c <onenand_scan+0x1a8>
34817624:	e3510080 	cmp	r1, #128	; 0x80
34817628:	0a000003 	beq	3481763c <onenand_scan+0x198>
3481762c:	e3510020 	cmp	r1, #32
34817630:	e59f7428 	ldr	r7, [pc, #1064]	; 34817a60 <onenand_scan+0x5bc>
34817634:	1a00000c 	bne	3481766c <onenand_scan+0x1c8>
34817638:	ea000007 	b	3481765c <onenand_scan+0x1b8>
	case 128:
		this->ecclayout = &onenand_oob_128;
3481763c:	e59f3420 	ldr	r3, [pc, #1056]	; 34817a64 <onenand_scan+0x5c0>
34817640:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 0;
34817644:	e5865090 	str	r5, [r6, #144]	; 0x90
		break;
34817648:	ea00000b 	b	3481767c <onenand_scan+0x1d8>

	case 64:
		this->ecclayout = &onenand_oob_64;
3481764c:	e59f3414 	ldr	r3, [pc, #1044]	; 34817a68 <onenand_scan+0x5c4>
34817650:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 2;
34817654:	e3a03002 	mov	r3, #2
34817658:	ea000001 	b	34817664 <onenand_scan+0x1c0>
		break;

	case 32:
		this->ecclayout = &onenand_oob_32;
3481765c:	e584709c 	str	r7, [r4, #156]	; 0x9c
		mtd->subpage_sft = 1;
34817660:	e3a03001 	mov	r3, #1
34817664:	e5863090 	str	r3, [r6, #144]	; 0x90
		break;
34817668:	ea000003 	b	3481767c <onenand_scan+0x1d8>

	default:
		printk(KERN_WARNING "No OOB scheme defined for oobsize %d\n",
3481766c:	e59f03f8 	ldr	r0, [pc, #1016]	; 34817a6c <onenand_scan+0x5c8>
34817670:	ebffc950 	bl	34809bb8 <printf>
			mtd->oobsize);
		mtd->subpage_sft = 0;
34817674:	e5865090 	str	r5, [r6, #144]	; 0x90
		/* To prevent kernel oops */
		this->ecclayout = &onenand_oob_32;
34817678:	e584709c 	str	r7, [r4, #156]	; 0x9c
		break;
	}

	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
3481767c:	e5962014 	ldr	r2, [r6, #20]
34817680:	e5963090 	ldr	r3, [r6, #144]	; 0x90
34817684:	e1a03332 	lsr	r3, r2, r3
34817688:	e5843098 	str	r3, [r4, #152]	; 0x98

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
3481768c:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
34817690:	e3a02000 	mov	r2, #0
34817694:	e5832204 	str	r2, [r3, #516]	; 0x204
 * This fills out all the not initialized function pointers
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
34817698:	e2830040 	add	r0, r3, #64	; 0x40

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
3481769c:	e1a02003 	mov	r2, r3
348176a0:	ea000005 	b	348176bc <onenand_scan+0x218>
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
348176a4:	e593c204 	ldr	ip, [r3, #516]	; 0x204
348176a8:	e2822008 	add	r2, r2, #8
348176ac:	e08c1001 	add	r1, ip, r1
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
348176b0:	e1520000 	cmp	r2, r0
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
348176b4:	e5831204 	str	r1, [r3, #516]	; 0x204
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
348176b8:	0a000002 	beq	348176c8 <onenand_scan+0x224>
	    this->ecclayout->oobfree[i].length; i++)
348176bc:	e592120c 	ldr	r1, [r2, #524]	; 0x20c
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
348176c0:	e3510000 	cmp	r1, #0
348176c4:	1afffff6 	bne	348176a4 <onenand_scan+0x200>
 *
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
348176c8:	e5965094 	ldr	r5, [r6, #148]	; 0x94
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
			this->ecclayout->oobfree[i].length;
	mtd->oobavail = this->ecclayout->oobavail;
348176cc:	e5932204 	ldr	r2, [r3, #516]	; 0x204

	mtd->ecclayout = this->ecclayout;
348176d0:	e5863028 	str	r3, [r6, #40]	; 0x28
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348176d4:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
			this->ecclayout->oobfree[i].length;
	mtd->oobavail = this->ecclayout->oobavail;
348176d8:	e586201c 	str	r2, [r6, #28]
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348176dc:	e3130002 	tst	r3, #2
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;
348176e0:	e596a008 	ldr	sl, [r6, #8]

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348176e4:	0a000050 	beq	3481782c <onenand_scan+0x388>
		/* Set start block address */
		this->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
348176e8:	e5951000 	ldr	r1, [r5]
348176ec:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
348176f0:	e2811b79 	add	r1, r1, #123904	; 0x1e400
348176f4:	e3a00000 	mov	r0, #0
348176f8:	e2811098 	add	r1, r1, #152	; 0x98
348176fc:	e12fff33 	blx	r3
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
34817700:	e3a03000 	mov	r3, #0
34817704:	e58d3000 	str	r3, [sp]
34817708:	e3a01027 	mov	r1, #39	; 0x27
3481770c:	e3a03000 	mov	r3, #0
34817710:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34817714:	e1a00006 	mov	r0, r6
34817718:	e3a02000 	mov	r2, #0
3481771c:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_LOCKING);
34817720:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34817724:	e1a00006 	mov	r0, r6
34817728:	e3a01008 	mov	r1, #8
3481772c:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
34817730:	e5950000 	ldr	r0, [r5]
34817734:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34817738:	e2800b79 	add	r0, r0, #123904	; 0x1e400
3481773c:	e2800080 	add	r0, r0, #128	; 0x80
34817740:	e12fff33 	blx	r3
34817744:	e3100902 	tst	r0, #32768	; 0x8000
34817748:	1afffff8 	bne	34817730 <onenand_scan+0x28c>
static int onenand_check_lock_status(struct onenand_chip *this)
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
3481774c:	e5959018 	ldr	r9, [r5, #24]
34817750:	e5953030 	ldr	r3, [r5, #48]	; 0x30
	for (block = 0; block < end; block++) {
34817754:	e3a07000 	mov	r7, #0
static int onenand_check_lock_status(struct onenand_chip *this)
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
34817758:	e1a09339 	lsr	r9, r9, r3
3481775c:	ea00002f 	b	34817820 <onenand_scan+0x37c>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34817760:	e5950028 	ldr	r0, [r5, #40]	; 0x28

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817764:	e5951000 	ldr	r1, [r5]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34817768:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
3481776c:	10270000 	eorne	r0, r7, r0
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34817770:	01a00007 	moveq	r0, r7
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34817774:	13800902 	orrne	r0, r0, #32768	; 0x8000

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817778:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
3481777c:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34817780:	e6ff0070 	uxth	r0, r0
34817784:	e2811c02 	add	r1, r1, #512	; 0x200
34817788:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
3481778c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34817790:	e5952000 	ldr	r2, [r5]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34817794:	e0173003 	ands	r3, r7, r3
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34817798:	e59f12d0 	ldr	r1, [pc, #720]	; 34817a70 <onenand_scan+0x5cc>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
3481779c:	01a00003 	moveq	r0, r3
348177a0:	13a00902 	movne	r0, #32768	; 0x8000
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
348177a4:	e0821001 	add	r1, r2, r1
348177a8:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
348177ac:	e6ff0070 	uxth	r0, r0
348177b0:	e12fff33 	blx	r3
		/* Set start block address */
		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
348177b4:	e5951000 	ldr	r1, [r5]
348177b8:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
348177bc:	e2811b79 	add	r1, r1, #123904	; 0x1e400
348177c0:	e6ff0077 	uxth	r0, r7
348177c4:	e2811098 	add	r1, r1, #152	; 0x98
348177c8:	e12fff33 	blx	r3

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
348177cc:	e5950000 	ldr	r0, [r5]
348177d0:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348177d4:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348177d8:	e280009c 	add	r0, r0, #156	; 0x9c
348177dc:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US)) {
348177e0:	e3100004 	tst	r0, #4
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
		/* Set start block address */
		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
348177e4:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US)) {
348177e8:	1a00000b 	bne	3481781c <onenand_scan+0x378>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
348177ec:	e59f0280 	ldr	r0, [pc, #640]	; 34817a74 <onenand_scan+0x5d0>
348177f0:	e1a01007 	mov	r1, r7
348177f4:	ebffc8ef 	bl	34809bb8 <printf>
		/* Check lock status */
		if (onenand_check_lock_status(this))
			return;

		/* Workaround for all block unlock in DDP */
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
348177f8:	e595301c 	ldr	r3, [r5, #28]
348177fc:	e2033f82 	and	r3, r3, #520	; 0x208
34817800:	e3530008 	cmp	r3, #8
			/* All blocks on another chip */
			ofs = this->chipsize >> 1;
34817804:	0595a018 	ldreq	sl, [r5, #24]
34817808:	01a0a0aa 	lsreq	sl, sl, #1
3481780c:	01a0200a 	moveq	r2, sl
34817810:	03a03000 	moveq	r3, #0
		/* Check lock status */
		if (onenand_check_lock_status(this))
			return;

		/* Workaround for all block unlock in DDP */
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
34817814:	1a000004 	bne	3481782c <onenand_scan+0x388>
34817818:	ea000005 	b	34817834 <onenand_scan+0x390>
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
3481781c:	e2877001 	add	r7, r7, #1
34817820:	e1570009 	cmp	r7, r9
34817824:	3affffcd 	bcc	34817760 <onenand_scan+0x2bc>
34817828:	ea000077 	b	34817a0c <onenand_scan+0x568>
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
3481782c:	e3a02000 	mov	r2, #0
34817830:	e3a03000 	mov	r3, #0
 *
 * Lock or unlock one or more blocks
 */
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
34817834:	e5965094 	ldr	r5, [r6, #148]	; 0x94
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34817838:	e1cd20f8 	strd	r2, [sp, #8]
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
3481783c:	e1cd20d8 	ldrd	r2, [sp, #8]
34817840:	e1a00005 	mov	r0, r5
34817844:	ebfff885 	bl	34815a60 <onenand_block>
	end = onenand_block(this, ofs + len);
34817848:	e1cd20d8 	ldrd	r2, [sp, #8]
3481784c:	e092200a 	adds	r2, r2, sl
34817850:	e2a33000 	adc	r3, r3, #0
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
34817854:	e1a07000 	mov	r7, r0
34817858:	e1a0b000 	mov	fp, r0
	end = onenand_block(this, ofs + len);
3481785c:	e1a00005 	mov	r0, r5
34817860:	ebfff87e 	bl	34815a60 <onenand_block>

	/* Continuous lock scheme */
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34817864:	e595902c 	ldr	r9, [r5, #44]	; 0x2c
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
	end = onenand_block(this, ofs + len);
34817868:	e1a0a000 	mov	sl, r0

	/* Continuous lock scheme */
	if (this->options & ONENAND_HAS_CONT_LOCK) {
3481786c:	e2199001 	ands	r9, r9, #1
34817870:	0a000063 	beq	34817a04 <onenand_scan+0x560>
		/* Set start block address */
		this->write_word(start,
34817874:	e5951000 	ldr	r1, [r5]
34817878:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
3481787c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34817880:	e6ff0077 	uxth	r0, r7
34817884:	e2811098 	add	r1, r1, #152	; 0x98
34817888:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
		/* Set end block address */
		this->write_word(end - 1,
3481788c:	e5951000 	ldr	r1, [r5]
34817890:	e24a0001 	sub	r0, sl, #1
34817894:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34817898:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
3481789c:	e6ff0070 	uxth	r0, r0
348178a0:	e281109a 	add	r1, r1, #154	; 0x9a
348178a4:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_END_BLOCK_ADDRESS);
		/* Write unlock command */
		this->command(mtd, cmd, 0, 0);
348178a8:	e3a03000 	mov	r3, #0
348178ac:	e58d3000 	str	r3, [sp]
348178b0:	e3a01023 	mov	r1, #35	; 0x23
348178b4:	e3a03000 	mov	r3, #0
348178b8:	e595c050 	ldr	ip, [r5, #80]	; 0x50
348178bc:	e1a00006 	mov	r0, r6
348178c0:	e3a02000 	mov	r2, #0
348178c4:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_UNLOCKING);
348178c8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348178cc:	e1a00006 	mov	r0, r6
348178d0:	e3a01007 	mov	r1, #7
348178d4:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
348178d8:	e5950000 	ldr	r0, [r5]
348178dc:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348178e0:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348178e4:	e2800080 	add	r0, r0, #128	; 0x80
348178e8:	e12fff33 	blx	r3
348178ec:	e3100902 	tst	r0, #32768	; 0x8000
348178f0:	1afffff8 	bne	348178d8 <onenand_scan+0x434>
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
348178f4:	e5950000 	ldr	r0, [r5]
348178f8:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348178fc:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34817900:	e280009c 	add	r0, r0, #156	; 0x9c
34817904:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
34817908:	e3100004 	tst	r0, #4
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
3481790c:	e1a01000 	mov	r1, r0
		if (!(status & ONENAND_WP_US))
34817910:	1a00003d 	bne	34817a0c <onenand_scan+0x568>
			printk(KERN_ERR "wp status = 0x%x\n", status);
34817914:	e59f015c 	ldr	r0, [pc, #348]	; 34817a78 <onenand_scan+0x5d4>
34817918:	ebffc8a6 	bl	34809bb8 <printf>
3481791c:	ea00003a 	b	34817a0c <onenand_scan+0x568>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34817920:	e5950028 	ldr	r0, [r5, #40]	; 0x28

	/* Block lock scheme */
	for (block = start; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817924:	e5951000 	ldr	r1, [r5]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34817928:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
3481792c:	10270000 	eorne	r0, r7, r0
34817930:	13800902 	orrne	r0, r0, #32768	; 0x8000
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34817934:	01a00007 	moveq	r0, r7

	/* Block lock scheme */
	for (block = start; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34817938:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
3481793c:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34817940:	e6ff0070 	uxth	r0, r0
34817944:	e2811c02 	add	r1, r1, #512	; 0x200
34817948:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
3481794c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34817950:	e5952000 	ldr	r2, [r5]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34817954:	e0173003 	ands	r3, r7, r3
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34817958:	e59f1110 	ldr	r1, [pc, #272]	; 34817a70 <onenand_scan+0x5cc>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
3481795c:	01a00003 	moveq	r0, r3
34817960:	13a00902 	movne	r0, #32768	; 0x8000
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34817964:	e0821001 	add	r1, r2, r1
34817968:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
3481796c:	e6ff0070 	uxth	r0, r0
34817970:	e12fff33 	blx	r3

		/* Set start block address */
		this->write_word(block,
34817974:	e5951000 	ldr	r1, [r5]
34817978:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
3481797c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34817980:	e6ff0077 	uxth	r0, r7
34817984:	e2811098 	add	r1, r1, #152	; 0x98
34817988:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
3481798c:	e58d9000 	str	r9, [sp]
34817990:	e3a01023 	mov	r1, #35	; 0x23
34817994:	e3a03000 	mov	r3, #0
34817998:	e595c050 	ldr	ip, [r5, #80]	; 0x50
3481799c:	e1a00006 	mov	r0, r6
348179a0:	e3a02000 	mov	r2, #0
348179a4:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_UNLOCKING);
348179a8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348179ac:	e1a00006 	mov	r0, r6
348179b0:	e3a01007 	mov	r1, #7
348179b4:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
348179b8:	e5950000 	ldr	r0, [r5]
348179bc:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348179c0:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348179c4:	e2800080 	add	r0, r0, #128	; 0x80
348179c8:	e12fff33 	blx	r3
348179cc:	e3100902 	tst	r0, #32768	; 0x8000
348179d0:	1afffff8 	bne	348179b8 <onenand_scan+0x514>
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
348179d4:	e5950000 	ldr	r0, [r5]
348179d8:	e5953068 	ldr	r3, [r5, #104]	; 0x68
348179dc:	e2800b79 	add	r0, r0, #123904	; 0x1e400
348179e0:	e280009c 	add	r0, r0, #156	; 0x9c
348179e4:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
348179e8:	e3100004 	tst	r0, #4
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
348179ec:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US))
348179f0:	1a000002 	bne	34817a00 <onenand_scan+0x55c>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n",
348179f4:	e59f0078 	ldr	r0, [pc, #120]	; 34817a74 <onenand_scan+0x5d0>
348179f8:	e1a01007 	mov	r1, r7
348179fc:	ebffc86d 	bl	34809bb8 <printf>

		return 0;
	}

	/* Block lock scheme */
	for (block = start; block < end; block++) {
34817a00:	e2877001 	add	r7, r7, #1
34817a04:	e157000a 	cmp	r7, sl
34817a08:	baffffc4 	blt	34817920 <onenand_scan+0x47c>
	mtd->ecclayout = this->ecclayout;

	/* Unlock whole block */
	onenand_unlock_all(mtd);

	return this->scan_bbt(mtd);
34817a0c:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
34817a10:	e1a00006 	mov	r0, r6
34817a14:	e12fff33 	blx	r3
34817a18:	ea000000 	b	34817a20 <onenand_scan+0x57c>
			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
			if (this->options & ONENAND_PAGEBUF_ALLOC) {
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
34817a1c:	e3e0000b 	mvn	r0, #11

	/* Unlock whole block */
	onenand_unlock_all(mtd);

	return this->scan_bbt(mtd);
}
34817a20:	e28dd010 	add	sp, sp, #16
34817a24:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34817a28:	34814858 	.word	0x34814858
34817a2c:	34814860 	.word	0x34814860
34817a30:	34815c68 	.word	0x34815c68
34817a34:	3481502c 	.word	0x3481502c
34817a38:	34814f60 	.word	0x34814f60
34817a3c:	34814868 	.word	0x34814868
34817a40:	3481494c 	.word	0x3481494c
34817a44:	34814a30 	.word	0x34814a30
34817a48:	34815af4 	.word	0x34815af4
34817a4c:	34817d44 	.word	0x34817d44
34817a50:	34827e94 	.word	0x34827e94
34817a54:	348148c8 	.word	0x348148c8
34817a58:	34827eb6 	.word	0x34827eb6
34817a5c:	34827edf 	.word	0x34827edf
34817a60:	34829284 	.word	0x34829284
34817a64:	34828df4 	.word	0x34828df4
34817a68:	3482903c 	.word	0x3482903c
34817a6c:	34827f05 	.word	0x34827f05
34817a70:	0001e202 	.word	0x0001e202
34817a74:	34827f2b 	.word	0x34827f2b
34817a78:	34827f37 	.word	0x34827f37

34817a7c <onenand_release>:
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34817a7c:	e12fff1e 	bx	lr

34817a80 <onenand_isbad_bbt>:
 * @param offs		offset in the device
 * @param allowbbt	allow access to bad block table region
 */
static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
34817a80:	e5900094 	ldr	r0, [r0, #148]	; 0x94
 * @param mtd		MTD device structure
 * @param offs		offset in the device
 * @param allowbbt	allow access to bad block table region
 */
static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
34817a84:	e92d4010 	push	{r4, lr}
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34817a88:	e59040a0 	ldr	r4, [r0, #160]	; 0xa0
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int) (onenand_block(this, offs) << 1);
34817a8c:	ebfff7f3 	bl	34815a60 <onenand_block>
	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
34817a90:	e594300c 	ldr	r3, [r4, #12]
	struct bbm_info *bbm = this->bbm;
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int) (onenand_block(this, offs) << 1);
34817a94:	e1a00080 	lsl	r0, r0, #1
	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
34817a98:	e7d331c0 	ldrb	r3, [r3, r0, asr #3]
34817a9c:	e2000006 	and	r0, r0, #6
34817aa0:	e1a00053 	asr	r0, r3, r0

	MTDDEBUG (MTD_DEBUG_LEVEL2,
		"onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
		(unsigned int)offs, block >> 1, res);

	switch ((int)res) {
34817aa4:	e2100003 	ands	r0, r0, #3
34817aa8:	08bd8010 	popeq	{r4, pc}
34817aac:	e3500002 	cmp	r0, #2
34817ab0:	1a000003 	bne	34817ac4 <onenand_isbad_bbt+0x44>
	case 0x00:
		return 0;
	case 0x01:
		return 1;
	case 0x02:
		return allowbbt ? 0 : 1;
34817ab4:	e59d0008 	ldr	r0, [sp, #8]
34817ab8:	e2700001 	rsbs	r0, r0, #1
34817abc:	33a00000 	movcc	r0, #0
34817ac0:	e8bd8010 	pop	{r4, pc}

	switch ((int)res) {
	case 0x00:
		return 0;
	case 0x01:
		return 1;
34817ac4:	e3a00001 	mov	r0, #1
	case 0x02:
		return allowbbt ? 0 : 1;
	}

	return 1;
}
34817ac8:	e8bd8010 	pop	{r4, pc}

34817acc <onenand_memory_bbt>:
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
34817acc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
34817ad0:	e5913000 	ldr	r3, [r1]
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t * buf,
		      struct nand_bbt_descr *bd, int chip)
{
	struct onenand_chip *this = mtd->priv;
34817ad4:	e590a094 	ldr	sl, [r0, #148]	; 0x94
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
34817ad8:	e3c33b02 	bic	r3, r3, #2048	; 0x800
 */
static int create_bbt(struct mtd_info *mtd, uint8_t * buf,
		      struct nand_bbt_descr *bd, int chip)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34817adc:	e59a60a0 	ldr	r6, [sl, #160]	; 0xa0
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
34817ae0:	e24ddd42 	sub	sp, sp, #4224	; 0x1080
34817ae4:	e24dd038 	sub	sp, sp, #56	; 0x38
34817ae8:	e1a05001 	mov	r5, r1
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
34817aec:	e5813000 	str	r3, [r1]
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
34817af0:	e1a07000 	mov	r7, r0
	loff_t from;
	size_t readlen, ooblen;
	struct mtd_oob_ops ops;
	int rgn;

	printk(KERN_INFO "Scanning device for bad blocks\n");
34817af4:	e59f018c 	ldr	r0, [pc, #396]	; 34817c88 <onenand_memory_bbt+0x1bc>
34817af8:	ebffc82e 	bl	34809bb8 <printf>

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817afc:	e5969000 	ldr	r9, [r6]

	len = 1;

	/* We need only read few bytes from the OOB area */
	scanlen = ooblen = 0;
	readlen = bd->len;
34817b00:	e5953014 	ldr	r3, [r5, #20]
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
34817b04:	e28d0a01 	add	r0, sp, #4096	; 0x1000

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817b08:	e59a2018 	ldr	r2, [sl, #24]
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
34817b0c:	e58030a4 	str	r3, [r0, #164]	; 0xa4

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817b10:	e2499001 	sub	r9, r9, #1
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
34817b14:	e28d3038 	add	r3, sp, #56	; 0x38
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
34817b18:	e3a04000 	mov	r4, #0

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
34817b1c:	e1a09932 	lsr	r9, r2, r9
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
34817b20:	e2432020 	sub	r2, r3, #32
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
34817b24:	e5804098 	str	r4, [r0, #152]	; 0x98
	ops.ooblen = readlen;
	ops.oobbuf = buf;
34817b28:	e58020b4 	str	r2, [r0, #180]	; 0xb4
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;
34817b2c:	e58040a8 	str	r4, [r0, #168]	; 0xa8
34817b30:	e58040a0 	str	r4, [r0, #160]	; 0xa0
34817b34:	e58040ac 	str	r4, [r0, #172]	; 0xac
34817b38:	e580409c 	str	r4, [r0, #156]	; 0x9c
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;
34817b3c:	e3a01000 	mov	r1, #0
34817b40:	e3a00000 	mov	r0, #0
34817b44:	e1cd01f0 	strd	r0, [sp, #16]
34817b48:	e1a0c00a 	mov	ip, sl
34817b4c:	ea000045 	b	34817c68 <onenand_memory_bbt+0x19c>
		int ret;

		for (j = 0; j < len; j++) {
			/* No need to read pages fully,
			 * just read required OOB bytes */
			ret = onenand_bbt_read_oob(mtd,
34817b50:	e5952008 	ldr	r2, [r5, #8]
34817b54:	e1cda1d0 	ldrd	sl, [sp, #16]
34817b58:	e09aa002 	adds	sl, sl, r2
34817b5c:	e0abbfc2 	adc	fp, fp, r2, asr #31
34817b60:	e28d1d42 	add	r1, sp, #4224	; 0x1080
34817b64:	e2811018 	add	r1, r1, #24
34817b68:	e1a00007 	mov	r0, r7
34817b6c:	e1a0200a 	mov	r2, sl
34817b70:	e1a0300b 	mov	r3, fp
34817b74:	e58dc00c 	str	ip, [sp, #12]
34817b78:	e58d1000 	str	r1, [sp]
34817b7c:	ebfffbdc 	bl	34816af4 <onenand_bbt_read_oob>
					     from + j * mtd->writesize +
					     bd->offs, &ops);

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
34817b80:	e3500004 	cmp	r0, #4
34817b84:	e59dc00c 	ldr	ip, [sp, #12]
34817b88:	0a00003a 	beq	34817c78 <onenand_memory_bbt+0x1ac>
				return -EIO;

			if (ret || check_short_pattern
34817b8c:	e3500000 	cmp	r0, #0
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
34817b90:	05953014 	ldreq	r3, [r5, #20]
34817b94:	01a0a00c 	moveq	sl, ip

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;

			if (ret || check_short_pattern
34817b98:	0a000008 	beq	34817bc0 <onenand_memory_bbt+0xf4>
34817b9c:	ea00000c 	b	34817bd4 <onenand_memory_bbt+0x108>
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
		if (p[i] != td->pattern[i])
34817ba0:	e28db038 	add	fp, sp, #56	; 0x38
34817ba4:	e5952020 	ldr	r2, [r5, #32]
34817ba8:	e24b1020 	sub	r1, fp, #32
34817bac:	e7d11000 	ldrb	r1, [r1, r0]
34817bb0:	e7d22000 	ldrb	r2, [r2, r0]
34817bb4:	e1510002 	cmp	r1, r2
34817bb8:	1a000004 	bne	34817bd0 <onenand_memory_bbt+0x104>
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
34817bbc:	e2800001 	add	r0, r0, #1
34817bc0:	e1500003 	cmp	r0, r3
34817bc4:	bafffff5 	blt	34817ba0 <onenand_memory_bbt+0xd4>
34817bc8:	e1a0c00a 	mov	ip, sl
34817bcc:	ea00000c 	b	34817c04 <onenand_memory_bbt+0x138>
34817bd0:	e1a0c00a 	mov	ip, sl
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;

			if (ret || check_short_pattern
			    (&buf[j * scanlen], scanlen, mtd->writesize, bd)) {
				bbm->bbt[i >> 3] |= 0x03 << (i & 0x6);
34817bd4:	e596300c 	ldr	r3, [r6, #12]
34817bd8:	e2041006 	and	r1, r4, #6
34817bdc:	e7d321c4 	ldrb	r2, [r3, r4, asr #3]
34817be0:	e3a00003 	mov	r0, #3
34817be4:	e1822110 	orr	r2, r2, r0, lsl r1
34817be8:	e7c321c4 	strb	r2, [r3, r4, asr #3]
				printk(KERN_WARNING
34817bec:	e59f0098 	ldr	r0, [pc, #152]	; 34817c8c <onenand_memory_bbt+0x1c0>
34817bf0:	e1a010c4 	asr	r1, r4, #1
34817bf4:	e59d2010 	ldr	r2, [sp, #16]
34817bf8:	e58dc00c 	str	ip, [sp, #12]
34817bfc:	ebffc7ed 	bl	34809bb8 <printf>
34817c00:	e59dc00c 	ldr	ip, [sp, #12]
				break;
			}
		}
		i += 2;

		if (FLEXONENAND(this)) {
34817c04:	e59c301c 	ldr	r3, [ip, #28]
				       "Bad eraseblock %d at 0x%08x\n", i >> 1,
				       (unsigned int)from);
				break;
			}
		}
		i += 2;
34817c08:	e2844002 	add	r4, r4, #2

		if (FLEXONENAND(this)) {
34817c0c:	e3130c02 	tst	r3, #512	; 0x200
34817c10:	0a00000d 	beq	34817c4c <onenand_memory_bbt+0x180>
			rgn = flexonenand_region(mtd, from);
34817c14:	e1cd21d0 	ldrd	r2, [sp, #16]
34817c18:	e1a00007 	mov	r0, r7
34817c1c:	e58dc00c 	str	ip, [sp, #12]
34817c20:	ebfff8a1 	bl	34815eac <flexonenand_region>
			from += mtd->eraseregions[rgn].erasesize;
34817c24:	e1cda1d0 	ldrd	sl, [sp, #16]
34817c28:	e5973030 	ldr	r3, [r7, #48]	; 0x30
34817c2c:	e3a01018 	mov	r1, #24
34817c30:	e0233091 	mla	r3, r1, r0, r3
34817c34:	e5933008 	ldr	r3, [r3, #8]
34817c38:	e59dc00c 	ldr	ip, [sp, #12]
34817c3c:	e09aa003 	adds	sl, sl, r3
34817c40:	e2abb000 	adc	fp, fp, #0
34817c44:	e1cda1f0 	strd	sl, [sp, #16]
34817c48:	ea000006 	b	34817c68 <onenand_memory_bbt+0x19c>
		} else
			from += (1 << bbm->bbt_erase_shift);
34817c4c:	e5963000 	ldr	r3, [r6]
34817c50:	e3a0b001 	mov	fp, #1
34817c54:	e1a0331b 	lsl	r3, fp, r3
34817c58:	e1cd01d0 	ldrd	r0, [sp, #16]
34817c5c:	e0900003 	adds	r0, r0, r3
34817c60:	e0a11fc3 	adc	r1, r1, r3, asr #31
34817c64:	e1cd01f0 	strd	r0, [sp, #16]
	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;

	for (i = startblock; i < numblocks;) {
34817c68:	e1540009 	cmp	r4, r9
34817c6c:	baffffb7 	blt	34817b50 <onenand_memory_bbt+0x84>
			from += mtd->eraseregions[rgn].erasesize;
		} else
			from += (1 << bbm->bbt_erase_shift);
	}

	return 0;
34817c70:	e3a00000 	mov	r0, #0
34817c74:	ea000000 	b	34817c7c <onenand_memory_bbt+0x1b0>
					     from + j * mtd->writesize +
					     bd->offs, &ops);

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;
34817c78:	e3e00004 	mvn	r0, #4
{
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
	return create_bbt(mtd, data_buf, bd, -1);
}
34817c7c:	e28dd0b8 	add	sp, sp, #184	; 0xb8
34817c80:	e28dda01 	add	sp, sp, #4096	; 0x1000
34817c84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34817c88:	34827f49 	.word	0x34827f49
34817c8c:	34827f69 	.word	0x34827f69

34817c90 <onenand_scan_bbt>:
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
34817c90:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
34817c94:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
34817c98:	e1a06000 	mov	r6, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
34817c9c:	e595a030 	ldr	sl, [r5, #48]	; 0x30
34817ca0:	e5953018 	ldr	r3, [r5, #24]
34817ca4:	e28aa002 	add	sl, sl, #2
34817ca8:	e1a0aa33 	lsr	sl, r3, sl
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
34817cac:	e1a0000a 	mov	r0, sl
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34817cb0:	e59540a0 	ldr	r4, [r5, #160]	; 0xa0
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
34817cb4:	e1a07001 	mov	r7, r1
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
34817cb8:	ebffc985 	bl	3480a2d4 <malloc>
	if (!bbm->bbt) {
34817cbc:	e3500000 	cmp	r0, #0
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
34817cc0:	e584000c 	str	r0, [r4, #12]
	if (!bbm->bbt) {
34817cc4:	1a000003 	bne	34817cd8 <onenand_scan_bbt+0x48>
		printk(KERN_ERR "onenand_scan_bbt: Out of memory\n");
34817cc8:	e59f0068 	ldr	r0, [pc, #104]	; 34817d38 <onenand_scan_bbt+0xa8>
34817ccc:	ebffc7b9 	bl	34809bb8 <printf>
		return -ENOMEM;
34817cd0:	e3e0500b 	mvn	r5, #11
34817cd4:	ea000015 	b	34817d30 <onenand_scan_bbt+0xa0>
	}
	/* Clear the memory bad block table */
	memset(bbm->bbt, 0x00, len);
34817cd8:	e3a01000 	mov	r1, #0
34817cdc:	e1a0200a 	mov	r2, sl
34817ce0:	eb001305 	bl	3481c8fc <memset>

	/* Set the bad block position */
	bbm->badblockpos = ONENAND_BADBLOCK_POS;
34817ce4:	e3a03000 	mov	r3, #0
34817ce8:	e5843004 	str	r3, [r4, #4]

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;
34817cec:	e5953030 	ldr	r3, [r5, #48]	; 0x30

	if (!bbm->isbad_bbt)
		bbm->isbad_bbt = onenand_isbad_bbt;

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
34817cf0:	e1a00006 	mov	r0, r6

	/* Set the bad block position */
	bbm->badblockpos = ONENAND_BADBLOCK_POS;

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;
34817cf4:	e5843000 	str	r3, [r4]

	if (!bbm->isbad_bbt)
34817cf8:	e5943010 	ldr	r3, [r4, #16]
		bbm->isbad_bbt = onenand_isbad_bbt;

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
34817cfc:	e1a01007 	mov	r1, r7
	bbm->badblockpos = ONENAND_BADBLOCK_POS;

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;

	if (!bbm->isbad_bbt)
34817d00:	e3530000 	cmp	r3, #0
		bbm->isbad_bbt = onenand_isbad_bbt;
34817d04:	059f3030 	ldreq	r3, [pc, #48]	; 34817d3c <onenand_scan_bbt+0xac>
34817d08:	05843010 	streq	r3, [r4, #16]

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
34817d0c:	ebffff6e 	bl	34817acc <onenand_memory_bbt>
34817d10:	e2505000 	subs	r5, r0, #0
34817d14:	0a000005 	beq	34817d30 <onenand_scan_bbt+0xa0>
		printk(KERN_ERR
34817d18:	e59f0020 	ldr	r0, [pc, #32]	; 34817d40 <onenand_scan_bbt+0xb0>
34817d1c:	ebffc7a5 	bl	34809bb8 <printf>
		       "onenand_scan_bbt: Can't scan flash and build the RAM-based BBT\n");
		free(bbm->bbt);
34817d20:	e594000c 	ldr	r0, [r4, #12]
34817d24:	ebffc8e1 	bl	3480a0b0 <free>
		bbm->bbt = NULL;
34817d28:	e3a03000 	mov	r3, #0
34817d2c:	e584300c 	str	r3, [r4, #12]
	}

	return ret;
}
34817d30:	e1a00005 	mov	r0, r5
34817d34:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34817d38:	34827f86 	.word	0x34827f86
34817d3c:	34817a80 	.word	0x34817a80
34817d40:	34827fa7 	.word	0x34827fa7

34817d44 <onenand_default_bbt>:
 *
 * This function selects the default bad block table
 * support for the device and calls the onenand_scan_bbt function
 */
int onenand_default_bbt(struct mtd_info *mtd)
{
34817d44:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34817d48:	e5906094 	ldr	r6, [r0, #148]	; 0x94
 *
 * This function selects the default bad block table
 * support for the device and calls the onenand_scan_bbt function
 */
int onenand_default_bbt(struct mtd_info *mtd)
{
34817d4c:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm;

	this->bbm = malloc(sizeof(struct bbm_info));
34817d50:	e3a0001c 	mov	r0, #28
34817d54:	ebffc95e 	bl	3480a2d4 <malloc>
	if (!this->bbm)
34817d58:	e3500000 	cmp	r0, #0
int onenand_default_bbt(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm;

	this->bbm = malloc(sizeof(struct bbm_info));
34817d5c:	e1a04000 	mov	r4, r0
34817d60:	e58600a0 	str	r0, [r6, #160]	; 0xa0
	if (!this->bbm)
34817d64:	0a00000a 	beq	34817d94 <onenand_default_bbt+0x50>
		return -ENOMEM;

	bbm = this->bbm;

	memset(bbm, 0, sizeof(struct bbm_info));
34817d68:	e3a01000 	mov	r1, #0
34817d6c:	e3a0201c 	mov	r2, #28
34817d70:	eb0012e1 	bl	3481c8fc <memset>

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
34817d74:	e5943014 	ldr	r3, [r4, #20]
		bbm->badblock_pattern = &largepage_memorybased;

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817d78:	e1a00005 	mov	r0, r5
	bbm = this->bbm;

	memset(bbm, 0, sizeof(struct bbm_info));

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
34817d7c:	e3530000 	cmp	r3, #0
		bbm->badblock_pattern = &largepage_memorybased;
34817d80:	059f3014 	ldreq	r3, [pc, #20]	; 34817d9c <onenand_default_bbt+0x58>
34817d84:	05843014 	streq	r3, [r4, #20]

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817d88:	e5941014 	ldr	r1, [r4, #20]
}
34817d8c:	e8bd4070 	pop	{r4, r5, r6, lr}

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
		bbm->badblock_pattern = &largepage_memorybased;

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817d90:	eaffffbe 	b	34817c90 <onenand_scan_bbt>
}
34817d94:	e3e0000b 	mvn	r0, #11
34817d98:	e8bd8070 	pop	{r4, r5, r6, pc}
34817d9c:	348294cc 	.word	0x348294cc

34817da0 <s3c_read_cmd>:

static struct s3c_onenand *onenand;

static int s3c_read_cmd(unsigned int cmd)
{
	return readl(onenand->ahb_addr + cmd);
34817da0:	e59f300c 	ldr	r3, [pc, #12]	; 34817db4 <s3c_read_cmd+0x14>
34817da4:	e5933000 	ldr	r3, [r3]
34817da8:	e5933008 	ldr	r3, [r3, #8]
34817dac:	e7930000 	ldr	r0, [r3, r0]
}
34817db0:	e12fff1e 	bx	lr
34817db4:	3482beb8 	.word	0x3482beb8

34817db8 <s3c_write_cmd>:

static void s3c_write_cmd(int value, unsigned int cmd)
{
	writel(value, onenand->ahb_addr + cmd);
34817db8:	e59f300c 	ldr	r3, [pc, #12]	; 34817dcc <s3c_write_cmd+0x14>
34817dbc:	e5933000 	ldr	r3, [r3]
34817dc0:	e5933008 	ldr	r3, [r3, #8]
34817dc4:	e7830001 	str	r0, [r3, r1]
}
34817dc8:	e12fff1e 	bx	lr
34817dcc:	3482beb8 	.word	0x3482beb8

34817dd0 <s3c_mem_addr>:
	return (fba << 12) | (fpa << 6) | (fsa << 4);
}
#elif defined(CONFIG_S5P)
static unsigned int s3c_mem_addr(int fba, int fpa, int fsa)
{
	return (fba << 13) | (fpa << 7) | (fsa << 5);
34817dd0:	e1a00680 	lsl	r0, r0, #13
34817dd4:	e1800381 	orr	r0, r0, r1, lsl #7
}
34817dd8:	e1800282 	orr	r0, r0, r2, lsl #5
34817ddc:	e12fff1e 	bx	lr

34817de0 <s3c_onenand_reset>:
static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
34817de0:	e59f206c 	ldr	r2, [pc, #108]	; 34817e54 <s3c_onenand_reset+0x74>
34817de4:	e3a01002 	mov	r1, #2
34817de8:	e5923000 	ldr	r3, [r2]
34817dec:	e593301c 	ldr	r3, [r3, #28]
34817df0:	e5831020 	str	r1, [r3, #32]
}
#endif

static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
34817df4:	e3a03801 	mov	r3, #65536	; 0x10000
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
34817df8:	ea000004 	b	34817e10 <s3c_onenand_reset+0x30>
		stat = readl(&onenand->reg->int_err_stat);
34817dfc:	e5921000 	ldr	r1, [r2]
34817e00:	e591101c 	ldr	r1, [r1, #28]
34817e04:	e5911030 	ldr	r1, [r1, #48]	; 0x30
		if (stat & RST_CMP)
34817e08:	e3110a01 	tst	r1, #4096	; 0x1000
34817e0c:	1a000001 	bne	34817e18 <s3c_onenand_reset+0x38>
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
34817e10:	e2533001 	subs	r3, r3, #1
34817e14:	2afffff8 	bcs	34817dfc <s3c_onenand_reset+0x1c>
		stat = readl(&onenand->reg->int_err_stat);
		if (stat & RST_CMP)
			break;
	}
	stat = readl(&onenand->reg->int_err_stat);
34817e18:	e59f3034 	ldr	r3, [pc, #52]	; 34817e54 <s3c_onenand_reset+0x74>
34817e1c:	e5932000 	ldr	r2, [r3]
34817e20:	e592201c 	ldr	r2, [r2, #28]
34817e24:	e5921030 	ldr	r1, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34817e28:	e5932000 	ldr	r2, [r3]
34817e2c:	e592201c 	ldr	r2, [r2, #28]
34817e30:	e5821050 	str	r1, [r2, #80]	; 0x50

	/* Clear interrupt */
	writel(0x0, &onenand->reg->int_err_ack);
34817e34:	e5932000 	ldr	r2, [r3]
34817e38:	e592101c 	ldr	r1, [r2, #28]
34817e3c:	e3a02000 	mov	r2, #0
34817e40:	e5812050 	str	r2, [r1, #80]	; 0x50
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
34817e44:	e5933000 	ldr	r3, [r3]
34817e48:	e593301c 	ldr	r3, [r3, #28]
34817e4c:	e5832060 	str	r2, [r3, #96]	; 0x60
}
34817e50:	e12fff1e 	bx	lr
34817e54:	3482beb8 	.word	0x3482beb8

34817e58 <s3c_onenand_command>:
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
34817e58:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34817e5c:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
34817e60:	e1cd20f0 	strd	r2, [sp]
34817e64:	e1a04001 	mov	r4, r1
34817e68:	e1a05000 	mov	r5, r0
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
34817e6c:	e1a01003 	mov	r1, r3
34817e70:	e1a00002 	mov	r0, r2
34817e74:	e5962034 	ldr	r2, [r6, #52]	; 0x34
34817e78:	eb002125 	bl	34820314 <__ashrdi3>
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817e7c:	e59f3230 	ldr	r3, [pc, #560]	; 348180b4 <s3c_onenand_command+0x25c>
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
34817e80:	e596703c 	ldr	r7, [r6, #60]	; 0x3c

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817e84:	e593a000 	ldr	sl, [r3]
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
34817e88:	e0077000 	and	r7, r7, r0
	int fba, fpa, fsa = 0;
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
34817e8c:	e5962030 	ldr	r2, [r6, #48]	; 0x30
34817e90:	e1cd00d0 	ldrd	r0, [sp]
34817e94:	eb00211e 	bl	34820314 <__ashrdi3>
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817e98:	e1a01007 	mov	r1, r7
34817e9c:	e59a3018 	ldr	r3, [sl, #24]
34817ea0:	e3a02000 	mov	r2, #0
34817ea4:	e12fff33 	blx	r3

	switch (cmd) {
34817ea8:	e3540013 	cmp	r4, #19

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817eac:	e1a07000 	mov	r7, r0

	switch (cmd) {
34817eb0:	0a000004 	beq	34817ec8 <s3c_onenand_command+0x70>
34817eb4:	e3013978 	movw	r3, #6520	; 0x1978
34817eb8:	e1540003 	cmp	r4, r3
34817ebc:	0a000001 	beq	34817ec8 <s3c_onenand_command+0x70>
34817ec0:	e3540000 	cmp	r4, #0
34817ec4:	1a000002 	bne	34817ed4 <s3c_onenand_command+0x7c>
	case ONENAND_CMD_READ:
	case ONENAND_CMD_READOOB:
	case ONENAND_CMD_BUFFERRAM:
		ONENAND_SET_NEXT_BUFFERRAM(this);
34817ec8:	e5963044 	ldr	r3, [r6, #68]	; 0x44
34817ecc:	e2233001 	eor	r3, r3, #1
34817ed0:	e5863044 	str	r3, [r6, #68]	; 0x44
	index = ONENAND_CURRENT_BUFFERRAM(this);

	/*
	 * Emulate Two BufferRAMs and access with 4 bytes pointer
	 */
	m = (unsigned int *) onenand->page_buf;
34817ed4:	e59f31d8 	ldr	r3, [pc, #472]	; 348180b4 <s3c_onenand_command+0x25c>
34817ed8:	e5933000 	ldr	r3, [r3]
34817edc:	e593a010 	ldr	sl, [r3, #16]
	s = (unsigned int *) onenand->oob_buf;
34817ee0:	e5939014 	ldr	r9, [r3, #20]

	if (index) {
34817ee4:	e5963044 	ldr	r3, [r6, #68]	; 0x44
34817ee8:	e3530000 	cmp	r3, #0
34817eec:	0a000005 	beq	34817f08 <s3c_onenand_command+0xb0>
		m += (this->writesize >> 2);
34817ef0:	e5963040 	ldr	r3, [r6, #64]	; 0x40
34817ef4:	e3c33003 	bic	r3, r3, #3
34817ef8:	e08aa003 	add	sl, sl, r3
		s += (mtd->oobsize >> 2);
34817efc:	e5953018 	ldr	r3, [r5, #24]
34817f00:	e3c33003 	bic	r3, r3, #3
34817f04:	e0899003 	add	r9, r9, r3
	}

	mcount = mtd->writesize >> 2;
34817f08:	e5956014 	ldr	r6, [r5, #20]
	scount = mtd->oobsize >> 2;
34817f0c:	e5955018 	ldr	r5, [r5, #24]

	switch (cmd) {
34817f10:	e3540027 	cmp	r4, #39	; 0x27
	if (index) {
		m += (this->writesize >> 2);
		s += (mtd->oobsize >> 2);
	}

	mcount = mtd->writesize >> 2;
34817f14:	e1a06126 	lsr	r6, r6, #2
	scount = mtd->oobsize >> 2;
34817f18:	e1a05125 	lsr	r5, r5, #2

	switch (cmd) {
34817f1c:	0a000059 	beq	34818088 <s3c_onenand_command+0x230>
34817f20:	ca000007 	bgt	34817f44 <s3c_onenand_command+0xec>
34817f24:	e3540013 	cmp	r4, #19
34817f28:	0a00001a 	beq	34817f98 <s3c_onenand_command+0x140>
34817f2c:	e354001a 	cmp	r4, #26
34817f30:	0a000037 	beq	34818014 <s3c_onenand_command+0x1bc>
34817f34:	e3540000 	cmp	r4, #0
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817f38:	03877301 	orreq	r7, r7, #67108864	; 0x4000000
	}

	mcount = mtd->writesize >> 2;
	scount = mtd->oobsize >> 2;

	switch (cmd) {
34817f3c:	0a000012 	beq	34817f8c <s3c_onenand_command+0x134>
34817f40:	ea000059 	b	348180ac <s3c_onenand_command+0x254>
34817f44:	e3540080 	cmp	r4, #128	; 0x80
34817f48:	0a000008 	beq	34817f70 <s3c_onenand_command+0x118>
34817f4c:	ca000002 	bgt	34817f5c <s3c_onenand_command+0x104>
34817f50:	e3540071 	cmp	r4, #113	; 0x71
34817f54:	1a000054 	bne	348180ac <s3c_onenand_command+0x254>
34817f58:	ea000050 	b	348180a0 <s3c_onenand_command+0x248>
34817f5c:	e3540094 	cmp	r4, #148	; 0x94
34817f60:	0a00004a 	beq	34818090 <s3c_onenand_command+0x238>
34817f64:	e3540095 	cmp	r4, #149	; 0x95
34817f68:	1a00004f 	bne	348180ac <s3c_onenand_command+0x254>
34817f6c:	ea000049 	b	34818098 <s3c_onenand_command+0x240>
34817f70:	e3a04000 	mov	r4, #0
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34817f74:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34817f78:	ea000022 	b	34818008 <s3c_onenand_command+0x1b0>

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817f7c:	e1a00007 	mov	r0, r7
34817f80:	ebffff86 	bl	34817da0 <s3c_read_cmd>
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
34817f84:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817f88:	e48a0004 	str	r0, [sl], #4
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
34817f8c:	e1540006 	cmp	r4, r6
34817f90:	bafffff9 	blt	34817f7c <s3c_onenand_command+0x124>
34817f94:	ea000044 	b	348180ac <s3c_onenand_command+0x254>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817f98:	e59f3114 	ldr	r3, [pc, #276]	; 348180b4 <s3c_onenand_command+0x25c>
34817f9c:	e3a02001 	mov	r2, #1
34817fa0:	e5933000 	ldr	r3, [r3]
		/* Main */
		for (i = 0; i < mcount; i++)
34817fa4:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817fa8:	e593301c 	ldr	r3, [r3, #28]
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817fac:	e387b301 	orr	fp, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817fb0:	e5832140 	str	r2, [r3, #320]	; 0x140
		/* Main */
		for (i = 0; i < mcount; i++)
34817fb4:	ea000003 	b	34817fc8 <s3c_onenand_command+0x170>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817fb8:	e1a0000b 	mov	r0, fp
34817fbc:	ebffff77 	bl	34817da0 <s3c_read_cmd>
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34817fc0:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817fc4:	e48a0004 	str	r0, [sl], #4
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34817fc8:	e1540006 	cmp	r4, r6
34817fcc:	bafffff9 	blt	34817fb8 <s3c_onenand_command+0x160>
34817fd0:	e3a04000 	mov	r4, #0
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817fd4:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34817fd8:	ea000003 	b	34817fec <s3c_onenand_command+0x194>
34817fdc:	e1a00007 	mov	r0, r7
34817fe0:	ebffff6e 	bl	34817da0 <s3c_read_cmd>
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34817fe4:	e2844001 	add	r4, r4, #1
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817fe8:	e4890004 	str	r0, [r9], #4
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34817fec:	e1540005 	cmp	r4, r5
34817ff0:	bafffff9 	blt	34817fdc <s3c_onenand_command+0x184>
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
34817ff4:	ea00001d 	b	34818070 <s3c_onenand_command+0x218>
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34817ff8:	e49a0004 	ldr	r0, [sl], #4
34817ffc:	e1a01007 	mov	r1, r7
34818000:	ebffff6c 	bl	34817db8 <s3c_write_cmd>
		writel(0, &onenand->reg->trans_spare);
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
34818004:	e2844001 	add	r4, r4, #1
34818008:	e1540006 	cmp	r4, r6
3481800c:	bafffff9 	blt	34817ff8 <s3c_onenand_command+0x1a0>
34818010:	ea000025 	b	348180ac <s3c_onenand_command+0x254>
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34818014:	e59f3098 	ldr	r3, [pc, #152]	; 348180b4 <s3c_onenand_command+0x25c>
34818018:	e3a02001 	mov	r2, #1
3481801c:	e5933000 	ldr	r3, [r3]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34818020:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34818024:	e593301c 	ldr	r3, [r3, #28]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34818028:	e387a301 	orr	sl, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
3481802c:	e5832140 	str	r2, [r3, #320]	; 0x140

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34818030:	ea000003 	b	34818044 <s3c_onenand_command+0x1ec>
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34818034:	e3e00000 	mvn	r0, #0
34818038:	e1a0100a 	mov	r1, sl
3481803c:	ebffff5d 	bl	34817db8 <s3c_write_cmd>

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34818040:	e2844001 	add	r4, r4, #1
34818044:	e1540006 	cmp	r4, r6
34818048:	bafffff9 	blt	34818034 <s3c_onenand_command+0x1dc>
3481804c:	e3a04000 	mov	r4, #0
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));
34818050:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34818054:	ea000003 	b	34818068 <s3c_onenand_command+0x210>
34818058:	e4990004 	ldr	r0, [r9], #4
3481805c:	e1a01007 	mov	r1, r7
34818060:	ebffff54 	bl	34817db8 <s3c_write_cmd>
		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34818064:	e2844001 	add	r4, r4, #1
34818068:	e1540005 	cmp	r4, r5
3481806c:	bafffff9 	blt	34818058 <s3c_onenand_command+0x200>
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
34818070:	e59f303c 	ldr	r3, [pc, #60]	; 348180b4 <s3c_onenand_command+0x25c>
34818074:	e3a02000 	mov	r2, #0
34818078:	e5933000 	ldr	r3, [r3]
3481807c:	e593301c 	ldr	r3, [r3, #28]
34818080:	e5832140 	str	r2, [r3, #320]	; 0x140
		return 0;
34818084:	ea000008 	b	348180ac <s3c_onenand_command+0x254>

	case ONENAND_CMD_UNLOCK_ALL:
		s3c_write_cmd(ONENAND_UNLOCK_ALL, CMD_MAP_10(mem_addr));
34818088:	e3a0000e 	mov	r0, #14
3481808c:	ea000004 	b	348180a4 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE:
		s3c_write_cmd(ONENAND_ERASE_START, CMD_MAP_10(mem_addr));
34818090:	e3a00003 	mov	r0, #3
34818094:	ea000002 	b	348180a4 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_MULTIBLOCK_ERASE:
		s3c_write_cmd(ONENAND_MULTI_ERASE_SET, CMD_MAP_10(mem_addr));
34818098:	e3a00001 	mov	r0, #1
3481809c:	ea000000 	b	348180a4 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE_VERIFY:
		s3c_write_cmd(ONENAND_ERASE_VERIFY, CMD_MAP_10(mem_addr));
348180a0:	e3a00015 	mov	r0, #21
348180a4:	e3871302 	orr	r1, r7, #134217728	; 0x8000000
348180a8:	ebffff42 	bl	34817db8 <s3c_write_cmd>
	default:
		break;
	}

	return 0;
}
348180ac:	e3a00000 	mov	r0, #0
348180b0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348180b4:	3482beb8 	.word	0x3482beb8

348180b8 <s3c_get_bufferram>:

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;
348180b8:	e590c094 	ldr	ip, [r0, #148]	; 0x94
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
348180bc:	e3510b01 	cmp	r1, #1024	; 0x400

	return 0;
}

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
348180c0:	e1a03000 	mov	r3, r0
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
348180c4:	e59c2044 	ldr	r2, [ip, #68]	; 0x44
348180c8:	e59f1030 	ldr	r1, [pc, #48]	; 34818100 <s3c_get_bufferram+0x48>
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
348180cc:	1a000005 	bne	348180e8 <s3c_get_bufferram+0x30>
		p = (unsigned char *) onenand->page_buf;
348180d0:	e5913000 	ldr	r3, [r1]
		if (index == 1)
348180d4:	e3520001 	cmp	r2, #1
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
348180d8:	e5930010 	ldr	r0, [r3, #16]
		if (index == 1)
			p += this->writesize;
348180dc:	059c3040 	ldreq	r3, [ip, #64]	; 0x40
348180e0:	00800003 	addeq	r0, r0, r3
348180e4:	e12fff1e 	bx	lr
	} else {
		p = (unsigned char *) onenand->oob_buf;
348180e8:	e5911000 	ldr	r1, [r1]
		if (index == 1)
348180ec:	e3520001 	cmp	r2, #1
	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
		if (index == 1)
			p += this->writesize;
	} else {
		p = (unsigned char *) onenand->oob_buf;
348180f0:	e5910014 	ldr	r0, [r1, #20]
		if (index == 1)
			p += mtd->oobsize;
348180f4:	05933018 	ldreq	r3, [r3, #24]
348180f8:	00800003 	addeq	r0, r0, r3
	}

	return p;
}
348180fc:	e12fff1e 	bx	lr
34818100:	3482beb8 	.word	0x3482beb8

34818104 <s3c_onenand_bbt_wait>:
	memcpy(p + offset, buffer, count);
	return 0;
}

static int s3c_onenand_bbt_wait(struct mtd_info *mtd, int state)
{
34818104:	e92d4008 	push	{r3, lr}
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
34818108:	e59f3078 	ldr	r3, [pc, #120]	; 34818188 <s3c_onenand_bbt_wait+0x84>
3481810c:	e5933000 	ldr	r3, [r3]
34818110:	e5932004 	ldr	r2, [r3, #4]
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;
34818114:	e3a03801 	mov	r3, #65536	; 0x10000

	while (timeout--) {
34818118:	ea000002 	b	34818128 <s3c_onenand_bbt_wait+0x24>
		stat = readl(&reg->int_err_stat);
3481811c:	e5921030 	ldr	r1, [r2, #48]	; 0x30
		if (stat & flags)
34818120:	e3110e41 	tst	r1, #1040	; 0x410
34818124:	1a000001 	bne	34818130 <s3c_onenand_bbt_wait+0x2c>
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;

	while (timeout--) {
34818128:	e2533001 	subs	r3, r3, #1
3481812c:	2afffffa 	bcs	3481811c <s3c_onenand_bbt_wait+0x18>
		stat = readl(&reg->int_err_stat);
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
34818130:	e59f3050 	ldr	r3, [pc, #80]	; 34818188 <s3c_onenand_bbt_wait+0x84>
34818134:	e5932000 	ldr	r2, [r3]
34818138:	e592201c 	ldr	r2, [r2, #28]
3481813c:	e5920030 	ldr	r0, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34818140:	e5933000 	ldr	r3, [r3]

	if (stat & LD_FAIL_ECC_ERR) {
34818144:	e3100001 	tst	r0, #1
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34818148:	e593301c 	ldr	r3, [r3, #28]
3481814c:	e5830050 	str	r0, [r3, #80]	; 0x50

	if (stat & LD_FAIL_ECC_ERR) {
34818150:	0a000002 	beq	34818160 <s3c_onenand_bbt_wait+0x5c>
		s3c_onenand_reset();
34818154:	ebffff21 	bl	34817de0 <s3c_onenand_reset>
		return ONENAND_BBT_READ_ERROR;
34818158:	e3a00001 	mov	r0, #1
3481815c:	e8bd8008 	pop	{r3, pc}
	}

	if (stat & LOAD_CMP) {
34818160:	e2100010 	ands	r0, r0, #16
34818164:	08bd8008 	popeq	{r3, pc}
		int ecc = readl(&onenand->reg->ecc_err_stat);
34818168:	e5933060 	ldr	r3, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
3481816c:	e3010010 	movw	r0, #4112	; 0x1010
34818170:	e0030000 	and	r0, r3, r0
34818174:	e3500000 	cmp	r0, #0
34818178:	08bd8008 	popeq	{r3, pc}
			s3c_onenand_reset();
3481817c:	ebffff17 	bl	34817de0 <s3c_onenand_reset>
			return ONENAND_BBT_READ_ERROR;
34818180:	e3a00001 	mov	r0, #1
		}
	}

	return 0;
}
34818184:	e8bd8008 	pop	{r3, pc}
34818188:	3482beb8 	.word	0x3482beb8

3481818c <onenand_write_bufferram>:
}

static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
3481818c:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
34818190:	e59d1008 	ldr	r1, [sp, #8]
34818194:	ebffffc7 	bl	348180b8 <s3c_get_bufferram>
	memcpy(p + offset, buffer, count);
34818198:	e59d3010 	ldr	r3, [sp, #16]
3481819c:	e59d100c 	ldr	r1, [sp, #12]
348181a0:	e0800003 	add	r0, r0, r3
348181a4:	e59d2014 	ldr	r2, [sp, #20]
348181a8:	eb0011f7 	bl	3481c98c <memcpy>
	return 0;
}
348181ac:	e3a00000 	mov	r0, #0
348181b0:	e8bd8008 	pop	{r3, pc}

348181b4 <onenand_read_bufferram>:
}

static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
348181b4:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
348181b8:	e59d1008 	ldr	r1, [sp, #8]
348181bc:	ebffffbd 	bl	348180b8 <s3c_get_bufferram>
	memcpy(buffer, p + offset, count);
348181c0:	e59d1010 	ldr	r1, [sp, #16]
348181c4:	e59d2014 	ldr	r2, [sp, #20]
348181c8:	e0801001 	add	r1, r0, r1
348181cc:	e59d000c 	ldr	r0, [sp, #12]
348181d0:	eb0011ed 	bl	3481c98c <memcpy>
	return 0;
}
348181d4:	e3a00000 	mov	r0, #0
348181d8:	e8bd8008 	pop	{r3, pc}

348181dc <s3c_onenand_wait>:
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
348181dc:	e2411001 	sub	r1, r1, #1
348181e0:	e3510007 	cmp	r1, #7

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
348181e4:	e92d4038 	push	{r3, r4, r5, lr}
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
348181e8:	959f30d8 	ldrls	r3, [pc, #216]	; 348182c8 <s3c_onenand_wait+0xec>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
348181ec:	e1a05000 	mov	r5, r0
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
348181f0:	97932101 	ldrls	r2, [r3, r1, lsl #2]
348181f4:	9a000007 	bls	34818218 <s3c_onenand_wait+0x3c>
348181f8:	ea000005 	b	34818214 <s3c_onenand_wait+0x38>
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
348181fc:	e5910000 	ldr	r0, [r1]
34818200:	e590001c 	ldr	r0, [r0, #28]
34818204:	e5900030 	ldr	r0, [r0, #48]	; 0x30
		if (stat & flags)
34818208:	e1120000 	tst	r2, r0
3481820c:	0a000003 	beq	34818220 <s3c_onenand_wait+0x44>
34818210:	ea000004 	b	34818228 <s3c_onenand_wait+0x4c>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34818214:	e3a02b01 	mov	r2, #1024	; 0x400
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
34818218:	e59f10ac 	ldr	r1, [pc, #172]	; 348182cc <s3c_onenand_wait+0xf0>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
3481821c:	e3a03601 	mov	r3, #1048576	; 0x100000
		break;
	default:
		break;
	}

	while (timeout--) {
34818220:	e2533001 	subs	r3, r3, #1
34818224:	2afffff4 	bcs	348181fc <s3c_onenand_wait+0x20>
		if (stat & flags)
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
34818228:	e59f309c 	ldr	r3, [pc, #156]	; 348182cc <s3c_onenand_wait+0xf0>
3481822c:	e5932000 	ldr	r2, [r3]
34818230:	e592201c 	ldr	r2, [r2, #28]
34818234:	e5924030 	ldr	r4, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34818238:	e5933000 	ldr	r3, [r3]
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
3481823c:	e3140010 	tst	r4, #16
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34818240:	e593301c 	ldr	r3, [r3, #28]
34818244:	e5834050 	str	r4, [r3, #80]	; 0x50
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
34818248:	0a00000c 	beq	34818280 <s3c_onenand_wait+0xa4>
		ecc = readl(&onenand->reg->ecc_err_stat);
3481824c:	e5932060 	ldr	r2, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
34818250:	e3013010 	movw	r3, #4112	; 0x1010
34818254:	e0023003 	and	r3, r2, r3
34818258:	e3530000 	cmp	r3, #0
3481825c:	0a000007 	beq	34818280 <s3c_onenand_wait+0xa4>
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
34818260:	e59f0068 	ldr	r0, [pc, #104]	; 348182d0 <s3c_onenand_wait+0xf4>
34818264:	e59f1068 	ldr	r1, [pc, #104]	; 348182d4 <s3c_onenand_wait+0xf8>
34818268:	ebffc652 	bl	34809bb8 <printf>
					__func__, ecc);
			mtd->ecc_stats.failed++;
3481826c:	e5953084 	ldr	r3, [r5, #132]	; 0x84
			return -EBADMSG;
34818270:	e3e00049 	mvn	r0, #73	; 0x49
	if (stat & LOAD_CMP) {
		ecc = readl(&onenand->reg->ecc_err_stat);
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
					__func__, ecc);
			mtd->ecc_stats.failed++;
34818274:	e2833001 	add	r3, r3, #1
34818278:	e5853084 	str	r3, [r5, #132]	; 0x84
			return -EBADMSG;
3481827c:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	if (stat & (LOCKED_BLK | ERS_FAIL | PGM_FAIL | LD_FAIL_ECC_ERR)) {
34818280:	e300010d 	movw	r0, #269	; 0x10d
34818284:	e0040000 	and	r0, r4, r0
34818288:	e3500000 	cmp	r0, #0
3481828c:	08bd8038 	popeq	{r3, r4, r5, pc}
		printk(KERN_INFO "%s: controller error = 0x%04x\n",
34818290:	e59f0040 	ldr	r0, [pc, #64]	; 348182d8 <s3c_onenand_wait+0xfc>
34818294:	e59f1038 	ldr	r1, [pc, #56]	; 348182d4 <s3c_onenand_wait+0xf8>
34818298:	e1a02004 	mov	r2, r4
3481829c:	ebffc645 	bl	34809bb8 <printf>
				__func__, stat);
		if (stat & LOCKED_BLK)
348182a0:	e3140c01 	tst	r4, #256	; 0x100
348182a4:	0a000005 	beq	348182c0 <s3c_onenand_wait+0xe4>
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
348182a8:	e59f002c 	ldr	r0, [pc, #44]	; 348182dc <s3c_onenand_wait+0x100>
348182ac:	e59f1020 	ldr	r1, [pc, #32]	; 348182d4 <s3c_onenand_wait+0xf8>
348182b0:	e1a02004 	mov	r2, r4
348182b4:	ebffc63f 	bl	34809bb8 <printf>
					__func__, stat);

		return -EIO;
348182b8:	e3e00004 	mvn	r0, #4
348182bc:	e8bd8038 	pop	{r3, r4, r5, pc}
348182c0:	e3e00004 	mvn	r0, #4
	}

	return 0;
}
348182c4:	e8bd8038 	pop	{r3, r4, r5, pc}
348182c8:	3482182c 	.word	0x3482182c
348182cc:	3482beb8 	.word	0x3482beb8
348182d0:	34827fe7 	.word	0x34827fe7
348182d4:	3482184c 	.word	0x3482184c
348182d8:	34827fff 	.word	0x34827fff
348182dc:	3482801e 	.word	0x3482801e

348182e0 <s3c_onenand_writew>:
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
348182e0:	e59f20c8 	ldr	r2, [pc, #200]	; 348183b0 <s3c_onenand_writew+0xd0>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
348182e4:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = onenand->mtd->priv;
348182e8:	e5923000 	ldr	r3, [r2]
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
348182ec:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = onenand->mtd->priv;
348182f0:	e5930000 	ldr	r0, [r3]
	int reg = addr - this->base;
348182f4:	e5900094 	ldr	r0, [r0, #148]	; 0x94
348182f8:	e5905000 	ldr	r5, [r0]
348182fc:	e0655001 	rsb	r5, r5, r1
	int word_addr = reg >> 1;

	/* It's used for probing time */
	switch (reg) {
34818300:	e59f10ac 	ldr	r1, [pc, #172]	; 348183b4 <s3c_onenand_writew+0xd4>
34818304:	e1550001 	cmp	r5, r1
34818308:	08bd8070 	popeq	{r4, r5, r6, pc}
3481830c:	ca000003 	bgt	34818320 <s3c_onenand_writew+0x40>
34818310:	e59f20a0 	ldr	r2, [pc, #160]	; 348183b8 <s3c_onenand_writew+0xd8>
34818314:	e1550002 	cmp	r5, r2
34818318:	1a00000b 	bne	3481834c <s3c_onenand_writew+0x6c>
3481831c:	e8bd8070 	pop	{r4, r5, r6, pc}
34818320:	e59f1094 	ldr	r1, [pc, #148]	; 348183bc <s3c_onenand_writew+0xdc>
34818324:	e1550001 	cmp	r5, r1
34818328:	0a000003 	beq	3481833c <s3c_onenand_writew+0x5c>
3481832c:	e59f208c 	ldr	r2, [pc, #140]	; 348183c0 <s3c_onenand_writew+0xe0>
34818330:	e1550002 	cmp	r5, r2
34818334:	1a000004 	bne	3481834c <s3c_onenand_writew+0x6c>
34818338:	e8bd8070 	pop	{r4, r5, r6, pc}
	case ONENAND_REG_SYS_CFG1:
		writel(value, &onenand->reg->mem_cfg);
3481833c:	e5923000 	ldr	r3, [r2]
34818340:	e593301c 	ldr	r3, [r3, #28]
34818344:	e5834000 	str	r4, [r3]
		return;
34818348:	e8bd8070 	pop	{r4, r5, r6, pc}
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
3481834c:	e3550b01 	cmp	r5, #1024	; 0x400
34818350:	aa00000c 	bge	34818388 <s3c_onenand_writew+0xa8>
		if (value == ONENAND_CMD_READID) {
34818354:	e3540090 	cmp	r4, #144	; 0x90
			onenand->bootram_command = 1;
34818358:	03a02001 	moveq	r2, #1
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
		if (value == ONENAND_CMD_READID) {
3481835c:	0a000007 	beq	34818380 <s3c_onenand_writew+0xa0>
			onenand->bootram_command = 1;
			return;
		}
		if (value == ONENAND_CMD_RESET) {
34818360:	e35400f0 	cmp	r4, #240	; 0xf0
34818364:	1a000007 	bne	34818388 <s3c_onenand_writew+0xa8>
			writel(ONENAND_MEM_RESET_COLD,
34818368:	e59f3040 	ldr	r3, [pc, #64]	; 348183b0 <s3c_onenand_writew+0xd0>
3481836c:	e3a01002 	mov	r1, #2
34818370:	e5933000 	ldr	r3, [r3]
34818374:	e593201c 	ldr	r2, [r3, #28]
34818378:	e5821020 	str	r1, [r2, #32]
					&onenand->reg->mem_reset);
			onenand->bootram_command = 0;
3481837c:	e3a02000 	mov	r2, #0
34818380:	e583200c 	str	r2, [r3, #12]
34818384:	e8bd8070 	pop	{r4, r5, r6, pc}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
34818388:	e1a050c5 	asr	r5, r5, #1
			onenand->bootram_command = 0;
			return;
		}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
3481838c:	e1a01005 	mov	r1, r5
34818390:	e1a02004 	mov	r2, r4
34818394:	e59f0028 	ldr	r0, [pc, #40]	; 348183c4 <s3c_onenand_writew+0xe4>
34818398:	ebffc606 	bl	34809bb8 <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
3481839c:	e1a01105 	lsl	r1, r5, #2
348183a0:	e1a00004 	mov	r0, r4
348183a4:	e3811303 	orr	r1, r1, #201326592	; 0xc000000
}
348183a8:	e8bd4070 	pop	{r4, r5, r6, lr}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
348183ac:	eafffe81 	b	34817db8 <s3c_write_cmd>
348183b0:	3482beb8 	.word	0x3482beb8
348183b4:	0001e202 	.word	0x0001e202
348183b8:	0001e200 	.word	0x0001e200
348183bc:	0001e442 	.word	0x0001e442
348183c0:	0001e498 	.word	0x0001e498
348183c4:	3482803e 	.word	0x3482803e

348183c8 <s3c_onenand_readw>:
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
348183c8:	e92d4038 	push	{r3, r4, r5, lr}
	struct onenand_chip *this = onenand->mtd->priv;
348183cc:	e59f3154 	ldr	r3, [pc, #340]	; 34818528 <s3c_onenand_readw+0x160>
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
348183d0:	e59f1154 	ldr	r1, [pc, #340]	; 3481852c <s3c_onenand_readw+0x164>
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
348183d4:	e5933000 	ldr	r3, [r3]
348183d8:	e5932000 	ldr	r2, [r3]
	int reg = addr - this->base;
348183dc:	e5922094 	ldr	r2, [r2, #148]	; 0x94
348183e0:	e5922000 	ldr	r2, [r2]
348183e4:	e0622000 	rsb	r2, r2, r0
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
348183e8:	e1520001 	cmp	r2, r1
348183ec:	0a000022 	beq	3481847c <s3c_onenand_readw+0xb4>
348183f0:	ca000008 	bgt	34818418 <s3c_onenand_readw+0x50>
348183f4:	e2411004 	sub	r1, r1, #4
348183f8:	e1520001 	cmp	r2, r1
348183fc:	0a000018 	beq	34818464 <s3c_onenand_readw+0x9c>
34818400:	e2811002 	add	r1, r1, #2
34818404:	e1520001 	cmp	r2, r1
34818408:	0a000018 	beq	34818470 <s3c_onenand_readw+0xa8>
3481840c:	e3520a1e 	cmp	r2, #122880	; 0x1e000
34818410:	1a000022 	bne	348184a0 <s3c_onenand_readw+0xd8>
34818414:	ea00000f 	b	34818458 <s3c_onenand_readw+0x90>
34818418:	e59f1110 	ldr	r1, [pc, #272]	; 34818530 <s3c_onenand_readw+0x168>
3481841c:	e1520001 	cmp	r2, r1
34818420:	0a00001b 	beq	34818494 <s3c_onenand_readw+0xcc>
34818424:	ca000003 	bgt	34818438 <s3c_onenand_readw+0x70>
34818428:	e59f1104 	ldr	r1, [pc, #260]	; 34818534 <s3c_onenand_readw+0x16c>
3481842c:	e1520001 	cmp	r2, r1
34818430:	1a00001a 	bne	348184a0 <s3c_onenand_readw+0xd8>
34818434:	ea000013 	b	34818488 <s3c_onenand_readw+0xc0>
34818438:	e59f10f8 	ldr	r1, [pc, #248]	; 34818538 <s3c_onenand_readw+0x170>
3481843c:	e1520001 	cmp	r2, r1
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);

	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;
34818440:	03a00000 	moveq	r0, #0
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34818444:	08bd8038 	popeq	{r3, r4, r5, pc}
34818448:	e281101c 	add	r1, r1, #28
3481844c:	e1520001 	cmp	r2, r1
34818450:	1a000012 	bne	348184a0 <s3c_onenand_readw+0xd8>
34818454:	ea000031 	b	34818520 <s3c_onenand_readw+0x158>
	case ONENAND_REG_MANUFACTURER_ID:
		return readl(&onenand->reg->manufact_id);
34818458:	e593301c 	ldr	r3, [r3, #28]
3481845c:	e5930070 	ldr	r0, [r3, #112]	; 0x70
34818460:	ea000018 	b	348184c8 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DEVICE_ID:
		return readl(&onenand->reg->device_id);
34818464:	e593301c 	ldr	r3, [r3, #28]
34818468:	e5930080 	ldr	r0, [r3, #128]	; 0x80
3481846c:	ea000015 	b	348184c8 <s3c_onenand_readw+0x100>
	case ONENAND_REG_VERSION_ID:
		return readl(&onenand->reg->flash_ver_id);
34818470:	e593301c 	ldr	r3, [r3, #28]
34818474:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34818478:	ea000012 	b	348184c8 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DATA_BUFFER_SIZE:
		return readl(&onenand->reg->data_buf_size);
3481847c:	e593301c 	ldr	r3, [r3, #28]
34818480:	e5930090 	ldr	r0, [r3, #144]	; 0x90
34818484:	ea00000f 	b	348184c8 <s3c_onenand_readw+0x100>
	case ONENAND_REG_TECHNOLOGY:
		return readl(&onenand->reg->tech);
34818488:	e593301c 	ldr	r3, [r3, #28]
3481848c:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
34818490:	ea00000c 	b	348184c8 <s3c_onenand_readw+0x100>
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);
34818494:	e593301c 	ldr	r3, [r3, #28]
34818498:	e5930000 	ldr	r0, [r3]
3481849c:	ea000009 	b	348184c8 <s3c_onenand_readw+0x100>
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
348184a0:	e3520b01 	cmp	r2, #1024	; 0x400

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
348184a4:	e1a050c2 	asr	r5, r2, #1
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
348184a8:	aa000012 	bge	348184f8 <s3c_onenand_readw+0x130>
348184ac:	e593200c 	ldr	r2, [r3, #12]
348184b0:	e3520000 	cmp	r2, #0
348184b4:	0a00000f 	beq	348184f8 <s3c_onenand_readw+0x130>
		if (word_addr == 0)
348184b8:	e3550000 	cmp	r5, #0
348184bc:	1a000003 	bne	348184d0 <s3c_onenand_readw+0x108>
			return readl(&onenand->reg->manufact_id);
348184c0:	e593301c 	ldr	r3, [r3, #28]
348184c4:	e5930070 	ldr	r0, [r3, #112]	; 0x70
348184c8:	e6ff0070 	uxth	r0, r0
348184cc:	e8bd8038 	pop	{r3, r4, r5, pc}
		if (word_addr == 1)
348184d0:	e3550001 	cmp	r5, #1
348184d4:	1a000002 	bne	348184e4 <s3c_onenand_readw+0x11c>
			return readl(&onenand->reg->device_id);
348184d8:	e593301c 	ldr	r3, [r3, #28]
348184dc:	e5930080 	ldr	r0, [r3, #128]	; 0x80
348184e0:	eafffff8 	b	348184c8 <s3c_onenand_readw+0x100>
		if (word_addr == 2)
348184e4:	e3550002 	cmp	r5, #2
348184e8:	1a000002 	bne	348184f8 <s3c_onenand_readw+0x130>
			return readl(&onenand->reg->flash_ver_id);
348184ec:	e593301c 	ldr	r3, [r3, #28]
348184f0:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
348184f4:	eafffff3 	b	348184c8 <s3c_onenand_readw+0x100>
	}

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
348184f8:	e1a00105 	lsl	r0, r5, #2
348184fc:	e3800303 	orr	r0, r0, #201326592	; 0xc000000
34818500:	ebfffe26 	bl	34817da0 <s3c_read_cmd>
34818504:	e6ff4070 	uxth	r4, r0
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
34818508:	e1a01005 	mov	r1, r5
3481850c:	e59f0028 	ldr	r0, [pc, #40]	; 3481853c <s3c_onenand_readw+0x174>
34818510:	e1a02004 	mov	r2, r4
34818514:	ebffc5a7 	bl	34809bb8 <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
34818518:	e6ff0074 	uxth	r0, r4
3481851c:	e8bd8038 	pop	{r3, r4, r5, pc}
	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;

	case ONENAND_REG_WP_STATUS:
		return ONENAND_WP_US;
34818520:	e3a00004 	mov	r0, #4

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}
34818524:	e8bd8038 	pop	{r3, r4, r5, pc}
34818528:	3482beb8 	.word	0x3482beb8
3481852c:	0001e006 	.word	0x0001e006
34818530:	0001e442 	.word	0x0001e442
34818534:	0001e00c 	.word	0x0001e00c
34818538:	0001e480 	.word	0x0001e480
3481853c:	3482807a 	.word	0x3482807a

34818540 <s3c_onenand_check_lock_status.clone.0>:
	}

	return 0;
}

static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
34818540:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
34818544:	e5907018 	ldr	r7, [r0, #24]
34818548:	e5903030 	ldr	r3, [r0, #48]	; 0x30

	for (block = 0; block < end; block++) {
3481854c:	e3a04000 	mov	r4, #0
static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
34818550:	e1a07337 	lsr	r7, r7, r3

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34818554:	e59f5060 	ldr	r5, [pc, #96]	; 348185bc <s3c_onenand_check_lock_status.clone.0+0x7c>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
34818558:	e3a06c01 	mov	r6, #256	; 0x100
3481855c:	ea000013 	b	348185b0 <s3c_onenand_check_lock_status.clone.0+0x70>
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34818560:	e5953000 	ldr	r3, [r5]
34818564:	e3a01000 	mov	r1, #0
34818568:	e5933018 	ldr	r3, [r3, #24]
3481856c:	e1a02001 	mov	r2, r1
34818570:	e1a00004 	mov	r0, r4
34818574:	e12fff33 	blx	r3
34818578:	e3800301 	orr	r0, r0, #67108864	; 0x4000000
3481857c:	ebfffe07 	bl	34817da0 <s3c_read_cmd>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
34818580:	e5953000 	ldr	r3, [r5]
34818584:	e593301c 	ldr	r3, [r3, #28]
34818588:	e5933030 	ldr	r3, [r3, #48]	; 0x30
3481858c:	e3130c01 	tst	r3, #256	; 0x100
34818590:	0a000005 	beq	348185ac <s3c_onenand_check_lock_status.clone.0+0x6c>
			printf("block %d is write-protected!\n", block);
34818594:	e1a01004 	mov	r1, r4
34818598:	e59f0020 	ldr	r0, [pc, #32]	; 348185c0 <s3c_onenand_check_lock_status.clone.0+0x80>
3481859c:	ebffc585 	bl	34809bb8 <printf>
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
348185a0:	e5953000 	ldr	r3, [r5]
348185a4:	e593301c 	ldr	r3, [r3, #28]
348185a8:	e5836050 	str	r6, [r3, #80]	; 0x50
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
348185ac:	e2844001 	add	r4, r4, #1
348185b0:	e1540007 	cmp	r4, r7
348185b4:	3affffe9 	bcc	34818560 <s3c_onenand_check_lock_status.clone.0+0x20>
		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
		}
	}
}
348185b8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348185bc:	3482beb8 	.word	0x3482beb8
348185c0:	348280b6 	.word	0x348280b6

348185c4 <s3c_onenand_unlock_all>:

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
348185c4:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	struct onenand_chip *this = mtd->priv;
348185c8:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
348185cc:	e5903014 	ldr	r3, [r0, #20]
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348185d0:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
348185d4:	e5853098 	str	r3, [r5, #152]	; 0x98
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348185d8:	e3120002 	tst	r2, #2
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
348185dc:	e3a03000 	mov	r3, #0

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
348185e0:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;
348185e4:	e5956018 	ldr	r6, [r5, #24]
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
348185e8:	03a01000 	moveq	r1, #0
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
348185ec:	e5803090 	str	r3, [r0, #144]	; 0x90
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
348185f0:	03a00000 	moveq	r0, #0

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
348185f4:	0a000010 	beq	3481863c <s3c_onenand_unlock_all+0x78>
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
348185f8:	e58d3000 	str	r3, [sp]
348185fc:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34818600:	e3a01027 	mov	r1, #39	; 0x27
34818604:	e3a02000 	mov	r2, #0
34818608:	e3a03000 	mov	r3, #0
3481860c:	e12fff3c 	blx	ip

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);
34818610:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34818614:	e3a01008 	mov	r1, #8
34818618:	e1a00004 	mov	r0, r4
3481861c:	e12fff33 	blx	r3

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34818620:	e595301c 	ldr	r3, [r5, #28]
34818624:	e3130008 	tst	r3, #8
			s3c_onenand_check_lock_status(mtd);
			return;
		}

		/* All blocks on another chip */
		ofs = this->chipsize >> 1;
34818628:	15956018 	ldrne	r6, [r5, #24]
3481862c:	11a060a6 	lsrne	r6, r6, #1
34818630:	11a00006 	movne	r0, r6
34818634:	13a01000 	movne	r1, #0

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34818638:	0a00001e 	beq	348186b8 <s3c_onenand_unlock_all+0xf4>
}

static void s3c_onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs,
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
3481863c:	e5945094 	ldr	r5, [r4, #148]	; 0x94
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34818640:	e59f7080 	ldr	r7, [pc, #128]	; 348186c8 <s3c_onenand_unlock_all+0x104>
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
34818644:	e5952030 	ldr	r2, [r5, #48]	; 0x30
34818648:	eb001f31 	bl	34820314 <__ashrdi3>
	start_mem_addr = onenand->mem_addr(start, 0, 0);
3481864c:	e5973000 	ldr	r3, [r7]
34818650:	e3a01000 	mov	r1, #0
34818654:	e1a02001 	mov	r2, r1
34818658:	e5933018 	ldr	r3, [r3, #24]
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
3481865c:	e1a09000 	mov	r9, r0
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34818660:	e12fff33 	blx	r3
34818664:	e1a0a000 	mov	sl, r0
	end = start + (len >> this->erase_shift) - 1;
34818668:	e5950030 	ldr	r0, [r5, #48]	; 0x30
	end_mem_addr = onenand->mem_addr(end, 0, 0);
3481866c:	e5973000 	ldr	r3, [r7]
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
34818670:	e1a06036 	lsr	r6, r6, r0
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34818674:	e3a01000 	mov	r1, #0
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
34818678:	e2460001 	sub	r0, r6, #1
	end_mem_addr = onenand->mem_addr(end, 0, 0);
3481867c:	e5933018 	ldr	r3, [r3, #24]
34818680:	e1a02001 	mov	r2, r1
34818684:	e0800009 	add	r0, r0, r9
34818688:	e12fff33 	blx	r3

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
3481868c:	e38a1302 	orr	r1, sl, #134217728	; 0x8000000
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34818690:	e1a06000 	mov	r6, r0

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
34818694:	e3a00008 	mov	r0, #8
34818698:	ebfffdc6 	bl	34817db8 <s3c_write_cmd>
		s3c_write_cmd(ONENAND_UNLOCK_END, CMD_MAP_10(end_mem_addr));
3481869c:	e3a00009 	mov	r0, #9
348186a0:	e3861302 	orr	r1, r6, #134217728	; 0x8000000
348186a4:	ebfffdc3 	bl	34817db8 <s3c_write_cmd>
	}

	this->wait(mtd, FL_LOCKING);
348186a8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348186ac:	e1a00004 	mov	r0, r4
348186b0:	e3a01008 	mov	r1, #8
348186b4:	e12fff33 	blx	r3
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
348186b8:	e5940094 	ldr	r0, [r4, #148]	; 0x94
}
348186bc:	e28dd00c 	add	sp, sp, #12
348186c0:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
348186c4:	eaffff9d 	b	34818540 <s3c_onenand_check_lock_status.clone.0>
348186c8:	3482beb8 	.word	0x3482beb8

348186cc <s5pc110_chip_probe>:
#endif

int s5pc110_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
348186cc:	e3a00000 	mov	r0, #0
348186d0:	e12fff1e 	bx	lr

348186d4 <s5pc210_chip_probe>:

int s5pc210_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
348186d4:	e3a00000 	mov	r0, #0
348186d8:	e12fff1e 	bx	lr

348186dc <s3c_onenand_init>:

void s3c_onenand_init(struct mtd_info *mtd)
{
348186dc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct onenand_chip *this = mtd->priv;
348186e0:	e5904094 	ldr	r4, [r0, #148]	; 0x94
{
	return 0;
}

void s3c_onenand_init(struct mtd_info *mtd)
{
348186e4:	e1a06000 	mov	r6, r0
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
348186e8:	e3a00020 	mov	r0, #32
348186ec:	ebffc6f8 	bl	3480a2d4 <malloc>
348186f0:	e59f50d4 	ldr	r5, [pc, #212]	; 348187cc <s3c_onenand_init+0xf0>
	if (!onenand)
348186f4:	e3500000 	cmp	r0, #0
void s3c_onenand_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
348186f8:	e1a07000 	mov	r7, r0
348186fc:	e5850000 	str	r0, [r5]
	if (!onenand)
34818700:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34818704:	e3a00a01 	mov	r0, #4096	; 0x1000
34818708:	ebffc6f1 	bl	3480a2d4 <malloc>
	if (!onenand->page_buf)
3481870c:	e5953000 	ldr	r3, [r5]

	onenand = malloc(sizeof(struct s3c_onenand));
	if (!onenand)
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34818710:	e5870010 	str	r0, [r7, #16]
	if (!onenand->page_buf)
34818714:	e5930010 	ldr	r0, [r3, #16]
34818718:	e3500000 	cmp	r0, #0
3481871c:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->page_buf, 0xff, size);
34818720:	e3a010ff 	mov	r1, #255	; 0xff
34818724:	e3a02a01 	mov	r2, #4096	; 0x1000
34818728:	eb001073 	bl	3481c8fc <memset>

	onenand->oob_buf = malloc(128 * sizeof(char));
3481872c:	e3a00080 	mov	r0, #128	; 0x80
34818730:	e5957000 	ldr	r7, [r5]
34818734:	ebffc6e6 	bl	3480a2d4 <malloc>
	if (!onenand->oob_buf)
34818738:	e5953000 	ldr	r3, [r5]
	onenand->page_buf = malloc(size * sizeof(char));
	if (!onenand->page_buf)
		return;
	memset(onenand->page_buf, 0xff, size);

	onenand->oob_buf = malloc(128 * sizeof(char));
3481873c:	e5870014 	str	r0, [r7, #20]
	if (!onenand->oob_buf)
34818740:	e5930014 	ldr	r0, [r3, #20]
34818744:	e3500000 	cmp	r0, #0
34818748:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->oob_buf, 0xff, 128);
3481874c:	e3a010ff 	mov	r1, #255	; 0xff
34818750:	e3a02080 	mov	r2, #128	; 0x80
34818754:	eb001068 	bl	3481c8fc <memset>

	onenand->mtd = mtd;
34818758:	e5953000 	ldr	r3, [r5]
#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
	onenand->ahb_addr = (void *)0xB0000000;
3481875c:	e3a0120b 	mov	r1, #-1342177280	; 0xb0000000
34818760:	e5831008 	str	r1, [r3, #8]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
34818764:	e59f2064 	ldr	r2, [pc, #100]	; 348187d0 <s3c_onenand_init+0xf4>
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
34818768:	e59f1064 	ldr	r1, [pc, #100]	; 348187d4 <s3c_onenand_init+0xf8>
	onenand->oob_buf = malloc(128 * sizeof(char));
	if (!onenand->oob_buf)
		return;
	memset(onenand->oob_buf, 0xff, 128);

	onenand->mtd = mtd;
3481876c:	e5836000 	str	r6, [r3]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
34818770:	e5832004 	str	r2, [r3, #4]
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
34818774:	e5831018 	str	r1, [r3, #24]
	onenand->reg = (struct samsung_onenand *)onenand->base;
34818778:	e583201c 	str	r2, [r3, #28]

	this->read_word = s3c_onenand_readw;
3481877c:	e59f3054 	ldr	r3, [pc, #84]	; 348187d8 <s3c_onenand_init+0xfc>
34818780:	e5843068 	str	r3, [r4, #104]	; 0x68
	this->write_word = s3c_onenand_writew;
34818784:	e59f3050 	ldr	r3, [pc, #80]	; 348187dc <s3c_onenand_init+0x100>
34818788:	e584306c 	str	r3, [r4, #108]	; 0x6c

	this->wait = s3c_onenand_wait;
3481878c:	e59f304c 	ldr	r3, [pc, #76]	; 348187e0 <s3c_onenand_init+0x104>
34818790:	e5843054 	str	r3, [r4, #84]	; 0x54
	this->bbt_wait = s3c_onenand_bbt_wait;
34818794:	e59f3048 	ldr	r3, [pc, #72]	; 348187e4 <s3c_onenand_init+0x108>
34818798:	e5843058 	str	r3, [r4, #88]	; 0x58
	this->unlock_all = s3c_onenand_unlock_all;
3481879c:	e59f3044 	ldr	r3, [pc, #68]	; 348187e8 <s3c_onenand_init+0x10c>
348187a0:	e584305c 	str	r3, [r4, #92]	; 0x5c
	this->command = s3c_onenand_command;
348187a4:	e59f3040 	ldr	r3, [pc, #64]	; 348187ec <s3c_onenand_init+0x110>
348187a8:	e5843050 	str	r3, [r4, #80]	; 0x50

	this->read_bufferram = onenand_read_bufferram;
348187ac:	e59f303c 	ldr	r3, [pc, #60]	; 348187f0 <s3c_onenand_init+0x114>
348187b0:	e5843060 	str	r3, [r4, #96]	; 0x60
	this->write_bufferram = onenand_write_bufferram;
348187b4:	e59f3038 	ldr	r3, [pc, #56]	; 348187f4 <s3c_onenand_init+0x118>
348187b8:	e5843064 	str	r3, [r4, #100]	; 0x64

	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
348187bc:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
348187c0:	e3833c02 	orr	r3, r3, #512	; 0x200
348187c4:	e584302c 	str	r3, [r4, #44]	; 0x2c
348187c8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348187cc:	3482beb8 	.word	0x3482beb8
348187d0:	e7100000 	.word	0xe7100000
348187d4:	34817dd0 	.word	0x34817dd0
348187d8:	348183c8 	.word	0x348183c8
348187dc:	348182e0 	.word	0x348182e0
348187e0:	348181dc 	.word	0x348181dc
348187e4:	34818104 	.word	0x34818104
348187e8:	348185c4 	.word	0x348185c4
348187ec:	34817e58 	.word	0x34817e58
348187f0:	348181b4 	.word	0x348181b4
348187f4:	3481818c 	.word	0x3481818c

348187f8 <samsung_get_base_uart>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348187f8:	e59f3028 	ldr	r3, [pc, #40]	; 34818828 <samsung_get_base_uart+0x30>
348187fc:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
34818800:	e3530cc1 	cmp	r3, #49408	; 0xc100
34818804:	0a000005 	beq	34818820 <samsung_get_base_uart+0x28>
34818808:	e30c0110 	movw	r0, #49424	; 0xc110
3481880c:	e59f2018 	ldr	r2, [pc, #24]	; 3481882c <samsung_get_base_uart+0x34>
34818810:	e1530000 	cmp	r3, r0
34818814:	01a00002 	moveq	r0, r2
34818818:	13a00000 	movne	r0, #0
3481881c:	e12fff1e 	bx	lr
34818820:	e3a0033b 	mov	r0, #-335544320	; 0xec000000
34818824:	e12fff1e 	bx	lr
34818828:	348285d0 	.word	0x348285d0
3481882c:	e2900000 	.word	0xe2900000

34818830 <serial_setbrg_dev>:
	0xdfdf,
	0xffdf,
};

void serial_setbrg_dev(const int dev_index)
{
34818830:	e92d4038 	push	{r3, r4, r5, lr}
34818834:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818838:	ebffffee 	bl	348187f8 <samsung_get_base_uart>
3481883c:	e0804505 	add	r4, r0, r5, lsl #10
};

void serial_setbrg_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);
	u32 uclk = get_uart_clk(dev_index);
34818840:	e1a00005 	mov	r0, r5
34818844:	ebffa473 	bl	34801a18 <get_uart_clk>
	u32 baudrate = gd->baudrate;
34818848:	e5981008 	ldr	r1, [r8, #8]
	u32 val;

	val = uclk / baudrate;
3481884c:	eb001d96 	bl	3481feac <__udivsi3>

	writel(val / 16 - 1, &uart->ubrdiv);
34818850:	e1a03220 	lsr	r3, r0, #4
34818854:	e2433001 	sub	r3, r3, #1
34818858:	e5843028 	str	r3, [r4, #40]	; 0x28

	if (s5p_uart_divslot())
		writew(udivslot[val % 16], &uart->rest.slot);
3481885c:	e59f3010 	ldr	r3, [pc, #16]	; 34818874 <serial_setbrg_dev+0x44>
34818860:	e200000f 	and	r0, r0, #15
34818864:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34818868:	e6ff3073 	uxth	r3, r3
3481886c:	e1c432bc 	strh	r3, [r4, #44]	; 0x2c
	else
		writeb(val % 16, &uart->rest.value);
}
34818870:	e8bd8038 	pop	{r3, r4, r5, pc}
34818874:	34821860 	.word	0x34821860

34818878 <s5p_serial3_setbrg>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34818878:	e3a00003 	mov	r0, #3
3481887c:	eaffffeb 	b	34818830 <serial_setbrg_dev>

34818880 <s5p_serial2_setbrg>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34818880:	e3a00002 	mov	r0, #2
34818884:	eaffffe9 	b	34818830 <serial_setbrg_dev>

34818888 <s5p_serial1_setbrg>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818888:	e3a00001 	mov	r0, #1
3481888c:	eaffffe7 	b	34818830 <serial_setbrg_dev>

34818890 <s5p_serial0_setbrg>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34818890:	e3a00000 	mov	r0, #0
34818894:	eaffffe5 	b	34818830 <serial_setbrg_dev>

34818898 <serial_init_dev>:
/*
 * Initialise the serial port with the given baudrate. The settings
 * are always 8 data bits, no parity, 1 stop bit, no start bits.
 */
int serial_init_dev(const int dev_index)
{
34818898:	e92d4038 	push	{r3, r4, r5, lr}
3481889c:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
348188a0:	ebffffd4 	bl	348187f8 <samsung_get_base_uart>
348188a4:	e0803505 	add	r3, r0, r5, lsl #10
int serial_init_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* reset and enable FIFOs, set triggers to the maximum */
	writel(0, &uart->ufcon);
348188a8:	e3a04000 	mov	r4, #0
348188ac:	e5834008 	str	r4, [r3, #8]
	writel(0, &uart->umcon);
348188b0:	e583400c 	str	r4, [r3, #12]
	/* 8N1 */
	writel(0x3, &uart->ulcon);
348188b4:	e3a02003 	mov	r2, #3
348188b8:	e7802505 	str	r2, [r0, r5, lsl #10]
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
348188bc:	e3002245 	movw	r2, #581	; 0x245

	serial_setbrg_dev(dev_index);
348188c0:	e1a00005 	mov	r0, r5
	writel(0, &uart->ufcon);
	writel(0, &uart->umcon);
	/* 8N1 */
	writel(0x3, &uart->ulcon);
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
348188c4:	e5832004 	str	r2, [r3, #4]

	serial_setbrg_dev(dev_index);
348188c8:	ebffffd8 	bl	34818830 <serial_setbrg_dev>

	return 0;
}
348188cc:	e1a00004 	mov	r0, r4
348188d0:	e8bd8038 	pop	{r3, r4, r5, pc}

348188d4 <s5p_serial3_init>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
348188d4:	e3a00003 	mov	r0, #3
348188d8:	eaffffee 	b	34818898 <serial_init_dev>

348188dc <s5p_serial2_init>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
348188dc:	e3a00002 	mov	r0, #2
348188e0:	eaffffec 	b	34818898 <serial_init_dev>

348188e4 <s5p_serial1_init>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
348188e4:	e3a00001 	mov	r0, #1
348188e8:	eaffffea 	b	34818898 <serial_init_dev>

348188ec <s5p_serial0_init>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
348188ec:	e3a00000 	mov	r0, #0
348188f0:	eaffffe8 	b	34818898 <serial_init_dev>

348188f4 <serial_getc_dev>:
 * Read a single byte from the serial port. Returns 1 on success, 0
 * otherwise. When the function is succesfull, the character read is
 * written into its argument c.
 */
int serial_getc_dev(const int dev_index)
{
348188f4:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
348188f8:	e1a05500 	lsl	r5, r0, #10
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
348188fc:	ebffffbd 	bl	348187f8 <samsung_get_base_uart>
34818900:	e0804005 	add	r4, r0, r5
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
34818904:	ea000004 	b	3481891c <serial_getc_dev+0x28>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818908:	ebffffba 	bl	348187f8 <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
3481890c:	e0800005 	add	r0, r0, r5
34818910:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
34818914:	e313000f 	tst	r3, #15
34818918:	1a000004 	bne	34818930 <serial_getc_dev+0x3c>
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
3481891c:	e5946010 	ldr	r6, [r4, #16]
34818920:	e2166001 	ands	r6, r6, #1
34818924:	0afffff7 	beq	34818908 <serial_getc_dev+0x14>
		if (serial_err_check(dev_index, 0))
			return 0;
	}

	return (int)(readb(&uart->urxh) & 0xff);
34818928:	e5d40024 	ldrb	r0, [r4, #36]	; 0x24
3481892c:	e8bd8070 	pop	{r4, r5, r6, pc}
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
			return 0;
34818930:	e1a00006 	mov	r0, r6
	}

	return (int)(readb(&uart->urxh) & 0xff);
}
34818934:	e8bd8070 	pop	{r4, r5, r6, pc}

34818938 <s5p_serial3_getc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34818938:	e3a00003 	mov	r0, #3
3481893c:	eaffffec 	b	348188f4 <serial_getc_dev>

34818940 <s5p_serial2_getc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34818940:	e3a00002 	mov	r0, #2
34818944:	eaffffea 	b	348188f4 <serial_getc_dev>

34818948 <s5p_serial1_getc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818948:	e3a00001 	mov	r0, #1
3481894c:	eaffffe8 	b	348188f4 <serial_getc_dev>

34818950 <s5p_serial0_getc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34818950:	e3a00000 	mov	r0, #0
34818954:	eaffffe6 	b	348188f4 <serial_getc_dev>

34818958 <serial_putc_dev>:

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
34818958:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
3481895c:	e1a06501 	lsl	r6, r1, #10

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
34818960:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818964:	ebffffa3 	bl	348187f8 <samsung_get_base_uart>
34818968:	e0805006 	add	r5, r0, r6
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
3481896c:	ea000004 	b	34818984 <serial_putc_dev+0x2c>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34818970:	ebffffa0 	bl	348187f8 <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
34818974:	e0800006 	add	r0, r0, r6
34818978:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
3481897c:	e3130008 	tst	r3, #8
34818980:	18bd8070 	popne	{r4, r5, r6, pc}
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
34818984:	e5953010 	ldr	r3, [r5, #16]
34818988:	e3130002 	tst	r3, #2
3481898c:	0afffff7 	beq	34818970 <serial_putc_dev+0x18>
	}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
34818990:	e354000a 	cmp	r4, #10
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
			return;
	}

	writeb(c, &uart->utxh);
34818994:	e5c54020 	strb	r4, [r5, #32]

	/* If \n, also do \r */
	if (c == '\n')
34818998:	18bd8070 	popne	{r4, r5, r6, pc}
		serial_putc('\r');
3481899c:	e3a0000d 	mov	r0, #13
}
348189a0:	e8bd4070 	pop	{r4, r5, r6, lr}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
		serial_putc('\r');
348189a4:	eaffd9d0 	b	3480f0ec <serial_putc>

348189a8 <s5p_serial3_putc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
348189a8:	e3a01003 	mov	r1, #3
348189ac:	eaffffe9 	b	34818958 <serial_putc_dev>

348189b0 <s5p_serial2_putc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
348189b0:	e3a01002 	mov	r1, #2
348189b4:	eaffffe7 	b	34818958 <serial_putc_dev>

348189b8 <s5p_serial1_putc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
348189b8:	e3a01001 	mov	r1, #1
348189bc:	eaffffe5 	b	34818958 <serial_putc_dev>

348189c0 <s5p_serial0_putc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
348189c0:	e3a01000 	mov	r1, #0
348189c4:	eaffffe3 	b	34818958 <serial_putc_dev>

348189c8 <serial_tstc_dev>:

/*
 * Test whether a character is in the RX buffer
 */
int serial_tstc_dev(const int dev_index)
{
348189c8:	e92d4010 	push	{r4, lr}
348189cc:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
348189d0:	ebffff88 	bl	348187f8 <samsung_get_base_uart>
 */
int serial_tstc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	return (int)(readl(&uart->utrstat) & 0x1);
348189d4:	e0800504 	add	r0, r0, r4, lsl #10
348189d8:	e5900010 	ldr	r0, [r0, #16]
}
348189dc:	e2000001 	and	r0, r0, #1
348189e0:	e8bd8010 	pop	{r4, pc}

348189e4 <s5p_serial3_tstc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
348189e4:	e3a00003 	mov	r0, #3
348189e8:	eafffff6 	b	348189c8 <serial_tstc_dev>

348189ec <s5p_serial2_tstc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
348189ec:	e3a00002 	mov	r0, #2
348189f0:	eafffff4 	b	348189c8 <serial_tstc_dev>

348189f4 <s5p_serial1_tstc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
348189f4:	e3a00001 	mov	r0, #1
348189f8:	eafffff2 	b	348189c8 <serial_tstc_dev>

348189fc <s5p_serial0_tstc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
348189fc:	e3a00000 	mov	r0, #0
34818a00:	eafffff0 	b	348189c8 <serial_tstc_dev>

34818a04 <serial_puts_dev>:

	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
34818a04:	e92d4038 	push	{r3, r4, r5, lr}
34818a08:	e1a05001 	mov	r5, r1
34818a0c:	e1a04000 	mov	r4, r0
	while (*s)
34818a10:	ea000001 	b	34818a1c <serial_puts_dev+0x18>
		serial_putc_dev(*s++, dev_index);
34818a14:	e1a01005 	mov	r1, r5
34818a18:	ebffffce 	bl	34818958 <serial_putc_dev>
	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
	while (*s)
34818a1c:	e4d40001 	ldrb	r0, [r4], #1
34818a20:	e3500000 	cmp	r0, #0
34818a24:	1afffffa 	bne	34818a14 <serial_puts_dev+0x10>
		serial_putc_dev(*s++, dev_index);
}
34818a28:	e8bd8038 	pop	{r3, r4, r5, pc}

34818a2c <s5p_serial3_puts>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34818a2c:	e3a01003 	mov	r1, #3
34818a30:	eafffff3 	b	34818a04 <serial_puts_dev>

34818a34 <s5p_serial2_puts>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34818a34:	e3a01002 	mov	r1, #2
34818a38:	eafffff1 	b	34818a04 <serial_puts_dev>

34818a3c <s5p_serial1_puts>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818a3c:	e3a01001 	mov	r1, #1
34818a40:	eaffffef 	b	34818a04 <serial_puts_dev>

34818a44 <s5p_serial0_puts>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34818a44:	e3a01000 	mov	r1, #0
34818a48:	eaffffed 	b	34818a04 <serial_puts_dev>

34818a4c <default_serial_console>:
#elif defined(CONFIG_SERIAL3)
	return &s5p_serial3_device;
#else
#error "CONFIG_SERIAL? missing."
#endif
}
34818a4c:	e59f0000 	ldr	r0, [pc, #0]	; 34818a54 <default_serial_console+0x8>
34818a50:	e12fff1e 	bx	lr
34818a54:	348294f4 	.word	0x348294f4

34818a58 <usb_ep_autoconfig>:
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34818a58:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818a5c:	e1a07000 	mov	r7, r0
34818a60:	e5b74008 	ldr	r4, [r7, #8]!
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34818a64:	e1a0a000 	mov	sl, r0
34818a68:	e1a05001 	mov	r5, r1
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818a6c:	e244400c 	sub	r4, r4, #12
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
34818a70:	e59f9200 	ldr	r9, [pc, #512]	; 34818c78 <usb_ep_autoconfig+0x220>

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
34818a74:	e300b3ff 	movw	fp, #1023	; 0x3ff
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818a78:	ea000078 	b	34818c60 <usb_ep_autoconfig+0x208>
	u8		type;
	const char	*tmp;
	u16		max;

	/* endpoint already claimed? */
	if (NULL != ep->driver_data)
34818a7c:	e5943000 	ldr	r3, [r4]
34818a80:	e3530000 	cmp	r3, #0
34818a84:	1a000073 	bne	34818c58 <usb_ep_autoconfig+0x200>
		return 0;

	/* only support ep0 for portable CONTROL traffic */
	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
34818a88:	e5d56003 	ldrb	r6, [r5, #3]
	if (USB_ENDPOINT_XFER_CONTROL == type)
34818a8c:	e2166003 	ands	r6, r6, #3
34818a90:	0a000070 	beq	34818c58 <usb_ep_autoconfig+0x200>
		return 0;

	/* some other naming convention */
	if ('e' != ep->name[0])
34818a94:	e5940004 	ldr	r0, [r4, #4]
34818a98:	e5d03000 	ldrb	r3, [r0]
34818a9c:	e3530065 	cmp	r3, #101	; 0x65
34818aa0:	1a00006c 	bne	34818c58 <usb_ep_autoconfig+0x200>
		return 0;

	/* type-restriction:  "-iso", "-bulk", or "-int".
	 * direction-restriction:  "in", "out".
	 */
	if ('-' != ep->name[2]) {
34818aa4:	e5d03002 	ldrb	r3, [r0, #2]
34818aa8:	e353002d 	cmp	r3, #45	; 0x2d
34818aac:	0a000023 	beq	34818b40 <usb_ep_autoconfig+0xe8>
		tmp = strrchr(ep->name, '-');
34818ab0:	e3a0102d 	mov	r1, #45	; 0x2d
34818ab4:	eb000f0c 	bl	3481c6ec <strrchr>
		if (tmp) {
34818ab8:	e3500000 	cmp	r0, #0
34818abc:	0a00000d 	beq	34818af8 <usb_ep_autoconfig+0xa0>
			switch (type) {
34818ac0:	e3560002 	cmp	r6, #2
34818ac4:	0a000005 	beq	34818ae0 <usb_ep_autoconfig+0x88>
34818ac8:	e3560003 	cmp	r6, #3
34818acc:	e5d03002 	ldrb	r3, [r0, #2]
34818ad0:	1a000005 	bne	34818aec <usb_ep_autoconfig+0x94>
			case USB_ENDPOINT_XFER_INT:
				/* bulk endpoints handle interrupt transfers,
				 * except the toggle-quirky iso-synch kind
				 */
				if ('s' == tmp[2])	/* == "-iso" */
34818ad4:	e3530073 	cmp	r3, #115	; 0x73
34818ad8:	1a00000c 	bne	34818b10 <usb_ep_autoconfig+0xb8>
34818adc:	ea00005d 	b	34818c58 <usb_ep_autoconfig+0x200>
				if (gadget_is_pxa(gadget)
						&& 'i' == tmp[1])
					return 0;
				break;
			case USB_ENDPOINT_XFER_BULK:
				if ('b' != tmp[1])	/* != "-bulk" */
34818ae0:	e5d03001 	ldrb	r3, [r0, #1]
34818ae4:	e3530062 	cmp	r3, #98	; 0x62
34818ae8:	ea000000 	b	34818af0 <usb_ep_autoconfig+0x98>
					return 0;
				break;
			case USB_ENDPOINT_XFER_ISOC:
				if ('s' != tmp[2])	/* != "-iso" */
34818aec:	e3530073 	cmp	r3, #115	; 0x73
34818af0:	1a000058 	bne	34818c58 <usb_ep_autoconfig+0x200>
34818af4:	ea000005 	b	34818b10 <usb_ep_autoconfig+0xb8>
					return 0;
			}
		} else {
			tmp = ep->name + strlen(ep->name);
34818af8:	e5943004 	ldr	r3, [r4, #4]
34818afc:	e1a00003 	mov	r0, r3
34818b00:	e58d3000 	str	r3, [sp]
34818b04:	eb000edc 	bl	3481c67c <strlen>
34818b08:	e59d3000 	ldr	r3, [sp]
34818b0c:	e0830000 	add	r0, r3, r0
		}

		/* direction-restriction:  "..in-..", "out-.." */
		tmp--;
		if (!isdigit(*tmp)) {
34818b10:	e5503001 	ldrb	r3, [r0, #-1]
34818b14:	e2432030 	sub	r2, r3, #48	; 0x30
34818b18:	e6ef2072 	uxtb	r2, r2
34818b1c:	e3520009 	cmp	r2, #9
34818b20:	9a000006 	bls	34818b40 <usb_ep_autoconfig+0xe8>
			if (desc->bEndpointAddress & USB_DIR_IN) {
34818b24:	e1d520d2 	ldrsb	r2, [r5, #2]
34818b28:	e3520000 	cmp	r2, #0
34818b2c:	aa000001 	bge	34818b38 <usb_ep_autoconfig+0xe0>
				if ('n' != *tmp)
34818b30:	e353006e 	cmp	r3, #110	; 0x6e
34818b34:	ea000000 	b	34818b3c <usb_ep_autoconfig+0xe4>
					return 0;
			} else {
				if ('t' != *tmp)
34818b38:	e3530074 	cmp	r3, #116	; 0x74
34818b3c:	1a000045 	bne	34818c58 <usb_ep_autoconfig+0x200>

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34818b40:	e5d52004 	ldrb	r2, [r5, #4]
34818b44:	e5d50005 	ldrb	r0, [r5, #5]
	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
	switch (type) {
34818b48:	e3560001 	cmp	r6, #1
34818b4c:	e1820400 	orr	r0, r2, r0, lsl #8

	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
34818b50:	e1a02a80 	lsl	r2, r0, #21
34818b54:	e2853004 	add	r3, r5, #4
34818b58:	e285c005 	add	ip, r5, #5
34818b5c:	e1a02aa2 	lsr	r2, r2, #21
	switch (type) {
34818b60:	0a00000a 	beq	34818b90 <usb_ep_autoconfig+0x138>
34818b64:	e3560003 	cmp	r6, #3
34818b68:	1a000018 	bne	34818bd0 <usb_ep_autoconfig+0x178>
	case USB_ENDPOINT_XFER_INT:
		/* INT:  limit 64 bytes full speed, 1024 high speed */
		if (!gadget->is_dualspeed && max > 64)
34818b6c:	e5da1014 	ldrb	r1, [sl, #20]
34818b70:	e3110001 	tst	r1, #1
34818b74:	13a01000 	movne	r1, #0
34818b78:	03a01001 	moveq	r1, #1
34818b7c:	e3520040 	cmp	r2, #64	; 0x40
34818b80:	93a01000 	movls	r1, #0
34818b84:	82011001 	andhi	r1, r1, #1
34818b88:	e3510000 	cmp	r1, #0
34818b8c:	1a000031 	bne	34818c58 <usb_ep_autoconfig+0x200>
			return 0;
		/* FALLTHROUGH */

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
34818b90:	e1d411b4 	ldrh	r1, [r4, #20]
34818b94:	e1510002 	cmp	r1, r2
34818b98:	3a00002e 	bcc	34818c58 <usb_ep_autoconfig+0x200>
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
34818b9c:	e5da1014 	ldrb	r1, [sl, #20]
34818ba0:	e3110001 	tst	r1, #1
34818ba4:	13a01000 	movne	r1, #0
34818ba8:	03a01001 	moveq	r1, #1
34818bac:	e152000b 	cmp	r2, fp
34818bb0:	93a02000 	movls	r2, #0
34818bb4:	82012001 	andhi	r2, r1, #1
34818bb8:	e3520000 	cmp	r2, #0
34818bbc:	1a000025 	bne	34818c58 <usb_ep_autoconfig+0x200>
			return 0;

		/* BOTH:  "high bandwidth" works only at high speed */
		if ((get_unaligned(&desc->wMaxPacketSize) &
34818bc0:	e3100b06 	tst	r0, #6144	; 0x1800
34818bc4:	0a000001 	beq	34818bd0 <usb_ep_autoconfig+0x178>
					__constant_cpu_to_le16(3<<11))) {
			if (!gadget->is_dualspeed)
34818bc8:	e3510000 	cmp	r1, #0
34818bcc:	1a000021 	bne	34818c58 <usb_ep_autoconfig+0x200>
	}

	/* MATCH!! */

	/* report address */
	if (isdigit(ep->name[2])) {
34818bd0:	e5942004 	ldr	r2, [r4, #4]
34818bd4:	e2820002 	add	r0, r2, #2
34818bd8:	e5d22002 	ldrb	r2, [r2, #2]
34818bdc:	e2422030 	sub	r2, r2, #48	; 0x30
34818be0:	e6ef2072 	uxtb	r2, r2
34818be4:	e3520009 	cmp	r2, #9
34818be8:	8a000009 	bhi	34818c14 <usb_ep_autoconfig+0x1bc>
		u8	num = simple_strtoul(&ep->name[2], NULL, 10);
34818bec:	e3a0200a 	mov	r2, #10
34818bf0:	e3a01000 	mov	r1, #0
34818bf4:	e88d1008 	stm	sp, {r3, ip}
34818bf8:	eb001232 	bl	3481d4c8 <simple_strtoul>
		desc->bEndpointAddress |= num;
34818bfc:	e5d52002 	ldrb	r2, [r5, #2]
34818c00:	e59d3000 	ldr	r3, [sp]
34818c04:	e1802002 	orr	r2, r0, r2
34818c08:	e5c52002 	strb	r2, [r5, #2]
34818c0c:	e59dc004 	ldr	ip, [sp, #4]
34818c10:	ea000007 	b	34818c34 <usb_ep_autoconfig+0x1dc>
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
34818c14:	e5992000 	ldr	r2, [r9]
34818c18:	e2822001 	add	r2, r2, #1
34818c1c:	e352000f 	cmp	r2, #15
34818c20:	e5892000 	str	r2, [r9]
34818c24:	8a00000b 	bhi	34818c58 <usb_ep_autoconfig+0x200>
			return 0;
		desc->bEndpointAddress |= epnum;
34818c28:	e5d51002 	ldrb	r1, [r5, #2]
34818c2c:	e1822001 	orr	r2, r2, r1
34818c30:	e5c52002 	strb	r2, [r5, #2]
	}

	/* report (variable) full speed bulk maxpacket */
	if (USB_ENDPOINT_XFER_BULK == type) {
34818c34:	e3560002 	cmp	r6, #2
34818c38:	1a00000c 	bne	34818c70 <usb_ep_autoconfig+0x218>
		int size = ep->maxpacket;
34818c3c:	e1d421b4 	ldrh	r2, [r4, #20]

		/* min() doesn't work on bitfields with gcc-3.5 */
		if (size > 64)
			size = 64;
		put_unaligned(cpu_to_le16(size), &desc->wMaxPacketSize);
34818c40:	e3520040 	cmp	r2, #64	; 0x40
34818c44:	a3a02040 	movge	r2, #64	; 0x40
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
34818c48:	e5c32000 	strb	r2, [r3]
	*p++ = val >> 8;
34818c4c:	e3a03000 	mov	r3, #0
34818c50:	e5cc3000 	strb	r3, [ip]
34818c54:	ea000005 	b	34818c70 <usb_ep_autoconfig+0x218>
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818c58:	e594400c 	ldr	r4, [r4, #12]
34818c5c:	e244400c 	sub	r4, r4, #12
34818c60:	e284300c 	add	r3, r4, #12
34818c64:	e1530007 	cmp	r3, r7
34818c68:	1affff83 	bne	34818a7c <usb_ep_autoconfig+0x24>
		if (ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Fail */
	return NULL;
34818c6c:	e3a04000 	mov	r4, #0
}
34818c70:	e1a00004 	mov	r0, r4
34818c74:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34818c78:	3482bebc 	.word	0x3482bebc

34818c7c <usb_ep_autoconfig_reset>:
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818c7c:	e5b03008 	ldr	r3, [r0, #8]!
		ep->driver_data = NULL;
34818c80:	e3a02000 	mov	r2, #0
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818c84:	e243300c 	sub	r3, r3, #12
34818c88:	ea000002 	b	34818c98 <usb_ep_autoconfig_reset+0x1c>
		ep->driver_data = NULL;
34818c8c:	e5832000 	str	r2, [r3]
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818c90:	e593300c 	ldr	r3, [r3, #12]
34818c94:	e243300c 	sub	r3, r3, #12
34818c98:	e283100c 	add	r1, r3, #12
34818c9c:	e1510000 	cmp	r1, r0
34818ca0:	1afffff9 	bne	34818c8c <usb_ep_autoconfig_reset+0x10>
		ep->driver_data = NULL;
	}
#ifdef	MANY_ENDPOINTS
	in_epnum = 0;
#endif
	epnum = 0;
34818ca4:	e59f3008 	ldr	r3, [pc, #8]	; 34818cb4 <usb_ep_autoconfig_reset+0x38>
34818ca8:	e3a02000 	mov	r2, #0
34818cac:	e5832000 	str	r2, [r3]
}
34818cb0:	e12fff1e 	bx	lr
34818cb4:	3482bebc 	.word	0x3482bebc

34818cb8 <usb_descriptor_fillbuf>:
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
34818cb8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8	*dest = buf;

	if (!src)
34818cbc:	e252a000 	subs	sl, r2, #0
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
34818cc0:	e1a07000 	mov	r7, r0
34818cc4:	e1a06001 	mov	r6, r1
	u8	*dest = buf;
34818cc8:	11a04000 	movne	r4, r0

	if (!src)
34818ccc:	1a000008 	bne	34818cf4 <usb_descriptor_fillbuf+0x3c>
34818cd0:	ea00000c 	b	34818d08 <usb_descriptor_fillbuf+0x50>
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;
34818cd4:	e5d15000 	ldrb	r5, [r1]

		if (len > buflen)
34818cd8:	e1550006 	cmp	r5, r6
34818cdc:	8a00000b 	bhi	34818d10 <usb_descriptor_fillbuf+0x58>
			return -EINVAL;
		memcpy(dest, *src, len);
34818ce0:	e1a00004 	mov	r0, r4
34818ce4:	e1a02005 	mov	r2, r5
34818ce8:	eb000f27 	bl	3481c98c <memcpy>
		buflen -= len;
34818cec:	e0656006 	rsb	r6, r5, r6
		dest += len;
34818cf0:	e0844005 	add	r4, r4, r5

	if (!src)
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
34818cf4:	e49a1004 	ldr	r1, [sl], #4
34818cf8:	e3510000 	cmp	r1, #0
34818cfc:	1afffff4 	bne	34818cd4 <usb_descriptor_fillbuf+0x1c>
			return -EINVAL;
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
34818d00:	e0670004 	rsb	r0, r7, r4
34818d04:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		const struct usb_descriptor_header **src)
{
	u8	*dest = buf;

	if (!src)
		return -EINVAL;
34818d08:	e3e00015 	mvn	r0, #21
34818d0c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;

		if (len > buflen)
			return -EINVAL;
34818d10:	e3e00015 	mvn	r0, #21
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
}
34818d14:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34818d18 <usb_gadget_config_buf>:
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818d18:	e3530000 	cmp	r3, #0
34818d1c:	13520008 	cmpne	r2, #8
	const struct usb_config_descriptor	*config,
	void					*buf,
	unsigned				length,
	const struct usb_descriptor_header	**desc
)
{
34818d20:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34818d24:	e1a0c000 	mov	ip, r0
34818d28:	e1a04001 	mov	r4, r1
34818d2c:	e1a05002 	mov	r5, r2
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818d30:	e1a07003 	mov	r7, r3
		return -EINVAL;
34818d34:	93e00015 	mvnls	r0, #21
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818d38:	98bd80f8 	popls	{r3, r4, r5, r6, r7, pc}
		return -EINVAL;
	*cp = *config;
34818d3c:	e3a06009 	mov	r6, #9
34818d40:	e1a00001 	mov	r0, r1
34818d44:	e1a02006 	mov	r2, r6
34818d48:	e1a0100c 	mov	r1, ip
34818d4c:	eb000f0e 	bl	3481c98c <memcpy>

	/* then interface/endpoint/class/vendor/... */
	len = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8 *)buf,
34818d50:	e0840006 	add	r0, r4, r6
34818d54:	e2451009 	sub	r1, r5, #9
34818d58:	e1a02007 	mov	r2, r7
34818d5c:	ebffffd5 	bl	34818cb8 <usb_descriptor_fillbuf>
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
34818d60:	e3500000 	cmp	r0, #0
34818d64:	b8bd80f8 	poplt	{r3, r4, r5, r6, r7, pc}
		return len;
	len += USB_DT_CONFIG_SIZE;
34818d68:	e0800006 	add	r0, r0, r6
	if (len > 0xffff)
34818d6c:	e3500801 	cmp	r0, #65536	; 0x10000
34818d70:	aa00000b 	bge	34818da4 <usb_gadget_config_buf+0x8c>
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
34818d74:	e3a03002 	mov	r3, #2
34818d78:	e5c43001 	strb	r3, [r4, #1]
	cp->wTotalLength = cpu_to_le16(len);
34818d7c:	e6ff3070 	uxth	r3, r0
34818d80:	e5c43002 	strb	r3, [r4, #2]
34818d84:	e1a03423 	lsr	r3, r3, #8
34818d88:	e5c43003 	strb	r3, [r4, #3]
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
34818d8c:	e5d43007 	ldrb	r3, [r4, #7]
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
34818d90:	e5c46000 	strb	r6, [r4]
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
34818d94:	e1e03c83 	mvn	r3, r3, lsl #25
34818d98:	e1e03ca3 	mvn	r3, r3, lsr #25
34818d9c:	e5c43007 	strb	r3, [r4, #7]
	return len;
34818da0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
		return len;
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;
34818da4:	e3e00015 	mvn	r0, #21
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
	return len;
}
34818da8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34818dac <usb_gadget_get_string>:
{
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
34818dac:	e3510000 	cmp	r1, #0
 * the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
 * characters (which are also widely used in C strings).
 */
int
usb_gadget_get_string(struct usb_gadget_strings *table, int id, u8 *buf)
{
34818db0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34818db4:	e1a04002 	mov	r4, r2
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
34818db8:	1a00000a 	bne	34818de8 <usb_gadget_get_string+0x3c>
		buf[0] = 4;
34818dbc:	e3a03004 	mov	r3, #4
34818dc0:	e5c23000 	strb	r3, [r2]
		buf[1] = USB_DT_STRING;
34818dc4:	e3a02003 	mov	r2, #3
34818dc8:	e5c42001 	strb	r2, [r4, #1]
		buf[2] = (u8) table->language;
34818dcc:	e1d020b0 	ldrh	r2, [r0]
34818dd0:	e5c42002 	strb	r2, [r4, #2]
		buf[3] = (u8) (table->language >> 8);
34818dd4:	e1d020b0 	ldrh	r2, [r0]
		return 4;
34818dd8:	e1a00003 	mov	r0, r3
	/* descriptor 0 has the language id */
	if (id == 0) {
		buf[0] = 4;
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
34818ddc:	e1a02422 	lsr	r2, r2, #8
34818de0:	e5c42003 	strb	r2, [r4, #3]
		return 4;
34818de4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	for (s = table->strings; s && s->s; s++)
34818de8:	e5905004 	ldr	r5, [r0, #4]
34818dec:	ea000003 	b	34818e00 <usb_gadget_get_string+0x54>
		if (s->id == id)
34818df0:	e5d53000 	ldrb	r3, [r5]
34818df4:	e1530001 	cmp	r3, r1
34818df8:	0a000006 	beq	34818e18 <usb_gadget_get_string+0x6c>
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
		return 4;
	}
	for (s = table->strings; s && s->s; s++)
34818dfc:	e2855008 	add	r5, r5, #8
34818e00:	e3550000 	cmp	r5, #0
34818e04:	0a000041 	beq	34818f10 <usb_gadget_get_string+0x164>
34818e08:	e5950004 	ldr	r0, [r5, #4]
34818e0c:	e3500000 	cmp	r0, #0
34818e10:	1afffff6 	bne	34818df0 <usb_gadget_get_string+0x44>
34818e14:	ea00003d 	b	34818f10 <usb_gadget_get_string+0x164>
	/* unrecognized: stall. */
	if (!s || !s->s)
		return -EINVAL;

	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
34818e18:	eb000e17 	bl	3481c67c <strlen>
34818e1c:	e350007e 	cmp	r0, #126	; 0x7e
34818e20:	31a06000 	movcc	r6, r0
34818e24:	23a0607e 	movcs	r6, #126	; 0x7e
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
34818e28:	e3a01000 	mov	r1, #0
34818e2c:	e2840002 	add	r0, r4, #2
34818e30:	e1a02086 	lsl	r2, r6, #1
34818e34:	eb000eb0 	bl	3481c8fc <memset>
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
34818e38:	e5953004 	ldr	r3, [r5, #4]
34818e3c:	e1a01004 	mov	r1, r4
#include <asm/unaligned.h>


static int utf8_to_utf16le(const char *s, __le16 *cp, unsigned len)
{
	int	count = 0;
34818e40:	e3a00000 	mov	r0, #0
					goto fail;
				c &= 0x3f;
				uchar |= c;

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
34818e44:	e30057ff 	movw	r5, #2047	; 0x7ff
34818e48:	ea00002a 	b	34818ef8 <usb_gadget_get_string+0x14c>
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
		if ((c & 0x80)) {
34818e4c:	e3120080 	tst	r2, #128	; 0x80
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
34818e50:	e2833001 	add	r3, r3, #1
		if ((c & 0x80)) {
34818e54:	0a000022 	beq	34818ee4 <usb_gadget_get_string+0x138>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
34818e58:	e202c0e0 	and	ip, r2, #224	; 0xe0
34818e5c:	e35c00c0 	cmp	ip, #192	; 0xc0
34818e60:	1a000008 	bne	34818e88 <usb_gadget_get_string+0xdc>
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
34818e64:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
34818e68:	e20c70c0 	and	r7, ip, #192	; 0xc0
34818e6c:	e3570080 	cmp	r7, #128	; 0x80
34818e70:	1a000026 	bne	34818f10 <usb_gadget_get_string+0x164>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;
34818e74:	e202201f 	and	r2, r2, #31

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818e78:	e20cc03f 	and	ip, ip, #63	; 0x3f
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
34818e7c:	e2833001 	add	r3, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818e80:	e18c2302 	orr	r2, ip, r2, lsl #6
34818e84:	ea000016 	b	34818ee4 <usb_gadget_get_string+0x138>

			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
34818e88:	e202c0f0 	and	ip, r2, #240	; 0xf0
34818e8c:	e35c00e0 	cmp	ip, #224	; 0xe0
34818e90:	1a00001e 	bne	34818f10 <usb_gadget_get_string+0x164>
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
34818e94:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
34818e98:	e20c70c0 	and	r7, ip, #192	; 0xc0
34818e9c:	e3570080 	cmp	r7, #128	; 0x80
34818ea0:	1a00001a 	bne	34818f10 <usb_gadget_get_string+0x164>
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
34818ea4:	e2837001 	add	r7, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
34818ea8:	e5d33001 	ldrb	r3, [r3, #1]
				if ((c & 0xc0) != 0x80)
34818eac:	e203a0c0 	and	sl, r3, #192	; 0xc0
34818eb0:	e35a0080 	cmp	sl, #128	; 0x80
34818eb4:	1a000015 	bne	34818f10 <usb_gadget_get_string+0x164>

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818eb8:	e20cc03f 	and	ip, ip, #63	; 0x3f
			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;
34818ebc:	e1a02602 	lsl	r2, r2, #12

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818ec0:	e182230c 	orr	r2, r2, ip, lsl #6

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818ec4:	e203303f 	and	r3, r3, #63	; 0x3f

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818ec8:	e6ff2072 	uxth	r2, r2

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818ecc:	e1822003 	orr	r2, r2, r3

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
34818ed0:	e2823b0a 	add	r3, r2, #10240	; 0x2800
34818ed4:	e6ff3073 	uxth	r3, r3
34818ed8:	e1530005 	cmp	r3, r5
34818edc:	9a00000d 	bls	34818f18 <usb_gadget_get_string+0x16c>
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
34818ee0:	e2873001 	add	r3, r7, #1
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
34818ee4:	e5c12002 	strb	r2, [r1, #2]
	*p++ = val >> 8;
34818ee8:	e1a02422 	lsr	r2, r2, #8
34818eec:	e5c12003 	strb	r2, [r1, #3]
			} else
				goto fail;
		} else
			uchar = c;
		put_unaligned_le16(uchar, cp++);
		count++;
34818ef0:	e2800001 	add	r0, r0, #1
34818ef4:	e2811002 	add	r1, r1, #2
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
34818ef8:	e1560000 	cmp	r6, r0
34818efc:	0a000007 	beq	34818f20 <usb_gadget_get_string+0x174>
34818f00:	e5d32000 	ldrb	r2, [r3]
34818f04:	e3520000 	cmp	r2, #0
34818f08:	1affffcf 	bne	34818e4c <usb_gadget_get_string+0xa0>
34818f0c:	ea000003 	b	34818f20 <usb_gadget_get_string+0x174>
	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
34818f10:	e3e00015 	mvn	r0, #21
34818f14:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34818f18:	e3e00015 	mvn	r0, #21
	buf[0] = (len + 1) * 2;
	buf[1] = USB_DT_STRING;
	return buf[0];
}
34818f1c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
34818f20:	e2800001 	add	r0, r0, #1
34818f24:	e1a00080 	lsl	r0, r0, #1
	buf[1] = USB_DT_STRING;
34818f28:	e3a03003 	mov	r3, #3
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
34818f2c:	e5c40000 	strb	r0, [r4]
	buf[1] = USB_DT_STRING;
34818f30:	e5c43001 	strb	r3, [r4, #1]
	return buf[0];
34818f34:	e20000fe 	and	r0, r0, #254	; 0xfe
34818f38:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34818f3c <get_unaligned_le16>:

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34818f3c:	e5d02001 	ldrb	r2, [r0, #1]
34818f40:	e5d03000 	ldrb	r3, [r0]
}

static inline u16 get_unaligned_le16(const void *p)
{
	return __get_unaligned_le16((const u8 *)p);
}
34818f44:	e1830402 	orr	r0, r3, r2, lsl #8
34818f48:	e12fff1e 	bx	lr

34818f4c <set_max_pktsize>:
static void set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
{
	unsigned int ep_ctrl;
	int i;

	if (speed == USB_SPEED_HIGH) {
34818f4c:	e3510003 	cmp	r1, #3
34818f50:	e59f307c 	ldr	r3, [pc, #124]	; 34818fd4 <set_max_pktsize+0x88>
34818f54:	1a000007 	bne	34818f78 <set_max_pktsize+0x2c>
		ep0_fifo_size = 64;
34818f58:	e3a02040 	mov	r2, #64	; 0x40
34818f5c:	e5832000 	str	r2, [r3]
		ep_fifo_size = 512;
34818f60:	e2822d07 	add	r2, r2, #448	; 0x1c0
34818f64:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 1024;
34818f68:	e2822c02 	add	r2, r2, #512	; 0x200
34818f6c:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_HIGH;
34818f70:	e5801010 	str	r1, [r0, #16]
34818f74:	ea000005 	b	34818f90 <set_max_pktsize+0x44>
	} else {
		ep0_fifo_size = 64;
34818f78:	e3a02040 	mov	r2, #64	; 0x40
34818f7c:	e5832000 	str	r2, [r3]
		ep_fifo_size = 64;
34818f80:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 64;
34818f84:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_FULL;
34818f88:	e3a03002 	mov	r3, #2
34818f8c:	e5803010 	str	r3, [r0, #16]
	}

	dev->ep[0].ep.maxpacket = ep0_fifo_size;
34818f90:	e3a03040 	mov	r3, #64	; 0x40
34818f94:	e1c036bc 	strh	r3, [r0, #108]	; 0x6c
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++)
		dev->ep[i].ep.maxpacket = ep_fifo_size;
34818f98:	e59f3034 	ldr	r3, [pc, #52]	; 34818fd4 <set_max_pktsize+0x88>
34818f9c:	e3a02f4b 	mov	r2, #300	; 0x12c
34818fa0:	e1d330b4 	ldrh	r3, [r3, #4]
34818fa4:	e18030b2 	strh	r3, [r0, r2]
34818fa8:	e1c03abc 	strh	r3, [r0, #172]	; 0xac
34818fac:	e1c03ebc 	strh	r3, [r0, #236]	; 0xec

	/* EP0 - Control IN (64 bytes)*/
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34818fb0:	e59f3020 	ldr	r3, [pc, #32]	; 34818fd8 <set_max_pktsize+0x8c>
34818fb4:	e5932000 	ldr	r2, [r3]
34818fb8:	e5921900 	ldr	r1, [r2, #2304]	; 0x900
	writel(ep_ctrl|(0<<0), &reg->in_endp[EP0_CON].diepctl);
34818fbc:	e5932000 	ldr	r2, [r3]
34818fc0:	e5821900 	str	r1, [r2, #2304]	; 0x900

	/* EP0 - Control OUT (64 bytes)*/
	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
34818fc4:	e5922b00 	ldr	r2, [r2, #2816]	; 0xb00
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
34818fc8:	e5933000 	ldr	r3, [r3]
34818fcc:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
}
34818fd0:	e12fff1e 	bx	lr
34818fd4:	348295b4 	.word	0x348295b4
34818fd8:	3482bec0 	.word	0x3482bec0

34818fdc <s3c_fifo_status>:
{
	int count = 0;
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
34818fdc:	e3500000 	cmp	r0, #0
34818fe0:	0a000004 	beq	34818ff8 <s3c_fifo_status+0x1c>
	}

	debug("%s: %d\n", __func__, ep_index(ep));

	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
34818fe4:	e1d033d5 	ldrsb	r3, [r0, #53]	; 0x35
34818fe8:	e3530000 	cmp	r3, #0
		return -EOPNOTSUPP;
34818fec:	a3a00000 	movge	r0, #0
34818ff0:	b3e0005e 	mvnlt	r0, #94	; 0x5e
34818ff4:	e12fff1e 	bx	lr
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
		debug("%s: bad ep\n", __func__);
		return -ENODEV;
34818ff8:	e3e00012 	mvn	r0, #18
	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
		return -EOPNOTSUPP;

	return count;
}
34818ffc:	e12fff1e 	bx	lr

34819000 <s3c_fifo_flush>:
		debug("%s: bad ep\n", __func__);
		return;
	}

	debug("%s: %d\n", __func__, ep_index(ep));
}
34819000:	e12fff1e 	bx	lr

34819004 <reconfig_usbd>:
	/* re-init driver-visible data structures */
	udc_reinit(dev);
}

static void reconfig_usbd(void)
{
34819004:	e92d4038 	push	{r3, r4, r5, lr}
	/* 2. Soft-reset OTG Core and then unreset again. */
	int i;
	unsigned int uTemp = writel(CORE_SOFT_RESET, &reg->grstctl);
34819008:	e59f4170 	ldr	r4, [pc, #368]	; 34819180 <reconfig_usbd+0x17c>
3481900c:	e3a05001 	mov	r5, #1
34819010:	e5943000 	ldr	r3, [r4]
34819014:	e5835010 	str	r5, [r3, #16]

	debug("Reseting OTG controller\n");

	writel(0<<15		/* PHY Low Power Clock sel*/
34819018:	e5943000 	ldr	r3, [r4]
3481901c:	e305240f 	movw	r2, #21519	; 0x540f
34819020:	e583200c 	str	r2, [r3, #12]
		|1<<3		/* phy i/f  0:8bit, 1:16bit*/
		|0x7<<0,	/* HS/FS Timeout**/
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
34819024:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp |= SOFT_DISCONNECT;
34819028:	e3822002 	orr	r2, r2, #2
	writel(uTemp, &reg->dctl);
3481902c:	e5943000 	ldr	r3, [r4]

	udelay(20);
34819030:	e3a00014 	mov	r0, #20
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
	uTemp |= SOFT_DISCONNECT;
	writel(uTemp, &reg->dctl);
34819034:	e5832804 	str	r2, [r3, #2052]	; 0x804

	udelay(20);
34819038:	eb000ede 	bl	3481cbb8 <udelay>

	/* 4. Make the OTG device core exit from the disconnected state.*/
	uTemp = readl(&reg->dctl);
3481903c:	e5943000 	ldr	r3, [r4]
34819040:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp = uTemp & ~SOFT_DISCONNECT;
34819044:	e3c22002 	bic	r2, r2, #2
	writel(uTemp, &reg->dctl);
34819048:	e5943000 	ldr	r3, [r4]
3481904c:	e5832804 	str	r2, [r3, #2052]	; 0x804

	/* 5. Configure OTG Core to initial settings of device mode.*/
	/* [][1: full speed(30Mhz) 0:high speed]*/
	writel(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
34819050:	e5943000 	ldr	r3, [r4]
34819054:	e3a02701 	mov	r2, #262144	; 0x40000
34819058:	e5832800 	str	r2, [r3, #2048]	; 0x800

	mdelay(1);
3481905c:	e1a00005 	mov	r0, r5
34819060:	eb000ee0 	bl	3481cbe8 <mdelay>

	/* 6. Unmask the core interrupts*/
	writel(GINTMSK_INIT, &reg->gintmsk);
34819064:	e59f2118 	ldr	r2, [pc, #280]	; 34819184 <reconfig_usbd+0x180>
34819068:	e5943000 	ldr	r3, [r4]
3481906c:	e5832018 	str	r2, [r3, #24]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
34819070:	e5942000 	ldr	r2, [r4]
34819074:	e3a03312 	mov	r3, #1207959552	; 0x48000000
34819078:	e5823b00 	str	r3, [r2, #2816]	; 0xb00
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);
3481907c:	e5942000 	ldr	r2, [r4]
34819080:	e5823900 	str	r3, [r2, #2304]	; 0x900

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
34819084:	e1a02003 	mov	r2, r3
34819088:	e5941000 	ldr	r1, [r4]
3481908c:	e2850058 	add	r0, r5, #88	; 0x58
34819090:	e7812280 	str	r2, [r1, r0, lsl #5]
34819094:	e59f30e4 	ldr	r3, [pc, #228]	; 34819180 <reconfig_usbd+0x17c>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
34819098:	e2850048 	add	r0, r5, #72	; 0x48
3481909c:	e5941000 	ldr	r1, [r4]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
348190a0:	e2855001 	add	r5, r5, #1
348190a4:	e3550004 	cmp	r5, #4
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
348190a8:	e7812280 	str	r2, [r1, r0, lsl #5]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
348190ac:	1afffff5 	bne	34819088 <reconfig_usbd+0x84>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
	}

	/* 8. Unmask EPO interrupts*/
	writel(((1 << EP0_CON) << DAINT_OUT_BIT)
348190b0:	e59f10d0 	ldr	r1, [pc, #208]	; 34819188 <reconfig_usbd+0x184>
348190b4:	e5932000 	ldr	r2, [r3]
348190b8:	e582181c 	str	r1, [r2, #2076]	; 0x81c
	       | (1 << EP0_CON), &reg->daintmsk);

	/* 9. Unmask device OUT EP common interrupts*/
	writel(DOEPMSK_INIT, &reg->doepmsk);
348190bc:	e5931000 	ldr	r1, [r3]
348190c0:	e3a0200d 	mov	r2, #13
348190c4:	e5812814 	str	r2, [r1, #2068]	; 0x814

	/* 10. Unmask device IN EP common interrupts*/
	writel(DIEPMSK_INIT, &reg->diepmsk);
348190c8:	e5931000 	ldr	r1, [r3]
348190cc:	e5812810 	str	r2, [r1, #2064]	; 0x810

	/* 11. Set Rx FIFO Size (in 32-bit words) */
	writel(RX_FIFO_SIZE >> 2, &reg->grxfsiz);
348190d0:	e5932000 	ldr	r2, [r3]
348190d4:	e3a01b01 	mov	r1, #1024	; 0x400
348190d8:	e5821024 	str	r1, [r2, #36]	; 0x24

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
348190dc:	e5932000 	ldr	r2, [r3]
348190e0:	e2811301 	add	r1, r1, #67108864	; 0x4000000
348190e4:	e5821028 	str	r1, [r2, #40]	; 0x28
348190e8:	e3a01000 	mov	r1, #0
348190ec:	e3a02a02 	mov	r2, #8192	; 0x2000
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
		writel((PTX_FIFO_SIZE >> 2) << 16 |
348190f0:	e1a04142 	asr	r4, r2, #2
348190f4:	e3844506 	orr	r4, r4, #25165824	; 0x1800000
348190f8:	e593c000 	ldr	ip, [r3]
348190fc:	e2822c06 	add	r2, r2, #1536	; 0x600
34819100:	e28ccf41 	add	ip, ip, #260	; 0x104

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
34819104:	e3520c7a 	cmp	r2, #31232	; 0x7a00
		writel((PTX_FIFO_SIZE >> 2) << 16 |
34819108:	e78c4001 	str	r4, [ip, r1]
3481910c:	e59f006c 	ldr	r0, [pc, #108]	; 34819180 <reconfig_usbd+0x17c>
34819110:	e2811004 	add	r1, r1, #4

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
34819114:	1afffff5 	bne	348190f0 <reconfig_usbd+0xec>
		       ((RX_FIFO_SIZE + NPTX_FIFO_SIZE +
			 PTX_FIFO_SIZE*(i-1)) >> 2) << 0,
		       &reg->dieptxf[i-1]);

	/* Flush the RX FIFO */
	writel(RX_FIFO_FLUSH, &reg->grstctl);
34819118:	e5903000 	ldr	r3, [r0]
3481911c:	e3a02010 	mov	r2, #16
34819120:	e5832010 	str	r2, [r3, #16]
	while (readl(&reg->grstctl) & RX_FIFO_FLUSH)
34819124:	e5902000 	ldr	r2, [r0]
34819128:	e59f3050 	ldr	r3, [pc, #80]	; 34819180 <reconfig_usbd+0x17c>
3481912c:	e5922010 	ldr	r2, [r2, #16]
34819130:	e3120010 	tst	r2, #16
34819134:	1afffffa 	bne	34819124 <reconfig_usbd+0x120>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* Flush all the Tx FIFO's */
	writel(TX_FIFO_FLUSH_ALL, &reg->grstctl);
34819138:	e5932000 	ldr	r2, [r3]
3481913c:	e3a01b01 	mov	r1, #1024	; 0x400
34819140:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_FLUSH_ALL | TX_FIFO_FLUSH, &reg->grstctl);
34819144:	e5932000 	ldr	r2, [r3]
34819148:	e2811020 	add	r1, r1, #32
3481914c:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34819150:	e5931000 	ldr	r1, [r3]
34819154:	e59f2024 	ldr	r2, [pc, #36]	; 34819180 <reconfig_usbd+0x17c>
34819158:	e5911010 	ldr	r1, [r1, #16]
3481915c:	e3110020 	tst	r1, #32
34819160:	1afffffa 	bne	34819150 <reconfig_usbd+0x14c>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* 13. Clear NAK bit of EP0, EP1, EP2*/
	/* For Slave mode*/
	/* EP0: Control OUT */
	writel(DEPCTL_EPDIS | DEPCTL_CNAK,
34819164:	e5923000 	ldr	r3, [r2]
34819168:	e3a01311 	mov	r1, #1140850688	; 0x44000000
3481916c:	e5831b00 	str	r1, [r3, #2816]	; 0xb00
	       &reg->out_endp[EP0_CON].doepctl);

	/* 14. Initialize OTG Link Core.*/
	writel(GAHBCFG_INIT, &reg->gahbcfg);
34819170:	e5923000 	ldr	r3, [r2]
34819174:	e3a02027 	mov	r2, #39	; 0x27
34819178:	e5832008 	str	r2, [r3, #8]
}
3481917c:	e8bd8038 	pop	{r3, r4, r5, pc}
34819180:	3482bec0 	.word	0x3482bec0
34819184:	800c3800 	.word	0x800c3800
34819188:	00010001 	.word	0x00010001

3481918c <done>:

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
3481918c:	e92d4038 	push	{r3, r4, r5, lr}
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
static inline void list_del_init(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34819190:	e591c028 	ldr	ip, [r1, #40]	; 0x28
	unsigned int stopped = ep->stopped;
34819194:	e5d05034 	ldrb	r5, [r0, #52]	; 0x34

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
34819198:	e1a04000 	mov	r4, r0
3481919c:	e591002c 	ldr	r0, [r1, #44]	; 0x2c
	unsigned int stopped = ep->stopped;

	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);
348191a0:	e2813028 	add	r3, r1, #40	; 0x28
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348191a4:	e58c0004 	str	r0, [ip, #4]
	prev->next = next;
348191a8:	e580c000 	str	ip, [r0]
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
	list->prev = list;
348191ac:	e581302c 	str	r3, [r1, #44]	; 0x2c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348191b0:	e5813028 	str	r3, [r1, #40]	; 0x28

	if (likely(req->req.status == -EINPROGRESS))
348191b4:	e5913020 	ldr	r3, [r1, #32]
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
348191b8:	e1a00004 	mov	r0, r4
	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
348191bc:	e3730073 	cmn	r3, #115	; 0x73
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
348191c0:	e3a03001 	mov	r3, #1
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
		req->req.status = status;
348191c4:	05812020 	streq	r2, [r1, #32]
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
348191c8:	e5c43034 	strb	r3, [r4, #52]	; 0x34
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
348191cc:	e5913010 	ldr	r3, [r1, #16]
348191d0:	e12fff33 	blx	r3
	spin_lock(&ep->dev->lock);

	debug("callback completed\n");

	ep->stopped = stopped;
348191d4:	e5c45034 	strb	r5, [r4, #52]	; 0x34
}
348191d8:	e8bd8038 	pop	{r3, r4, r5, pc}

348191dc <s3c_dequeue>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
348191dc:	e3500000 	cmp	r0, #0
	kfree(req);
}

/* dequeue JUST ONE request */
static int s3c_dequeue(struct usb_ep *_ep, struct usb_request *_req)
{
348191e0:	e92d4008 	push	{r3, lr}
348191e4:	e1a03001 	mov	r3, r1
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
348191e8:	0a000013 	beq	3481923c <s3c_dequeue+0x60>
348191ec:	e59f2058 	ldr	r2, [pc, #88]	; 3481924c <s3c_dequeue+0x70>
348191f0:	e5901004 	ldr	r1, [r0, #4]
348191f4:	e1510002 	cmp	r1, r2
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
348191f8:	11a02000 	movne	r2, r0
348191fc:	15b21020 	ldrne	r1, [r2, #32]!
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
34819200:	0a00000d 	beq	3481923c <s3c_dequeue+0x60>
34819204:	ea000002 	b	34819214 <s3c_dequeue+0x38>

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
		if (&req->req == _req)
34819208:	e1510003 	cmp	r1, r3
3481920c:	0a000006 	beq	3481922c <s3c_dequeue+0x50>
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
34819210:	e5911028 	ldr	r1, [r1, #40]	; 0x28
34819214:	e2411028 	sub	r1, r1, #40	; 0x28
34819218:	e281c028 	add	ip, r1, #40	; 0x28
3481921c:	e15c0002 	cmp	ip, r2
34819220:	1afffff8 	bne	34819208 <s3c_dequeue+0x2c>
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
34819224:	e1510003 	cmp	r1, r3
34819228:	1a000005 	bne	34819244 <s3c_dequeue+0x68>
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
	}

	done(ep, req, -ECONNRESET);
3481922c:	e3e02067 	mvn	r2, #103	; 0x67
34819230:	ebffffd5 	bl	3481918c <done>

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
34819234:	e3a00000 	mov	r0, #0
34819238:	e8bd8008 	pop	{r3, pc}

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
		return -EINVAL;
3481923c:	e3e00015 	mvn	r0, #21
34819240:	e8bd8008 	pop	{r3, pc}
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
34819244:	e3e00015 	mvn	r0, #21

	done(ep, req, -ECONNRESET);

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
}
34819248:	e8bd8008 	pop	{r3, pc}
3481924c:	348218a0 	.word	0x348218a0

34819250 <nuke>:

/*
 *	nuke - dequeue ALL requests
 */
static void nuke(struct s3c_ep *ep, int status)
{
34819250:	e92d4070 	push	{r4, r5, r6, lr}
34819254:	e1a04000 	mov	r4, r0
34819258:	e1a06001 	mov	r6, r1
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
3481925c:	e2805020 	add	r5, r0, #32
34819260:	ea000003 	b	34819274 <nuke+0x24>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
34819264:	e1a00004 	mov	r0, r4
34819268:	e2411028 	sub	r1, r1, #40	; 0x28
3481926c:	e1a02006 	mov	r2, r6
34819270:	ebffffc5 	bl	3481918c <done>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34819274:	e5941020 	ldr	r1, [r4, #32]
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
34819278:	e1510005 	cmp	r1, r5
3481927c:	1afffff8 	bne	34819264 <nuke+0x14>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
	}
}
34819280:	e8bd8070 	pop	{r4, r5, r6, pc}

34819284 <s3c_ep_disable>:

/*
 * Disable EP
 */
static int s3c_ep_disable(struct usb_ep *_ep)
{
34819284:	e92d4010 	push	{r4, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
34819288:	e2504000 	subs	r4, r0, #0
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
3481928c:	03e00015 	mvneq	r0, #21
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
34819290:	08bd8010 	popeq	{r4, pc}
34819294:	e594301c 	ldr	r3, [r4, #28]
34819298:	e3530000 	cmp	r3, #0
3481929c:	0a000006 	beq	348192bc <s3c_ep_disable+0x38>
	}

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);
348192a0:	e3e0106b 	mvn	r1, #107	; 0x6b
348192a4:	ebffffe9 	bl	34819250 <nuke>

	ep->desc = 0;
348192a8:	e3a00000 	mov	r0, #0
	ep->stopped = 1;
348192ac:	e3a03001 	mov	r3, #1
	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);

	ep->desc = 0;
348192b0:	e584001c 	str	r0, [r4, #28]
	ep->stopped = 1;
348192b4:	e5c43034 	strb	r3, [r4, #52]	; 0x34

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
348192b8:	e8bd8010 	pop	{r4, pc}

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
348192bc:	e3e00015 	mvn	r0, #21

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
}
348192c0:	e8bd8010 	pop	{r4, pc}

348192c4 <s3c_ep0_complete_out>:
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}

static inline void s3c_ep0_complete_out(void)
{
348192c4:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
348192c8:	e59f4034 	ldr	r4, [pc, #52]	; 34819304 <s3c_ep0_complete_out+0x40>
348192cc:	e5940004 	ldr	r0, [r4, #4]
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
348192d0:	e2801901 	add	r1, r0, #16384	; 0x4000
348192d4:	ebff9f87 	bl	348010f8 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
348192d8:	e59f2028 	ldr	r2, [pc, #40]	; 34819308 <s3c_ep0_complete_out+0x44>
348192dc:	e5943000 	ldr	r3, [r4]
348192e0:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
348192e4:	e5942004 	ldr	r2, [r4, #4]
348192e8:	e5943000 	ldr	r3, [r4]
348192ec:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
348192f0:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348192f4:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
348192f8:	e5943000 	ldr	r3, [r4]
348192fc:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
34819300:	e8bd8010 	pop	{r4, pc}
34819304:	3482bec0 	.word	0x3482bec0
34819308:	00080008 	.word	0x00080008

3481930c <setdma_rx>:


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
3481930c:	e92d4070 	push	{r4, r5, r6, lr}
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
34819310:	e5913024 	ldr	r3, [r1, #36]	; 0x24
34819314:	e5912000 	ldr	r2, [r1]

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
34819318:	e5911004 	ldr	r1, [r1, #4]
3481931c:	e1d061b4 	ldrh	r6, [r0, #20]
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
34819320:	e0822003 	add	r2, r2, r3

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34819324:	e5d05035 	ldrb	r5, [r0, #53]	; 0x35

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
34819328:	e0633001 	rsb	r3, r3, r1
3481932c:	e1560003 	cmp	r6, r3
34819330:	21a06003 	movcs	r6, r3

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34819334:	e5903018 	ldr	r3, [r0, #24]

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34819338:	e205500f 	and	r5, r5, #15

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
3481933c:	e0833105 	add	r3, r3, r5, lsl #2
	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;
34819340:	e5802030 	str	r2, [r0, #48]	; 0x30

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
34819344:	e580602c 	str	r6, [r0, #44]	; 0x2c

}


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
34819348:	e1a04000 	mov	r4, r0

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
3481934c:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
34819350:	e2801901 	add	r1, r0, #16384	; 0x4000
34819354:	ebff9f67 	bl	348010f8 <invalidate_dcache_range>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;

	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);
34819358:	e59f3050 	ldr	r3, [pc, #80]	; 348193b0 <setdma_rx+0xa4>
3481935c:	e2852058 	add	r2, r5, #88	; 0x58
34819360:	e5931000 	ldr	r1, [r3]
34819364:	e7911282 	ldr	r1, [r1, r2, lsl #5]

	writel(the_controller->dma_addr[ep_index(ep)+1],
34819368:	e5d4c035 	ldrb	ip, [r4, #53]	; 0x35
3481936c:	e5930008 	ldr	r0, [r3, #8]
34819370:	e20cc00f 	and	ip, ip, #15
34819374:	e28cc011 	add	ip, ip, #17
34819378:	e790c10c 	ldr	ip, [r0, ip, lsl #2]
3481937c:	e5930000 	ldr	r0, [r3]
34819380:	e1a05285 	lsl	r5, r5, #5
34819384:	e2855eb1 	add	r5, r5, #2832	; 0xb10
34819388:	e0800005 	add	r0, r0, r5
3481938c:	e580c004 	str	ip, [r0, #4]
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
34819390:	e3866702 	orr	r6, r6, #524288	; 0x80000
34819394:	e5930000 	ldr	r0, [r3]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
34819398:	e3811321 	orr	r1, r1, #-2080374784	; 0x84000000
	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
3481939c:	e7806005 	str	r6, [r0, r5]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
348193a0:	e5933000 	ldr	r3, [r3]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
348193a4:	e3a00000 	mov	r0, #0

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
348193a8:	e7831282 	str	r1, [r3, r2, lsl #5]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
348193ac:	e8bd8070 	pop	{r4, r5, r6, pc}
348193b0:	3482bec0 	.word	0x3482bec0

348193b4 <s3c_free_request>:
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
348193b4:	e5912028 	ldr	r2, [r1, #40]	; 0x28
348193b8:	e2813028 	add	r3, r1, #40	; 0x28
348193bc:	e1520003 	cmp	r2, r3

	return &req->req;
}

static void s3c_free_request(struct usb_ep *ep, struct usb_request *_req)
{
348193c0:	e92d4010 	push	{r4, lr}
348193c4:	e1a04001 	mov	r4, r1
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
348193c8:	0a000003 	beq	348193dc <s3c_free_request+0x28>
348193cc:	e59f0014 	ldr	r0, [pc, #20]	; 348193e8 <s3c_free_request+0x34>
348193d0:	e59f1014 	ldr	r1, [pc, #20]	; 348193ec <s3c_free_request+0x38>
348193d4:	e3a02faf 	mov	r2, #700	; 0x2bc
348193d8:	ebffc1f6 	bl	34809bb8 <printf>
	kfree(req);
348193dc:	e1a00004 	mov	r0, r4
}
348193e0:	e8bd4010 	pop	{r4, lr}

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
	kfree(req);
348193e4:	eaffc331 	b	3480a0b0 <free>
348193e8:	348280d4 	.word	0x348280d4
348193ec:	348280eb 	.word	0x348280eb

348193f0 <s3c_alloc_request>:
	return 0;
}

static struct usb_request *s3c_alloc_request(struct usb_ep *ep,
					     gfp_t gfp_flags)
{
348193f0:	e92d4010 	push	{r4, lr}
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->name, ep);

	req = memalign(CONFIG_SYS_CACHELINE_SIZE, sizeof(*req));
348193f4:	e3a00040 	mov	r0, #64	; 0x40
348193f8:	e3a01030 	mov	r1, #48	; 0x30
348193fc:	ebffc559 	bl	3480a968 <memalign>
	if (!req)
34819400:	e2504000 	subs	r4, r0, #0
34819404:	0a000005 	beq	34819420 <s3c_alloc_request+0x30>
		return 0;

	memset(req, 0, sizeof *req);
34819408:	e3a01000 	mov	r1, #0
3481940c:	e3a02030 	mov	r2, #48	; 0x30
34819410:	eb000d39 	bl	3481c8fc <memset>
	INIT_LIST_HEAD(&req->queue);
34819414:	e2843028 	add	r3, r4, #40	; 0x28
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819418:	e5843028 	str	r3, [r4, #40]	; 0x28
	list->prev = list;
3481941c:	e584302c 	str	r3, [r4, #44]	; 0x2c

	return &req->req;
}
34819420:	e1a00004 	mov	r0, r4
34819424:	e8bd8010 	pop	{r4, pc}

34819428 <s3c_udc_ep0_zlp.clone.2>:

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
34819428:	e92d4038 	push	{r3, r4, r5, lr}
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
3481942c:	e59f4040 	ldr	r4, [pc, #64]	; 34819474 <s3c_udc_ep0_zlp.clone.2+0x4c>

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
34819430:	e1a05000 	mov	r5, r0
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
34819434:	e5940004 	ldr	r0, [r4, #4]

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
34819438:	e2801901 	add	r1, r0, #16384	; 0x4000
3481943c:	ebff9f36 	bl	3480111c <flush_dcache_range>
			   (unsigned long) usb_ctrl_dma_addr
			   + DMA_BUFFER_SIZE);

	writel(usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
34819440:	e5942004 	ldr	r2, [r4, #4]
34819444:	e5943000 	ldr	r3, [r4]
34819448:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1), &reg->in_endp[EP0_CON].dieptsiz);
3481944c:	e5943000 	ldr	r3, [r4]
34819450:	e3a02702 	mov	r2, #524288	; 0x80000
34819454:	e5832910 	str	r2, [r3, #2320]	; 0x910

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34819458:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
3481945c:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34819460:	e5943000 	ldr	r3, [r4]
34819464:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);

	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
34819468:	e3a03007 	mov	r3, #7
3481946c:	e5853000 	str	r3, [r5]
}
34819470:	e8bd8038 	pop	{r3, r4, r5, pc}
34819474:	3482bec0 	.word	0x3482bec0

34819478 <complete_rx>:

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
34819478:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
3481947c:	e1a05001 	mov	r5, r1
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34819480:	e1a01301 	lsl	r1, r1, #6
34819484:	e0802001 	add	r2, r0, r1
34819488:	e59f3134 	ldr	r3, [pc, #308]	; 348195c4 <complete_rx+0x14c>

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
3481948c:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34819490:	e5d2008d 	ldrb	r0, [r2, #141]	; 0x8d
34819494:	e593c008 	ldr	ip, [r3, #8]

	if (list_empty(&ep->queue)) {
34819498:	e2811078 	add	r1, r1, #120	; 0x78
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
3481949c:	e5926078 	ldr	r6, [r2, #120]	; 0x78
348194a0:	e0841001 	add	r1, r4, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
348194a4:	e200000f 	and	r0, r0, #15
348194a8:	e08c0100 	add	r0, ip, r0, lsl #2

	if (list_empty(&ep->queue)) {
348194ac:	e1560001 	cmp	r6, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
348194b0:	e5909030 	ldr	r9, [r0, #48]	; 0x30

	if (list_empty(&ep->queue)) {
348194b4:	e58d100c 	str	r1, [sp, #12]
348194b8:	0a00003f 	beq	348195bc <complete_rx+0x144>
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
348194bc:	e5933000 	ldr	r3, [r3]
			   __func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
348194c0:	e246c028 	sub	ip, r6, #40	; 0x28
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
348194c4:	e0833285 	add	r3, r3, r5, lsl #5
348194c8:	e5933b10 	ldr	r3, [r3, #2832]	; 0xb10
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348194cc:	e285b002 	add	fp, r5, #2
	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
348194d0:	e3550000 	cmp	r5, #0
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348194d4:	e084b30b 	add	fp, r4, fp, lsl #6
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
348194d8:	11a03883 	lslne	r3, r3, #17

	xfer_size = ep->len - xfer_size;
348194dc:	e59b2004 	ldr	r2, [fp, #4]

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
348194e0:	0203307f 	andeq	r3, r3, #127	; 0x7f
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
348194e4:	11a038a3 	lsrne	r3, r3, #17
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
348194e8:	e1a0a305 	lsl	sl, r5, #6
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348194ec:	e0633002 	rsb	r3, r3, r2
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
348194f0:	e28a7058 	add	r7, sl, #88	; 0x58
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
348194f4:	e1a00009 	mov	r0, r9
348194f8:	e2891901 	add	r1, r9, #16384	; 0x4000
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
348194fc:	e084a00a 	add	sl, r4, sl
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
34819500:	e98d1008 	stmib	sp, {r3, ip}
34819504:	ebff9efb 	bl	348010f8 <invalidate_dcache_range>
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
34819508:	e1a01009 	mov	r1, r9
3481950c:	e59b2004 	ldr	r2, [fp, #4]
34819510:	e59a0088 	ldr	r0, [sl, #136]	; 0x88
34819514:	eb000d1c 	bl	3481c98c <memcpy>

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819518:	e5161004 	ldr	r1, [r6, #-4]
3481951c:	e5162024 	ldr	r2, [r6, #-36]	; 0x24
34819520:	e59d3004 	ldr	r3, [sp, #4]
34819524:	e0610002 	rsb	r0, r1, r2
34819528:	e1530000 	cmp	r3, r0
3481952c:	90811003 	addls	r1, r1, r3
34819530:	80811000 	addhi	r1, r1, r0
	is_short = (xfer_size < ep->ep.maxpacket);
34819534:	e1da06bc 	ldrh	r0, [sl, #108]	; 0x6c
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34819538:	e0847007 	add	r7, r4, r7
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
3481953c:	e1530000 	cmp	r3, r0
	invalidate_dcache_range((unsigned long) p,
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819540:	e5061004 	str	r1, [r6, #-4]
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34819544:	e59dc008 	ldr	ip, [sp, #8]
34819548:	3a000003 	bcc	3481955c <complete_rx+0xe4>
3481954c:	e1510002 	cmp	r1, r2
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
34819550:	11a00007 	movne	r0, r7
34819554:	11a0100c 	movne	r1, ip
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34819558:	1a000014 	bne	348195b0 <complete_rx+0x138>
		if (ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
3481955c:	e3550000 	cmp	r5, #0
34819560:	1a000007 	bne	34819584 <complete_rx+0x10c>
34819564:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819568:	e3530004 	cmp	r3, #4
3481956c:	1a000004 	bne	34819584 <complete_rx+0x10c>
			debug_cond(DEBUG_OUT_EP != 0, "	=> Send ZLP\n");
			s3c_udc_ep0_zlp(dev);
34819570:	e2840054 	add	r0, r4, #84	; 0x54
34819574:	ebffffab 	bl	34819428 <s3c_udc_ep0_zlp.clone.2>
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
34819578:	e3a03007 	mov	r3, #7
3481957c:	e5843054 	str	r3, [r4, #84]	; 0x54
34819580:	ea00000d 	b	348195bc <complete_rx+0x144>
		} else {
			done(ep, req, 0);
34819584:	e1a00007 	mov	r0, r7
34819588:	e1a0100c 	mov	r1, ip
3481958c:	e3a02000 	mov	r2, #0
34819590:	e0844305 	add	r4, r4, r5, lsl #6
34819594:	ebfffefc 	bl	3481918c <done>
34819598:	e5941078 	ldr	r1, [r4, #120]	; 0x78

			if (!list_empty(&ep->queue)) {
3481959c:	e59d200c 	ldr	r2, [sp, #12]
348195a0:	e1510002 	cmp	r1, r2
				req = list_entry(ep->queue.next,
					struct s3c_request, queue);
				debug_cond(DEBUG_OUT_EP != 0,
					   "%s: Next Rx request start...\n",
					   __func__);
				setdma_rx(ep, req);
348195a4:	11a00007 	movne	r0, r7
348195a8:	12411028 	subne	r1, r1, #40	; 0x28
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
		} else {
			done(ep, req, 0);

			if (!list_empty(&ep->queue)) {
348195ac:	0a000002 	beq	348195bc <complete_rx+0x144>
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
}
348195b0:	e28dd010 	add	sp, sp, #16
348195b4:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
348195b8:	eaffff53 	b	3481930c <setdma_rx>
}
348195bc:	e28dd010 	add	sp, sp, #16
348195c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348195c4:	3482bec0 	.word	0x3482bec0

348195c8 <udc_set_address>:
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
348195c8:	e92d4038 	push	{r3, r4, r5, lr}
	u32 ctrl = readl(&reg->dcfg);
348195cc:	e59f3028 	ldr	r3, [pc, #40]	; 348195fc <udc_set_address+0x34>
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
348195d0:	e1a04000 	mov	r4, r0
	u32 ctrl = readl(&reg->dcfg);
348195d4:	e5932000 	ldr	r2, [r3]
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
348195d8:	e1a05001 	mov	r5, r1
	u32 ctrl = readl(&reg->dcfg);
348195dc:	e5922800 	ldr	r2, [r2, #2048]	; 0x800
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
348195e0:	e1822201 	orr	r2, r2, r1, lsl #4
348195e4:	e5933000 	ldr	r3, [r3]

	s3c_udc_ep0_zlp(dev);
348195e8:	e2800054 	add	r0, r0, #84	; 0x54
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
	u32 ctrl = readl(&reg->dcfg);
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
348195ec:	e5832800 	str	r2, [r3, #2048]	; 0x800

	s3c_udc_ep0_zlp(dev);
348195f0:	ebffff8c 	bl	34819428 <s3c_udc_ep0_zlp.clone.2>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
		   __func__, address, readl(&reg->dcfg));

	dev->usb_address = address;
348195f4:	e5c45158 	strb	r5, [r4, #344]	; 0x158
}
348195f8:	e8bd8038 	pop	{r3, r4, r5, pc}
348195fc:	3482bec0 	.word	0x3482bec0

34819600 <set_udc_gadget_private_data>:
void set_udc_gadget_private_data(void *p)
{
	debug_cond(DEBUG_SETUP != 0,
		   "%s: the_controller: 0x%p, p: 0x%p\n", __func__,
		   the_controller, p);
	the_controller->gadget.dev.device_data = p;
34819600:	e59f3008 	ldr	r3, [pc, #8]	; 34819610 <set_udc_gadget_private_data+0x10>
34819604:	e5933008 	ldr	r3, [r3, #8]
34819608:	e5830020 	str	r0, [r3, #32]
}
3481960c:	e12fff1e 	bx	lr
34819610:	3482bec0 	.word	0x3482bec0

34819614 <get_udc_gadget_private_data>:

void *get_udc_gadget_private_data(struct usb_gadget *gadget)
{
	return gadget->dev.device_data;
}
34819614:	e5900020 	ldr	r0, [r0, #32]
34819618:	e12fff1e 	bx	lr

3481961c <otg_phy_init>:
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
	dev->pdata->phy_control(1);
3481961c:	e5903028 	ldr	r3, [r0, #40]	; 0x28
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
34819620:	e92d4010 	push	{r4, lr}
	dev->pdata->phy_control(1);
34819624:	e5933000 	ldr	r3, [r3]
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
34819628:	e1a04000 	mov	r4, r0
	dev->pdata->phy_control(1);
3481962c:	e3a00001 	mov	r0, #1
34819630:	e12fff33 	blx	r3

	/*USB PHY0 Enable */
	printf("USB PHY0 Enable\n");
34819634:	e59f00a4 	ldr	r0, [pc, #164]	; 348196e0 <otg_phy_init+0xc4>
34819638:	ebffc15e 	bl	34809bb8 <printf>

	/* Enable PHY */
	writel(readl(usb_phy_ctrl) | USB_PHY_CTRL_EN0, usb_phy_ctrl);
3481963c:	e59f30a0 	ldr	r3, [pc, #160]	; 348196e4 <otg_phy_init+0xc8>
34819640:	e593200c 	ldr	r2, [r3, #12]
34819644:	e5921000 	ldr	r1, [r2]
34819648:	e3811001 	orr	r1, r1, #1
3481964c:	e593200c 	ldr	r2, [r3, #12]
34819650:	e5821000 	str	r1, [r2]

	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
34819654:	e5942028 	ldr	r2, [r4, #40]	; 0x28
34819658:	e5922010 	ldr	r2, [r2, #16]
3481965c:	e3520020 	cmp	r2, #32
34819660:	1a000003 	bne	34819674 <otg_phy_init+0x58>
		writel((readl(&phy->phypwr)
34819664:	e5932010 	ldr	r2, [r3, #16]
34819668:	e5922000 	ldr	r2, [r2]
3481966c:	e3c22039 	bic	r2, r2, #57	; 0x39
34819670:	ea000002 	b	34819680 <otg_phy_init+0x64>
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34819674:	e5932010 	ldr	r2, [r3, #16]
34819678:	e5922000 	ldr	r2, [r2]
3481967c:	e3c22019 	bic	r2, r2, #25
34819680:	e5933010 	ldr	r3, [r3, #16]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
34819684:	e59f4058 	ldr	r4, [pc, #88]	; 348196e4 <otg_phy_init+0xc8>
	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
		writel((readl(&phy->phypwr)
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34819688:	e5832000 	str	r2, [r3]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
3481968c:	e5943010 	ldr	r3, [r4, #16]
34819690:	e5932004 	ldr	r2, [r3, #4]
34819694:	e3c22017 	bic	r2, r2, #23
34819698:	e3822003 	orr	r2, r2, #3
3481969c:	e5943010 	ldr	r3, [r4, #16]
348196a0:	e5832004 	str	r2, [r3, #4]
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
348196a4:	e5932008 	ldr	r2, [r3, #8]
348196a8:	e3c22007 	bic	r2, r2, #7
348196ac:	e3822001 	orr	r2, r2, #1
348196b0:	e5943010 	ldr	r3, [r4, #16]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
348196b4:	e3a0000a 	mov	r0, #10
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
348196b8:	e5832008 	str	r2, [r3, #8]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
348196bc:	eb000d3d 	bl	3481cbb8 <udelay>
	writel(readl(&phy->rstcon)
348196c0:	e5943010 	ldr	r3, [r4, #16]
348196c4:	e5932008 	ldr	r2, [r3, #8]
348196c8:	e3c22007 	bic	r2, r2, #7
348196cc:	e5943010 	ldr	r3, [r4, #16]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
348196d0:	e3a0000a 	mov	r0, #10
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
348196d4:	e5832008 	str	r2, [r3, #8]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
}
348196d8:	e8bd4010 	pop	{r4, lr}
	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
348196dc:	ea000d35 	b	3481cbb8 <udelay>
348196e0:	348280f9 	.word	0x348280f9
348196e4:	3482bec0 	.word	0x3482bec0

348196e8 <otg_phy_off>:
}

void otg_phy_off(struct s3c_udc *dev)
{
348196e8:	e92d4038 	push	{r3, r4, r5, lr}
348196ec:	e1a05000 	mov	r5, r0
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
348196f0:	e59f4084 	ldr	r4, [pc, #132]	; 3481977c <otg_phy_off+0x94>
348196f4:	e3a02001 	mov	r2, #1
348196f8:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
348196fc:	e3a00014 	mov	r0, #20
}

void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
34819700:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34819704:	eb000d2b 	bl	3481cbb8 <udelay>
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34819708:	e5943010 	ldr	r3, [r4, #16]
3481970c:	e5932000 	ldr	r2, [r3]
34819710:	e3c22001 	bic	r2, r2, #1
34819714:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
34819718:	e3a00014 	mov	r0, #20
void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
	udelay(20);
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
3481971c:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34819720:	eb000d24 	bl	3481cbb8 <udelay>

	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
34819724:	e5943010 	ldr	r3, [r4, #16]
34819728:	e5932000 	ldr	r2, [r3]
3481972c:	e3822019 	orr	r2, r2, #25
34819730:	e5943010 	ldr	r3, [r4, #16]
34819734:	e5832000 	str	r2, [r3]
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);
34819738:	e594300c 	ldr	r3, [r4, #12]
3481973c:	e5932000 	ldr	r2, [r3]
34819740:	e3c22001 	bic	r2, r2, #1
34819744:	e594300c 	ldr	r3, [r4, #12]
34819748:	e5832000 	str	r2, [r3]

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
3481974c:	e5943010 	ldr	r3, [r4, #16]
34819750:	e5932004 	ldr	r2, [r3, #4]
34819754:	e3c22014 	bic	r2, r2, #20
34819758:	e5943010 	ldr	r3, [r4, #16]
	      &phy->phyclk);

	udelay(10000);
3481975c:	e3020710 	movw	r0, #10000	; 0x2710
	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34819760:	e5832004 	str	r2, [r3, #4]
	      &phy->phyclk);

	udelay(10000);
34819764:	eb000d13 	bl	3481cbb8 <udelay>

	dev->pdata->phy_control(0);
34819768:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481976c:	e3a00000 	mov	r0, #0
34819770:	e5933000 	ldr	r3, [r3]
34819774:	e12fff33 	blx	r3
}
34819778:	e8bd8038 	pop	{r3, r4, r5, pc}
3481977c:	3482bec0 	.word	0x3482bec0

34819780 <s3c_udc_pre_setup>:
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
}

void s3c_udc_pre_setup(void)
{
34819780:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
34819784:	e59f4034 	ldr	r4, [pc, #52]	; 348197c0 <s3c_udc_pre_setup+0x40>
34819788:	e5940004 	ldr	r0, [r4, #4]
	u32 ep_ctrl;

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
3481978c:	e2801901 	add	r1, r0, #16384	; 0x4000
34819790:	ebff9e58 	bl	348010f8 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
34819794:	e59f2028 	ldr	r2, [pc, #40]	; 348197c4 <s3c_udc_pre_setup+0x44>
34819798:	e5943000 	ldr	r3, [r4]
3481979c:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
348197a0:	e5942004 	ldr	r2, [r4, #4]
348197a4:	e5943000 	ldr	r3, [r4]
348197a8:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
348197ac:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA, &reg->out_endp[EP0_CON].doepctl);
348197b0:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
348197b4:	e5943000 	ldr	r3, [r4]
348197b8:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
348197bc:	e8bd8010 	pop	{r4, pc}
348197c0:	3482bec0 	.word	0x3482bec0
348197c4:	00080008 	.word	0x00080008

348197c8 <s3c_udc_ep0_set_stall.clone.3>:
{
	struct s3c_udc *dev;
	u32		ep_ctrl = 0;

	dev = ep->dev;
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
348197c8:	e59f3028 	ldr	r3, [pc, #40]	; 348197f8 <s3c_udc_ep0_set_stall.clone.3+0x30>
348197cc:	e5933000 	ldr	r3, [r3]
348197d0:	e5933900 	ldr	r3, [r3, #2304]	; 0x900

	/* set the disable and stall bits */
	if (ep_ctrl & DEPCTL_EPENA)
348197d4:	e3530000 	cmp	r3, #0
		ep_ctrl |= DEPCTL_EPDIS;
348197d8:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

	ep_ctrl |= DEPCTL_STALL;
348197dc:	e3833602 	orr	r3, r3, #2097152	; 0x200000

	writel(ep_ctrl, &reg->in_endp[EP0_CON].diepctl);
348197e0:	e59f2010 	ldr	r2, [pc, #16]	; 348197f8 <s3c_udc_ep0_set_stall.clone.3+0x30>
348197e4:	e5922000 	ldr	r2, [r2]
348197e8:	e5823900 	str	r3, [r2, #2304]	; 0x900
		   __func__, ep_index(ep), &reg->in_endp[EP0_CON].diepctl);
	/*
	 * The application can only set this bit, and the core clears it,
	 * when a SETUP token is received for this endpoint
	 */
	dev->ep0state = WAIT_FOR_SETUP;
348197ec:	e3a03000 	mov	r3, #0
348197f0:	e5803054 	str	r3, [r0, #84]	; 0x54

	s3c_udc_pre_setup();
348197f4:	eaffffe1 	b	34819780 <s3c_udc_pre_setup>
348197f8:	3482bec0 	.word	0x3482bec0

348197fc <setdma_tx>:
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
348197fc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34819800:	e59f211c 	ldr	r2, [pc, #284]	; 34819924 <setdma_tx+0x128>

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34819804:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34819808:	e5922008 	ldr	r2, [r2, #8]

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
3481980c:	e206600f 	and	r6, r6, #15
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34819810:	e1a03001 	mov	r3, r1
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34819814:	e0822106 	add	r2, r2, r6, lsl #2
34819818:	e5927030 	ldr	r7, [r2, #48]	; 0x30

	buf = req->req.buf + req->req.actual;
	length = req->req.length - req->req.actual;
3481981c:	e5935004 	ldr	r5, [r3, #4]
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
34819820:	e5912024 	ldr	r2, [r1, #36]	; 0x24
34819824:	e5911000 	ldr	r1, [r1]
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
34819828:	e3560000 	cmp	r6, #0
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
3481982c:	e1a04000 	mov	r4, r0
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
34819830:	e0811002 	add	r1, r1, r2
	length = req->req.length - req->req.actual;
34819834:	e0625005 	rsb	r5, r2, r5

	if (ep_num == EP0_CON)
34819838:	1a000002 	bne	34819848 <setdma_tx+0x4c>
		length = min(length, (u32)ep_maxpacket(ep));
3481983c:	e1d031b4 	ldrh	r3, [r0, #20]
34819840:	e1550003 	cmp	r5, r3
34819844:	21a05003 	movcs	r5, r3

	ep->len = length;
	ep->dma_buf = buf;
34819848:	e5841030 	str	r1, [r4, #48]	; 0x30
	memcpy(p, ep->dma_buf, length);
3481984c:	e1a02005 	mov	r2, r5
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
		length = min(length, (u32)ep_maxpacket(ep));

	ep->len = length;
34819850:	e584502c 	str	r5, [r4, #44]	; 0x2c
	ep->dma_buf = buf;
	memcpy(p, ep->dma_buf, length);
34819854:	e1a00007 	mov	r0, r7
34819858:	eb000c4b 	bl	3481c98c <memcpy>

	flush_dcache_range((unsigned long) p ,
3481985c:	e1a00007 	mov	r0, r7
34819860:	e2871901 	add	r1, r7, #16384	; 0x4000
34819864:	ebff9e2c 	bl	3480111c <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
34819868:	e3550000 	cmp	r5, #0
		pktcnt = 1;
3481986c:	03a00001 	moveq	r0, #1
	memcpy(p, ep->dma_buf, length);

	flush_dcache_range((unsigned long) p ,
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
34819870:	0a000003 	beq	34819884 <setdma_tx+0x88>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
34819874:	e2450001 	sub	r0, r5, #1
34819878:	e1d411b4 	ldrh	r1, [r4, #20]
3481987c:	eb00198a 	bl	3481feac <__udivsi3>
34819880:	e2800001 	add	r0, r0, #1

	/* Flush the endpoint's Tx FIFO */
	writel(TX_FIFO_NUMBER(ep->fifo_num), &reg->grstctl);
34819884:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34819888:	e1a01301 	lsl	r1, r1, #6
3481988c:	e59f3090 	ldr	r3, [pc, #144]	; 34819924 <setdma_tx+0x128>
34819890:	e5932000 	ldr	r2, [r3]
34819894:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_NUMBER(ep->fifo_num) | TX_FIFO_FLUSH, &reg->grstctl);
34819898:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
3481989c:	e1a01301 	lsl	r1, r1, #6
348198a0:	e3811020 	orr	r1, r1, #32
348198a4:	e5932000 	ldr	r2, [r3]
348198a8:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
348198ac:	e1a02003 	mov	r2, r3
348198b0:	e5921000 	ldr	r1, [r2]
348198b4:	e59f3068 	ldr	r3, [pc, #104]	; 34819924 <setdma_tx+0x128>
348198b8:	e5911010 	ldr	r1, [r1, #16]
348198bc:	e3110020 	tst	r1, #32
348198c0:	1afffffa 	bne	348198b0 <setdma_tx+0xb4>
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
348198c4:	e5d41035 	ldrb	r1, [r4, #53]	; 0x35
348198c8:	e5932008 	ldr	r2, [r3, #8]
348198cc:	e201100f 	and	r1, r1, #15
348198d0:	e2811011 	add	r1, r1, #17
348198d4:	e792c101 	ldr	ip, [r2, r1, lsl #2]
348198d8:	e5932000 	ldr	r2, [r3]
348198dc:	e1a01286 	lsl	r1, r6, #5
348198e0:	e2811e91 	add	r1, r1, #2320	; 0x910
348198e4:	e0822001 	add	r2, r2, r1
348198e8:	e582c004 	str	ip, [r2, #4]
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
348198ec:	e1850980 	orr	r0, r5, r0, lsl #19
348198f0:	e5932000 	ldr	r2, [r3]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
348198f4:	e2866048 	add	r6, r6, #72	; 0x48
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
348198f8:	e7820001 	str	r0, [r2, r1]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
348198fc:	e7922286 	ldr	r2, [r2, r6, lsl #5]

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34819900:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
34819904:	e3c2250f 	bic	r2, r2, #62914560	; 0x3c00000
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34819908:	e1822b01 	orr	r2, r2, r1, lsl #22

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));
3481990c:	e3c22b1e 	bic	r2, r2, #30720	; 0x7800

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34819910:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34819914:	e5933000 	ldr	r3, [r3]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
34819918:	e1a00005 	mov	r0, r5
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
3481991c:	e7832286 	str	r2, [r3, r6, lsl #5]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
34819920:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34819924:	3482bec0 	.word	0x3482bec0

34819928 <write_fifo_ep0>:
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
34819928:	e92d4070 	push	{r4, r5, r6, lr}
	u32 max;
	unsigned count;
	int is_last;

	max = ep_maxpacket(ep);
3481992c:	e1d061b4 	ldrh	r6, [r0, #20]
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
34819930:	e1a05000 	mov	r5, r0
34819934:	e1a04001 	mov	r4, r1

	max = ep_maxpacket(ep);

	debug_cond(DEBUG_EP0 != 0, "%s: max = %d\n", __func__, max);

	count = setdma_tx(ep, req);
34819938:	ebffffaf 	bl	348197fc <setdma_tx>

	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
3481993c:	e1500006 	cmp	r0, r6
34819940:	1a00000d 	bne	3481997c <write_fifo_ep0+0x54>
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
34819944:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819948:	e0800003 	add	r0, r0, r3
3481994c:	e5943004 	ldr	r3, [r4, #4]
34819950:	e1530000 	cmp	r3, r0
34819954:	1a000006 	bne	34819974 <write_fifo_ep0+0x4c>
		    || req->req.zero)
34819958:	e5d4300c 	ldrb	r3, [r4, #12]
3481995c:	e2033002 	and	r3, r3, #2
34819960:	e6ef3073 	uxtb	r3, r3
34819964:	e3530000 	cmp	r3, #0
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34819968:	13a00000 	movne	r0, #0
	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
		    || req->req.zero)
3481996c:	18bd8070 	popne	{r4, r5, r6, pc}
34819970:	ea000001 	b	3481997c <write_fifo_ep0+0x54>
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34819974:	e3a00000 	mov	r0, #0
}
34819978:	e8bd8070 	pop	{r4, r5, r6, pc}
		   is_last ? "/L" : "",
		   req->req.length - req->req.actual - count, req);

	/* requests complete when all IN data is in the FIFO */
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
3481997c:	e5953018 	ldr	r3, [r5, #24]
34819980:	e3a02000 	mov	r2, #0
34819984:	e5832054 	str	r2, [r3, #84]	; 0x54
		return 1;
34819988:	e3a00001 	mov	r0, #1
3481998c:	e8bd8070 	pop	{r4, r5, r6, pc}

34819990 <s3c_queue>:
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
34819990:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34819994:	e2516000 	subs	r6, r1, #0
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
34819998:	e1a04000 	mov	r4, r0
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
3481999c:	0a00006a 	beq	34819b4c <s3c_queue+0x1bc>
348199a0:	e5963010 	ldr	r3, [r6, #16]
348199a4:	e3530000 	cmp	r3, #0
348199a8:	1a00006c 	bne	34819b60 <s3c_queue+0x1d0>
348199ac:	ea000066 	b	34819b4c <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep = container_of(_ep, struct s3c_ep, ep);

	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
348199b0:	e3540000 	cmp	r4, #0
348199b4:	0a000064 	beq	34819b4c <s3c_queue+0x1bc>
348199b8:	e594301c 	ldr	r3, [r4, #28]
348199bc:	e3530000 	cmp	r3, #0
348199c0:	1a00006e 	bne	34819b80 <s3c_queue+0x1f0>
348199c4:	e5942004 	ldr	r2, [r4, #4]
348199c8:	e59f31c8 	ldr	r3, [pc, #456]	; 34819b98 <s3c_queue+0x208>
348199cc:	e1520003 	cmp	r2, r3
348199d0:	0a00006a 	beq	34819b80 <s3c_queue+0x1f0>
348199d4:	ea00005c 	b	34819b4c <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
348199d8:	e5953010 	ldr	r3, [r5, #16]
348199dc:	e3530000 	cmp	r3, #0
348199e0:	0a00005b 	beq	34819b54 <s3c_queue+0x1c4>
348199e4:	e5942020 	ldr	r2, [r4, #32]
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
348199e8:	e3e03072 	mvn	r3, #114	; 0x72
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
348199ec:	e2849020 	add	r9, r4, #32
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
348199f0:	e5863020 	str	r3, [r6, #32]
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
348199f4:	e1520009 	cmp	r2, r9
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
	_req->actual = 0;
348199f8:	e2833073 	add	r3, r3, #115	; 0x73
348199fc:	e5863024 	str	r3, [r6, #36]	; 0x24
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34819a00:	1a000048 	bne	34819b28 <s3c_queue+0x198>
34819a04:	e5d43034 	ldrb	r3, [r4, #52]	; 0x34
34819a08:	e3530000 	cmp	r3, #0
34819a0c:	1a000045 	bne	34819b28 <s3c_queue+0x198>

		if (ep_num == 0) {
34819a10:	e21aa00f 	ands	sl, sl, #15
34819a14:	1a000039 	bne	34819b00 <s3c_queue+0x170>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34819a18:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34819a1c:	e5862028 	str	r2, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34819a20:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
34819a24:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34819a28:	e586302c 	str	r3, [r6, #44]	; 0x2c

static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
34819a2c:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
34819a30:	e1a02005 	mov	r2, r5
34819a34:	e3530000 	cmp	r3, #0
34819a38:	e5b23078 	ldr	r3, [r2, #120]!	; 0x78
34819a3c:	aa000017 	bge	34819aa0 <s3c_queue+0x110>
		dev->ep0state = DATA_STATE_XMIT;
34819a40:	e3a04001 	mov	r4, #1
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
34819a44:	e1530002 	cmp	r3, r2
static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
34819a48:	e5854054 	str	r4, [r5, #84]	; 0x54
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
34819a4c:	0a000041 	beq	34819b58 <s3c_queue+0x1c8>
		req = 0;
	else
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	if (!req) {
34819a50:	e2531028 	subs	r1, r3, #40	; 0x28
34819a54:	0a00003a 	beq	34819b44 <s3c_queue+0x1b4>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
34819a58:	e5137024 	ldr	r7, [r3, #-36]	; 0x24
34819a5c:	e5133004 	ldr	r3, [r3, #-4]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
34819a60:	e2850058 	add	r0, r5, #88	; 0x58

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
34819a64:	e0637007 	rsb	r7, r3, r7
34819a68:	e59f312c 	ldr	r3, [pc, #300]	; 34819b9c <s3c_queue+0x20c>
34819a6c:	e5936000 	ldr	r6, [r3]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
34819a70:	ebffffac 	bl	34819928 <write_fifo_ep0>

	if ((ret == 1) && !need_zlp) {
34819a74:	e1500004 	cmp	r0, r4
34819a78:	13a01000 	movne	r1, #0
34819a7c:	03a01001 	moveq	r1, #1
34819a80:	e1570006 	cmp	r7, r6
34819a84:	03a01000 	moveq	r1, #0
34819a88:	e3510000 	cmp	r1, #0
		/* Last packet */
		dev->ep0state = WAIT_FOR_COMPLETE;
34819a8c:	13a03005 	movne	r3, #5
34819a90:	15853054 	strne	r3, [r5, #84]	; 0x54
		debug_cond(DEBUG_EP0 != 0,
			   "%s: finished, waiting for status\n", __func__);

	} else {
		dev->ep0state = DATA_STATE_XMIT;
34819a94:	05854054 	streq	r4, [r5, #84]	; 0x54
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);

	if ((ret == 1) && !need_zlp) {
34819a98:	0a000029 	beq	34819b44 <s3c_queue+0x1b4>
34819a9c:	ea00002d 	b	34819b58 <s3c_queue+0x1c8>
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
34819aa0:	e3a01004 	mov	r1, #4
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
34819aa4:	e1530002 	cmp	r3, r2
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
34819aa8:	e5851054 	str	r1, [r5, #84]	; 0x54
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
34819aac:	0a000004 	beq	34819ac4 <s3c_queue+0x134>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
34819ab0:	e5134024 	ldr	r4, [r3, #-36]	; 0x24
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
34819ab4:	e2431028 	sub	r1, r3, #40	; 0x28

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
34819ab8:	e3540000 	cmp	r4, #0
34819abc:	1a00000c 	bne	34819af4 <s3c_queue+0x164>
34819ac0:	ea000006 	b	34819ae0 <s3c_queue+0x150>
	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	} else {
		debug("%s: ---> BUG\n", __func__);
		BUG();
34819ac4:	e59f00d4 	ldr	r0, [pc, #212]	; 34819ba0 <s3c_queue+0x210>
34819ac8:	e59f10d4 	ldr	r1, [pc, #212]	; 34819ba4 <s3c_queue+0x214>
34819acc:	e3002332 	movw	r2, #818	; 0x332
34819ad0:	e59f30d0 	ldr	r3, [pc, #208]	; 34819ba8 <s3c_queue+0x218>
34819ad4:	ebffc037 	bl	34809bb8 <printf>
34819ad8:	e59f00cc 	ldr	r0, [pc, #204]	; 34819bac <s3c_queue+0x21c>
34819adc:	eb000f28 	bl	3481d784 <panic>

	if (req->req.length == 0) {
		/* zlp for Set_configuration, Set_interface,
		 * or Bulk-Only mass storge reset */

		ep->len = 0;
34819ae0:	e5854084 	str	r4, [r5, #132]	; 0x84
		s3c_udc_ep0_zlp(dev);
34819ae4:	e2850054 	add	r0, r5, #84	; 0x54
34819ae8:	ebfffe4e 	bl	34819428 <s3c_udc_ep0_zlp.clone.2>
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819aec:	e1a0a004 	mov	sl, r4
34819af0:	ea000018 	b	34819b58 <s3c_queue+0x1c8>
			   "%s: req.length = 0, bRequest = %d\n",
			   __func__, usb_ctrl->bRequest);
		return;
	}

	setdma_rx(ep, req);
34819af4:	e2850058 	add	r0, r5, #88	; 0x58
34819af8:	ebfffe03 	bl	3481930c <setdma_rx>
34819afc:	ea000015 	b	34819b58 <s3c_queue+0x1c8>
			/* EP0 */
			list_add_tail(&req->queue, &ep->queue);
			s3c_ep0_kick(dev, ep);
			req = 0;

		} else if (ep_is_in(ep)) {
34819b00:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
34819b04:	e3530000 	cmp	r3, #0
34819b08:	aa000003 	bge	34819b1c <s3c_queue+0x18c>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_IN_EP,
				   "%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_tx(ep, req);
34819b0c:	e1a00004 	mov	r0, r4
34819b10:	e1a01006 	mov	r1, r6
34819b14:	ebffff38 	bl	348197fc <setdma_tx>
34819b18:	ea000002 	b	34819b28 <s3c_queue+0x198>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_OUT_EP != 0,
				   "%s:ep_is_out, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_rx(ep, req);
34819b1c:	e1a00004 	mov	r0, r4
34819b20:	e1a01006 	mov	r1, r6
34819b24:	ebfffdf8 	bl	3481930c <setdma_rx>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34819b28:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34819b2c:	e5869028 	str	r9, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34819b30:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
34819b34:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34819b38:	e586302c 	str	r3, [r6, #44]	; 0x2c
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819b3c:	e3a0a000 	mov	sl, #0
34819b40:	ea000004 	b	34819b58 <s3c_queue+0x1c8>
34819b44:	e1a0a001 	mov	sl, r1
34819b48:	ea000002 	b	34819b58 <s3c_queue+0x1c8>
	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
		     || !list_empty(&req->queue))) {

		debug("%s: bad params\n", __func__);
		return -EINVAL;
34819b4c:	e3e0a015 	mvn	sl, #21
34819b50:	ea000000 	b	34819b58 <s3c_queue+0x1c8>
	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {

		debug("%s: bogus device state %p\n", __func__, dev->driver);
		return -ESHUTDOWN;
34819b54:	e3e0a06b 	mvn	sl, #107	; 0x6b
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
34819b58:	e1a0000a 	mov	r0, sl
34819b5c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34819b60:	e5963000 	ldr	r3, [r6]
34819b64:	e3530000 	cmp	r3, #0
34819b68:	0afffff7 	beq	34819b4c <s3c_queue+0x1bc>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34819b6c:	e1a03006 	mov	r3, r6
34819b70:	e5b37028 	ldr	r7, [r3, #40]!	; 0x28
34819b74:	e1570003 	cmp	r7, r3
34819b78:	0affff8c 	beq	348199b0 <s3c_queue+0x20>
34819b7c:	eafffff2 	b	34819b4c <s3c_queue+0x1bc>
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
34819b80:	e5945018 	ldr	r5, [r4, #24]
		debug("%s: bad ep: %s, %d, %p\n", __func__,
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
34819b84:	e5d4a035 	ldrb	sl, [r4, #53]	; 0x35
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
34819b88:	e5953024 	ldr	r3, [r5, #36]	; 0x24
34819b8c:	e3530000 	cmp	r3, #0
34819b90:	1affff90 	bne	348199d8 <s3c_queue+0x48>
34819b94:	eaffffee 	b	34819b54 <s3c_queue+0x1c4>
34819b98:	348218a0 	.word	0x348218a0
34819b9c:	348295b4 	.word	0x348295b4
34819ba0:	34827683 	.word	0x34827683
34819ba4:	3482810a 	.word	0x3482810a
34819ba8:	348218ac 	.word	0x348218ac
34819bac:	348276aa 	.word	0x348276aa

34819bb0 <s3c_fifo_read>:

	return 0;
}

int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
{
34819bb0:	e92d4008 	push	{r3, lr}
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
				(unsigned long) ep->dev->dma_buf[ep_index(ep)]
34819bb4:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
34819bb8:	e5902018 	ldr	r2, [r0, #24]
34819bbc:	e203300f 	and	r3, r3, #15
34819bc0:	e0823103 	add	r3, r2, r3, lsl #2
34819bc4:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
{
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
34819bc8:	e2801901 	add	r1, r0, #16384	; 0x4000
34819bcc:	ebff9d49 	bl	348010f8 <invalidate_dcache_range>
	debug_cond(DEBUG_EP0 != 0,
		   "%s: bytes=%d, ep_index=%d %p\n", __func__,
		   bytes, ep_index(ep), ep->dev->dma_buf[ep_index(ep)]);

	return bytes;
}
34819bd0:	e3a00008 	mov	r0, #8
34819bd4:	e8bd8008 	pop	{r3, pc}

34819bd8 <s3c_udc_get_status>:

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
34819bd8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
34819bdc:	e59f70e8 	ldr	r7, [pc, #232]	; 34819ccc <s3c_udc_get_status+0xf4>
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
34819be0:	e5d13004 	ldrb	r3, [r1, #4]
34819be4:	e5d1a005 	ldrb	sl, [r1, #5]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
34819be8:	e1a04001 	mov	r4, r1
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819bec:	e5d11000 	ldrb	r1, [r1]
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
34819bf0:	e183a40a 	orr	sl, r3, sl, lsl #8
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
34819bf4:	e5973008 	ldr	r3, [r7, #8]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
34819bf8:	e1a05000 	mov	r5, r0
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819bfc:	e201101f 	and	r1, r1, #31
34819c00:	e59f00c8 	ldr	r0, [pc, #200]	; 34819cd0 <s3c_udc_get_status+0xf8>
int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
34819c04:	e5936030 	ldr	r6, [r3, #48]	; 0x30

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34819c08:	ebffbfea 	bl	34809bb8 <printf>
	switch (crq->bRequestType & USB_RECIP_MASK) {
34819c0c:	e5d43000 	ldrb	r3, [r4]
34819c10:	e203301f 	and	r3, r3, #31
34819c14:	e3530001 	cmp	r3, #1
34819c18:	0a000005 	beq	34819c34 <s3c_udc_get_status+0x5c>
34819c1c:	e3530002 	cmp	r3, #2
34819c20:	0a000005 	beq	34819c3c <s3c_udc_get_status+0x64>
34819c24:	e3530000 	cmp	r3, #0
			   "\tGET_STATUS:USB_RECIP_INTERFACE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_DEVICE:
		g_status = 0x1; /* Self powered */
34819c28:	03a03001 	moveq	r3, #1
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
	switch (crq->bRequestType & USB_RECIP_MASK) {
34819c2c:	0a00000a 	beq	34819c5c <s3c_udc_get_status+0x84>
34819c30:	ea000021 	b	34819cbc <s3c_udc_get_status+0xe4>
	case USB_RECIP_INTERFACE:
		g_status = 0;
34819c34:	e3a03000 	mov	r3, #0
34819c38:	ea000007 	b	34819c5c <s3c_udc_get_status+0x84>
			   "\tGET_STATUS: USB_RECIP_DEVICE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
34819c3c:	e5d43006 	ldrb	r3, [r4, #6]
34819c40:	e5d42007 	ldrb	r2, [r4, #7]
34819c44:	e1833402 	orr	r3, r3, r2, lsl #8
34819c48:	e3530002 	cmp	r3, #2
34819c4c:	8a00001c 	bhi	34819cc4 <s3c_udc_get_status+0xec>
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
34819c50:	e20aa07f 	and	sl, sl, #127	; 0x7f
34819c54:	e085a30a 	add	sl, r5, sl, lsl #6
34819c58:	e5da308c 	ldrb	r3, [sl, #140]	; 0x8c

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
34819c5c:	e59f4068 	ldr	r4, [pc, #104]	; 34819ccc <s3c_udc_get_status+0xf4>
34819c60:	e3a02002 	mov	r2, #2
34819c64:	e2841014 	add	r1, r4, #20
34819c68:	e1a00006 	mov	r0, r6
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
34819c6c:	e1c731b4 	strh	r3, [r7, #20]

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
34819c70:	eb000b45 	bl	3481c98c <memcpy>

	flush_dcache_range((unsigned long) p,
34819c74:	e1a00006 	mov	r0, r6
34819c78:	e2861901 	add	r1, r6, #16384	; 0x4000
34819c7c:	ebff9d26 	bl	3480111c <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
34819c80:	e5943008 	ldr	r3, [r4, #8]
34819c84:	e5932044 	ldr	r2, [r3, #68]	; 0x44
34819c88:	e5943000 	ldr	r3, [r4]
34819c8c:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
34819c90:	e59f203c 	ldr	r2, [pc, #60]	; 34819cd4 <s3c_udc_get_status+0xfc>
34819c94:	e5943000 	ldr	r3, [r4]
34819c98:	e5832910 	str	r2, [r3, #2320]	; 0x910
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34819c9c:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34819ca0:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34819ca4:	e5943000 	ldr	r3, [r4]
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
34819ca8:	e3a00000 	mov	r0, #0
	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34819cac:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;
34819cb0:	e3a03008 	mov	r3, #8
34819cb4:	e5853054 	str	r3, [r5, #84]	; 0x54

	return 0;
34819cb8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
			   g_status);

		break;

	default:
		return 1;
34819cbc:	e3a00001 	mov	r0, #1
34819cc0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
34819cc4:	e3a00001 	mov	r0, #1
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
}
34819cc8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34819ccc:	3482bec0 	.word	0x3482bec0
34819cd0:	34828121 	.word	0x34828121
34819cd4:	00080002 	.word	0x00080002

34819cd8 <s3c_udc_ep_set_stall>:
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819cd8:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819cdc:	e3130080 	tst	r3, #128	; 0x80
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819ce0:	e203200f 	and	r2, r3, #15
34819ce4:	e59f3048 	ldr	r3, [pc, #72]	; 34819d34 <s3c_udc_ep_set_stall+0x5c>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819ce8:	0a00000a 	beq	34819d18 <s3c_udc_ep_set_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819cec:	e5933000 	ldr	r3, [r3]
34819cf0:	e2821048 	add	r1, r2, #72	; 0x48
34819cf4:	e7933281 	ldr	r3, [r3, r1, lsl #5]

		/* set the disable and stall bits */
		if (ep_ctrl & DEPCTL_EPENA)
34819cf8:	e3530000 	cmp	r3, #0
			ep_ctrl |= DEPCTL_EPDIS;
34819cfc:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

		ep_ctrl |= DEPCTL_STALL;
34819d00:	e3833602 	orr	r3, r3, #2097152	; 0x200000

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819d04:	e59f1028 	ldr	r1, [pc, #40]	; 34819d34 <s3c_udc_ep_set_stall+0x5c>
34819d08:	e2822048 	add	r2, r2, #72	; 0x48
34819d0c:	e5911000 	ldr	r1, [r1]
34819d10:	e7813282 	str	r3, [r1, r2, lsl #5]
34819d14:	e12fff1e 	bx	lr
		debug("%s: set stall, DIEPCTL%d = 0x%x\n",
		      __func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819d18:	e5931000 	ldr	r1, [r3]
34819d1c:	e2822058 	add	r2, r2, #88	; 0x58
34819d20:	e7911282 	ldr	r1, [r1, r2, lsl #5]

		/* set the stall bit */
		ep_ctrl |= DEPCTL_STALL;
34819d24:	e3811602 	orr	r1, r1, #2097152	; 0x200000

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819d28:	e5933000 	ldr	r3, [r3]
34819d2c:	e7831282 	str	r1, [r3, r2, lsl #5]
34819d30:	e12fff1e 	bx	lr
34819d34:	3482bec0 	.word	0x3482bec0

34819d38 <s3c_udc_ep_clear_stall>:
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819d38:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819d3c:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819d40:	e202300f 	and	r3, r2, #15
34819d44:	e59f2064 	ldr	r2, [pc, #100]	; 34819db0 <s3c_udc_ep_clear_stall+0x78>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819d48:	0a00000a 	beq	34819d78 <s3c_udc_ep_clear_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819d4c:	e5922000 	ldr	r2, [r2]
34819d50:	e2831048 	add	r1, r3, #72	; 0x48
34819d54:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819d58:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
34819d5c:	e3c22602 	bic	r2, r2, #2097152	; 0x200000
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819d60:	e2411002 	sub	r1, r1, #2
		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34819d64:	e6ef1071 	uxtb	r1, r1
34819d68:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34819d6c:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819d70:	e2833048 	add	r3, r3, #72	; 0x48
34819d74:	ea000009 	b	34819da0 <s3c_udc_ep_clear_stall+0x68>
		debug("%s: cleared stall, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819d78:	e5922000 	ldr	r2, [r2]
34819d7c:	e2831058 	add	r1, r3, #88	; 0x58
34819d80:	e7922281 	ldr	r2, [r2, r1, lsl #5]

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819d84:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
34819d88:	e3c22602 	bic	r2, r2, #2097152	; 0x200000

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819d8c:	e2411002 	sub	r1, r1, #2
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34819d90:	e6ef1071 	uxtb	r1, r1
34819d94:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34819d98:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819d9c:	e2833058 	add	r3, r3, #88	; 0x58
34819da0:	e59f1008 	ldr	r1, [pc, #8]	; 34819db0 <s3c_udc_ep_clear_stall+0x78>
34819da4:	e5911000 	ldr	r1, [r1]
34819da8:	e7812283 	str	r2, [r1, r3, lsl #5]
34819dac:	e12fff1e 	bx	lr
34819db0:	3482bec0 	.word	0x3482bec0

34819db4 <s3c_udc_set_halt>:

	return;
}

static int s3c_udc_set_halt(struct usb_ep *_ep, int value)
{
34819db4:	e92d4010 	push	{r4, lr}
	struct s3c_udc	*dev;
	unsigned long	flags;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
34819db8:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
34819dbc:	e590301c 	ldr	r3, [r0, #28]
34819dc0:	e312000f 	tst	r2, #15
34819dc4:	13a0c000 	movne	ip, #0
34819dc8:	03a0c001 	moveq	ip, #1
34819dcc:	e3530000 	cmp	r3, #0
34819dd0:	038cc001 	orreq	ip, ip, #1
34819dd4:	e35c0000 	cmp	ip, #0
34819dd8:	0a000019 	beq	34819e44 <s3c_udc_set_halt+0x90>
34819ddc:	ea000014 	b	34819e34 <s3c_udc_set_halt+0x80>
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
34819de0:	e3510000 	cmp	r1, #0
34819de4:	0a000008 	beq	34819e0c <s3c_udc_set_halt+0x58>
34819de8:	e3120080 	tst	r2, #128	; 0x80
34819dec:	0a000004 	beq	34819e04 <s3c_udc_set_halt+0x50>
34819df0:	e5902020 	ldr	r2, [r0, #32]
34819df4:	e2803020 	add	r3, r0, #32
34819df8:	e1520003 	cmp	r2, r3
		debug("%s: %s queue not empty, req = %p\n",
			__func__, ep->ep.name,
			list_entry(ep->queue.next, struct s3c_request, queue));

		return -EAGAIN;
34819dfc:	13e0000a 	mvnne	r0, #10
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
34819e00:	18bd8010 	popne	{r4, pc}
	dev = ep->dev;
	debug("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);

	spin_lock_irqsave(&dev->lock, flags);

	if (value == 0) {
34819e04:	e3510000 	cmp	r1, #0
34819e08:	1a000004 	bne	34819e20 <s3c_udc_set_halt+0x6c>
		ep->stopped = 0;
34819e0c:	e3a04000 	mov	r4, #0
34819e10:	e5c04034 	strb	r4, [r0, #52]	; 0x34
		s3c_udc_ep_clear_stall(ep);
34819e14:	ebffffc7 	bl	34819d38 <s3c_udc_ep_clear_stall>
		s3c_udc_ep_set_stall(ep);
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819e18:	e1a00004 	mov	r0, r4
34819e1c:	e8bd8010 	pop	{r4, pc}
		s3c_udc_ep_clear_stall(ep);
	} else {
		if (ep_num == 0)
			dev->ep0state = WAIT_FOR_SETUP;

		ep->stopped = 1;
34819e20:	e3a03001 	mov	r3, #1
34819e24:	e5c03034 	strb	r3, [r0, #52]	; 0x34
		s3c_udc_ep_set_stall(ep);
34819e28:	ebffffaa 	bl	34819cd8 <s3c_udc_ep_set_stall>
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819e2c:	e3a00000 	mov	r0, #0
34819e30:	e8bd8010 	pop	{r4, pc}
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
		     ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)) {
		debug("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
		return -EINVAL;
34819e34:	e3e00015 	mvn	r0, #21
34819e38:	e8bd8010 	pop	{r4, pc}
34819e3c:	e3e00015 	mvn	r0, #21
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
34819e40:	e8bd8010 	pop	{r4, pc}
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
34819e44:	e5d33003 	ldrb	r3, [r3, #3]
34819e48:	e3530001 	cmp	r3, #1
34819e4c:	1affffe3 	bne	34819de0 <s3c_udc_set_halt+0x2c>
34819e50:	eafffff9 	b	34819e3c <s3c_udc_set_halt+0x88>

34819e54 <s3c_udc_ep_activate>:
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
34819e54:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
34819e58:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
34819e5c:	e202300f 	and	r3, r2, #15
34819e60:	e59f2094 	ldr	r2, [pc, #148]	; 34819efc <s3c_udc_ep_activate+0xa8>

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
34819e64:	0a000004 	beq	34819e7c <s3c_udc_ep_activate+0x28>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819e68:	e5922000 	ldr	r2, [r2]
34819e6c:	e2831048 	add	r1, r3, #72	; 0x48
34819e70:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = 1 << ep_num;
34819e74:	e3a01001 	mov	r1, #1
34819e78:	ea000003 	b	34819e8c <s3c_udc_ep_activate+0x38>
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819e7c:	e5922000 	ldr	r2, [r2]
34819e80:	e2831058 	add	r1, r3, #88	; 0x58
34819e84:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819e88:	e3a01801 	mov	r1, #65536	; 0x10000
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34819e8c:	e3120902 	tst	r2, #32768	; 0x8000
	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
		daintmsk = 1 << ep_num;
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819e90:	e1a01311 	lsl	r1, r1, r3
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34819e94:	1a000011 	bne	34819ee0 <s3c_udc_ep_activate+0x8c>
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
34819e98:	e5d0c036 	ldrb	ip, [r0, #54]	; 0x36
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
34819e9c:	e3c22703 	bic	r2, r2, #786432	; 0xc0000
34819ea0:	e182290c 	orr	r2, r2, ip, lsl #18
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
34819ea4:	e1d0c1b4 	ldrh	ip, [r0, #20]
34819ea8:	e3c22e7f 	bic	r2, r2, #2032	; 0x7f0
34819eac:	e38cc306 	orr	ip, ip, #402653184	; 0x18000000
34819eb0:	e3c2200f 	bic	r2, r2, #15
34819eb4:	e38cc902 	orr	ip, ip, #32768	; 0x8000
			(ep->ep.maxpacket << DEPCTL_MPS_BIT);
		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP | DEPCTL_SNAK);
34819eb8:	e18cc002 	orr	ip, ip, r2

		if (ep_is_in(ep)) {
34819ebc:	e1d023d5 	ldrsb	r2, [r0, #53]	; 0x35
34819ec0:	e3520000 	cmp	r2, #0
34819ec4:	e59f2030 	ldr	r2, [pc, #48]	; 34819efc <s3c_udc_ep_activate+0xa8>
34819ec8:	aa000001 	bge	34819ed4 <s3c_udc_ep_activate+0x80>
			writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819ecc:	e2833048 	add	r3, r3, #72	; 0x48
34819ed0:	ea000000 	b	34819ed8 <s3c_udc_ep_activate+0x84>
			debug("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
			      __func__, ep_num, ep_num,
			      readl(&reg->in_endp[ep_num].diepctl));
		} else {
			writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819ed4:	e2833058 	add	r3, r3, #88	; 0x58
34819ed8:	e5922000 	ldr	r2, [r2]
34819edc:	e782c283 	str	ip, [r2, r3, lsl #5]
			      readl(&reg->out_endp[ep_num].doepctl));
		}
	}

	/* Unmask EP Interrtupt */
	writel(readl(&reg->daintmsk)|daintmsk, &reg->daintmsk);
34819ee0:	e59f3014 	ldr	r3, [pc, #20]	; 34819efc <s3c_udc_ep_activate+0xa8>
34819ee4:	e5932000 	ldr	r2, [r3]
34819ee8:	e592281c 	ldr	r2, [r2, #2076]	; 0x81c
34819eec:	e1811002 	orr	r1, r1, r2
34819ef0:	e5933000 	ldr	r3, [r3]
34819ef4:	e583181c 	str	r1, [r3, #2076]	; 0x81c
	debug("%s: DAINTMSK = 0x%x\n", __func__, readl(&reg->daintmsk));

}
34819ef8:	e12fff1e 	bx	lr
34819efc:	3482bec0 	.word	0x3482bec0

34819f00 <s3c_ep_enable>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
34819f00:	e3500000 	cmp	r0, #0
34819f04:	13510000 	cmpne	r1, #0
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
}

static int s3c_ep_enable(struct usb_ep *_ep,
			 const struct usb_endpoint_descriptor *desc)
{
34819f08:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
34819f0c:	e1a05001 	mov	r5, r1
34819f10:	e1a04000 	mov	r4, r0
34819f14:	0a000047 	beq	3481a038 <s3c_ep_enable+0x138>
34819f18:	e590301c 	ldr	r3, [r0, #28]
34819f1c:	e3530000 	cmp	r3, #0
34819f20:	1a000044 	bne	3481a038 <s3c_ep_enable+0x138>
34819f24:	e5902004 	ldr	r2, [r0, #4]
34819f28:	e59f3120 	ldr	r3, [pc, #288]	; 3481a050 <s3c_ep_enable+0x150>
34819f2c:	e1520003 	cmp	r2, r3
34819f30:	0a000040 	beq	3481a038 <s3c_ep_enable+0x138>
	    || desc->bDescriptorType != USB_DT_ENDPOINT
34819f34:	e5d13001 	ldrb	r3, [r1, #1]
34819f38:	e3530005 	cmp	r3, #5
34819f3c:	1a00003d 	bne	3481a038 <s3c_ep_enable+0x138>
	    || ep->bEndpointAddress != desc->bEndpointAddress
34819f40:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
34819f44:	e5d13002 	ldrb	r3, [r1, #2]
34819f48:	e1530006 	cmp	r3, r6
34819f4c:	1a000039 	bne	3481a038 <s3c_ep_enable+0x138>
	    || ep_maxpacket(ep) <
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
34819f50:	e2817004 	add	r7, r1, #4

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
34819f54:	e1d0a1b4 	ldrh	sl, [r0, #20]
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
34819f58:	e1a00007 	mov	r0, r7
34819f5c:	ebfffbf6 	bl	34818f3c <get_unaligned_le16>

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
34819f60:	e15a0000 	cmp	sl, r0
34819f64:	3a000033 	bcc	3481a038 <s3c_ep_enable+0x138>
		debug("%s: bad ep or descriptor\n", __func__);
		return -EINVAL;
	}

	/* xfer types must match, except that interrupt ~= bulk */
	if (ep->bmAttributes != desc->bmAttributes
34819f68:	e5d42036 	ldrb	r2, [r4, #54]	; 0x36
34819f6c:	e5d53003 	ldrb	r3, [r5, #3]
34819f70:	e1520003 	cmp	r2, r3
34819f74:	0a000004 	beq	34819f8c <s3c_ep_enable+0x8c>
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
34819f78:	e3520002 	cmp	r2, #2
34819f7c:	0a000002 	beq	34819f8c <s3c_ep_enable+0x8c>
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
34819f80:	e3530003 	cmp	r3, #3
34819f84:	1a00002b 	bne	3481a038 <s3c_ep_enable+0x138>
34819f88:	ea000003 	b	34819f9c <s3c_ep_enable+0x9c>
		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
	}

	/* hardware _could_ do smaller, but driver doesn't */
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
34819f8c:	e3530002 	cmp	r3, #2
34819f90:	1a000001 	bne	34819f9c <s3c_ep_enable+0x9c>
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
34819f94:	e150000a 	cmp	r0, sl
34819f98:	1a000028 	bne	3481a040 <s3c_ep_enable+0x140>
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {
34819f9c:	e3500000 	cmp	r0, #0
34819fa0:	0a000026 	beq	3481a040 <s3c_ep_enable+0x140>

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
34819fa4:	e5943018 	ldr	r3, [r4, #24]
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
34819fa8:	e5932024 	ldr	r2, [r3, #36]	; 0x24
34819fac:	e3520000 	cmp	r2, #0

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
34819fb0:	03e0006b 	mvneq	r0, #107	; 0x6b
		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
34819fb4:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
34819fb8:	e5933010 	ldr	r3, [r3, #16]
34819fbc:	e3530000 	cmp	r3, #0
34819fc0:	0a000020 	beq	3481a048 <s3c_ep_enable+0x148>

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
34819fc4:	e3a03000 	mov	r3, #0
34819fc8:	e5c43034 	strb	r3, [r4, #52]	; 0x34
	ep->desc = desc;
	ep->pio_irqs = 0;
34819fcc:	e5843028 	str	r3, [r4, #40]	; 0x28
		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
	ep->desc = desc;
34819fd0:	e584501c 	str	r5, [r4, #28]
	ep->pio_irqs = 0;
	ep->ep.maxpacket = le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
34819fd4:	e1a00007 	mov	r0, r7
34819fd8:	ebfffbd7 	bl	34818f3c <get_unaligned_le16>
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819fdc:	e3160080 	tst	r6, #128	; 0x80
34819fe0:	e1c401b4 	strh	r0, [r4, #20]
static void s3c_udc_set_nak(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819fe4:	e206200f 	and	r2, r6, #15
34819fe8:	e59f3064 	ldr	r3, [pc, #100]	; 3481a054 <s3c_ep_enable+0x154>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819fec:	0a000004 	beq	3481a004 <s3c_ep_enable+0x104>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819ff0:	e5931000 	ldr	r1, [r3]
34819ff4:	e2822048 	add	r2, r2, #72	; 0x48
34819ff8:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
34819ffc:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
3481a000:	ea000003 	b	3481a014 <s3c_ep_enable+0x114>
		debug("%s: set NAK, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
3481a004:	e5931000 	ldr	r1, [r3]
3481a008:	e2822058 	add	r2, r2, #88	; 0x58
3481a00c:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
3481a010:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
3481a014:	e5933000 	ldr	r3, [r3]

	/* Reset halt state */
	s3c_udc_set_nak(ep);
	s3c_udc_set_halt(_ep, 0);
3481a018:	e1a00004 	mov	r0, r4
3481a01c:	e7831282 	str	r1, [r3, r2, lsl #5]
3481a020:	e3a01000 	mov	r1, #0
3481a024:	ebffff62 	bl	34819db4 <s3c_udc_set_halt>

	spin_lock_irqsave(&ep->dev->lock, flags);
	s3c_udc_ep_activate(ep);
3481a028:	e1a00004 	mov	r0, r4
3481a02c:	ebffff88 	bl	34819e54 <s3c_udc_ep_activate>
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
3481a030:	e3a00000 	mov	r0, #0
3481a034:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (ep->bmAttributes != desc->bmAttributes
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {

		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
3481a038:	e3e00015 	mvn	r0, #21
3481a03c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
3481a040:	e3e00021 	mvn	r0, #33	; 0x21
3481a044:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
3481a048:	e3e0006b 	mvn	r0, #107	; 0x6b
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
}
3481a04c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481a050:	348218a0 	.word	0x348218a0
3481a054:	3482bec0 	.word	0x3482bec0

3481a058 <s3c_ep0_setup>:

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
3481a058:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_ep *ep = &dev->ep[0];
3481a05c:	e2806058 	add	r6, r0, #88	; 0x58

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
3481a060:	e59f5298 	ldr	r5, [pc, #664]	; 3481a300 <s3c_ep0_setup+0x2a8>
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
3481a064:	e3e01046 	mvn	r1, #70	; 0x46

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
3481a068:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
3481a06c:	e1a00006 	mov	r0, r6
3481a070:	ebfffc76 	bl	34819250 <nuke>

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
3481a074:	e5951018 	ldr	r1, [r5, #24]
3481a078:	e1a00006 	mov	r0, r6
3481a07c:	e3a02008 	mov	r2, #8
3481a080:	ebfffeca 	bl	34819bb0 <s3c_fifo_read>
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
3481a084:	e5951018 	ldr	r1, [r5, #24]
3481a088:	e5d13001 	ldrb	r3, [r1, #1]
3481a08c:	e35300fe 	cmp	r3, #254	; 0xfe
3481a090:	1a000005 	bne	3481a0ac <s3c_ep0_setup+0x54>
	    usb_ctrl->wLength != 1) {
3481a094:	e5d13006 	ldrb	r3, [r1, #6]
3481a098:	e5d12007 	ldrb	r2, [r1, #7]
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
3481a09c:	e1833402 	orr	r3, r3, r2, lsl #8
3481a0a0:	e3530001 	cmp	r3, #1
3481a0a4:	0a000006 	beq	3481a0c4 <s3c_ep0_setup+0x6c>
3481a0a8:	ea00008a 	b	3481a2d8 <s3c_ep0_setup+0x280>

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
3481a0ac:	e35300ff 	cmp	r3, #255	; 0xff
3481a0b0:	1a000003 	bne	3481a0c4 <s3c_ep0_setup+0x6c>
		 usb_ctrl->wLength != 0) {
3481a0b4:	e5d13006 	ldrb	r3, [r1, #6]
3481a0b8:	e5d12007 	ldrb	r2, [r1, #7]

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
3481a0bc:	e1932402 	orrs	r2, r3, r2, lsl #8
3481a0c0:	1a000084 	bne	3481a2d8 <s3c_ep0_setup+0x280>

		return;
	}

	/* Set direction of EP0 */
	if (likely(usb_ctrl->bRequestType & USB_DIR_IN)) {
3481a0c4:	e1d130d0 	ldrsb	r3, [r1]
3481a0c8:	e3530000 	cmp	r3, #0
3481a0cc:	e5d4308d 	ldrb	r3, [r4, #141]	; 0x8d
		ep->bEndpointAddress |= USB_DIR_IN;
3481a0d0:	b1e03c83 	mvnlt	r3, r3, lsl #25
3481a0d4:	b1e03ca3 	mvnlt	r3, r3, lsr #25
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
3481a0d8:	a203307f 	andge	r3, r3, #127	; 0x7f
3481a0dc:	e5c4308d 	strb	r3, [r4, #141]	; 0x8d
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
3481a0e0:	e5d13000 	ldrb	r3, [r1]
		== USB_TYPE_STANDARD;
3481a0e4:	e3130060 	tst	r3, #96	; 0x60
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
3481a0e8:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
		== USB_TYPE_STANDARD;
3481a0ec:	13a02000 	movne	r2, #0
3481a0f0:	03a02001 	moveq	r2, #1
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
3481a0f4:	e7c13092 	bfi	r3, r2, #1, #1
		== USB_TYPE_STANDARD;

	dev->req_pending = 1;
3481a0f8:	e6ef3073 	uxtb	r3, r3
3481a0fc:	e3833001 	orr	r3, r3, #1
3481a100:	e5c43159 	strb	r3, [r4, #345]	; 0x159

	/* Handle some SETUP packets ourselves */
	if (dev->req_std) {
3481a104:	e2033002 	and	r3, r3, #2
3481a108:	e6ef3073 	uxtb	r3, r3
3481a10c:	e3530000 	cmp	r3, #0
3481a110:	0a000066 	beq	3481a2b0 <s3c_ep0_setup+0x258>
		switch (usb_ctrl->bRequest) {
3481a114:	e5d13001 	ldrb	r3, [r1, #1]
3481a118:	e353000b 	cmp	r3, #11
3481a11c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481a120:	ea000062 	b	3481a2b0 <s3c_ep0_setup+0x258>
3481a124:	3481a19c 	.word	0x3481a19c
3481a128:	3481a1b0 	.word	0x3481a1b0
3481a12c:	3481a2b0 	.word	0x3481a2b0
3481a130:	3481a238 	.word	0x3481a238
3481a134:	3481a2b0 	.word	0x3481a2b0
3481a138:	3481a154 	.word	0x3481a154
3481a13c:	3481a2b0 	.word	0x3481a2b0
3481a140:	3481a2b0 	.word	0x3481a2b0
3481a144:	3481a2b0 	.word	0x3481a2b0
3481a148:	3481a170 	.word	0x3481a170
3481a14c:	3481a2b0 	.word	0x3481a2b0
3481a150:	3481a188 	.word	0x3481a188
		case USB_REQ_SET_ADDRESS:
		debug_cond(DEBUG_SETUP != 0,
			   "%s: *** USB_REQ_SET_ADDRESS (%d)\n",
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
3481a154:	e5d13000 	ldrb	r3, [r1]
3481a158:	e3530000 	cmp	r3, #0
3481a15c:	1a000053 	bne	3481a2b0 <s3c_ep0_setup+0x258>
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
3481a160:	e5d11002 	ldrb	r1, [r1, #2]
3481a164:	e1a00004 	mov	r0, r4

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
3481a168:	e8bd4070 	pop	{r4, r5, r6, lr}
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
3481a16c:	eafffd15 	b	348195c8 <udc_set_address>
				   "=====================================\n");
			debug_cond(DEBUG_SETUP != 0,
				   "%s: USB_REQ_SET_CONFIGURATION (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_DEVICE)
3481a170:	e5d13000 	ldrb	r3, [r1]
3481a174:	e3530000 	cmp	r3, #0
				reset_available = 1;
3481a178:	059f3184 	ldreq	r3, [pc, #388]	; 3481a304 <s3c_ep0_setup+0x2ac>
3481a17c:	03a02001 	moveq	r2, #1
3481a180:	0583200c 	streq	r2, [r3, #12]
3481a184:	ea000049 	b	3481a2b0 <s3c_ep0_setup+0x258>
		case USB_REQ_SET_INTERFACE:
			debug_cond(DEBUG_SETUP != 0,
				   "%s: *** USB_REQ_SET_INTERFACE (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_INTERFACE)
3481a188:	e5d13000 	ldrb	r3, [r1]
3481a18c:	e3530001 	cmp	r3, #1
				reset_available = 1;
3481a190:	059f216c 	ldreq	r2, [pc, #364]	; 3481a304 <s3c_ep0_setup+0x2ac>
3481a194:	0582300c 	streq	r3, [r2, #12]
3481a198:	ea000044 	b	3481a2b0 <s3c_ep0_setup+0x258>
				   "%s: *** USB_REQ_GET_CONFIGURATION\n",
				   __func__);
			break;

		case USB_REQ_GET_STATUS:
			if (!s3c_udc_get_status(dev, usb_ctrl))
3481a19c:	e1a00004 	mov	r0, r4
3481a1a0:	ebfffe8c 	bl	34819bd8 <s3c_udc_get_status>
3481a1a4:	e3500000 	cmp	r0, #0
3481a1a8:	1a000040 	bne	3481a2b0 <s3c_ep0_setup+0x258>
3481a1ac:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
3481a1b0:	e5d15004 	ldrb	r5, [r1, #4]
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
3481a1b4:	e5d12006 	ldrb	r2, [r1, #6]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
3481a1b8:	e205507f 	and	r5, r5, #127	; 0x7f
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
3481a1bc:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
3481a1c0:	e0845305 	add	r5, r4, r5, lsl #6
3481a1c4:	e2855058 	add	r5, r5, #88	; 0x58
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
3481a1c8:	e192c40c 	orrs	ip, r2, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
3481a1cc:	e5d53035 	ldrb	r3, [r5, #53]	; 0x35

	dev = ep->dev;
3481a1d0:	e5950018 	ldr	r0, [r5, #24]
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
3481a1d4:	1a000035 	bne	3481a2b0 <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
3481a1d8:	e5d12000 	ldrb	r2, [r1]
3481a1dc:	e212201f 	ands	r2, r2, #31
				   "\tCLEAR_FEATURE: USB_DEVICE_TEST_MODE\n");
			/** @todo Add CLEAR_FEATURE for TEST modes. */
			break;
		}

		s3c_udc_ep0_zlp(dev);
3481a1e0:	02800054 	addeq	r0, r0, #84	; 0x54
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
3481a1e4:	0a00002f 	beq	3481a2a8 <s3c_ep0_setup+0x250>
3481a1e8:	e3520002 	cmp	r2, #2
3481a1ec:	18bd8070 	popne	{r4, r5, r6, pc}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE:USB_RECIP_ENDPOINT, wValue = %d\n",
			   usb_ctrl->wValue);

		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
3481a1f0:	e5d12002 	ldrb	r2, [r1, #2]
3481a1f4:	e5d16003 	ldrb	r6, [r1, #3]
3481a1f8:	e1926406 	orrs	r6, r2, r6, lsl #8
3481a1fc:	18bd8070 	popne	{r4, r5, r6, pc}
			if (ep_num == 0) {
3481a200:	e213400f 	ands	r4, r3, #15
3481a204:	0a000021 	beq	3481a290 <s3c_ep0_setup+0x238>
				s3c_udc_ep0_set_stall(ep);
				return 0;
			}

			s3c_udc_ep0_zlp(dev);
3481a208:	e2800054 	add	r0, r0, #84	; 0x54
3481a20c:	ebfffc85 	bl	34819428 <s3c_udc_ep0_zlp.clone.2>

			s3c_udc_ep_clear_stall(ep);
3481a210:	e1a00005 	mov	r0, r5
3481a214:	ebfffec7 	bl	34819d38 <s3c_udc_ep_clear_stall>
			s3c_udc_ep_activate(ep);
3481a218:	e1a00005 	mov	r0, r5
3481a21c:	ebffff0c 	bl	34819e54 <s3c_udc_ep_activate>
			ep->stopped = 0;

			clear_feature_num = ep_num;
3481a220:	e59f30d8 	ldr	r3, [pc, #216]	; 3481a300 <s3c_ep0_setup+0x2a8>
			clear_feature_flag = 1;
3481a224:	e3a02001 	mov	r2, #1

			s3c_udc_ep0_zlp(dev);

			s3c_udc_ep_clear_stall(ep);
			s3c_udc_ep_activate(ep);
			ep->stopped = 0;
3481a228:	e5c56034 	strb	r6, [r5, #52]	; 0x34

			clear_feature_num = ep_num;
3481a22c:	e5c3401c 	strb	r4, [r3, #28]
			clear_feature_flag = 1;
3481a230:	e5832020 	str	r2, [r3, #32]
3481a234:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
3481a238:	e5d10004 	ldrb	r0, [r1, #4]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
3481a23c:	e5d13006 	ldrb	r3, [r1, #6]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
3481a240:	e200007f 	and	r0, r0, #127	; 0x7f

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
3481a244:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
3481a248:	e0840300 	add	r0, r4, r0, lsl #6
3481a24c:	e2800058 	add	r0, r0, #88	; 0x58

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
3481a250:	e193c40c 	orrs	ip, r3, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
3481a254:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	dev = ep->dev;
3481a258:	e5905018 	ldr	r5, [r0, #24]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
3481a25c:	1a000013 	bne	3481a2b0 <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
3481a260:	e5d13000 	ldrb	r3, [r1]
3481a264:	e213301f 	ands	r3, r3, #31
3481a268:	0a00000d 	beq	3481a2a4 <s3c_ep0_setup+0x24c>
3481a26c:	e3530002 	cmp	r3, #2
3481a270:	1a00000e 	bne	3481a2b0 <s3c_ep0_setup+0x258>
		break;

	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
3481a274:	e5d13002 	ldrb	r3, [r1, #2]
3481a278:	e5d11003 	ldrb	r1, [r1, #3]
3481a27c:	e1931401 	orrs	r1, r3, r1, lsl #8
3481a280:	1a000007 	bne	3481a2a4 <s3c_ep0_setup+0x24c>
			if (ep_num == 0) {
3481a284:	e312000f 	tst	r2, #15
3481a288:	1a000002 	bne	3481a298 <s3c_ep0_setup+0x240>
				s3c_udc_ep0_set_stall(ep);
3481a28c:	e1a00005 	mov	r0, r5

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
3481a290:	e8bd4070 	pop	{r4, r5, r6, lr}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
			if (ep_num == 0) {
				s3c_udc_ep0_set_stall(ep);
3481a294:	eafffd4b 	b	348197c8 <s3c_udc_ep0_set_stall.clone.3>
				return 0;
			}
			ep->stopped = 1;
3481a298:	e3a03001 	mov	r3, #1
3481a29c:	e5c03034 	strb	r3, [r0, #52]	; 0x34
			s3c_udc_ep_set_stall(ep);
3481a2a0:	ebfffe8c 	bl	34819cd8 <s3c_udc_ep_set_stall>
		}

		s3c_udc_ep0_zlp(dev);
3481a2a4:	e2850054 	add	r0, r5, #84	; 0x54

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
3481a2a8:	e8bd4070 	pop	{r4, r5, r6, lr}
			}
			ep->stopped = 1;
			s3c_udc_ep_set_stall(ep);
		}

		s3c_udc_ep0_zlp(dev);
3481a2ac:	eafffc5d 	b	34819428 <s3c_udc_ep0_zlp.clone.2>
			break;
		}
	}


	if (likely(dev->driver)) {
3481a2b0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a2b4:	e3530000 	cmp	r3, #0
3481a2b8:	08bd8070 	popeq	{r4, r5, r6, pc}
		debug_cond(DEBUG_SETUP != 0,
			   "%s:usb_ctrlreq will be passed to fsg_setup()\n",
			    __func__);

		spin_unlock(&dev->lock);
		i = dev->driver->setup(&dev->gadget, usb_ctrl);
3481a2bc:	e59f203c 	ldr	r2, [pc, #60]	; 3481a300 <s3c_ep0_setup+0x2a8>
3481a2c0:	e593300c 	ldr	r3, [r3, #12]
3481a2c4:	e1a00004 	mov	r0, r4
3481a2c8:	e5921018 	ldr	r1, [r2, #24]
3481a2cc:	e12fff33 	blx	r3
		spin_lock(&dev->lock);

		if (i < 0) {
3481a2d0:	e3500000 	cmp	r0, #0
3481a2d4:	aa000004 	bge	3481a2ec <s3c_ep0_setup+0x294>
			/* setup processing failed, force stall */
			s3c_udc_ep0_set_stall(ep);
3481a2d8:	e5940070 	ldr	r0, [r4, #112]	; 0x70
3481a2dc:	ebfffd39 	bl	348197c8 <s3c_udc_ep0_set_stall.clone.3>
			dev->ep0state = WAIT_FOR_SETUP;
3481a2e0:	e3a03000 	mov	r3, #0
3481a2e4:	e5843054 	str	r3, [r4, #84]	; 0x54
3481a2e8:	e8bd8070 	pop	{r4, r5, r6, pc}
				   "\tdev->driver->setup failed (%d),"
				    " bRequest = %d\n",
				i, usb_ctrl->bRequest);


		} else if (dev->req_pending) {
3481a2ec:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
3481a2f0:	e3130001 	tst	r3, #1
			dev->req_pending = 0;
3481a2f4:	17c0301f 	bfcne	r3, #0, #1
3481a2f8:	15c43159 	strbne	r3, [r4, #345]	; 0x159
3481a2fc:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a300:	3482bec0 	.word	0x3482bec0
3481a304:	348295b4 	.word	0x348295b4

3481a308 <usb_gadget_register_driver>:
/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
3481a308:	e59f3094 	ldr	r3, [pc, #148]	; 3481a3a4 <usb_gadget_register_driver+0x9c>
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
3481a30c:	e3500000 	cmp	r0, #0

/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
3481a310:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_udc *dev = the_controller;
3481a314:	e5935008 	ldr	r5, [r3, #8]
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
3481a318:	0a00001e 	beq	3481a398 <usb_gadget_register_driver+0x90>
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
3481a31c:	e5903000 	ldr	r3, [r0]
3481a320:	e2433002 	sub	r3, r3, #2
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
3481a324:	e3530001 	cmp	r3, #1
3481a328:	8a00001a 	bhi	3481a398 <usb_gadget_register_driver+0x90>
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
3481a32c:	e5903004 	ldr	r3, [r0, #4]
3481a330:	e3530000 	cmp	r3, #0
3481a334:	0a000017 	beq	3481a398 <usb_gadget_register_driver+0x90>
3481a338:	e5902010 	ldr	r2, [r0, #16]
3481a33c:	e3520000 	cmp	r2, #0
3481a340:	0a000014 	beq	3481a398 <usb_gadget_register_driver+0x90>
3481a344:	e590200c 	ldr	r2, [r0, #12]
3481a348:	e3520000 	cmp	r2, #0
3481a34c:	0a000011 	beq	3481a398 <usb_gadget_register_driver+0x90>
		return -EINVAL;
	if (!dev)
3481a350:	e3550000 	cmp	r5, #0
		return -ENODEV;
3481a354:	03e04012 	mvneq	r4, #18
	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
3481a358:	0a00000f 	beq	3481a39c <usb_gadget_register_driver+0x94>
		return -ENODEV;
	if (dev->driver)
3481a35c:	e5956024 	ldr	r6, [r5, #36]	; 0x24
3481a360:	e3560000 	cmp	r6, #0
		return -EBUSY;
3481a364:	13e0400f 	mvnne	r4, #15
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
		return -ENODEV;
	if (dev->driver)
3481a368:	1a00000b 	bne	3481a39c <usb_gadget_register_driver+0x94>
		return -EBUSY;

	spin_lock_irqsave(&dev->lock, flags);
	/* first hook up the driver ... */
	dev->driver = driver;
3481a36c:	e5850024 	str	r0, [r5, #36]	; 0x24
	if (retval) { /* TODO */
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
3481a370:	e1a00005 	mov	r0, r5
3481a374:	e12fff33 	blx	r3
	if (retval) {
3481a378:	e2504000 	subs	r4, r0, #0
		debug_cond(DEBUG_SETUP != 0,
			   "%s: bind to driver --> error %d\n",
			    dev->gadget.name, retval);
		dev->driver = 0;
3481a37c:	15856024 	strne	r6, [r5, #36]	; 0x24
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
	if (retval) {
3481a380:	1a000005 	bne	3481a39c <usb_gadget_register_driver+0x94>
 */
static int udc_enable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	otg_phy_init(dev);
3481a384:	e1a00005 	mov	r0, r5
3481a388:	ebfffca3 	bl	3481961c <otg_phy_init>
	reconfig_usbd();
3481a38c:	ebfffb1c 	bl	34819004 <reconfig_usbd>

	debug_cond(DEBUG_SETUP != 0,
		   "S3C USB 2.0 OTG Controller Core Initialized : 0x%x\n",
		    readl(&reg->gintmsk));

	dev->gadget.speed = USB_SPEED_UNKNOWN;
3481a390:	e5854010 	str	r4, [r5, #16]

	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
3481a394:	ea000000 	b	3481a39c <usb_gadget_register_driver+0x94>

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
3481a398:	e3e04015 	mvn	r4, #21
	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
}
3481a39c:	e1a00004 	mov	r0, r4
3481a3a0:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a3a4:	3482bec0 	.word	0x3482bec0

3481a3a8 <usb_gadget_unregister_driver>:
/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
3481a3a8:	e59f3144 	ldr	r3, [pc, #324]	; 3481a4f4 <usb_gadget_unregister_driver+0x14c>

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
3481a3ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct s3c_udc *dev = the_controller;
3481a3b0:	e5934008 	ldr	r4, [r3, #8]

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
3481a3b4:	e1a07000 	mov	r7, r0
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
3481a3b8:	e3540000 	cmp	r4, #0
		return -ENODEV;
3481a3bc:	03e00012 	mvneq	r0, #18
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
3481a3c0:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
		return -ENODEV;
	if (!driver || driver != dev->driver)
3481a3c4:	e3570000 	cmp	r7, #0
		return -EINVAL;
3481a3c8:	03e00015 	mvneq	r0, #21
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
3481a3cc:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a3d0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a3d4:	e1570003 	cmp	r7, r3
3481a3d8:	1a000043 	bne	3481a4ec <usb_gadget_unregister_driver+0x144>
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
3481a3dc:	e5949010 	ldr	r9, [r4, #16]
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
3481a3e0:	e3a06000 	mov	r6, #0
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
3481a3e4:	e1590006 	cmp	r9, r6
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
3481a3e8:	e5846024 	str	r6, [r4, #36]	; 0x24
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
3481a3ec:	11a09007 	movne	r9, r7
3481a3f0:	01a09006 	moveq	r9, r6
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
3481a3f4:	e5846010 	str	r6, [r4, #16]
3481a3f8:	e1a05004 	mov	r5, r4
3481a3fc:	e1a0a004 	mov	sl, r4

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
3481a400:	e3a0b001 	mov	fp, #1
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
3481a404:	e0840306 	add	r0, r4, r6, lsl #6
		ep->stopped = 1;
3481a408:	e5cab08c 	strb	fp, [sl, #140]	; 0x8c
		nuke(ep, -ESHUTDOWN);
3481a40c:	e2800058 	add	r0, r0, #88	; 0x58
3481a410:	e3e0106b 	mvn	r1, #107	; 0x6b
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a414:	e2866001 	add	r6, r6, #1
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
3481a418:	ebfffb8c 	bl	34819250 <nuke>
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a41c:	e3560004 	cmp	r6, #4
3481a420:	e28aa040 	add	sl, sl, #64	; 0x40
3481a424:	1afffff6 	bne	3481a404 <usb_gadget_unregister_driver+0x5c>
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
	}

	/* report disconnect; the driver is already quiesced */
	if (driver) {
3481a428:	e3590000 	cmp	r9, #0
3481a42c:	0a000002 	beq	3481a43c <usb_gadget_unregister_driver+0x94>
		spin_unlock(&dev->lock);
		driver->disconnect(&dev->gadget);
3481a430:	e5993010 	ldr	r3, [r9, #16]
3481a434:	e1a00004 	mov	r0, r4
3481a438:	e12fff33 	blx	r3

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
3481a43c:	e5943004 	ldr	r3, [r4, #4]
	unsigned int i;

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
3481a440:	e2842008 	add	r2, r4, #8
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
3481a444:	e283100c 	add	r1, r3, #12
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a448:	e5842008 	str	r2, [r4, #8]
	list->prev = list;
3481a44c:	e584200c 	str	r2, [r4, #12]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a450:	e583100c 	str	r1, [r3, #12]
	list->prev = list;
3481a454:	e5831010 	str	r1, [r3, #16]
	dev->ep0state = WAIT_FOR_SETUP;
3481a458:	e3a03000 	mov	r3, #0
3481a45c:	e5843054 	str	r3, [r4, #84]	; 0x54
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a460:	e1a06003 	mov	r6, r3
3481a464:	ea000009 	b	3481a490 <usb_gadget_unregister_driver+0xe8>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
3481a468:	e3530000 	cmp	r3, #0
3481a46c:	0a000006 	beq	3481a48c <usb_gadget_unregister_driver+0xe4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3481a470:	e594100c 	ldr	r1, [r4, #12]
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
3481a474:	e0840303 	add	r0, r4, r3, lsl #6
3481a478:	e2800064 	add	r0, r0, #100	; 0x64
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481a47c:	e584000c 	str	r0, [r4, #12]
	new->next = next;
3481a480:	e58520a4 	str	r2, [r5, #164]	; 0xa4
	new->prev = prev;
3481a484:	e58510a8 	str	r1, [r5, #168]	; 0xa8
	prev->next = new;
3481a488:	e5810000 	str	r0, [r1]
3481a48c:	e2855040 	add	r5, r5, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a490:	e0841303 	add	r1, r4, r3, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a494:	e2833001 	add	r3, r3, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a498:	e2811078 	add	r1, r1, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a49c:	e3530004 	cmp	r3, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a4a0:	e5856074 	str	r6, [r5, #116]	; 0x74
		ep->stopped = 0;
3481a4a4:	e5c5608c 	strb	r6, [r5, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a4a8:	e5851078 	str	r1, [r5, #120]	; 0x78
	list->prev = list;
3481a4ac:	e585107c 	str	r1, [r5, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
3481a4b0:	e5856080 	str	r6, [r5, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a4b4:	1affffeb 	bne	3481a468 <usb_gadget_unregister_driver+0xc0>
	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
	stop_activity(dev, driver);
	spin_unlock_irqrestore(&dev->lock, flags);

	driver->unbind(&dev->gadget);
3481a4b8:	e5973008 	ldr	r3, [r7, #8]
3481a4bc:	e1a00004 	mov	r0, r4
3481a4c0:	e12fff33 	blx	r3
 */
static void udc_disable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);
3481a4c4:	e1a00004 	mov	r0, r4
3481a4c8:	e1a01006 	mov	r1, r6
3481a4cc:	ebfffc3d 	bl	348195c8 <udc_set_address>

	dev->ep0state = WAIT_FOR_SETUP;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
	dev->usb_address = 0;

	otg_phy_off(dev);
3481a4d0:	e1a00004 	mov	r0, r4
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);

	dev->ep0state = WAIT_FOR_SETUP;
3481a4d4:	e5846054 	str	r6, [r4, #84]	; 0x54
	dev->gadget.speed = USB_SPEED_UNKNOWN;
3481a4d8:	e5846010 	str	r6, [r4, #16]
	dev->usb_address = 0;
3481a4dc:	e5c46158 	strb	r6, [r4, #344]	; 0x158

	otg_phy_off(dev);
3481a4e0:	ebfffc80 	bl	348196e8 <otg_phy_off>
	driver->unbind(&dev->gadget);

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
3481a4e4:	e1a00006 	mov	r0, r6
3481a4e8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;
3481a4ec:	e3e00015 	mvn	r0, #21

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
}
3481a4f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a4f4:	3482bec0 	.word	0x3482bec0

3481a4f8 <s3c_udc_probe>:

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
3481a4f8:	e59f3108 	ldr	r3, [pc, #264]	; 3481a608 <s3c_udc_probe+0x110>
3481a4fc:	e5902004 	ldr	r2, [r0, #4]
/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
{
3481a500:	e92d4070 	push	{r4, r5, r6, lr}

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
3481a504:	e5832010 	str	r2, [r3, #16]
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
3481a508:	e5902008 	ldr	r2, [r0, #8]
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
3481a50c:	e59f60f8 	ldr	r6, [pc, #248]	; 3481a60c <s3c_udc_probe+0x114>

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
3481a510:	e5832000 	str	r2, [r3]
	usb_phy_ctrl = pdata->usb_phy_ctrl;
3481a514:	e590200c 	ldr	r2, [r0, #12]
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;
3481a518:	e2864010 	add	r4, r6, #16

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
	usb_phy_ctrl = pdata->usb_phy_ctrl;
3481a51c:	e583200c 	str	r2, [r3, #12]

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
3481a520:	e5d62024 	ldrb	r2, [r6, #36]	; 0x24
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
3481a524:	e5860038 	str	r0, [r6, #56]	; 0x38
	usb_phy_ctrl = pdata->usb_phy_ctrl;

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
	dev->gadget.is_otg = 0;
3481a528:	e3822001 	orr	r2, r2, #1
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;
3481a52c:	e20220e1 	and	r2, r2, #225	; 0xe1
3481a530:	e7c5229f 	bfc	r2, #5, #1
3481a534:	e5c62024 	strb	r2, [r6, #36]	; 0x24

	the_controller = dev;
3481a538:	e2865038 	add	r5, r6, #56	; 0x38
3481a53c:	e5834008 	str	r4, [r3, #8]

/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
3481a540:	e286604c 	add	r6, r6, #76	; 0x4c
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
		dev->dma_buf[i] = memalign(CONFIG_SYS_CACHELINE_SIZE,
3481a544:	e3a01901 	mov	r1, #16384	; 0x4000
3481a548:	e3a00040 	mov	r0, #64	; 0x40
3481a54c:	ebffc105 	bl	3480a968 <memalign>
3481a550:	e5a50004 	str	r0, [r5, #4]!
					   DMA_BUFFER_SIZE);
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
3481a554:	e5850014 	str	r0, [r5, #20]
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
3481a558:	e2801901 	add	r1, r0, #16384	; 0x4000
3481a55c:	ebff9ae5 	bl	348010f8 <invalidate_dcache_range>
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
3481a560:	e1550006 	cmp	r5, r6
3481a564:	1afffff6 	bne	3481a544 <s3c_udc_probe+0x4c>
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
					(unsigned long) (dev->dma_buf[i]
							 + DMA_BUFFER_SIZE));
	}
	usb_ctrl = dev->dma_buf[0];
3481a568:	e59f309c 	ldr	r3, [pc, #156]	; 3481a60c <s3c_udc_probe+0x114>
3481a56c:	e59f2094 	ldr	r2, [pc, #148]	; 3481a608 <s3c_udc_probe+0x110>
3481a570:	e593103c 	ldr	r1, [r3, #60]	; 0x3c
3481a574:	e5821018 	str	r1, [r2, #24]
	usb_ctrl_dma_addr = dev->dma_addr[0];
3481a578:	e5931050 	ldr	r1, [r3, #80]	; 0x50
3481a57c:	e5821004 	str	r1, [r2, #4]

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
3481a580:	e5932014 	ldr	r2, [r3, #20]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a584:	e2831018 	add	r1, r3, #24
3481a588:	e282000c 	add	r0, r2, #12
3481a58c:	e582000c 	str	r0, [r2, #12]
	list->prev = list;
3481a590:	e5820010 	str	r0, [r2, #16]
	dev->ep0state = WAIT_FOR_SETUP;
3481a594:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a598:	e5831018 	str	r1, [r3, #24]
3481a59c:	e5832064 	str	r2, [r3, #100]	; 0x64
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a5a0:	e1a00002 	mov	r0, r2
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a5a4:	e2833010 	add	r3, r3, #16
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
3481a5a8:	e1a05001 	mov	r5, r1
3481a5ac:	ea000008 	b	3481a5d4 <s3c_udc_probe+0xdc>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
3481a5b0:	e3520000 	cmp	r2, #0
3481a5b4:	0a000005 	beq	3481a5d0 <s3c_udc_probe+0xd8>
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
3481a5b8:	e083c302 	add	ip, r3, r2, lsl #6
3481a5bc:	e28cc064 	add	ip, ip, #100	; 0x64
3481a5c0:	e58450a4 	str	r5, [r4, #164]	; 0xa4
	new->prev = prev;
3481a5c4:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	prev->next = new;
3481a5c8:	e581c000 	str	ip, [r1]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481a5cc:	e1a0100c 	mov	r1, ip
	new->next = next;
	new->prev = prev;
	prev->next = new;
3481a5d0:	e2844040 	add	r4, r4, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a5d4:	e083c302 	add	ip, r3, r2, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a5d8:	e2822001 	add	r2, r2, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481a5dc:	e28cc078 	add	ip, ip, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a5e0:	e3520004 	cmp	r2, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
3481a5e4:	e5840074 	str	r0, [r4, #116]	; 0x74
		ep->stopped = 0;
3481a5e8:	e5c4008c 	strb	r0, [r4, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481a5ec:	e584c078 	str	ip, [r4, #120]	; 0x78
	list->prev = list;
3481a5f0:	e584c07c 	str	ip, [r4, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
3481a5f4:	e5840080 	str	r0, [r4, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
3481a5f8:	1affffec 	bne	3481a5b0 <s3c_udc_probe+0xb8>
3481a5fc:	e59f3008 	ldr	r3, [pc, #8]	; 3481a60c <s3c_udc_probe+0x114>
3481a600:	e583101c 	str	r1, [r3, #28]
	usb_ctrl_dma_addr = dev->dma_addr[0];

	udc_reinit(dev);

	return retval;
}
3481a604:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a608:	3482bec0 	.word	0x3482bec0
3481a60c:	348295b4 	.word	0x348295b4

3481a610 <usb_gadget_handle_interrupts>:

int usb_gadget_handle_interrupts()
{
3481a610:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u32 intr_status = readl(&reg->gintsts);
3481a614:	e59f3434 	ldr	r3, [pc, #1076]	; 3481aa50 <usb_gadget_handle_interrupts+0x440>
3481a618:	e5932000 	ldr	r2, [r3]
3481a61c:	e5922014 	ldr	r2, [r2, #20]
	u32 gintmsk = readl(&reg->gintmsk);
3481a620:	e5931000 	ldr	r1, [r3]
3481a624:	e5910018 	ldr	r0, [r1, #24]

	if (intr_status & gintmsk)
3481a628:	e0100002 	ands	r0, r0, r2
3481a62c:	0a000105 	beq	3481aa48 <usb_gadget_handle_interrupts+0x438>
	u32 usb_status, gintmsk;
	unsigned long flags;

	spin_lock_irqsave(&dev->lock, flags);

	intr_status = readl(&reg->gintsts);
3481a630:	e5932000 	ldr	r2, [r3]
		return s3c_udc_irq(1, (void *)the_controller);
3481a634:	e5934008 	ldr	r4, [r3, #8]
3481a638:	e5926014 	ldr	r6, [r2, #20]
		  "\n*** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x,"
		  "DAINT : 0x%x, DAINTMSK : 0x%x\n",
		  __func__, intr_status, state_names[dev->ep0state], gintmsk,
		  readl(&reg->daint), readl(&reg->daintmsk));

	if (!intr_status) {
3481a63c:	e3560000 	cmp	r6, #0
3481a640:	0a0000ff 	beq	3481aa44 <usb_gadget_handle_interrupts+0x434>
		spin_unlock_irqrestore(&dev->lock, flags);
		return IRQ_HANDLED;
	}

	if (intr_status & INT_ENUMDONE) {
3481a644:	e3160a02 	tst	r6, #8192	; 0x2000
3481a648:	0a000009 	beq	3481a674 <usb_gadget_handle_interrupts+0x64>
		debug_cond(DEBUG_ISR, "\tSpeed Detection interrupt\n");

		writel(INT_ENUMDONE, &reg->gintsts);
3481a64c:	e5933000 	ldr	r3, [r3]
3481a650:	e3a02a02 	mov	r2, #8192	; 0x2000
3481a654:	e5832014 	str	r2, [r3, #20]
		usb_status = (readl(&reg->dsts) & 0x6);
3481a658:	e5933808 	ldr	r3, [r3, #2056]	; 0x808

		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
3481a65c:	e3130006 	tst	r3, #6
			debug_cond(DEBUG_ISR,
				   "\t\tFull Speed Detection\n");
			set_max_pktsize(dev, USB_SPEED_FULL);
3481a660:	11a00004 	movne	r0, r4
3481a664:	13a01002 	movne	r1, #2

		} else {
			debug_cond(DEBUG_ISR,
				"\t\tHigh Speed Detection : 0x%x\n",
				usb_status);
			set_max_pktsize(dev, USB_SPEED_HIGH);
3481a668:	01a00004 	moveq	r0, r4
3481a66c:	03a01003 	moveq	r1, #3
3481a670:	ebfffa35 	bl	34818f4c <set_max_pktsize>
		}
	}

	if (intr_status & INT_EARLY_SUSPEND) {
3481a674:	e3160b01 	tst	r6, #1024	; 0x400
3481a678:	0a000003 	beq	3481a68c <usb_gadget_handle_interrupts+0x7c>
		debug_cond(DEBUG_ISR, "\tEarly suspend interrupt\n");
		writel(INT_EARLY_SUSPEND, &reg->gintsts);
3481a67c:	e59f33cc 	ldr	r3, [pc, #972]	; 3481aa50 <usb_gadget_handle_interrupts+0x440>
3481a680:	e3a02b01 	mov	r2, #1024	; 0x400
3481a684:	e5933000 	ldr	r3, [r3]
3481a688:	e5832014 	str	r2, [r3, #20]
	}

	if (intr_status & INT_SUSPEND) {
3481a68c:	e3160b02 	tst	r6, #2048	; 0x800
3481a690:	0a000014 	beq	3481a6e8 <usb_gadget_handle_interrupts+0xd8>
		usb_status = readl(&reg->dsts);
		debug_cond(DEBUG_ISR,
			"\tSuspend interrupt :(DSTS):0x%x\n", usb_status);
		writel(INT_SUSPEND, &reg->gintsts);
3481a694:	e59f33b4 	ldr	r3, [pc, #948]	; 3481aa50 <usb_gadget_handle_interrupts+0x440>
3481a698:	e3a02b02 	mov	r2, #2048	; 0x800
3481a69c:	e5933000 	ldr	r3, [r3]
3481a6a0:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
3481a6a4:	e5943010 	ldr	r3, [r4, #16]
3481a6a8:	e3530000 	cmp	r3, #0
3481a6ac:	0a00000d 	beq	3481a6e8 <usb_gadget_handle_interrupts+0xd8>
		    && dev->driver) {
3481a6b0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a6b4:	e3530000 	cmp	r3, #0
3481a6b8:	0a00000a 	beq	3481a6e8 <usb_gadget_handle_interrupts+0xd8>
			if (dev->driver->suspend)
3481a6bc:	e5933014 	ldr	r3, [r3, #20]
3481a6c0:	e3530000 	cmp	r3, #0
3481a6c4:	0a000001 	beq	3481a6d0 <usb_gadget_handle_interrupts+0xc0>
				dev->driver->suspend(&dev->gadget);
3481a6c8:	e1a00004 	mov	r0, r4
3481a6cc:	e12fff33 	blx	r3

			/* HACK to let gadget detect disconnected state */
			if (dev->driver->disconnect) {
3481a6d0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a6d4:	e5933010 	ldr	r3, [r3, #16]
3481a6d8:	e3530000 	cmp	r3, #0
3481a6dc:	0a000001 	beq	3481a6e8 <usb_gadget_handle_interrupts+0xd8>
				spin_unlock_irqrestore(&dev->lock, flags);
				dev->driver->disconnect(&dev->gadget);
3481a6e0:	e1a00004 	mov	r0, r4
3481a6e4:	e12fff33 	blx	r3
				spin_lock_irqsave(&dev->lock, flags);
			}
		}
	}

	if (intr_status & INT_RESUME) {
3481a6e8:	e3560000 	cmp	r6, #0
3481a6ec:	aa00000e 	bge	3481a72c <usb_gadget_handle_interrupts+0x11c>
		debug_cond(DEBUG_ISR, "\tResume interrupt\n");
		writel(INT_RESUME, &reg->gintsts);
3481a6f0:	e59f3358 	ldr	r3, [pc, #856]	; 3481aa50 <usb_gadget_handle_interrupts+0x440>
3481a6f4:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
3481a6f8:	e5933000 	ldr	r3, [r3]
3481a6fc:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
3481a700:	e5943010 	ldr	r3, [r4, #16]
3481a704:	e3530000 	cmp	r3, #0
3481a708:	0a000007 	beq	3481a72c <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver
3481a70c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481a710:	e3530000 	cmp	r3, #0
3481a714:	0a000004 	beq	3481a72c <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver->resume) {
3481a718:	e5933018 	ldr	r3, [r3, #24]
3481a71c:	e3530000 	cmp	r3, #0
3481a720:	0a000001 	beq	3481a72c <usb_gadget_handle_interrupts+0x11c>

			dev->driver->resume(&dev->gadget);
3481a724:	e1a00004 	mov	r0, r4
3481a728:	e12fff33 	blx	r3
		}
	}

	if (intr_status & INT_RESET) {
3481a72c:	e3160a01 	tst	r6, #4096	; 0x1000
3481a730:	0a000014 	beq	3481a788 <usb_gadget_handle_interrupts+0x178>
		usb_status = readl(&reg->gotgctl);
3481a734:	e59f3314 	ldr	r3, [pc, #788]	; 3481aa50 <usb_gadget_handle_interrupts+0x440>
3481a738:	e5932000 	ldr	r2, [r3]
3481a73c:	e5922000 	ldr	r2, [r2]
		debug_cond(DEBUG_ISR,
			"\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
		writel(INT_RESET, &reg->gintsts);
3481a740:	e5933000 	ldr	r3, [r3]
3481a744:	e3a01a01 	mov	r1, #4096	; 0x1000
3481a748:	e5831014 	str	r1, [r3, #20]

		if ((usb_status & 0xc0000) == (0x3 << 18)) {
3481a74c:	e2023703 	and	r3, r2, #786432	; 0xc0000
3481a750:	e3530703 	cmp	r3, #786432	; 0xc0000
3481a754:	e59f52f8 	ldr	r5, [pc, #760]	; 3481aa54 <usb_gadget_handle_interrupts+0x444>
3481a758:	1a000008 	bne	3481a780 <usb_gadget_handle_interrupts+0x170>
			if (reset_available) {
3481a75c:	e595300c 	ldr	r3, [r5, #12]
3481a760:	e3530000 	cmp	r3, #0
3481a764:	0a000005 	beq	3481a780 <usb_gadget_handle_interrupts+0x170>
				debug_cond(DEBUG_ISR,
					"\t\tOTG core got reset (%d)!!\n",
					reset_available);
				reconfig_usbd();
3481a768:	ebfffa25 	bl	34819004 <reconfig_usbd>
				dev->ep0state = WAIT_FOR_SETUP;
3481a76c:	e3a03000 	mov	r3, #0
3481a770:	e5843054 	str	r3, [r4, #84]	; 0x54
				reset_available = 0;
3481a774:	e585300c 	str	r3, [r5, #12]
				s3c_udc_pre_setup();
3481a778:	ebfffc00 	bl	34819780 <s3c_udc_pre_setup>
3481a77c:	ea000001 	b	3481a788 <usb_gadget_handle_interrupts+0x178>
			} else
				reset_available = 1;

		} else {
			reset_available = 1;
3481a780:	e3a03001 	mov	r3, #1
3481a784:	e585300c 	str	r3, [r5, #12]
			debug_cond(DEBUG_ISR,
				   "\t\tRESET handling skipped\n");
		}
	}

	if (intr_status & INT_IN_EP)
3481a788:	e3160701 	tst	r6, #262144	; 0x40000
3481a78c:	0a00007a 	beq	3481a97c <usb_gadget_handle_interrupts+0x36c>
static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
3481a790:	e59f72b8 	ldr	r7, [pc, #696]	; 3481aa50 <usb_gadget_handle_interrupts+0x440>
3481a794:	e5973000 	ldr	r3, [r7]
3481a798:	e5939818 	ldr	r9, [r3, #2072]	; 0x818
}

static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
3481a79c:	e3a05000 	mov	r5, #0

	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;
3481a7a0:	e6ff9079 	uxth	r9, r9
3481a7a4:	e58d6004 	str	r6, [sp, #4]
3481a7a8:	ea000070 	b	3481a970 <usb_gadget_handle_interrupts+0x360>

	while (ep_intr) {
		if (ep_intr & DAINT_IN_EP_INT(1)) {
3481a7ac:	e3190001 	tst	r9, #1
3481a7b0:	0a00006b 	beq	3481a964 <usb_gadget_handle_interrupts+0x354>
			ep_intr_status = readl(&reg->in_endp[ep_num].diepint);
3481a7b4:	e5973000 	ldr	r3, [r7]
3481a7b8:	e1a02285 	lsl	r2, r5, #5
3481a7bc:	e0833002 	add	r3, r3, r2
3481a7c0:	e5933908 	ldr	r3, [r3, #2312]	; 0x908
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
3481a7c4:	e2822c09 	add	r2, r2, #2304	; 0x900
3481a7c8:	e5971000 	ldr	r1, [r7]
3481a7cc:	e2822008 	add	r2, r2, #8

			if (ep_intr_status & TRANSFER_DONE) {
3481a7d0:	e3130001 	tst	r3, #1
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
3481a7d4:	e7813002 	str	r3, [r1, r2]

			if (ep_intr_status & TRANSFER_DONE) {
3481a7d8:	0a000061 	beq	3481a964 <usb_gadget_handle_interrupts+0x354>
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 last;

	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
3481a7dc:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a7e0:	e3530008 	cmp	r3, #8
3481a7e4:	1a000003 	bne	3481a7f8 <usb_gadget_handle_interrupts+0x1e8>
		dev->ep0state = WAIT_FOR_OUT_COMPLETE;
3481a7e8:	e3a00006 	mov	r0, #6
3481a7ec:	e5840054 	str	r0, [r4, #84]	; 0x54
		s3c_ep0_complete_out();
3481a7f0:	ebfffab3 	bl	348192c4 <s3c_ep0_complete_out>
3481a7f4:	ea00003a 	b	3481a8e4 <usb_gadget_handle_interrupts+0x2d4>
		return;
	}

	if (list_empty(&ep->queue)) {
3481a7f8:	e1a06305 	lsl	r6, r5, #6
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
3481a7fc:	e0843006 	add	r3, r4, r6
3481a800:	e286b078 	add	fp, r6, #120	; 0x78
3481a804:	e5933078 	ldr	r3, [r3, #120]	; 0x78
3481a808:	e084b00b 	add	fp, r4, fp
3481a80c:	e153000b 	cmp	r3, fp
3481a810:	0a000033 	beq	3481a8e4 <usb_gadget_handle_interrupts+0x2d4>
		setdma_rx(ep, req);
}

static void complete_tx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a814:	e2866058 	add	r6, r6, #88	; 0x58
3481a818:	e0846006 	add	r6, r4, r6
			__func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
3481a81c:	e2431028 	sub	r1, r3, #40	; 0x28

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
3481a820:	e513a004 	ldr	sl, [r3, #-4]
3481a824:	e5132024 	ldr	r2, [r3, #-36]	; 0x24

	req = list_entry(ep->queue.next, struct s3c_request, queue);

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
3481a828:	e0840305 	add	r0, r4, r5, lsl #6
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
3481a82c:	e5900084 	ldr	r0, [r0, #132]	; 0x84
3481a830:	e06ac002 	rsb	ip, sl, r2
3481a834:	e15c0000 	cmp	ip, r0
3481a838:	908aa00c 	addls	sl, sl, ip
3481a83c:	808aa000 	addhi	sl, sl, r0
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
3481a840:	e3550000 	cmp	r5, #0

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
3481a844:	e503a004 	str	sl, [r3, #-4]
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
3481a848:	1a000018 	bne	3481a8b0 <usb_gadget_handle_interrupts+0x2a0>
		if (dev->ep0state == DATA_STATE_XMIT) {
3481a84c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a850:	e3530001 	cmp	r3, #1
3481a854:	1a000005 	bne	3481a870 <usb_gadget_handle_interrupts+0x260>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, ep0stat =="
				"DATA_STATE_XMIT\n",
				__func__, ep_num);
			last = write_fifo_ep0(ep, req);
3481a858:	e1a00006 	mov	r0, r6
3481a85c:	ebfffc31 	bl	34819928 <write_fifo_ep0>
			if (last)
3481a860:	e3500000 	cmp	r0, #0
				dev->ep0state = WAIT_FOR_COMPLETE;
3481a864:	13a00005 	movne	r0, #5
3481a868:	15840054 	strne	r0, [r4, #84]	; 0x54
3481a86c:	ea00001e 	b	3481a8ec <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_IN_COMPLETE) {
3481a870:	e3530007 	cmp	r3, #7
3481a874:	1a000004 	bne	3481a88c <usb_gadget_handle_interrupts+0x27c>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
3481a878:	e1a00006 	mov	r0, r6
3481a87c:	e1a02005 	mov	r2, r5
3481a880:	ebfffa41 	bl	3481918c <done>
			dev->ep0state = WAIT_FOR_SETUP;
3481a884:	e5845054 	str	r5, [r4, #84]	; 0x54
3481a888:	ea000017 	b	3481a8ec <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_COMPLETE) {
3481a88c:	e3530005 	cmp	r3, #5
3481a890:	1a000015 	bne	3481a8ec <usb_gadget_handle_interrupts+0x2dc>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
3481a894:	e1a00006 	mov	r0, r6
3481a898:	e1a02005 	mov	r2, r5
3481a89c:	ebfffa3a 	bl	3481918c <done>
			dev->ep0state = WAIT_FOR_OUT_COMPLETE;
3481a8a0:	e3a03006 	mov	r3, #6
3481a8a4:	e5843054 	str	r3, [r4, #84]	; 0x54
			s3c_ep0_complete_out();
3481a8a8:	ebfffa85 	bl	348192c4 <s3c_ep0_complete_out>
3481a8ac:	ea00000e 	b	3481a8ec <usb_gadget_handle_interrupts+0x2dc>
				__func__, ep_num);
		}
		return;
	}

	if (req->req.actual == req->req.length)
3481a8b0:	e15a0002 	cmp	sl, r2
3481a8b4:	1a000002 	bne	3481a8c4 <usb_gadget_handle_interrupts+0x2b4>
		done(ep, req, 0);
3481a8b8:	e1a00006 	mov	r0, r6
3481a8bc:	e3a02000 	mov	r2, #0
3481a8c0:	ebfffa31 	bl	3481918c <done>
3481a8c4:	e0843305 	add	r3, r4, r5, lsl #6
3481a8c8:	e5931078 	ldr	r1, [r3, #120]	; 0x78

	if (!list_empty(&ep->queue)) {
3481a8cc:	e151000b 	cmp	r1, fp
3481a8d0:	0a000023 	beq	3481a964 <usb_gadget_handle_interrupts+0x354>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request start...\n", __func__);
		setdma_tx(ep, req);
3481a8d4:	e1a00006 	mov	r0, r6
3481a8d8:	e2411028 	sub	r1, r1, #40	; 0x28
3481a8dc:	ebfffbc6 	bl	348197fc <setdma_tx>
3481a8e0:	ea00001f 	b	3481a964 <usb_gadget_handle_interrupts+0x354>
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);

			if (ep_intr_status & TRANSFER_DONE) {
				complete_tx(dev, ep_num);

				if (ep_num == 0) {
3481a8e4:	e3550000 	cmp	r5, #0
3481a8e8:	1a00001d 	bne	3481a964 <usb_gadget_handle_interrupts+0x354>
					if (dev->ep0state ==
3481a8ec:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a8f0:	e3530007 	cmp	r3, #7
					    WAIT_FOR_IN_COMPLETE)
						dev->ep0state = WAIT_FOR_SETUP;
3481a8f4:	03a0a000 	moveq	sl, #0
3481a8f8:	0584a054 	streq	sl, [r4, #84]	; 0x54

					if (dev->ep0state == WAIT_FOR_SETUP)
3481a8fc:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a900:	e3530000 	cmp	r3, #0
3481a904:	1a000000 	bne	3481a90c <usb_gadget_handle_interrupts+0x2fc>
						s3c_udc_pre_setup();
3481a908:	ebfffb9c 	bl	34819780 <s3c_udc_pre_setup>

					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
3481a90c:	e5973020 	ldr	r3, [r7, #32]
3481a910:	e3530001 	cmp	r3, #1
3481a914:	1a000012 	bne	3481a964 <usb_gadget_handle_interrupts+0x354>
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a918:	e5d7001c 	ldrb	r0, [r7, #28]
3481a91c:	e1a00300 	lsl	r0, r0, #6
3481a920:	e0843000 	add	r3, r4, r0
3481a924:	e5931078 	ldr	r1, [r3, #120]	; 0x78
	struct s3c_request *req;

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
3481a928:	e2802078 	add	r2, r0, #120	; 0x78
3481a92c:	e0842002 	add	r2, r4, r2
3481a930:	e1510002 	cmp	r1, r2
3481a934:	0a000008 	beq	3481a95c <usb_gadget_handle_interrupts+0x34c>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
3481a938:	e1d338dd 	ldrsb	r3, [r3, #141]	; 0x8d
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a93c:	e2800058 	add	r0, r0, #88	; 0x58
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
3481a940:	e3530000 	cmp	r3, #0
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
3481a944:	e0840000 	add	r0, r4, r0

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
3481a948:	e2411028 	sub	r1, r1, #40	; 0x28
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
3481a94c:	aa000001 	bge	3481a958 <usb_gadget_handle_interrupts+0x348>
			setdma_tx(ep, req);
3481a950:	ebfffba9 	bl	348197fc <setdma_tx>
3481a954:	ea000000 	b	3481a95c <usb_gadget_handle_interrupts+0x34c>
		else
			setdma_rx(ep, req);
3481a958:	ebfffa6b 	bl	3481930c <setdma_rx>
					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
						s3c_udc_check_tx_queue(dev,
							clear_feature_num);
						clear_feature_flag = 0;
3481a95c:	e3a00000 	mov	r0, #0
3481a960:	e5870020 	str	r0, [r7, #32]
					}
				}
			}
		}
		ep_num++;
3481a964:	e2855001 	add	r5, r5, #1
3481a968:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
3481a96c:	e1a090a9 	lsr	r9, r9, #1
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;

	while (ep_intr) {
3481a970:	e3590000 	cmp	r9, #0
3481a974:	1affff8c 	bne	3481a7ac <usb_gadget_handle_interrupts+0x19c>
3481a978:	e59d6004 	ldr	r6, [sp, #4]
	}

	if (intr_status & INT_IN_EP)
		process_ep_in_intr(dev);

	if (intr_status & INT_OUT_EP)
3481a97c:	e3160702 	tst	r6, #524288	; 0x80000
3481a980:	0a00002f 	beq	3481aa44 <usb_gadget_handle_interrupts+0x434>
static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
3481a984:	e59fa0c4 	ldr	sl, [pc, #196]	; 3481aa50 <usb_gadget_handle_interrupts+0x440>
3481a988:	e59a3000 	ldr	r3, [sl]
3481a98c:	e5936818 	ldr	r6, [r3, #2072]	; 0x818
}

static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
3481a990:	e3a05000 	mov	r5, #0
	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_OUT_EP != 0,
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
3481a994:	e1a06826 	lsr	r6, r6, #16
3481a998:	ea000027 	b	3481aa3c <usb_gadget_handle_interrupts+0x42c>

	while (ep_intr) {
		if (ep_intr & 0x1) {
3481a99c:	e3160001 	tst	r6, #1
3481a9a0:	0a000022 	beq	3481aa30 <usb_gadget_handle_interrupts+0x420>
			ep_intr_status = readl(&reg->out_endp[ep_num].doepint);
3481a9a4:	e59a2000 	ldr	r2, [sl]
3481a9a8:	e1a03285 	lsl	r3, r5, #5
3481a9ac:	e0822003 	add	r2, r2, r3
3481a9b0:	e5927b08 	ldr	r7, [r2, #2824]	; 0xb08
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
3481a9b4:	e2833c0b 	add	r3, r3, #2816	; 0xb00
3481a9b8:	e59a2000 	ldr	r2, [sl]
3481a9bc:	e2833008 	add	r3, r3, #8

			if (ep_num == 0) {
3481a9c0:	e3550000 	cmp	r5, #0
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
3481a9c4:	e7827003 	str	r7, [r2, r3]
3481a9c8:	e2073001 	and	r3, r7, #1

			if (ep_num == 0) {
3481a9cc:	1a000012 	bne	3481aa1c <usb_gadget_handle_interrupts+0x40c>
				if (ep_intr_status & TRANSFER_DONE) {
3481a9d0:	e3530000 	cmp	r3, #0
3481a9d4:	0a000008 	beq	3481a9fc <usb_gadget_handle_interrupts+0x3ec>
					if (dev->ep0state !=
3481a9d8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481a9dc:	e3530006 	cmp	r3, #6
3481a9e0:	0a000003 	beq	3481a9f4 <usb_gadget_handle_interrupts+0x3e4>
					    WAIT_FOR_OUT_COMPLETE)
						complete_rx(dev, ep_num);
3481a9e4:	e1a00004 	mov	r0, r4
3481a9e8:	e1a01005 	mov	r1, r5
3481a9ec:	ebfffaa1 	bl	34819478 <complete_rx>
3481a9f0:	ea000001 	b	3481a9fc <usb_gadget_handle_interrupts+0x3ec>
					else {
						dev->ep0state = WAIT_FOR_SETUP;
3481a9f4:	e5845054 	str	r5, [r4, #84]	; 0x54
						s3c_udc_pre_setup();
3481a9f8:	ebfffb60 	bl	34819780 <s3c_udc_pre_setup>
					}
				}

				if (ep_intr_status &
3481a9fc:	e3170008 	tst	r7, #8
3481aa00:	0a00000a 	beq	3481aa30 <usb_gadget_handle_interrupts+0x420>
/*
 * handle ep0 interrupt
 */
static void s3c_handle_ep0(struct s3c_udc *dev)
{
	if (dev->ep0state == WAIT_FOR_SETUP) {
3481aa04:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481aa08:	e3530000 	cmp	r3, #0
3481aa0c:	1a000007 	bne	3481aa30 <usb_gadget_handle_interrupts+0x420>
		debug_cond(DEBUG_OUT_EP != 0,
			   "%s: WAIT_FOR_SETUP\n", __func__);
		s3c_ep0_setup(dev);
3481aa10:	e1a00004 	mov	r0, r4
3481aa14:	ebfffd8f 	bl	3481a058 <s3c_ep0_setup>
3481aa18:	ea000004 	b	3481aa30 <usb_gadget_handle_interrupts+0x420>
					debug_cond(DEBUG_OUT_EP != 0,
						   "SETUP packet arrived\n");
					s3c_handle_ep0(dev);
				}
			} else {
				if (ep_intr_status & TRANSFER_DONE)
3481aa1c:	e3530000 	cmp	r3, #0
3481aa20:	0a000002 	beq	3481aa30 <usb_gadget_handle_interrupts+0x420>
					complete_rx(dev, ep_num);
3481aa24:	e1a00004 	mov	r0, r4
3481aa28:	e1a01005 	mov	r1, r5
3481aa2c:	ebfffa91 	bl	34819478 <complete_rx>
			}
		}
		ep_num++;
3481aa30:	e2855001 	add	r5, r5, #1
3481aa34:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
3481aa38:	e1a060a6 	lsr	r6, r6, #1
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;

	while (ep_intr) {
3481aa3c:	e3560000 	cmp	r6, #0
3481aa40:	1affffd5 	bne	3481a99c <usb_gadget_handle_interrupts+0x38c>
3481aa44:	e3a00001 	mov	r0, #1
	return 0;
}
3481aa48:	e28dd010 	add	sp, sp, #16
3481aa4c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481aa50:	3482bec0 	.word	0x3482bec0
3481aa54:	348295b4 	.word	0x348295b4

3481aa58 <cyg_crc16>:
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
3481aa58:	e1a03000 	mov	r3, r0
    int i;
    uint16_t cksum;

    cksum = 0;
3481aa5c:	e3a00000 	mov	r0, #0
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
3481aa60:	e92d4010 	push	{r4, lr}
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481aa64:	e1a02000 	mov	r2, r0
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481aa68:	e59fc028 	ldr	ip, [pc, #40]	; 3481aa98 <cyg_crc16+0x40>
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481aa6c:	ea000006 	b	3481aa8c <cyg_crc16+0x34>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481aa70:	e7d34002 	ldrb	r4, [r3, r2]
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481aa74:	e2822001 	add	r2, r2, #1
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481aa78:	e0244420 	eor	r4, r4, r0, lsr #8
3481aa7c:	e1a04084 	lsl	r4, r4, #1
3481aa80:	e19c40b4 	ldrh	r4, [ip, r4]
3481aa84:	e0240400 	eor	r0, r4, r0, lsl #8
3481aa88:	e6ff0070 	uxth	r0, r0
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481aa8c:	e1520001 	cmp	r2, r1
3481aa90:	bafffff6 	blt	3481aa70 <cyg_crc16+0x18>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
    }
    return cksum;
}
3481aa94:	e8bd8010 	pop	{r4, pc}
3481aa98:	348218e0 	.word	0x348218e0

3481aa9c <crc32_no_comp>:
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
3481aa9c:	e211c003 	ands	ip, r1, #3
3481aaa0:	13a0c001 	movne	ip, #1
3481aaa4:	e3520000 	cmp	r2, #0
3481aaa8:	03a0c000 	moveq	ip, #0
3481aaac:	120cc001 	andne	ip, ip, #1
3481aab0:	e35c0000 	cmp	ip, #0

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
{
3481aab4:	e92d4070 	push	{r4, r5, r6, lr}
    const uint32_t *tab = crc_table;
    const uint32_t *b =(const uint32_t *)buf;
3481aab8:	e1a03001 	mov	r3, r1
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
3481aabc:	0a00000a 	beq	3481aaec <crc32_no_comp+0x50>
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
3481aac0:	e59f30b8 	ldr	r3, [pc, #184]	; 3481ab80 <crc32_no_comp+0xe4>
3481aac4:	e4d1c001 	ldrb	ip, [r1], #1
	 } while ((--len) && ((long)p)&3);
3481aac8:	e2522001 	subs	r2, r2, #1
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
3481aacc:	e020c00c 	eor	ip, r0, ip
3481aad0:	e20cc0ff 	and	ip, ip, #255	; 0xff
3481aad4:	e793c10c 	ldr	ip, [r3, ip, lsl #2]
3481aad8:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while ((--len) && ((long)p)&3);
3481aadc:	0a000001 	beq	3481aae8 <crc32_no_comp+0x4c>
3481aae0:	e3110003 	tst	r1, #3
3481aae4:	1afffff6 	bne	3481aac4 <crc32_no_comp+0x28>
	 b = (uint32_t *)p;
3481aae8:	e1a03001 	mov	r3, r1
    }

    rem_len = len & 3;
3481aaec:	e2025003 	and	r5, r2, #3
    len = len >> 2;
3481aaf0:	e1a02122 	lsr	r2, r2, #2
    for (--b; len; --len) {
3481aaf4:	e2431004 	sub	r1, r3, #4
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
3481aaf8:	e1a04002 	mov	r4, r2
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
3481aafc:	e59fc07c 	ldr	ip, [pc, #124]	; 3481ab80 <crc32_no_comp+0xe4>
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481ab00:	ea00000e 	b	3481ab40 <crc32_no_comp+0xa4>
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
3481ab04:	e4936004 	ldr	r6, [r3], #4
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481ab08:	e2444001 	sub	r4, r4, #1
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
3481ab0c:	e0200006 	eor	r0, r0, r6
	 DO_CRC(0);
3481ab10:	e20060ff 	and	r6, r0, #255	; 0xff
3481ab14:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481ab18:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481ab1c:	e20060ff 	and	r6, r0, #255	; 0xff
3481ab20:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481ab24:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481ab28:	e20060ff 	and	r6, r0, #255	; 0xff
3481ab2c:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481ab30:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481ab34:	e20060ff 	and	r6, r0, #255	; 0xff
3481ab38:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481ab3c:	e0260420 	eor	r0, r6, r0, lsr #8
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481ab40:	e3540000 	cmp	r4, #0
3481ab44:	1affffee 	bne	3481ab04 <crc32_no_comp+0x68>
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
3481ab48:	e3550000 	cmp	r5, #0
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481ab4c:	e0812102 	add	r2, r1, r2, lsl #2
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
3481ab50:	08bd8070 	popeq	{r4, r5, r6, pc}
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481ab54:	e59f1024 	ldr	r1, [pc, #36]	; 3481ab80 <crc32_no_comp+0xe4>
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
3481ab58:	e2822003 	add	r2, r2, #3
3481ab5c:	e1a03005 	mov	r3, r5
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481ab60:	e5f2c001 	ldrb	ip, [r2, #1]!
	 } while (--len);
3481ab64:	e2533001 	subs	r3, r3, #1
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481ab68:	e020c00c 	eor	ip, r0, ip
3481ab6c:	e20cc0ff 	and	ip, ip, #255	; 0xff
3481ab70:	e791c10c 	ldr	ip, [r1, ip, lsl #2]
3481ab74:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while (--len);
3481ab78:	1afffff8 	bne	3481ab60 <crc32_no_comp+0xc4>
    }

    return le32_to_cpu(crc);
}
3481ab7c:	e8bd8070 	pop	{r4, r5, r6, pc}
3481ab80:	34821ae0 	.word	0x34821ae0

3481ab84 <crc32>:
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
3481ab84:	e92d4008 	push	{r3, lr}
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
3481ab88:	e1e00000 	mvn	r0, r0
3481ab8c:	ebffffc2 	bl	3481aa9c <crc32_no_comp>
}
3481ab90:	e1e00000 	mvn	r0, r0
3481ab94:	e8bd8008 	pop	{r3, pc}

3481ab98 <crc32_wd>:
		crc = crc32 (crc, curr, chunk);
		curr += chunk;
		WATCHDOG_RESET ();
	}
#else
	crc = crc32 (crc, buf, len);
3481ab98:	eafffff9 	b	3481ab84 <crc32>

3481ab9c <crc7>:

extern const u8 crc7_syndrome_table[256];

static inline u8 crc7_byte(u8 crc, u8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
3481ab9c:	e59f301c 	ldr	r3, [pc, #28]	; 3481abc0 <crc7+0x24>
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
3481aba0:	ea000003 	b	3481abb4 <crc7+0x18>
		crc = crc7_byte(crc, *buffer++);
3481aba4:	e4d1c001 	ldrb	ip, [r1], #1
3481aba8:	e2422001 	sub	r2, r2, #1
3481abac:	e02c0080 	eor	r0, ip, r0, lsl #1
3481abb0:	e7d30000 	ldrb	r0, [r3, r0]
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
3481abb4:	e3520000 	cmp	r2, #0
3481abb8:	1afffff9 	bne	3481aba4 <crc7+0x8>
		crc = crc7_byte(crc, *buffer++);
	return crc;
}
3481abbc:	e12fff1e 	bx	lr
3481abc0:	34821ee0 	.word	0x34821ee0

3481abc4 <display_options>:
#include <version.h>
#include <linux/ctype.h>
#include <asm/io.h>

int display_options (void)
{
3481abc4:	e92d4008 	push	{r3, lr}
#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
3481abc8:	e59f100c 	ldr	r1, [pc, #12]	; 3481abdc <display_options+0x18>
3481abcc:	e59f000c 	ldr	r0, [pc, #12]	; 3481abe0 <display_options+0x1c>
3481abd0:	ebffbbf8 	bl	34809bb8 <printf>
#endif
	return 0;
}
3481abd4:	e3a00000 	mov	r0, #0
3481abd8:	e8bd8008 	pop	{r3, pc}
3481abdc:	34820544 	.word	0x34820544
3481abe0:	34822ba1 	.word	0x34822ba1

3481abe4 <print_size>:
 * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB", "xxx.y MiB",
 * xxx GiB, xxx.y GiB, etc as needed; allow for optional trailing string
 * (like "\n")
 */
void print_size(unsigned long long size, const char *s)
{
3481abe4:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3481abe8:	e1a04000 	mov	r4, r0
3481abec:	e1a05001 	mov	r5, r1
3481abf0:	e1a09002 	mov	r9, r2
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
3481abf4:	e3a0a000 	mov	sl, #0
void print_size(unsigned long long size, const char *s)
{
	unsigned long m = 0, n;
	unsigned long long f;
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
3481abf8:	e3a0603c 	mov	r6, #60	; 0x3c
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
		if (size >> d) {
3481abfc:	e1a00004 	mov	r0, r4
3481ac00:	e1a01005 	mov	r1, r5
3481ac04:	e1a02006 	mov	r2, r6
3481ac08:	eb0015ba 	bl	348202f8 <__lshrdi3>
3481ac0c:	e1901001 	orrs	r1, r0, r1
3481ac10:	0a000004 	beq	3481ac28 <print_size+0x44>
			c = names[i];
3481ac14:	e59f30e0 	ldr	r3, [pc, #224]	; 3481acfc <print_size+0x118>
3481ac18:	e7d3a00a 	ldrb	sl, [r3, sl]
			break;
		}
	}

	if (!c) {
3481ac1c:	e35a0000 	cmp	sl, #0
3481ac20:	1a00000b 	bne	3481ac54 <print_size+0x70>
3481ac24:	ea000003 	b	3481ac38 <print_size+0x54>
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
3481ac28:	e28aa001 	add	sl, sl, #1
3481ac2c:	e35a0006 	cmp	sl, #6
3481ac30:	1246600a 	subne	r6, r6, #10
3481ac34:	1afffff0 	bne	3481abfc <print_size+0x18>
			break;
		}
	}

	if (!c) {
		printf("%llu Bytes%s", size, s);
3481ac38:	e1a02004 	mov	r2, r4
3481ac3c:	e1a03005 	mov	r3, r5
3481ac40:	e59f00b8 	ldr	r0, [pc, #184]	; 3481ad00 <print_size+0x11c>
3481ac44:	e58d9000 	str	r9, [sp]
3481ac48:	ebffbbda 	bl	34809bb8 <printf>
	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
}
3481ac4c:	e28dd00c 	add	sp, sp, #12
3481ac50:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
	f = size & ((1ULL << d) - 1);
3481ac54:	e1a02006 	mov	r2, r6
	if (!c) {
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
3481ac58:	e1a07000 	mov	r7, r0
	f = size & ((1ULL << d) - 1);
3481ac5c:	e3a01000 	mov	r1, #0
3481ac60:	e3a00001 	mov	r0, #1
3481ac64:	eb0015b1 	bl	34820330 <__ashldi3>
3481ac68:	e3e02000 	mvn	r2, #0
3481ac6c:	e0922000 	adds	r2, r2, r0
3481ac70:	e3e03000 	mvn	r3, #0
3481ac74:	e0a33001 	adc	r3, r3, r1
3481ac78:	e0022004 	and	r2, r2, r4
3481ac7c:	e0033005 	and	r3, r3, r5

	/* If there's a remainder, deal with it */
	if (f) {
3481ac80:	e1924003 	orrs	r4, r2, r3
3481ac84:	0a00000e 	beq	3481acc4 <print_size+0xe0>
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
3481ac88:	e3a0100a 	mov	r1, #10
3481ac8c:	e0854192 	umull	r4, r5, r2, r1
3481ac90:	e3a00001 	mov	r0, #1
3481ac94:	e0255391 	mla	r5, r1, r3, r5
3481ac98:	e2462001 	sub	r2, r6, #1
3481ac9c:	e3a01000 	mov	r1, #0
3481aca0:	eb0015a2 	bl	34820330 <__ashldi3>
3481aca4:	e0900004 	adds	r0, r0, r4
3481aca8:	e0a11005 	adc	r1, r1, r5
3481acac:	e1a02006 	mov	r2, r6
3481acb0:	eb001590 	bl	348202f8 <__lshrdi3>

		if (m >= 10) {
3481acb4:	e3500009 	cmp	r0, #9
	n = size >> d;
	f = size & ((1ULL << d) - 1);

	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
3481acb8:	e1a04000 	mov	r4, r0

		if (m >= 10) {
			m -= 10;
			n += 1;
3481acbc:	82877001 	addhi	r7, r7, #1
	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;

		if (m >= 10) {
			m -= 10;
3481acc0:	8240400a 	subhi	r4, r0, #10
			n += 1;
		}
	}

	printf ("%lu", n);
3481acc4:	e59f0038 	ldr	r0, [pc, #56]	; 3481ad04 <print_size+0x120>
3481acc8:	e1a01007 	mov	r1, r7
3481accc:	ebffbbb9 	bl	34809bb8 <printf>
	if (m) {
3481acd0:	e3540000 	cmp	r4, #0
3481acd4:	0a000002 	beq	3481ace4 <print_size+0x100>
		printf (".%ld", m);
3481acd8:	e59f0028 	ldr	r0, [pc, #40]	; 3481ad08 <print_size+0x124>
3481acdc:	e1a01004 	mov	r1, r4
3481ace0:	ebffbbb4 	bl	34809bb8 <printf>
	}
	printf (" %ciB%s", c, s);
3481ace4:	e59f0020 	ldr	r0, [pc, #32]	; 3481ad0c <print_size+0x128>
3481ace8:	e1a0100a 	mov	r1, sl
3481acec:	e1a02009 	mov	r2, r9
}
3481acf0:	e28dd00c 	add	sp, sp, #12
3481acf4:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}

	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
3481acf8:	eaffbbae 	b	34809bb8 <printf>
3481acfc:	348220e0 	.word	0x348220e0
3481ad00:	34828156 	.word	0x34828156
3481ad04:	34828163 	.word	0x34828163
3481ad08:	34828167 	.word	0x34828167
3481ad0c:	3482816c 	.word	0x3482816c

3481ad10 <print_buffer>:
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
3481ad10:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481ad14:	e24dd050 	sub	sp, sp, #80	; 0x50
3481ad18:	e59d5070 	ldr	r5, [sp, #112]	; 0x70
3481ad1c:	e1a07003 	mov	r7, r3
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
3481ad20:	e0030592 	mul	r3, r2, r5
3481ad24:	e3530040 	cmp	r3, #64	; 0x40
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
3481ad28:	e1a0b000 	mov	fp, r0
3481ad2c:	e1a09001 	mov	r9, r1
3481ad30:	e1a04002 	mov	r4, r2
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
3481ad34:	9a000003 	bls	3481ad48 <print_buffer+0x38>
		linelen = MAX_LINE_LENGTH_BYTES / width;
3481ad38:	e3a00040 	mov	r0, #64	; 0x40
3481ad3c:	e1a01002 	mov	r1, r2
3481ad40:	eb001459 	bl	3481feac <__udivsi3>
3481ad44:	e1a05000 	mov	r5, r0
	if (linelen < 1)
3481ad48:	e3550000 	cmp	r5, #0
3481ad4c:	1a00003c 	bne	3481ae44 <print_buffer+0x134>
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;
3481ad50:	e3a00010 	mov	r0, #16
3481ad54:	e1a01004 	mov	r1, r4
3481ad58:	eb001453 	bl	3481feac <__udivsi3>
3481ad5c:	e1a05000 	mov	r5, r0
3481ad60:	ea000037 	b	3481ae44 <print_buffer+0x134>

	while (count) {
		printf("%08lx:", addr);
3481ad64:	e59f00fc 	ldr	r0, [pc, #252]	; 3481ae68 <print_buffer+0x158>
3481ad68:	e1a0100b 	mov	r1, fp
3481ad6c:	ebffbb91 	bl	34809bb8 <printf>
3481ad70:	e1550007 	cmp	r5, r7
3481ad74:	21a05007 	movcs	r5, r7
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
3481ad78:	e1a0a009 	mov	sl, r9
3481ad7c:	e3a06000 	mov	r6, #0
3481ad80:	ea000010 	b	3481adc8 <print_buffer+0xb8>
			uint32_t x;
			if (width == 4)
3481ad84:	e3540004 	cmp	r4, #4
				x = lb.ui[i] = *(volatile uint32_t *)data;
3481ad88:	059a2000 	ldreq	r2, [sl]
3481ad8c:	028d300c 	addeq	r3, sp, #12
3481ad90:	07832106 	streq	r2, [r3, r6, lsl #2]
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
3481ad94:	0a000006 	beq	3481adb4 <print_buffer+0xa4>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
3481ad98:	e3540002 	cmp	r4, #2
				x = lb.us[i] = *(volatile uint16_t *)data;
3481ad9c:	01da20b0 	ldrheq	r2, [sl]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481ada0:	15da2000 	ldrbne	r2, [sl]
3481ada4:	e28d300c 	add	r3, sp, #12
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
3481ada8:	01a01086 	lsleq	r1, r6, #1
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
3481adac:	018320b1 	strheq	r2, [r3, r1]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481adb0:	17c32006 	strbne	r2, [r3, r6]
			printf(" %0*x", width * 2, x);
3481adb4:	e59f00b0 	ldr	r0, [pc, #176]	; 3481ae6c <print_buffer+0x15c>
3481adb8:	e59d1004 	ldr	r1, [sp, #4]
3481adbc:	ebffbb7d 	bl	34809bb8 <printf>
			data += width;
3481adc0:	e08aa004 	add	sl, sl, r4
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
3481adc4:	e2866001 	add	r6, r6, #1
3481adc8:	e1560005 	cmp	r6, r5
3481adcc:	3affffec 	bcc	3481ad84 <print_buffer+0x74>
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
3481add0:	e0060594 	mul	r6, r4, r5
3481add4:	e28d300c 	add	r3, sp, #12
3481add8:	e0899006 	add	r9, r9, r6
3481addc:	e0861003 	add	r1, r6, r3
3481ade0:	ea000008 	b	3481ae08 <print_buffer+0xf8>
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
3481ade4:	e4d32001 	ldrb	r2, [r3], #1
3481ade8:	e59fc080 	ldr	ip, [pc, #128]	; 3481ae70 <print_buffer+0x160>
3481adec:	e7dc0002 	ldrb	r0, [ip, r2]
3481adf0:	e3100097 	tst	r0, #151	; 0x97
3481adf4:	0a000001 	beq	3481ae00 <print_buffer+0xf0>
3481adf8:	e3120080 	tst	r2, #128	; 0x80
3481adfc:	0a000001 	beq	3481ae08 <print_buffer+0xf8>
				lb.uc[i] = '.';
3481ae00:	e3a0202e 	mov	r2, #46	; 0x2e
3481ae04:	e5432001 	strb	r2, [r3, #-1]
			printf(" %0*x", width * 2, x);
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
3481ae08:	e1530001 	cmp	r3, r1
3481ae0c:	1afffff4 	bne	3481ade4 <print_buffer+0xd4>
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
				lb.uc[i] = '.';
		}
		lb.uc[i] = '\0';
3481ae10:	e28dc050 	add	ip, sp, #80	; 0x50
3481ae14:	e08c3006 	add	r3, ip, r6
3481ae18:	e3a02000 	mov	r2, #0
3481ae1c:	e5432044 	strb	r2, [r3, #-68]	; 0x44
		printf("    %s\n", lb.uc);
3481ae20:	e28d100c 	add	r1, sp, #12
3481ae24:	e59f0048 	ldr	r0, [pc, #72]	; 3481ae74 <print_buffer+0x164>
3481ae28:	ebffbb62 	bl	34809bb8 <printf>

		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
3481ae2c:	ebffbb86 	bl	34809c4c <ctrlc>
3481ae30:	e3500000 	cmp	r0, #0
3481ae34:	1a000008 	bne	3481ae5c <print_buffer+0x14c>
		}
		lb.uc[i] = '\0';
		printf("    %s\n", lb.uc);

		/* update references */
		addr += linelen * width;
3481ae38:	e08bb006 	add	fp, fp, r6
		count -= linelen;
3481ae3c:	e0657007 	rsb	r7, r5, r7
3481ae40:	ea000001 	b	3481ae4c <print_buffer+0x13c>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
			printf(" %0*x", width * 2, x);
3481ae44:	e1a03084 	lsl	r3, r4, #1
3481ae48:	e58d3004 	str	r3, [sp, #4]
	if (linelen*width > MAX_LINE_LENGTH_BYTES)
		linelen = MAX_LINE_LENGTH_BYTES / width;
	if (linelen < 1)
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;

	while (count) {
3481ae4c:	e3570000 	cmp	r7, #0
3481ae50:	1affffc3 	bne	3481ad64 <print_buffer+0x54>

		if (ctrlc())
			return -1;
	}

	return 0;
3481ae54:	e1a00007 	mov	r0, r7
3481ae58:	ea000000 	b	3481ae60 <print_buffer+0x150>
		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
			return -1;
3481ae5c:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
3481ae60:	e28dd050 	add	sp, sp, #80	; 0x50
3481ae64:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481ae68:	348240b4 	.word	0x348240b4
3481ae6c:	34828174 	.word	0x34828174
3481ae70:	34821fe0 	.word	0x34821fe0
3481ae74:	3482817a 	.word	0x3482817a

3481ae78 <__div64_32>:
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481ae78:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	uint64_t rem = *n;
3481ae7c:	e1c060d0 	ldrd	r6, [r0]
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
3481ae80:	e1510007 	cmp	r1, r7
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481ae84:	e1a09000 	mov	r9, r0
3481ae88:	e1a0a001 	mov	sl, r1
	uint64_t rem = *n;
	uint64_t b = base;
3481ae8c:	e1a04001 	mov	r4, r1
3481ae90:	e3a05000 	mov	r5, #0
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
3481ae94:	8a000009 	bhi	3481aec0 <__div64_32+0x48>
		high /= base;
3481ae98:	e1a00007 	mov	r0, r7
3481ae9c:	eb001402 	bl	3481feac <__udivsi3>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
3481aea0:	e003009a 	mul	r3, sl, r0

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
3481aea4:	e3a0c000 	mov	ip, #0
		rem -= (uint64_t) (high*base) << 32;
3481aea8:	e1a0200c 	mov	r2, ip

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
3481aeac:	e58d0004 	str	r0, [sp, #4]
3481aeb0:	e58dc000 	str	ip, [sp]
		rem -= (uint64_t) (high*base) << 32;
3481aeb4:	e0566002 	subs	r6, r6, r2
3481aeb8:	e0c77003 	sbc	r7, r7, r3
3481aebc:	ea000002 	b	3481aecc <__div64_32+0x54>
	uint64_t b = base;
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
3481aec0:	e3a02000 	mov	r2, #0
3481aec4:	e3a03000 	mov	r3, #0
3481aec8:	e1cd20f0 	strd	r2, [sp]
3481aecc:	e3a00001 	mov	r0, #1
3481aed0:	e3a01000 	mov	r1, #0
3481aed4:	ea000003 	b	3481aee8 <__div64_32+0x70>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
		b = b+b;
3481aed8:	e0944004 	adds	r4, r4, r4
3481aedc:	e0a55005 	adc	r5, r5, r5
		d = d+d;
3481aee0:	e0900000 	adds	r0, r0, r0
3481aee4:	e0a11001 	adc	r1, r1, r1
		high /= base;
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
3481aee8:	e1a0afc5 	asr	sl, r5, #31
3481aeec:	e1a0200a 	mov	r2, sl
3481aef0:	e1a0300a 	mov	r3, sl
3481aef4:	e0522004 	subs	r2, r2, r4
3481aef8:	e0c33005 	sbc	r3, r3, r5
3481aefc:	e1570005 	cmp	r7, r5
3481af00:	e1a02fa3 	lsr	r2, r3, #31
3481af04:	e1a0b00a 	mov	fp, sl
3481af08:	e3a03001 	mov	r3, #1
3481af0c:	8a000003 	bhi	3481af20 <__div64_32+0xa8>
3481af10:	1a000001 	bne	3481af1c <__div64_32+0xa4>
3481af14:	e1560004 	cmp	r6, r4
3481af18:	8a000000 	bhi	3481af20 <__div64_32+0xa8>
3481af1c:	e3a03000 	mov	r3, #0
3481af20:	e1120003 	tst	r2, r3
3481af24:	1affffeb 	bne	3481aed8 <__div64_32+0x60>
3481af28:	e1cd20d0 	ldrd	r2, [sp]
		b = b+b;
		d = d+d;
	}

	do {
		if (rem >= b) {
3481af2c:	e1550007 	cmp	r5, r7
3481af30:	8a000006 	bhi	3481af50 <__div64_32+0xd8>
3481af34:	1a000001 	bne	3481af40 <__div64_32+0xc8>
3481af38:	e1540006 	cmp	r4, r6
3481af3c:	8a000003 	bhi	3481af50 <__div64_32+0xd8>
			rem -= b;
3481af40:	e0566004 	subs	r6, r6, r4
3481af44:	e0c77005 	sbc	r7, r7, r5
			res += d;
3481af48:	e0922000 	adds	r2, r2, r0
3481af4c:	e0a33001 	adc	r3, r3, r1
		}
		b >>= 1;
		d >>= 1;
3481af50:	e1b010a1 	lsrs	r1, r1, #1
3481af54:	e1a00060 	rrx	r0, r0
	} while (d);
3481af58:	e190c001 	orrs	ip, r0, r1
3481af5c:	0a000002 	beq	3481af6c <__div64_32+0xf4>
	do {
		if (rem >= b) {
			rem -= b;
			res += d;
		}
		b >>= 1;
3481af60:	e1b050a5 	lsrs	r5, r5, #1
3481af64:	e1a04064 	rrx	r4, r4
3481af68:	eaffffef 	b	3481af2c <__div64_32+0xb4>
		d >>= 1;
	} while (d);

	*n = res;
3481af6c:	e1c920f0 	strd	r2, [r9]
	return rem;
}
3481af70:	e1a00006 	mov	r0, r6
3481af74:	e28dd010 	add	sp, sp, #16
3481af78:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481af7c <gzfree>:
	return (p);
}

void gzfree(void *x, void *addr, unsigned nb)
{
	free (addr);
3481af7c:	e1a00001 	mov	r0, r1
3481af80:	eaffbc4a 	b	3480a0b0 <free>

3481af84 <gzalloc>:

void *gzalloc(void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
3481af84:	e0020291 	mul	r2, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
3481af88:	e282000f 	add	r0, r2, #15

	p = malloc (size);
3481af8c:	e3c0000f 	bic	r0, r0, #15
3481af90:	eaffbccf 	b	3480a2d4 <malloc>

3481af94 <zunzip>:
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481af94:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481af98:	e1a04003 	mov	r4, r3
	z_stream s;
	int r;

	s.zalloc = gzalloc;
3481af9c:	e59f30e4 	ldr	r3, [pc, #228]	; 3481b088 <zunzip+0xf4>
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481afa0:	e24dd040 	sub	sp, sp, #64	; 0x40
	z_stream s;
	int r;

	s.zalloc = gzalloc;
3481afa4:	e58d3024 	str	r3, [sp, #36]	; 0x24
	s.zfree = gzfree;
3481afa8:	e59f30dc 	ldr	r3, [pc, #220]	; 3481b08c <zunzip+0xf8>

	r = inflateInit2(&s, -MAX_WBITS);
3481afac:	e28da004 	add	sl, sp, #4
{
	z_stream s;
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;
3481afb0:	e58d3028 	str	r3, [sp, #40]	; 0x28
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481afb4:	e1a05000 	mov	r5, r0
3481afb8:	e1a07001 	mov	r7, r1
3481afbc:	e1a09002 	mov	r9, r2
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
3481afc0:	e3e0100e 	mvn	r1, #14
3481afc4:	e1a0000a 	mov	r0, sl
3481afc8:	e59f20c0 	ldr	r2, [pc, #192]	; 3481b090 <zunzip+0xfc>
3481afcc:	e3a0303c 	mov	r3, #60	; 0x3c
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481afd0:	e59db060 	ldr	fp, [sp, #96]	; 0x60
3481afd4:	e59d6064 	ldr	r6, [sp, #100]	; 0x64
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
3481afd8:	eb000cf1 	bl	3481e3a4 <inflateInit2_>
	if (r != Z_OK) {
3481afdc:	e2501000 	subs	r1, r0, #0
3481afe0:	0a000002 	beq	3481aff0 <zunzip+0x5c>
		printf ("Error: inflateInit2() returned %d\n", r);
3481afe4:	e59f00a8 	ldr	r0, [pc, #168]	; 3481b094 <zunzip+0x100>
3481afe8:	ebffbaf2 	bl	34809bb8 <printf>
3481afec:	ea000013 	b	3481b040 <zunzip+0xac>
		return -1;
	}
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
3481aff0:	e5943000 	ldr	r3, [r4]
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
3481aff4:	e0899006 	add	r9, r9, r6
	s.avail_in = *lenp - offset;
3481aff8:	e0663003 	rsb	r3, r6, r3
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
3481affc:	e58d9004 	str	r9, [sp, #4]
	s.avail_in = *lenp - offset;
3481b000:	e58d3008 	str	r3, [sp, #8]
	s.next_out = dst;
3481b004:	e58d5010 	str	r5, [sp, #16]
	s.avail_out = dstlen;
3481b008:	e58d7014 	str	r7, [sp, #20]
	do {
		r = inflate(&s, Z_FINISH);
3481b00c:	e3a01004 	mov	r1, #4
3481b010:	e1a0000a 	mov	r0, sl
3481b014:	eb000dfd 	bl	3481e810 <inflate>
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481b018:	e3500001 	cmp	r0, #1
3481b01c:	13700005 	cmnne	r0, #5
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
	s.next_out = dst;
	s.avail_out = dstlen;
	do {
		r = inflate(&s, Z_FINISH);
3481b020:	e1a01000 	mov	r1, r0
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481b024:	0a000007 	beq	3481b048 <zunzip+0xb4>
3481b028:	e35b0001 	cmp	fp, #1
3481b02c:	1a000005 	bne	3481b048 <zunzip+0xb4>
			printf("Error: inflate() returned %d\n", r);
3481b030:	e59f0060 	ldr	r0, [pc, #96]	; 3481b098 <zunzip+0x104>
3481b034:	ebffbadf 	bl	34809bb8 <printf>
			inflateEnd(&s);
3481b038:	e1a0000a 	mov	r0, sl
3481b03c:	eb000d1e 	bl	3481e4bc <inflateEnd>
			return -1;
3481b040:	e3e00000 	mvn	r0, #0
3481b044:	ea00000d 	b	3481b080 <zunzip+0xec>
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481b048:	e59d3010 	ldr	r3, [sp, #16]
3481b04c:	e5942000 	ldr	r2, [r4]
3481b050:	e0630005 	rsb	r0, r3, r5
3481b054:	e0802002 	add	r2, r0, r2
3481b058:	e0662002 	rsb	r2, r6, r2
		s.avail_out = dstlen;
	} while (r == Z_BUF_ERROR);
3481b05c:	e3710005 	cmn	r1, #5
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
			printf("Error: inflate() returned %d\n", r);
			inflateEnd(&s);
			return -1;
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481b060:	e58d2008 	str	r2, [sp, #8]
		s.avail_out = dstlen;
3481b064:	e58d7014 	str	r7, [sp, #20]
	} while (r == Z_BUF_ERROR);
3481b068:	0affffe7 	beq	3481b00c <zunzip+0x78>
	*lenp = s.next_out - (unsigned char *) dst;
3481b06c:	e0655003 	rsb	r5, r5, r3
3481b070:	e5845000 	str	r5, [r4]
	inflateEnd(&s);
3481b074:	e28d0004 	add	r0, sp, #4
3481b078:	eb000d0f 	bl	3481e4bc <inflateEnd>

	return 0;
3481b07c:	e3a00000 	mov	r0, #0
}
3481b080:	e28dd040 	add	sp, sp, #64	; 0x40
3481b084:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b088:	3481af84 	.word	0x3481af84
3481b08c:	3481af7c 	.word	0x3481af7c
3481b090:	34828182 	.word	0x34828182
3481b094:	34828188 	.word	0x34828188
3481b098:	348281ab 	.word	0x348281ab

3481b09c <gunzip>:
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481b09c:	e5d2c002 	ldrb	ip, [r2, #2]
{
	free (addr);
}

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
3481b0a0:	e92d4013 	push	{r0, r1, r4, lr}
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481b0a4:	e35c0008 	cmp	ip, #8
{
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
3481b0a8:	e5d2e003 	ldrb	lr, [r2, #3]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481b0ac:	1a000001 	bne	3481b0b8 <gunzip+0x1c>
3481b0b0:	e31e00e0 	tst	lr, #224	; 0xe0
3481b0b4:	0a000001 	beq	3481b0c0 <gunzip+0x24>
		puts ("Error: Bad gzipped data\n");
3481b0b8:	e59f0080 	ldr	r0, [pc, #128]	; 3481b140 <gunzip+0xa4>
3481b0bc:	ea000017 	b	3481b120 <gunzip+0x84>
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
3481b0c0:	e31e0004 	tst	lr, #4
		i = 12 + src[10] + (src[11] << 8);
3481b0c4:	15d2c00a 	ldrbne	ip, [r2, #10]
3481b0c8:	15d2400b 	ldrbne	r4, [r2, #11]
3481b0cc:	128cc00c 	addne	ip, ip, #12
3481b0d0:	108cc404 	addne	ip, ip, r4, lsl #8
int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
	int i, flags;

	/* skip header */
	i = 10;
3481b0d4:	03a0c00a 	moveq	ip, #10
		puts ("Error: Bad gzipped data\n");
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
		i = 12 + src[10] + (src[11] << 8);
	if ((flags & ORIG_NAME) != 0)
3481b0d8:	e31e0008 	tst	lr, #8
3481b0dc:	0a000003 	beq	3481b0f0 <gunzip+0x54>
		while (src[i++] != 0)
3481b0e0:	e7d2400c 	ldrb	r4, [r2, ip]
3481b0e4:	e28cc001 	add	ip, ip, #1
3481b0e8:	e3540000 	cmp	r4, #0
3481b0ec:	1afffffb 	bne	3481b0e0 <gunzip+0x44>
			;
	if ((flags & COMMENT) != 0)
3481b0f0:	e31e0010 	tst	lr, #16
3481b0f4:	0a000003 	beq	3481b108 <gunzip+0x6c>
		while (src[i++] != 0)
3481b0f8:	e7d2400c 	ldrb	r4, [r2, ip]
3481b0fc:	e28cc001 	add	ip, ip, #1
3481b100:	e3540000 	cmp	r4, #0
3481b104:	1afffffb 	bne	3481b0f8 <gunzip+0x5c>
			;
	if ((flags & HEAD_CRC) != 0)
3481b108:	e31e0002 	tst	lr, #2
		i += 2;
	if (i >= *lenp) {
3481b10c:	e593e000 	ldr	lr, [r3]
			;
	if ((flags & COMMENT) != 0)
		while (src[i++] != 0)
			;
	if ((flags & HEAD_CRC) != 0)
		i += 2;
3481b110:	128cc002 	addne	ip, ip, #2
	if (i >= *lenp) {
3481b114:	e15c000e 	cmp	ip, lr
3481b118:	3a000003 	bcc	3481b12c <gunzip+0x90>
		puts ("Error: gunzip out of data in header\n");
3481b11c:	e59f0020 	ldr	r0, [pc, #32]	; 3481b144 <gunzip+0xa8>
3481b120:	ebffba9a 	bl	34809b90 <puts>
		return (-1);
3481b124:	e3e00000 	mvn	r0, #0
3481b128:	ea000003 	b	3481b13c <gunzip+0xa0>
	}

	return zunzip(dst, dstlen, src, lenp, 1, i);
3481b12c:	e3a0e001 	mov	lr, #1
3481b130:	e58de000 	str	lr, [sp]
3481b134:	e58dc004 	str	ip, [sp, #4]
3481b138:	ebffff95 	bl	3481af94 <zunzip>
}
3481b13c:	e8bd801c 	pop	{r2, r3, r4, pc}
3481b140:	348281c9 	.word	0x348281c9
3481b144:	348281e2 	.word	0x348281e2

3481b148 <drop_var_from_set>:
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
3481b148:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
3481b14c:	e251a000 	subs	sl, r1, #0
3481b150:	13a05000 	movne	r5, #0
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
3481b154:	e1a04000 	mov	r4, r0
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
3481b158:	11a07002 	movne	r7, r2
3481b15c:	11a06005 	movne	r6, r5
3481b160:	1a000009 	bne	3481b18c <drop_var_from_set+0x44>
3481b164:	ea00000b 	b	3481b198 <drop_var_from_set+0x50>
		return 1;

	for (i = 0; i < nvars; i++) {
		if (vars[i] == NULL)
3481b168:	e4971004 	ldr	r1, [r7], #4
3481b16c:	e3510000 	cmp	r1, #0
3481b170:	0a000004 	beq	3481b188 <drop_var_from_set+0x40>
			continue;
		/* If we found it, delete all of them */
		if (!strcmp(name, vars[i])) {
3481b174:	e1a00004 	mov	r0, r4
3481b178:	eb00050b 	bl	3481c5ac <strcmp>
3481b17c:	e3500000 	cmp	r0, #0
			vars[i] = NULL;
3481b180:	05070004 	streq	r0, [r7, #-4]
			res = 1;
3481b184:	03a05001 	moveq	r5, #1

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;

	for (i = 0; i < nvars; i++) {
3481b188:	e2866001 	add	r6, r6, #1
3481b18c:	e156000a 	cmp	r6, sl
3481b190:	bafffff4 	blt	3481b168 <drop_var_from_set+0x20>
3481b194:	ea000000 	b	3481b19c <drop_var_from_set+0x54>
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;
3481b198:	e3a05001 	mov	r5, #1
	}
	if (!res)
		debug("Skipping non-listed variable %s\n", name);

	return res;
}
3481b19c:	e1a00005 	mov	r0, r5
3481b1a0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481b1a4 <cmpkey>:
static int cmpkey(const void *p1, const void *p2)
{
	ENTRY *e1 = *(ENTRY **) p1;
	ENTRY *e2 = *(ENTRY **) p2;

	return (strcmp(e1->key, e2->key));
3481b1a4:	e5902000 	ldr	r2, [r0]
3481b1a8:	e5913000 	ldr	r3, [r1]
3481b1ac:	e5920000 	ldr	r0, [r2]
3481b1b0:	e5931000 	ldr	r1, [r3]
3481b1b4:	ea0004fc 	b	3481c5ac <strcmp>

3481b1b8 <hcreate_r>:
 * The contents of the table is zeroed, especially the field used
 * becomes zero.
 */

int hcreate_r(size_t nel, struct hsearch_data *htab)
{
3481b1b8:	e92d4070 	push	{r4, r5, r6, lr}
	/* Test for correct arguments.  */
	if (htab == NULL) {
3481b1bc:	e2516000 	subs	r6, r1, #0
3481b1c0:	1a000004 	bne	3481b1d8 <hcreate_r+0x20>
		__set_errno(EINVAL);
3481b1c4:	e59f3094 	ldr	r3, [pc, #148]	; 3481b260 <hcreate_r+0xa8>
3481b1c8:	e3a02016 	mov	r2, #22
3481b1cc:	e5832000 	str	r2, [r3]
		return 0;
3481b1d0:	e1a00006 	mov	r0, r6
3481b1d4:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
3481b1d8:	e5963000 	ldr	r3, [r6]
3481b1dc:	e3530000 	cmp	r3, #0
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
3481b1e0:	03804001 	orreq	r4, r0, #1
		__set_errno(EINVAL);
		return 0;
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
3481b1e4:	1a00001b 	bne	3481b258 <hcreate_r+0xa0>
3481b1e8:	ea000000 	b	3481b1f0 <hcreate_r+0x38>
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;
3481b1ec:	e2844002 	add	r4, r4, #2
 * b)  the number is small because the table must fit in the core
 * */
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;
3481b1f0:	e3a05003 	mov	r5, #3
3481b1f4:	ea000000 	b	3481b1fc <hcreate_r+0x44>

	while (div * div < number && number % div != 0)
		div += 2;
3481b1f8:	e2855002 	add	r5, r5, #2
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;

	while (div * div < number && number % div != 0)
3481b1fc:	e0030595 	mul	r3, r5, r5
3481b200:	e1530004 	cmp	r3, r4
3481b204:	2a000004 	bcs	3481b21c <hcreate_r+0x64>
3481b208:	e1a00004 	mov	r0, r4
3481b20c:	e1a01005 	mov	r1, r5
3481b210:	eb0013a0 	bl	34820098 <__aeabi_uidivmod>
3481b214:	e3510000 	cmp	r1, #0
3481b218:	1afffff6 	bne	3481b1f8 <hcreate_r+0x40>
		div += 2;

	return number % div != 0;
3481b21c:	e1a00004 	mov	r0, r4
3481b220:	e1a01005 	mov	r1, r5
3481b224:	eb00139b 	bl	34820098 <__aeabi_uidivmod>
	if (htab->table != NULL)
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
3481b228:	e3510000 	cmp	r1, #0
3481b22c:	0affffee 	beq	3481b1ec <hcreate_r+0x34>
		nel += 2;

	htab->size = nel;
	htab->filled = 0;
3481b230:	e3a03000 	mov	r3, #0
	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;

	htab->size = nel;
3481b234:	e5864004 	str	r4, [r6, #4]
	htab->filled = 0;
3481b238:	e5863008 	str	r3, [r6, #8]

	/* allocate memory and zero out */
	htab->table = (_ENTRY *) calloc(htab->size + 1, sizeof(_ENTRY));
3481b23c:	e2840001 	add	r0, r4, #1
3481b240:	e3a0100c 	mov	r1, #12
3481b244:	ebffbd8f 	bl	3480a888 <calloc>
3481b248:	e5860000 	str	r0, [r6]
int hcreate_r(size_t nel, struct hsearch_data *htab)
{
	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
		return 0;
3481b24c:	e2500000 	subs	r0, r0, #0
3481b250:	13a00001 	movne	r0, #1
3481b254:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
		return 0;
3481b258:	e3a00000 	mov	r0, #0
	if (htab->table == NULL)
		return 0;

	/* everything went alright */
	return 1;
}
3481b25c:	e8bd8070 	pop	{r4, r5, r6, pc}
3481b260:	3482bee8 	.word	0x3482bee8

3481b264 <hdestroy_r>:
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
3481b264:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481b268:	e2504000 	subs	r4, r0, #0
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
3481b26c:	e1a0a001 	mov	sl, r1
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481b270:	13a0600c 	movne	r6, #12
3481b274:	13a07001 	movne	r7, #1
3481b278:	1a000017 	bne	3481b2dc <hdestroy_r+0x78>
		__set_errno(EINVAL);
3481b27c:	e59f3078 	ldr	r3, [pc, #120]	; 3481b2fc <hdestroy_r+0x98>
3481b280:	e3a02016 	mov	r2, #22
3481b284:	e5832000 	str	r2, [r3]
		return;
3481b288:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
		if (htab->table[i].used > 0) {
3481b28c:	e5943000 	ldr	r3, [r4]
3481b290:	e0835006 	add	r5, r3, r6
3481b294:	e7933006 	ldr	r3, [r3, r6]
3481b298:	e3530000 	cmp	r3, #0
3481b29c:	da00000c 	ble	3481b2d4 <hdestroy_r+0x70>
			ENTRY *ep = &htab->table[i].entry;
			if (do_apply && htab->apply != NULL) {
3481b2a0:	e35a0000 	cmp	sl, #0
3481b2a4:	0a000006 	beq	3481b2c4 <hdestroy_r+0x60>
3481b2a8:	e594c00c 	ldr	ip, [r4, #12]
3481b2ac:	e35c0000 	cmp	ip, #0
3481b2b0:	0a000003 	beq	3481b2c4 <hdestroy_r+0x60>
				/* deletion is always forced */
				htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481b2b4:	e9950003 	ldmib	r5, {r0, r1}
3481b2b8:	e3a02000 	mov	r2, #0
3481b2bc:	e3a03002 	mov	r3, #2
3481b2c0:	e12fff3c 	blx	ip
			}
			free((void *)ep->key);
3481b2c4:	e5950004 	ldr	r0, [r5, #4]
3481b2c8:	ebffbb78 	bl	3480a0b0 <free>
			free(ep->data);
3481b2cc:	e5950008 	ldr	r0, [r5, #8]
3481b2d0:	ebffbb76 	bl	3480a0b0 <free>
		__set_errno(EINVAL);
		return;
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
3481b2d4:	e2877001 	add	r7, r7, #1
3481b2d8:	e286600c 	add	r6, r6, #12
3481b2dc:	e5943004 	ldr	r3, [r4, #4]
3481b2e0:	e1570003 	cmp	r7, r3
3481b2e4:	9affffe8 	bls	3481b28c <hdestroy_r+0x28>
			}
			free((void *)ep->key);
			free(ep->data);
		}
	}
	free(htab->table);
3481b2e8:	e5940000 	ldr	r0, [r4]
3481b2ec:	ebffbb6f 	bl	3480a0b0 <free>

	/* the sign for an existing table is an value != NULL in htable */
	htab->table = NULL;
3481b2f0:	e3a03000 	mov	r3, #0
3481b2f4:	e5843000 	str	r3, [r4]
3481b2f8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481b2fc:	3482bee8 	.word	0x3482bee8

3481b300 <hstrstr_r>:
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b300:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b304:	e2817001 	add	r7, r1, #1
3481b308:	e3a0600c 	mov	r6, #12
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b30c:	e1a04000 	mov	r4, r0
3481b310:	e1a05002 	mov	r5, r2
3481b314:	e1a0a003 	mov	sl, r3
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b318:	e0060796 	mul	r6, r6, r7
3481b31c:	ea000018 	b	3481b384 <hstrstr_r+0x84>
		if (htab->table[idx].used <= 0)
3481b320:	e59a3000 	ldr	r3, [sl]
3481b324:	e0832006 	add	r2, r3, r6
3481b328:	e7933006 	ldr	r3, [r3, r6]
3481b32c:	e3530000 	cmp	r3, #0
3481b330:	da000011 	ble	3481b37c <hstrstr_r+0x7c>
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
3481b334:	e5920004 	ldr	r0, [r2, #4]
3481b338:	e1a01004 	mov	r1, r4
3481b33c:	eb0005dd 	bl	3481cab8 <strstr>
3481b340:	e3500000 	cmp	r0, #0
3481b344:	1a000006 	bne	3481b364 <hstrstr_r+0x64>
		    strstr(htab->table[idx].entry.data, match)) {
3481b348:	e59a3000 	ldr	r3, [sl]
3481b34c:	e1a01004 	mov	r1, r4
3481b350:	e0833006 	add	r3, r3, r6
3481b354:	e5930008 	ldr	r0, [r3, #8]
3481b358:	eb0005d6 	bl	3481cab8 <strstr>
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
3481b35c:	e3500000 	cmp	r0, #0
3481b360:	0a000005 	beq	3481b37c <hstrstr_r+0x7c>
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
3481b364:	e59a3000 	ldr	r3, [sl]
			return idx;
3481b368:	e1a00007 	mov	r0, r7
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
3481b36c:	e0836006 	add	r6, r3, r6
3481b370:	e2866004 	add	r6, r6, #4
3481b374:	e5856000 	str	r6, [r5]
			return idx;
3481b378:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b37c:	e2877001 	add	r7, r7, #1
3481b380:	e286600c 	add	r6, r6, #12
3481b384:	e59a3004 	ldr	r3, [sl, #4]
3481b388:	e1570003 	cmp	r7, r3
3481b38c:	3affffe3 	bcc	3481b320 <hstrstr_r+0x20>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b390:	e59f3010 	ldr	r3, [pc, #16]	; 3481b3a8 <hstrstr_r+0xa8>
3481b394:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481b398:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b39c:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481b3a0:	e5850000 	str	r0, [r5]
	return 0;
}
3481b3a4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481b3a8:	3482bee8 	.word	0x3482bee8

3481b3ac <hmatch_r>:

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
3481b3ac:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3481b3b0:	e1a05001 	mov	r5, r1
3481b3b4:	e1a09000 	mov	r9, r0
3481b3b8:	e1a04002 	mov	r4, r2
3481b3bc:	e1a07003 	mov	r7, r3
	unsigned int idx;
	size_t key_len = strlen(match);
3481b3c0:	eb0004ad 	bl	3481c67c <strlen>

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b3c4:	e2855001 	add	r5, r5, #1
3481b3c8:	e3a0600c 	mov	r6, #12

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);
3481b3cc:	e1a0a000 	mov	sl, r0

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b3d0:	e0060596 	mul	r6, r6, r5
3481b3d4:	ea000012 	b	3481b424 <hmatch_r+0x78>
		if (htab->table[idx].used <= 0)
3481b3d8:	e5972000 	ldr	r2, [r7]
3481b3dc:	e0823006 	add	r3, r2, r6
3481b3e0:	e7922006 	ldr	r2, [r2, r6]
3481b3e4:	e3520000 	cmp	r2, #0
3481b3e8:	da00000b 	ble	3481b41c <hmatch_r+0x70>
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
3481b3ec:	e1a00009 	mov	r0, r9
3481b3f0:	e5931004 	ldr	r1, [r3, #4]
3481b3f4:	e1a0200a 	mov	r2, sl
3481b3f8:	eb000477 	bl	3481c5dc <strncmp>
3481b3fc:	e3500000 	cmp	r0, #0
3481b400:	1a000005 	bne	3481b41c <hmatch_r+0x70>
			*retval = &htab->table[idx].entry;
3481b404:	e5973000 	ldr	r3, [r7]
			return idx;
3481b408:	e1a00005 	mov	r0, r5

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
			*retval = &htab->table[idx].entry;
3481b40c:	e0836006 	add	r6, r3, r6
3481b410:	e2866004 	add	r6, r6, #4
3481b414:	e5846000 	str	r6, [r4]
			return idx;
3481b418:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481b41c:	e2855001 	add	r5, r5, #1
3481b420:	e286600c 	add	r6, r6, #12
3481b424:	e5973004 	ldr	r3, [r7, #4]
3481b428:	e1550003 	cmp	r5, r3
3481b42c:	3affffe9 	bcc	3481b3d8 <hmatch_r+0x2c>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b430:	e59f3010 	ldr	r3, [pc, #16]	; 3481b448 <hmatch_r+0x9c>
3481b434:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481b438:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481b43c:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481b440:	e5840000 	str	r0, [r4]
	return 0;
}
3481b444:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3481b448:	3482bee8 	.word	0x3482bee8

3481b44c <hsearch_r>:

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b44c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481b450:	e24dd018 	sub	sp, sp, #24
3481b454:	e28dc010 	add	ip, sp, #16
3481b458:	e88c0003 	stm	ip, {r0, r1}
3481b45c:	e58d2008 	str	r2, [sp, #8]
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
3481b460:	e59d2014 	ldr	r2, [sp, #20]
	return 0;
}

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481b464:	e1a07003 	mov	r7, r3
3481b468:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
3481b46c:	e1a0b000 	mov	fp, r0
3481b470:	e58d2004 	str	r2, [sp, #4]
int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
3481b474:	eb000480 	bl	3481c67c <strlen>
3481b478:	e1a0a000 	mov	sl, r0
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
3481b47c:	ea000002 	b	3481b48c <hsearch_r+0x40>
3481b480:	e24aa001 	sub	sl, sl, #1
		hval <<= 4;
		hval += item.key[count];
3481b484:	e7db300a 	ldrb	r3, [fp, sl]
3481b488:	e0830200 	add	r0, r3, r0, lsl #4
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
3481b48c:	e35a0000 	cmp	sl, #0
3481b490:	1afffffa 	bne	3481b480 <hsearch_r+0x34>

	/*
	 * First hash function:
	 * simply take the modul but prevent zero.
	 */
	hval %= htab->size;
3481b494:	e5941004 	ldr	r1, [r4, #4]
3481b498:	eb0012fe 	bl	34820098 <__aeabi_uidivmod>
	if (hval == 0)
		++hval;
3481b49c:	e3510000 	cmp	r1, #0
3481b4a0:	11a06001 	movne	r6, r1
3481b4a4:	03a06001 	moveq	r6, #1

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
3481b4a8:	e3a0300c 	mov	r3, #12
3481b4ac:	e0090693 	mul	r9, r3, r6
3481b4b0:	e5942000 	ldr	r2, [r4]
3481b4b4:	e7925009 	ldr	r5, [r2, r9]
3481b4b8:	e0823009 	add	r3, r2, r9
3481b4bc:	e3550000 	cmp	r5, #0
3481b4c0:	01a05006 	moveq	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481b4c4:	058da00c 	streq	sl, [sp, #12]
		++hval;

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
3481b4c8:	0a000067 	beq	3481b66c <hsearch_r+0x220>
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481b4cc:	e3750001 	cmn	r5, #1
3481b4d0:	01a02006 	moveq	r2, r6
3481b4d4:	13a02000 	movne	r2, #0

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
3481b4d8:	e1550006 	cmp	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481b4dc:	e58d200c 	str	r2, [sp, #12]

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
3481b4e0:	1a000023 	bne	3481b574 <hsearch_r+0x128>
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481b4e4:	e1a0000b 	mov	r0, fp
3481b4e8:	e5931004 	ldr	r1, [r3, #4]
3481b4ec:	eb00042e 	bl	3481c5ac <strcmp>
3481b4f0:	e3500000 	cmp	r0, #0
3481b4f4:	1a00001e 	bne	3481b574 <hsearch_r+0x128>
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
3481b4f8:	e59d3008 	ldr	r3, [sp, #8]
3481b4fc:	e3530001 	cmp	r3, #1
3481b500:	1a000016 	bne	3481b560 <hsearch_r+0x114>
3481b504:	e59d2004 	ldr	r2, [sp, #4]
3481b508:	e3520000 	cmp	r2, #0
3481b50c:	0a000013 	beq	3481b560 <hsearch_r+0x114>
				free(htab->table[idx].entry.data);
3481b510:	e5943000 	ldr	r3, [r4]
3481b514:	e0833009 	add	r3, r3, r9
3481b518:	e5930008 	ldr	r0, [r3, #8]
3481b51c:	ebffbae3 	bl	3480a0b0 <free>
				htab->table[idx].entry.data =
					strdup(item.data);
3481b520:	e59d0004 	ldr	r0, [sp, #4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
3481b524:	e5946000 	ldr	r6, [r4]
					strdup(item.data);
3481b528:	eb000488 	bl	3481c750 <strdup>
				if (!htab->table[idx].entry.data) {
3481b52c:	e5943000 	ldr	r3, [r4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
3481b530:	e0866009 	add	r6, r6, r9
3481b534:	e5860008 	str	r0, [r6, #8]
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
3481b538:	e0833009 	add	r3, r3, r9
3481b53c:	e5933008 	ldr	r3, [r3, #8]
3481b540:	e3530000 	cmp	r3, #0
3481b544:	1a000005 	bne	3481b560 <hsearch_r+0x114>
					__set_errno(ENOMEM);
3481b548:	e59f31dc 	ldr	r3, [pc, #476]	; 3481b72c <hsearch_r+0x2e0>
3481b54c:	e3a0200c 	mov	r2, #12
3481b550:	e5832000 	str	r2, [r3]
					*retval = NULL;
					return 0;
3481b554:	e1a0500a 	mov	r5, sl
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
					__set_errno(ENOMEM);
					*retval = NULL;
3481b558:	e587a000 	str	sl, [r7]
					return 0;
3481b55c:	ea00006f 	b	3481b720 <hsearch_r+0x2d4>
				}
			}
			/* return found entry */
			*retval = &htab->table[idx].entry;
3481b560:	e5943000 	ldr	r3, [r4]
3481b564:	e0839009 	add	r9, r3, r9
3481b568:	e2899004 	add	r9, r9, #4
3481b56c:	e5879000 	str	r9, [r7]
			return idx;
3481b570:	ea00006a 	b	3481b720 <hsearch_r+0x2d4>

		/*
		 * Second hash function:
		 * as suggested in [Knuth]
		 */
		hval2 = 1 + hval % (htab->size - 2);
3481b574:	e5941004 	ldr	r1, [r4, #4]
3481b578:	e1a00006 	mov	r0, r6
3481b57c:	e2411002 	sub	r1, r1, #2
3481b580:	eb0012c4 	bl	34820098 <__aeabi_uidivmod>
3481b584:	e1a05006 	mov	r5, r6
3481b588:	e2819001 	add	r9, r1, #1
			 */
			if (idx == hval)
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
3481b58c:	e3a0c00c 	mov	ip, #12
		do {
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
3481b590:	e1550009 	cmp	r5, r9
				idx = htab->size + idx - hval2;
3481b594:	95943004 	ldrls	r3, [r4, #4]
			else
				idx -= hval2;
3481b598:	80695005 	rsbhi	r5, r9, r5
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
				idx = htab->size + idx - hval2;
3481b59c:	90693003 	rsbls	r3, r9, r3
3481b5a0:	90855003 	addls	r5, r5, r3

			/*
			 * If we visited all entries leave the loop
			 * unsuccessfully.
			 */
			if (idx == hval)
3481b5a4:	e1550006 	cmp	r5, r6
3481b5a8:	0a00002f 	beq	3481b66c <hsearch_r+0x220>
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
3481b5ac:	e00a059c 	mul	sl, ip, r5
3481b5b0:	e5942000 	ldr	r2, [r4]
3481b5b4:	e082300a 	add	r3, r2, sl
3481b5b8:	e792200a 	ldr	r2, [r2, sl]
3481b5bc:	e1520006 	cmp	r2, r6
3481b5c0:	1a000025 	bne	3481b65c <hsearch_r+0x210>
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481b5c4:	e5931004 	ldr	r1, [r3, #4]
3481b5c8:	e1a0000b 	mov	r0, fp
3481b5cc:	e58dc000 	str	ip, [sp]
3481b5d0:	eb0003f5 	bl	3481c5ac <strcmp>
3481b5d4:	e3500000 	cmp	r0, #0
3481b5d8:	e59dc000 	ldr	ip, [sp]
3481b5dc:	1a00001e 	bne	3481b65c <hsearch_r+0x210>
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
3481b5e0:	e59d3008 	ldr	r3, [sp, #8]
3481b5e4:	e3530001 	cmp	r3, #1
3481b5e8:	1a000016 	bne	3481b648 <hsearch_r+0x1fc>
3481b5ec:	e59d2004 	ldr	r2, [sp, #4]
3481b5f0:	e3520000 	cmp	r2, #0
3481b5f4:	0a000013 	beq	3481b648 <hsearch_r+0x1fc>
					free(htab->table[idx].entry.data);
3481b5f8:	e5943000 	ldr	r3, [r4]
3481b5fc:	e083300a 	add	r3, r3, sl
3481b600:	e5930008 	ldr	r0, [r3, #8]
3481b604:	ebffbaa9 	bl	3480a0b0 <free>
					htab->table[idx].entry.data =
						strdup(item.data);
3481b608:	e59d0004 	ldr	r0, [sp, #4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
3481b60c:	e5946000 	ldr	r6, [r4]
						strdup(item.data);
3481b610:	eb00044e 	bl	3481c750 <strdup>
					if (!htab->table[idx].entry.data) {
3481b614:	e5943000 	ldr	r3, [r4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
3481b618:	e086600a 	add	r6, r6, sl
3481b61c:	e5860008 	str	r0, [r6, #8]
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
3481b620:	e083300a 	add	r3, r3, sl
3481b624:	e5933008 	ldr	r3, [r3, #8]
3481b628:	e3530000 	cmp	r3, #0
3481b62c:	1a000005 	bne	3481b648 <hsearch_r+0x1fc>
						__set_errno(ENOMEM);
3481b630:	e59f20f4 	ldr	r2, [pc, #244]	; 3481b72c <hsearch_r+0x2e0>
3481b634:	e3a0100c 	mov	r1, #12
3481b638:	e5821000 	str	r1, [r2]
						*retval = NULL;
						return 0;
3481b63c:	e1a05003 	mov	r5, r3
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
						__set_errno(ENOMEM);
						*retval = NULL;
3481b640:	e5873000 	str	r3, [r7]
						return 0;
3481b644:	ea000035 	b	3481b720 <hsearch_r+0x2d4>
					}
				}
				/* return found entry */
				*retval = &htab->table[idx].entry;
3481b648:	e5943000 	ldr	r3, [r4]
3481b64c:	e083a00a 	add	sl, r3, sl
3481b650:	e28aa004 	add	sl, sl, #4
3481b654:	e587a000 	str	sl, [r7]
				return idx;
3481b658:	ea000030 	b	3481b720 <hsearch_r+0x2d4>
			}
		}
		while (htab->table[idx].used);
3481b65c:	e5943000 	ldr	r3, [r4]
3481b660:	e793300a 	ldr	r3, [r3, sl]
3481b664:	e3530000 	cmp	r3, #0
3481b668:	1affffc8 	bne	3481b590 <hsearch_r+0x144>
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
3481b66c:	e59d3008 	ldr	r3, [sp, #8]
3481b670:	e3530001 	cmp	r3, #1
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
3481b674:	13a02003 	movne	r2, #3
		}
		while (htab->table[idx].used);
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
3481b678:	1a000024 	bne	3481b710 <hsearch_r+0x2c4>
		/*
		 * If table is full and another entry should be
		 * entered return with error.
		 */
		if (htab->filled == htab->size) {
3481b67c:	e5942008 	ldr	r2, [r4, #8]
3481b680:	e5943004 	ldr	r3, [r4, #4]
3481b684:	e1520003 	cmp	r2, r3
3481b688:	0a000017 	beq	3481b6ec <hsearch_r+0x2a0>

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
3481b68c:	e59d200c 	ldr	r2, [sp, #12]
			idx = first_deleted;

		htab->table[idx].used = hval;
3481b690:	e3a0300c 	mov	r3, #12

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
3481b694:	e3520000 	cmp	r2, #0
3481b698:	11a05002 	movne	r5, r2
			idx = first_deleted;

		htab->table[idx].used = hval;
3481b69c:	e0050593 	mul	r5, r3, r5
3481b6a0:	e5943000 	ldr	r3, [r4]
		htab->table[idx].entry.key = strdup(item.key);
3481b6a4:	e1a0000b 	mov	r0, fp
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
3481b6a8:	e7836005 	str	r6, [r3, r5]
3481b6ac:	e083a005 	add	sl, r3, r5
		htab->table[idx].entry.key = strdup(item.key);
3481b6b0:	eb000426 	bl	3481c750 <strdup>
3481b6b4:	e58a0004 	str	r0, [sl, #4]
		htab->table[idx].entry.data = strdup(item.data);
3481b6b8:	e59d0004 	ldr	r0, [sp, #4]
3481b6bc:	e5946000 	ldr	r6, [r4]
3481b6c0:	eb000422 	bl	3481c750 <strdup>
		if (!htab->table[idx].entry.key ||
3481b6c4:	e5943000 	ldr	r3, [r4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
3481b6c8:	e0866005 	add	r6, r6, r5
		if (!htab->table[idx].entry.key ||
3481b6cc:	e0835005 	add	r5, r3, r5
3481b6d0:	e5953004 	ldr	r3, [r5, #4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
3481b6d4:	e5860008 	str	r0, [r6, #8]
		if (!htab->table[idx].entry.key ||
3481b6d8:	e3530000 	cmp	r3, #0
3481b6dc:	0a000002 	beq	3481b6ec <hsearch_r+0x2a0>
3481b6e0:	e5953008 	ldr	r3, [r5, #8]
3481b6e4:	e3530000 	cmp	r3, #0
3481b6e8:	1a000001 	bne	3481b6f4 <hsearch_r+0x2a8>
		    !htab->table[idx].entry.data) {
			__set_errno(ENOMEM);
3481b6ec:	e3a0200c 	mov	r2, #12
3481b6f0:	ea000006 	b	3481b710 <hsearch_r+0x2c4>
			*retval = NULL;
			return 0;
		}

		++htab->filled;
3481b6f4:	e5943008 	ldr	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
3481b6f8:	e2855004 	add	r5, r5, #4
			__set_errno(ENOMEM);
			*retval = NULL;
			return 0;
		}

		++htab->filled;
3481b6fc:	e2833001 	add	r3, r3, #1
3481b700:	e5843008 	str	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
3481b704:	e5875000 	str	r5, [r7]
		return 1;
3481b708:	e59d5008 	ldr	r5, [sp, #8]
3481b70c:	ea000003 	b	3481b720 <hsearch_r+0x2d4>
	}

	__set_errno(ESRCH);
3481b710:	e59f3014 	ldr	r3, [pc, #20]	; 3481b72c <hsearch_r+0x2e0>
	*retval = NULL;
3481b714:	e3a05000 	mov	r5, #0
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
3481b718:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481b71c:	e5875000 	str	r5, [r7]
	return 0;
}
3481b720:	e1a00005 	mov	r0, r5
3481b724:	e28dd018 	add	sp, sp, #24
3481b728:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b72c:	3482bee8 	.word	0x3482bee8

3481b730 <hdelete_r>:
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
3481b730:	e92d4070 	push	{r4, r5, r6, lr}
3481b734:	e24dd018 	sub	sp, sp, #24
	ENTRY e, *ep;
	int idx;

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;
3481b738:	e58d000c 	str	r0, [sp, #12]

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481b73c:	e58d1000 	str	r1, [sp]
3481b740:	e28d300c 	add	r3, sp, #12
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
3481b744:	e1a04001 	mov	r4, r1
3481b748:	e1a06002 	mov	r6, r2

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481b74c:	e8930003 	ldm	r3, {r0, r1}
3481b750:	e3a02000 	mov	r2, #0
3481b754:	e28d3014 	add	r3, sp, #20
3481b758:	ebffff3b 	bl	3481b44c <hsearch_r>
3481b75c:	e2505000 	subs	r5, r0, #0
		__set_errno(ESRCH);
3481b760:	059f3078 	ldreq	r3, [pc, #120]	; 3481b7e0 <hdelete_r+0xb0>
3481b764:	03a02003 	moveq	r2, #3
3481b768:	05832000 	streq	r2, [r3]
		return 0;	/* not found */
3481b76c:	01a00005 	moveq	r0, r5
3481b770:	0a000018 	beq	3481b7d8 <hdelete_r+0xa8>
	}

	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	if (do_apply && htab->apply != NULL)
3481b774:	e3560000 	cmp	r6, #0
3481b778:	0a000007 	beq	3481b79c <hdelete_r+0x6c>
3481b77c:	e594c00c 	ldr	ip, [r4, #12]
3481b780:	e35c0000 	cmp	ip, #0
3481b784:	0a000004 	beq	3481b79c <hdelete_r+0x6c>
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481b788:	e59d3014 	ldr	r3, [sp, #20]
3481b78c:	e3a02000 	mov	r2, #0
3481b790:	e8930003 	ldm	r3, {r0, r1}
3481b794:	e3a03002 	mov	r3, #2
3481b798:	e12fff3c 	blx	ip
	free((void *)ep->key);
3481b79c:	e59d3014 	ldr	r3, [sp, #20]
3481b7a0:	e5930000 	ldr	r0, [r3]
3481b7a4:	ebffba41 	bl	3480a0b0 <free>
	free(ep->data);
3481b7a8:	e59d3014 	ldr	r3, [sp, #20]
3481b7ac:	e5930004 	ldr	r0, [r3, #4]
3481b7b0:	ebffba3e 	bl	3480a0b0 <free>
	htab->table[idx].used = -1;
3481b7b4:	e3a0200c 	mov	r2, #12
3481b7b8:	e0050592 	mul	r5, r2, r5
3481b7bc:	e5943000 	ldr	r3, [r4]
3481b7c0:	e3e02000 	mvn	r2, #0
3481b7c4:	e7832005 	str	r2, [r3, r5]

	--htab->filled;
3481b7c8:	e5943008 	ldr	r3, [r4, #8]

	return 1;
3481b7cc:	e3a00001 	mov	r0, #1
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
	free((void *)ep->key);
	free(ep->data);
	htab->table[idx].used = -1;

	--htab->filled;
3481b7d0:	e0833002 	add	r3, r3, r2
3481b7d4:	e5843008 	str	r3, [r4, #8]

	return 1;
}
3481b7d8:	e28dd018 	add	sp, sp, #24
3481b7dc:	e8bd8070 	pop	{r4, r5, r6, pc}
3481b7e0:	3482bee8 	.word	0x3482bee8

3481b7e4 <hexport_r>:
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
3481b7e4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481b7e8:	e28db01c 	add	fp, sp, #28
3481b7ec:	e24dd018 	sub	sp, sp, #24
3481b7f0:	e1a04003 	mov	r4, r3
	ENTRY *list[htab->size];
3481b7f4:	e5903004 	ldr	r3, [r0, #4]
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
3481b7f8:	e3520000 	cmp	r2, #0

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
	ENTRY *list[htab->size];
3481b7fc:	e1a03103 	lsl	r3, r3, #2
3481b800:	e283300e 	add	r3, r3, #14
3481b804:	e3c33007 	bic	r3, r3, #7
3481b808:	e04dd003 	sub	sp, sp, r3
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
3481b80c:	e1a05000 	mov	r5, r0
3481b810:	e1a07001 	mov	r7, r1
	ENTRY *list[htab->size];
3481b814:	e50bd028 	str	sp, [fp, #-40]	; 0x28
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
3481b818:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
3481b81c:	0a000006 	beq	3481b83c <hexport_r+0x58>
3481b820:	e3a06000 	mov	r6, #0
3481b824:	e3a02001 	mov	r2, #1
3481b828:	e3a0900c 	mov	r9, #12
3481b82c:	e50b2024 	str	r2, [fp, #-36]	; 0x24
3481b830:	e50b6020 	str	r6, [fp, #-32]
3481b834:	e50b4030 	str	r4, [fp, #-48]	; 0x30
3481b838:	ea000041 	b	3481b944 <hexport_r+0x160>
		__set_errno(EINVAL);
3481b83c:	e3a02016 	mov	r2, #22
3481b840:	ea000054 	b	3481b998 <hexport_r+0x1b4>
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
3481b844:	e5953000 	ldr	r3, [r5]
3481b848:	e0834009 	add	r4, r3, r9
3481b84c:	e7933009 	ldr	r3, [r3, r9]
3481b850:	e3530000 	cmp	r3, #0
3481b854:	da000036 	ble	3481b934 <hexport_r+0x150>
3481b858:	e59b3008 	ldr	r3, [fp, #8]
3481b85c:	e1a02006 	mov	r2, r6
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
3481b860:	e3a0a000 	mov	sl, #0
3481b864:	e1a06003 	mov	r6, r3
3481b868:	ea000007 	b	3481b88c <hexport_r+0xa8>
				if (strcmp(argv[arg], ep->key) == 0) {
3481b86c:	e4960004 	ldr	r0, [r6], #4
3481b870:	e5941004 	ldr	r1, [r4, #4]
3481b874:	e50b2034 	str	r2, [fp, #-52]	; 0x34
3481b878:	eb00034b 	bl	3481c5ac <strcmp>
3481b87c:	e3500000 	cmp	r0, #0
3481b880:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
3481b884:	0a000006 	beq	3481b8a4 <hexport_r+0xc0>

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
3481b888:	e28aa001 	add	sl, sl, #1
3481b88c:	e59b3004 	ldr	r3, [fp, #4]
3481b890:	e15a0003 	cmp	sl, r3
3481b894:	bafffff4 	blt	3481b86c <hexport_r+0x88>
3481b898:	e1a06002 	mov	r6, r2
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;
3481b89c:	e3a03000 	mov	r3, #0
3481b8a0:	ea000001 	b	3481b8ac <hexport_r+0xc8>
3481b8a4:	e1a06002 	mov	r6, r2

			for (arg = 0; arg < argc; ++arg) {
				if (strcmp(argv[arg], ep->key) == 0) {
					found = 1;
3481b8a8:	e3a03001 	mov	r3, #1
					break;
				}
			}
			if ((argc > 0) && (found == 0))
3481b8ac:	e59b2004 	ldr	r2, [fp, #4]
3481b8b0:	e2233001 	eor	r3, r3, #1
3481b8b4:	e3520000 	cmp	r2, #0
3481b8b8:	d3a03000 	movle	r3, #0
3481b8bc:	c2033001 	andgt	r3, r3, #1
3481b8c0:	e3530000 	cmp	r3, #0
3481b8c4:	1a00001a 	bne	3481b934 <hexport_r+0x150>
				continue;

			list[n++] = ep;
3481b8c8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
3481b8cc:	e2843004 	add	r3, r4, #4
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
3481b8d0:	e7823106 	str	r3, [r2, r6, lsl #2]

			totlen += strlen(ep->key) + 2;
3481b8d4:	e5940004 	ldr	r0, [r4, #4]
3481b8d8:	eb000367 	bl	3481c67c <strlen>
3481b8dc:	e51b3020 	ldr	r3, [fp, #-32]

			if (sep == '\0') {
3481b8e0:	e3570000 	cmp	r7, #0
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;
3481b8e4:	e283a002 	add	sl, r3, #2
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
3481b8e8:	e2866001 	add	r6, r6, #1

			totlen += strlen(ep->key) + 2;
3481b8ec:	e08aa000 	add	sl, sl, r0

			if (sep == '\0') {
				totlen += strlen(ep->data);
3481b8f0:	15942008 	ldrne	r2, [r4, #8]

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;

			if (sep == '\0') {
3481b8f4:	1a000009 	bne	3481b920 <hexport_r+0x13c>
				totlen += strlen(ep->data);
3481b8f8:	e5940008 	ldr	r0, [r4, #8]
3481b8fc:	eb00035e 	bl	3481c67c <strlen>
3481b900:	e08aa000 	add	sl, sl, r0
3481b904:	ea000008 	b	3481b92c <hexport_r+0x148>
				char *s = ep->data;

				while (*s) {
					++totlen;
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
3481b908:	e1530007 	cmp	r3, r7
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
					++totlen;
3481b90c:	e28aa001 	add	sl, sl, #1
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
3481b910:	0a000001 	beq	3481b91c <hexport_r+0x138>
3481b914:	e353005c 	cmp	r3, #92	; 0x5c
3481b918:	1a000000 	bne	3481b920 <hexport_r+0x13c>
						++totlen;
3481b91c:	e28aa001 	add	sl, sl, #1
			if (sep == '\0') {
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
3481b920:	e4d23001 	ldrb	r3, [r2], #1
3481b924:	e3530000 	cmp	r3, #0
3481b928:	1afffff6 	bne	3481b908 <hexport_r+0x124>
					if ((*s == sep) || (*s == '\\'))
						++totlen;
					++s;
				}
			}
			totlen += 2;	/* for '=' and 'sep' char */
3481b92c:	e28aa002 	add	sl, sl, #2
3481b930:	e50ba020 	str	sl, [fp, #-32]
	/*
	 * Pass 1:
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
3481b934:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
3481b938:	e289900c 	add	r9, r9, #12
3481b93c:	e2822001 	add	r2, r2, #1
3481b940:	e50b2024 	str	r2, [fp, #-36]	; 0x24
3481b944:	e5953004 	ldr	r3, [r5, #4]
3481b948:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
3481b94c:	e1520003 	cmp	r2, r3
3481b950:	9affffbb 	bls	3481b844 <hexport_r+0x60>
		       i, list[i], list[i]->key, list[i]->data);
	}
#endif

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);
3481b954:	e3a02004 	mov	r2, #4
3481b958:	e59f3124 	ldr	r3, [pc, #292]	; 3481ba84 <hexport_r+0x2a0>
3481b95c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
3481b960:	e1a01006 	mov	r1, r6
3481b964:	e51b4030 	ldr	r4, [fp, #-48]	; 0x30
3481b968:	eb0002a0 	bl	3481c3f0 <qsort>
3481b96c:	e51b3020 	ldr	r3, [fp, #-32]

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
3481b970:	e3540000 	cmp	r4, #0
3481b974:	e2832001 	add	r2, r3, #1
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
			return (-1);
		}
	} else {
		size = totlen + 1;
3481b978:	01a04002 	moveq	r4, r2

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
3481b97c:	0a000009 	beq	3481b9a8 <hexport_r+0x1c4>
		if (size < totlen + 1) {	/* provided buffer too small */
3481b980:	e1540002 	cmp	r4, r2
3481b984:	2a000007 	bcs	3481b9a8 <hexport_r+0x1c4>
			printf("Env export buffer too small: %zu, "
3481b988:	e59f00f8 	ldr	r0, [pc, #248]	; 3481ba88 <hexport_r+0x2a4>
3481b98c:	e1a01004 	mov	r1, r4
3481b990:	ebffb888 	bl	34809bb8 <printf>
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
3481b994:	e3a0200c 	mov	r2, #12
3481b998:	e59f30ec 	ldr	r3, [pc, #236]	; 3481ba8c <hexport_r+0x2a8>
			return (-1);
3481b99c:	e3e00000 	mvn	r0, #0
	/* Check if the user supplied buffer size is sufficient */
	if (size) {
		if (size < totlen + 1) {	/* provided buffer too small */
			printf("Env export buffer too small: %zu, "
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
3481b9a0:	e5832000 	str	r2, [r3]
3481b9a4:	ea000034 	b	3481ba7c <hexport_r+0x298>
	} else {
		size = totlen + 1;
	}

	/* Check if the user provided a buffer */
	if (*resp) {
3481b9a8:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
3481b9ac:	e5925000 	ldr	r5, [r2]
3481b9b0:	e3550000 	cmp	r5, #0
3481b9b4:	0a000008 	beq	3481b9dc <hexport_r+0x1f8>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
3481b9b8:	e1a00005 	mov	r0, r5
3481b9bc:	e3a01000 	mov	r1, #0
3481b9c0:	e1a02004 	mov	r2, r4
3481b9c4:	eb0003cc 	bl	3481c8fc <memset>
3481b9c8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
		if (res == NULL) {
3481b9cc:	e3a03000 	mov	r3, #0
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
3481b9d0:	e3a0a03d 	mov	sl, #61	; 0x3d

		s = list[i]->data;

		while (*s) {
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
3481b9d4:	e3a0905c 	mov	r9, #92	; 0x5c
3481b9d8:	ea000022 	b	3481ba68 <hexport_r+0x284>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
3481b9dc:	e3a00001 	mov	r0, #1
3481b9e0:	e1a01004 	mov	r1, r4
3481b9e4:	ebffbba7 	bl	3480a888 <calloc>
3481b9e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
		if (res == NULL) {
3481b9ec:	e3500000 	cmp	r0, #0
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
3481b9f0:	e5830000 	str	r0, [r3]
		if (res == NULL) {
3481b9f4:	11a05000 	movne	r5, r0
3481b9f8:	1afffff2 	bne	3481b9c8 <hexport_r+0x1e4>
3481b9fc:	eaffffe4 	b	3481b994 <hexport_r+0x1b0>
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
3481ba00:	e4921004 	ldr	r1, [r2], #4
3481ba04:	e5911000 	ldr	r1, [r1]
		while (*s)
3481ba08:	ea000001 	b	3481ba14 <hexport_r+0x230>
			*p++ = *s++;
3481ba0c:	e5c50000 	strb	r0, [r5]
3481ba10:	e1a0500c 	mov	r5, ip
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
		while (*s)
3481ba14:	e4d10001 	ldrb	r0, [r1], #1
3481ba18:	e285c001 	add	ip, r5, #1
3481ba1c:	e3500000 	cmp	r0, #0
3481ba20:	1afffff9 	bne	3481ba0c <hexport_r+0x228>
			*p++ = *s++;
		*p++ = '=';
3481ba24:	e5c5a000 	strb	sl, [r5]

		s = list[i]->data;
3481ba28:	e5121004 	ldr	r1, [r2, #-4]
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
3481ba2c:	e1a0500c 	mov	r5, ip
3481ba30:	e5911004 	ldr	r1, [r1, #4]

		s = list[i]->data;

		while (*s) {
3481ba34:	ea000006 	b	3481ba54 <hexport_r+0x270>
			if ((*s == sep) || (*s == '\\'))
3481ba38:	e1500007 	cmp	r0, r7
3481ba3c:	0a000001 	beq	3481ba48 <hexport_r+0x264>
3481ba40:	e350005c 	cmp	r0, #92	; 0x5c
3481ba44:	1a000000 	bne	3481ba4c <hexport_r+0x268>
				*p++ = '\\';	/* escape */
3481ba48:	e4c59001 	strb	r9, [r5], #1
			*p++ = *s++;
3481ba4c:	e5510001 	ldrb	r0, [r1, #-1]
3481ba50:	e4c50001 	strb	r0, [r5], #1
			*p++ = *s++;
		*p++ = '=';

		s = list[i]->data;

		while (*s) {
3481ba54:	e4d10001 	ldrb	r0, [r1], #1
3481ba58:	e3500000 	cmp	r0, #0
3481ba5c:	1afffff5 	bne	3481ba38 <hexport_r+0x254>
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
3481ba60:	e4c57001 	strb	r7, [r5], #1
	}
	/*
	 * Pass 2:
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
3481ba64:	e2833001 	add	r3, r3, #1
3481ba68:	e1530006 	cmp	r3, r6
3481ba6c:	baffffe3 	blt	3481ba00 <hexport_r+0x21c>
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
	}
	*p = '\0';		/* terminate result */
3481ba70:	e3a03000 	mov	r3, #0
3481ba74:	e5c53000 	strb	r3, [r5]

	return size;
3481ba78:	e1a00004 	mov	r0, r4
}
3481ba7c:	e24bd01c 	sub	sp, fp, #28
3481ba80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481ba84:	3481b1a4 	.word	0x3481b1a4
3481ba88:	34828207 	.word	0x34828207
3481ba8c:	3482bee8 	.word	0x3482bee8

3481ba90 <himport_r>:
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481ba90:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481ba94:	e28db01c 	add	fp, sp, #28
3481ba98:	e24dd028 	sub	sp, sp, #40	; 0x28
3481ba9c:	e1a06002 	mov	r6, r2
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481baa0:	e59b2008 	ldr	r2, [fp, #8]
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481baa4:	e1a0a003 	mov	sl, r3
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481baa8:	e1a05102 	lsl	r5, r2, #2
3481baac:	e285300e 	add	r3, r5, #14
3481bab0:	e3c33007 	bic	r3, r3, #7
3481bab4:	e04dd003 	sub	sp, sp, r3
3481bab8:	e28d3008 	add	r3, sp, #8
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481babc:	e2504000 	subs	r4, r0, #0
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481bac0:	e1a07001 	mov	r7, r1
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481bac4:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
3481bac8:	059f3318 	ldreq	r3, [pc, #792]	; 3481bde8 <himport_r+0x358>
3481bacc:	03a02016 	moveq	r2, #22
3481bad0:	05832000 	streq	r2, [r3]
		return 0;
3481bad4:	01a00004 	moveq	r0, r4
3481bad8:	0a0000c0 	beq	3481bde0 <himport_r+0x350>
	}

	/* we allocate new space to make sure we can write to the array */
	if ((data = malloc(size)) == NULL) {
3481badc:	e1a00006 	mov	r0, r6
3481bae0:	ebffb9fb 	bl	3480a2d4 <malloc>
3481bae4:	e2509000 	subs	r9, r0, #0
		debug("himport_r: can't malloc %zu bytes\n", size);
		__set_errno(ENOMEM);
3481bae8:	059f32f8 	ldreq	r3, [pc, #760]	; 3481bde8 <himport_r+0x358>
3481baec:	03a0200c 	moveq	r2, #12
3481baf0:	05832000 	streq	r2, [r3]
		return 0;
3481baf4:	01a00009 	moveq	r0, r9
3481baf8:	0a0000b8 	beq	3481bde0 <himport_r+0x350>
	}
	memcpy(data, env, size);
3481bafc:	e1a02006 	mov	r2, r6
3481bb00:	e1a01007 	mov	r1, r7
3481bb04:	eb0003a0 	bl	3481c98c <memcpy>
	dp = data;

	/* make a local copy of the list of variables */
	if (nvars)
3481bb08:	e59b2008 	ldr	r2, [fp, #8]
3481bb0c:	e3520000 	cmp	r2, #0
3481bb10:	0a000003 	beq	3481bb24 <himport_r+0x94>
		memcpy(localvars, vars, sizeof(vars[0]) * nvars);
3481bb14:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
3481bb18:	e59b100c 	ldr	r1, [fp, #12]
3481bb1c:	e1a02005 	mov	r2, r5
3481bb20:	eb000399 	bl	3481c98c <memcpy>

	if ((flag & H_NOCLEAR) == 0) {
3481bb24:	e59b3004 	ldr	r3, [fp, #4]
3481bb28:	e3130001 	tst	r3, #1
3481bb2c:	1a000005 	bne	3481bb48 <himport_r+0xb8>
		/* Destroy old hash table if one exists */
		debug("Destroy Hash Table: %p table = %p\n", htab,
		       htab->table);
		if (htab->table)
3481bb30:	e5943000 	ldr	r3, [r4]
3481bb34:	e3530000 	cmp	r3, #0
3481bb38:	0a000002 	beq	3481bb48 <himport_r+0xb8>
			hdestroy_r(htab, do_apply);
3481bb3c:	e1a00004 	mov	r0, r4
3481bb40:	e59b1010 	ldr	r1, [fp, #16]
3481bb44:	ebfffdc6 	bl	3481b264 <hdestroy_r>
	 * On the other hand we need to add some more entries for free
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
3481bb48:	e5943000 	ldr	r3, [r4]
3481bb4c:	e3530000 	cmp	r3, #0
3481bb50:	0a000003 	beq	3481bb64 <himport_r+0xd4>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481bb54:	e0896006 	add	r6, r9, r6
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481bb58:	e1a05009 	mov	r5, r9
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481bb5c:	e50b6034 	str	r6, [fp, #-52]	; 0x34
3481bb60:	ea00000c 	b	3481bb98 <himport_r+0x108>
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
3481bb64:	e1a001a6 	lsr	r0, r6, #3
3481bb68:	e2800040 	add	r0, r0, #64	; 0x40
		if (nent > CONFIG_ENV_MAX_ENTRIES)
			nent = CONFIG_ENV_MAX_ENTRIES;

		debug("Create Hash Table: N=%d\n", nent);

		if (hcreate_r(nent, htab) == 0) {
3481bb6c:	e3500c02 	cmp	r0, #512	; 0x200
3481bb70:	a3a00c02 	movge	r0, #512	; 0x200
3481bb74:	e1a01004 	mov	r1, r4
3481bb78:	ebfffd8e 	bl	3481b1b8 <hcreate_r>
3481bb7c:	e2505000 	subs	r5, r0, #0
3481bb80:	1afffff3 	bne	3481bb54 <himport_r+0xc4>
			free(data);
3481bb84:	e1a00009 	mov	r0, r9
3481bb88:	ebffb948 	bl	3480a0b0 <free>
			return 0;
3481bb8c:	e1a00005 	mov	r0, r5
3481bb90:	ea000092 	b	3481bde0 <himport_r+0x350>
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481bb94:	e1a05006 	mov	r5, r6
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
3481bb98:	e5d53000 	ldrb	r3, [r5]
3481bb9c:	e3530020 	cmp	r3, #32
3481bba0:	13530009 	cmpne	r3, #9
			++dp;
3481bba4:	02856001 	addeq	r6, r5, #1
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
3481bba8:	0afffff9 	beq	3481bb94 <himport_r+0x104>
			++dp;

		/* skip comment lines */
		if (*dp == '#') {
3481bbac:	e3530023 	cmp	r3, #35	; 0x23
3481bbb0:	11a02005 	movne	r2, r5
3481bbb4:	1a000007 	bne	3481bbd8 <himport_r+0x148>
3481bbb8:	e1a06005 	mov	r6, r5
			while (*dp && (*dp != sep))
3481bbbc:	e4d53001 	ldrb	r3, [r5], #1
3481bbc0:	e3530000 	cmp	r3, #0
3481bbc4:	0a000001 	beq	3481bbd0 <himport_r+0x140>
3481bbc8:	e153000a 	cmp	r3, sl
3481bbcc:	1afffff9 	bne	3481bbb8 <himport_r+0x128>
				++dp;
			++dp;
3481bbd0:	e2866001 	add	r6, r6, #1
			continue;
3481bbd4:	ea000066 	b	3481bd74 <himport_r+0x2e4>
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481bbd8:	e5d23000 	ldrb	r3, [r2]
		/* skip comment lines */
		if (*dp == '#') {
			while (*dp && (*dp != sep))
				++dp;
			++dp;
			continue;
3481bbdc:	e1a06002 	mov	r6, r2
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481bbe0:	e3530000 	cmp	r3, #0
3481bbe4:	1353003d 	cmpne	r3, #61	; 0x3d
3481bbe8:	e2822001 	add	r2, r2, #1
3481bbec:	1a000002 	bne	3481bbfc <himport_r+0x16c>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
3481bbf0:	e3530000 	cmp	r3, #0
3481bbf4:	0a00000e 	beq	3481bc34 <himport_r+0x1a4>
3481bbf8:	ea000001 	b	3481bc04 <himport_r+0x174>
			++dp;
			continue;
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481bbfc:	e153000a 	cmp	r3, sl
3481bc00:	1afffff4 	bne	3481bbd8 <himport_r+0x148>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
3481bc04:	e5d62001 	ldrb	r2, [r6, #1]
3481bc08:	e2867001 	add	r7, r6, #1
3481bc0c:	e3520000 	cmp	r2, #0
3481bc10:	0a000003 	beq	3481bc24 <himport_r+0x194>
3481bc14:	e153000a 	cmp	r3, sl
3481bc18:	0a000001 	beq	3481bc24 <himport_r+0x194>
		    *dp == sep || *(dp + 1) == sep) {
3481bc1c:	e152000a 	cmp	r2, sl
3481bc20:	1a000010 	bne	3481bc68 <himport_r+0x1d8>
			if (*dp == '=')
3481bc24:	e353003d 	cmp	r3, #61	; 0x3d
				*dp++ = '\0';
3481bc28:	03a02000 	moveq	r2, #0
3481bc2c:	05c62000 	strbeq	r2, [r6]
3481bc30:	01a06007 	moveq	r6, r7
			*dp++ = '\0';	/* terminate name */
3481bc34:	e3a03000 	mov	r3, #0
3481bc38:	e4c63001 	strb	r3, [r6], #1

			debug("DELETE CANDIDATE: \"%s\"\n", name);
			if (!drop_var_from_set(name, nvars, localvars))
3481bc3c:	e1a00005 	mov	r0, r5
3481bc40:	e59b1008 	ldr	r1, [fp, #8]
3481bc44:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
3481bc48:	ebfffd3e 	bl	3481b148 <drop_var_from_set>
3481bc4c:	e3500000 	cmp	r0, #0
3481bc50:	0a000047 	beq	3481bd74 <himport_r+0x2e4>
				continue;

			if (hdelete_r(name, htab, do_apply) == 0)
3481bc54:	e1a00005 	mov	r0, r5
3481bc58:	e1a01004 	mov	r1, r4
3481bc5c:	e59b2010 	ldr	r2, [fp, #16]
3481bc60:	ebfffeb2 	bl	3481b730 <hdelete_r>
				debug("DELETE ERROR ##############################\n");

			continue;
3481bc64:	ea000042 	b	3481bd74 <himport_r+0x2e4>
		}
		*dp++ = '\0';	/* terminate name */
3481bc68:	e3a02000 	mov	r2, #0
3481bc6c:	e5c62000 	strb	r2, [r6]

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481bc70:	e1a03007 	mov	r3, r7
3481bc74:	e1a06007 	mov	r6, r7
3481bc78:	ea000006 	b	3481bc98 <himport_r+0x208>
			if ((*dp == '\\') && *(dp + 1))
3481bc7c:	e352005c 	cmp	r2, #92	; 0x5c
3481bc80:	1a000002 	bne	3481bc90 <himport_r+0x200>
3481bc84:	e5d62001 	ldrb	r2, [r6, #1]
3481bc88:	e3520000 	cmp	r2, #0
3481bc8c:	12866001 	addne	r6, r6, #1
				++dp;
			*sp++ = *dp;
3481bc90:	e4d62001 	ldrb	r2, [r6], #1
3481bc94:	e4c32001 	strb	r2, [r3], #1
			continue;
		}
		*dp++ = '\0';	/* terminate name */

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481bc98:	e5d62000 	ldrb	r2, [r6]
3481bc9c:	e3520000 	cmp	r2, #0
3481bca0:	0a000001 	beq	3481bcac <himport_r+0x21c>
3481bca4:	e152000a 	cmp	r2, sl
3481bca8:	1afffff3 	bne	3481bc7c <himport_r+0x1ec>
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
3481bcac:	e3a02000 	mov	r2, #0
3481bcb0:	e5c32000 	strb	r2, [r3]
		++dp;

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
3481bcb4:	e1a00005 	mov	r0, r5
3481bcb8:	e59b1008 	ldr	r1, [fp, #8]
3481bcbc:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
3481bcc0:	ebfffd20 	bl	3481b148 <drop_var_from_set>
3481bcc4:	e3500000 	cmp	r0, #0
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
		++dp;
3481bcc8:	e2866001 	add	r6, r6, #1

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
3481bccc:	0a000028 	beq	3481bd74 <himport_r+0x2e4>
		/* enter into hash table */
		e.key = name;
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481bcd0:	e59b3010 	ldr	r3, [fp, #16]
		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
3481bcd4:	e50b5028 	str	r5, [fp, #-40]	; 0x28
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481bcd8:	e3530000 	cmp	r3, #0
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
		e.data = value;
3481bcdc:	e50b7024 	str	r7, [fp, #-36]	; 0x24

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481bce0:	0a000012 	beq	3481bd30 <himport_r+0x2a0>
3481bce4:	e594300c 	ldr	r3, [r4, #12]
3481bce8:	e3530000 	cmp	r3, #0
3481bcec:	0a00000f 	beq	3481bd30 <himport_r+0x2a0>
				" for  %s\n", name);
			/*
			 * Search for variable in existing env, so to pass
			 * its previous value to the apply callback
			 */
			hsearch_r(e, FIND, &rv, htab);
3481bcf0:	e58d4000 	str	r4, [sp]
3481bcf4:	e24b3028 	sub	r3, fp, #40	; 0x28
3481bcf8:	e8930003 	ldm	r3, {r0, r1}
3481bcfc:	e3a02000 	mov	r2, #0
3481bd00:	e24b3020 	sub	r3, fp, #32
3481bd04:	ebfffdd0 	bl	3481b44c <hsearch_r>
			debug("previous value was %s\n", rv ? rv->data : "");
			if (htab->apply(name, rv ? rv->data : NULL,
3481bd08:	e51b1020 	ldr	r1, [fp, #-32]
3481bd0c:	e594c00c 	ldr	ip, [r4, #12]
3481bd10:	e3510000 	cmp	r1, #0
3481bd14:	15911004 	ldrne	r1, [r1, #4]
3481bd18:	e1a00005 	mov	r0, r5
3481bd1c:	e1a02007 	mov	r2, r7
3481bd20:	e59b3004 	ldr	r3, [fp, #4]
3481bd24:	e12fff3c 	blx	ip
3481bd28:	e3500000 	cmp	r0, #0
3481bd2c:	1a000010 	bne	3481bd74 <himport_r+0x2e4>
					" variable %s, skipping it!\n", name);
				continue;
			}
		}

		hsearch_r(e, ENTER, &rv, htab);
3481bd30:	e58d4000 	str	r4, [sp]
3481bd34:	e24b3028 	sub	r3, fp, #40	; 0x28
3481bd38:	e8930003 	ldm	r3, {r0, r1}
3481bd3c:	e3a02001 	mov	r2, #1
3481bd40:	e24b3020 	sub	r3, fp, #32
3481bd44:	ebfffdc0 	bl	3481b44c <hsearch_r>
		if (rv == NULL) {
3481bd48:	e51b3020 	ldr	r3, [fp, #-32]
3481bd4c:	e3530000 	cmp	r3, #0
3481bd50:	1a000007 	bne	3481bd74 <himport_r+0x2e4>
			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
3481bd54:	e59f0090 	ldr	r0, [pc, #144]	; 3481bdec <himport_r+0x35c>
3481bd58:	e1a01005 	mov	r1, r5
3481bd5c:	e1a02007 	mov	r2, r7
3481bd60:	e50b3038 	str	r3, [fp, #-56]	; 0x38
3481bd64:	ebffb793 	bl	34809bb8 <printf>
				name, value);
			return 0;
3481bd68:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
3481bd6c:	e1a00003 	mov	r0, r3
3481bd70:	ea00001a 	b	3481bde0 <himport_r+0x350>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481bd74:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
3481bd78:	e1560002 	cmp	r6, r2
3481bd7c:	2a000002 	bcs	3481bd8c <himport_r+0x2fc>
3481bd80:	e5d63000 	ldrb	r3, [r6]
3481bd84:	e3530000 	cmp	r3, #0
3481bd88:	1affff81 	bne	3481bb94 <himport_r+0x104>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481bd8c:	e1a00009 	mov	r0, r9
3481bd90:	ebffb8c6 	bl	3480a0b0 <free>

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481bd94:	e3a06000 	mov	r6, #0
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481bd98:	e51b5030 	ldr	r5, [fp, #-48]	; 0x30

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481bd9c:	ea00000b 	b	3481bdd0 <himport_r+0x340>
		if (localvars[i] == NULL)
3481bda0:	e4950004 	ldr	r0, [r5], #4
3481bda4:	e3500000 	cmp	r0, #0
3481bda8:	0a000007 	beq	3481bdcc <himport_r+0x33c>
		 * This could mean two things:
		 * a) if the variable was present in current env, we delete it
		 * b) if the variable was not present in current env, we notify
		 *    it might be a typo
		 */
		if (hdelete_r(localvars[i], htab, do_apply) == 0)
3481bdac:	e1a01004 	mov	r1, r4
3481bdb0:	e59b2010 	ldr	r2, [fp, #16]
3481bdb4:	ebfffe5d 	bl	3481b730 <hdelete_r>
3481bdb8:	e3500000 	cmp	r0, #0
			printf("WARNING: '%s' neither in running nor in imported env!\n", localvars[i]);
3481bdbc:	059f002c 	ldreq	r0, [pc, #44]	; 3481bdf0 <himport_r+0x360>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
3481bdc0:	159f002c 	ldrne	r0, [pc, #44]	; 3481bdf4 <himport_r+0x364>
3481bdc4:	e5151004 	ldr	r1, [r5, #-4]
3481bdc8:	ebffb77a 	bl	34809bb8 <printf>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481bdcc:	e2866001 	add	r6, r6, #1
3481bdd0:	e59b3008 	ldr	r3, [fp, #8]
3481bdd4:	e1560003 	cmp	r6, r3
3481bdd8:	bafffff0 	blt	3481bda0 <himport_r+0x310>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
	}

	debug("INSERT: done\n");
	return 1;		/* everything OK */
3481bddc:	e3a00001 	mov	r0, #1
}
3481bde0:	e24bd01c 	sub	sp, fp, #28
3481bde4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481bde8:	3482bee8 	.word	0x3482bee8
3481bdec:	34828237 	.word	0x34828237
3481bdf0:	34828268 	.word	0x34828268
3481bdf4:	3482829f 	.word	0x3482829f

3481bdf8 <ldiv>:
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
3481bdf8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481bdfc:	e1a05001 	mov	r5, r1
3481be00:	e1a04000 	mov	r4, r0
  ldiv_t result;

  result.quot = numer / denom;
3481be04:	e1a00001 	mov	r0, r1
3481be08:	e1a01002 	mov	r1, r2
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
3481be0c:	e1a07002 	mov	r7, r2
  ldiv_t result;

  result.quot = numer / denom;
3481be10:	eb0010a8 	bl	348200b8 <__divsi3>
  result.rem = numer % denom;
3481be14:	e1a01007 	mov	r1, r7
ldiv_t
ldiv (long int numer, long int denom)
{
  ldiv_t result;

  result.quot = numer / denom;
3481be18:	e1a06000 	mov	r6, r0
  result.rem = numer % denom;
3481be1c:	e1a00005 	mov	r0, r5
3481be20:	eb00112c 	bl	348202d8 <__aeabi_idivmod>
     RESULT will always be positive.  This all boils down to: if
     NUMER >= 0, but REM < 0, we got the wrong answer.  In that
     case, to get the right answer, add 1 to QUOT and subtract
     DENOM from REM.  */

  if (numer >= 0 && result.rem < 0)
3481be24:	e3550000 	cmp	r5, #0
3481be28:	ba000002 	blt	3481be38 <ldiv+0x40>
3481be2c:	e3510000 	cmp	r1, #0
    {
      ++result.quot;
3481be30:	b2866001 	addlt	r6, r6, #1
      result.rem -= denom;
3481be34:	b0671001 	rsblt	r1, r7, r1
3481be38:	e5846000 	str	r6, [r4]
3481be3c:	e5841004 	str	r1, [r4, #4]
    }

  return result;
}
3481be40:	e1a00004 	mov	r0, r4
3481be44:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481be48 <lmb_add_region>:
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481be48:	e590c000 	ldr	ip, [r0]
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
3481be4c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481be50:	e35c0001 	cmp	ip, #1
3481be54:	1a000005 	bne	3481be70 <lmb_add_region+0x28>
3481be58:	e590500c 	ldr	r5, [r0, #12]
3481be5c:	e3550000 	cmp	r5, #0
		rgn->region[0].base = base;
3481be60:	05801008 	streq	r1, [r0, #8]
		rgn->region[0].size = size;
3481be64:	0580200c 	streq	r2, [r0, #12]
		return 0;
3481be68:	01a00005 	moveq	r0, r5
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481be6c:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
3481be70:	e1a04000 	mov	r4, r0
static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
		return 1;
	else if (base1 == base2 + size2)
3481be74:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481be78:	e0827001 	add	r7, r2, r1
3481be7c:	ea000019 	b	3481bee8 <lmb_add_region+0xa0>
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
		phys_addr_t rgnbase = rgn->region[i].base;
3481be80:	e5946008 	ldr	r6, [r4, #8]
		phys_size_t rgnsize = rgn->region[i].size;
3481be84:	e594500c 	ldr	r5, [r4, #12]

		if ((rgnbase == base) && (rgnsize == size))
3481be88:	e1550002 	cmp	r5, r2
3481be8c:	01560001 	cmpeq	r6, r1
3481be90:	0a000054 	beq	3481bfe8 <lmb_add_region+0x1a0>
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481be94:	e1560007 	cmp	r6, r7
3481be98:	0a000005 	beq	3481beb4 <lmb_add_region+0x6c>
		return 1;
	else if (base1 == base2 + size2)
3481be9c:	e0856006 	add	r6, r5, r6
3481bea0:	e1510006 	cmp	r1, r6
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bea4:	e2844008 	add	r4, r4, #8
3481bea8:	e2836001 	add	r6, r3, #1
		return 1;
	else if (base1 == base2 + size2)
3481beac:	1a000051 	bne	3481bff8 <lmb_add_region+0x1b0>
3481beb0:	ea000007 	b	3481bed4 <lmb_add_region+0x8c>
			/* Already have this region, so we're done */
			return 0;

		adjacent = lmb_addrs_adjacent(base,size,rgnbase,rgnsize);
		if ( adjacent > 0 ) {
			rgn->region[i].base -= size;
3481beb4:	e2834001 	add	r4, r3, #1
3481beb8:	e0627007 	rsb	r7, r2, r7
3481bebc:	e7807184 	str	r7, [r0, r4, lsl #3]
			rgn->region[i].size += size;
3481bec0:	e0804184 	add	r4, r0, r4, lsl #3
3481bec4:	e5945004 	ldr	r5, [r4, #4]
3481bec8:	e0825005 	add	r5, r2, r5
3481becc:	e5845004 	str	r5, [r4, #4]
3481bed0:	ea000002 	b	3481bee0 <lmb_add_region+0x98>
			coalesced++;
			break;
		}
		else if ( adjacent < 0 ) {
			rgn->region[i].size += size;
3481bed4:	e0806186 	add	r6, r0, r6, lsl #3
3481bed8:	e0855002 	add	r5, r5, r2
3481bedc:	e5865004 	str	r5, [r6, #4]
			coalesced++;
3481bee0:	e3a05001 	mov	r5, #1
			break;
3481bee4:	ea000002 	b	3481bef4 <lmb_add_region+0xac>
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
3481bee8:	e153000c 	cmp	r3, ip
3481beec:	3affffe3 	bcc	3481be80 <lmb_add_region+0x38>
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
3481bef0:	e3a05000 	mov	r5, #0
			coalesced++;
			break;
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
3481bef4:	e24c4001 	sub	r4, ip, #1
3481bef8:	e1530004 	cmp	r3, r4
3481befc:	2a00001e 	bcs	3481bf7c <lmb_add_region+0x134>
3481bf00:	e2836001 	add	r6, r3, #1

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
3481bf04:	e080a186 	add	sl, r0, r6, lsl #3
}

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
3481bf08:	e7907186 	ldr	r7, [r0, r6, lsl #3]
	phys_size_t size1 = rgn->region[r1].size;
3481bf0c:	e59ab004 	ldr	fp, [sl, #4]
	phys_addr_t base2 = rgn->region[r2].base;
3481bf10:	e2866001 	add	r6, r6, #1
3481bf14:	e790a186 	ldr	sl, [r0, r6, lsl #3]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bf18:	e08b9007 	add	r9, fp, r7
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
3481bf1c:	e0806186 	add	r6, r0, r6, lsl #3
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bf20:	e15a0009 	cmp	sl, r9
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
3481bf24:	e5966004 	ldr	r6, [r6, #4]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481bf28:	0a000002 	beq	3481bf38 <lmb_add_region+0xf0>
		return 1;
	else if (base1 == base2 + size2)
3481bf2c:	e086a00a 	add	sl, r6, sl
3481bf30:	e157000a 	cmp	r7, sl
3481bf34:	1a000010 	bne	3481bf7c <lmb_add_region+0x134>

/* Assumption: base addr of region 1 < base addr of region 2 */
static void lmb_coalesce_regions(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	rgn->region[r1].size += rgn->region[r2].size;
3481bf38:	e0802183 	add	r2, r0, r3, lsl #3
3481bf3c:	e086600b 	add	r6, r6, fp
3481bf40:	e582600c 	str	r6, [r2, #12]
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
3481bf44:	e2832003 	add	r2, r3, #3
3481bf48:	e0802182 	add	r2, r0, r2, lsl #3
3481bf4c:	ea000003 	b	3481bf60 <lmb_add_region+0x118>
static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
		rgn->region[i].base = rgn->region[i + 1].base;
3481bf50:	e5121008 	ldr	r1, [r2, #-8]
3481bf54:	e5021010 	str	r1, [r2, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
3481bf58:	e5121004 	ldr	r1, [r2, #-4]
3481bf5c:	e502100c 	str	r1, [r2, #-12]
3481bf60:	e2833001 	add	r3, r3, #1

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481bf64:	e1530004 	cmp	r3, r4
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
3481bf68:	e2822008 	add	r2, r2, #8

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481bf6c:	3afffff7 	bcc	3481bf50 <lmb_add_region+0x108>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
3481bf70:	e5804000 	str	r4, [r0]
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
		lmb_coalesce_regions(rgn, i, i+1);
		coalesced++;
3481bf74:	e2850001 	add	r0, r5, #1
3481bf78:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
3481bf7c:	e3550000 	cmp	r5, #0
3481bf80:	13a00001 	movne	r0, #1
3481bf84:	18bd8ef0 	popne	{r4, r5, r6, r7, r9, sl, fp, pc}
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481bf88:	e35c0007 	cmp	ip, #7
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
3481bf8c:	928c3001 	addls	r3, ip, #1
3481bf90:	90803183 	addls	r3, r0, r3, lsl #3
		coalesced++;
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481bf94:	9a00000b 	bls	3481bfc8 <lmb_add_region+0x180>
3481bf98:	ea000014 	b	3481bff0 <lmb_add_region+0x1a8>
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
		if (base < rgn->region[i].base) {
3481bf9c:	e5335008 	ldr	r5, [r3, #-8]!
3481bfa0:	e1510005 	cmp	r1, r5
			rgn->region[i+1].base = rgn->region[i].base;
3481bfa4:	35835008 	strcc	r5, [r3, #8]
			rgn->region[i+1].size = rgn->region[i].size;
3481bfa8:	35935004 	ldrcc	r5, [r3, #4]
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
3481bfac:	32444001 	subcc	r4, r4, #1
		if (base < rgn->region[i].base) {
			rgn->region[i+1].base = rgn->region[i].base;
			rgn->region[i+1].size = rgn->region[i].size;
3481bfb0:	3583500c 	strcc	r5, [r3, #12]
		} else {
			rgn->region[i+1].base = base;
3481bfb4:	22844002 	addcs	r4, r4, #2
3481bfb8:	27801184 	strcs	r1, [r0, r4, lsl #3]
			rgn->region[i+1].size = size;
3481bfbc:	20804184 	addcs	r4, r0, r4, lsl #3
3481bfc0:	25842004 	strcs	r2, [r4, #4]
			break;
3481bfc4:	2a000001 	bcs	3481bfd0 <lmb_add_region+0x188>
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
3481bfc8:	e3540000 	cmp	r4, #0
3481bfcc:	aafffff2 	bge	3481bf9c <lmb_add_region+0x154>
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
3481bfd0:	e5903008 	ldr	r3, [r0, #8]
		rgn->region[0].base = base;
		rgn->region[0].size = size;
	}

	rgn->cnt++;
3481bfd4:	e28cc001 	add	ip, ip, #1
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
3481bfd8:	e1510003 	cmp	r1, r3
		rgn->region[0].base = base;
3481bfdc:	35801008 	strcc	r1, [r0, #8]
		rgn->region[0].size = size;
3481bfe0:	3580200c 	strcc	r2, [r0, #12]
	}

	rgn->cnt++;
3481bfe4:	e580c000 	str	ip, [r0]
		phys_addr_t rgnbase = rgn->region[i].base;
		phys_size_t rgnsize = rgn->region[i].size;

		if ((rgnbase == base) && (rgnsize == size))
			/* Already have this region, so we're done */
			return 0;
3481bfe8:	e3a00000 	mov	r0, #0
3481bfec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;
3481bff0:	e3e00000 	mvn	r0, #0
	}

	rgn->cnt++;

	return 0;
}
3481bff4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
3481bff8:	e1a03006 	mov	r3, r6
3481bffc:	eaffffb9 	b	3481bee8 <lmb_add_region+0xa0>

3481c000 <lmb_dump_all>:
			(long long unsigned)lmb->reserved.region[i].base);
		debug("		     .size = 0x%llx\n",
			(long long unsigned)lmb->reserved.region[i].size);
	}
#endif /* DEBUG */
}
3481c000:	e12fff1e 	bx	lr

3481c004 <lmb_init>:
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
3481c004:	e3a03000 	mov	r3, #0
	lmb->memory.region[0].size = 0;
	lmb->memory.cnt = 1;
3481c008:	e3a02001 	mov	r2, #1
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
3481c00c:	e5803008 	str	r3, [r0, #8]
	lmb->memory.region[0].size = 0;
3481c010:	e580300c 	str	r3, [r0, #12]
	lmb->memory.cnt = 1;
3481c014:	e880000c 	stm	r0, {r2, r3}
	lmb->memory.size = 0;

	/* Ditto. */
	lmb->reserved.region[0].base = 0;
3481c018:	e5803058 	str	r3, [r0, #88]	; 0x58
	lmb->reserved.region[0].size = 0;
3481c01c:	e580305c 	str	r3, [r0, #92]	; 0x5c
	lmb->reserved.cnt = 1;
3481c020:	e5802050 	str	r2, [r0, #80]	; 0x50
	lmb->reserved.size = 0;
3481c024:	e5803054 	str	r3, [r0, #84]	; 0x54
}
3481c028:	e12fff1e 	bx	lr

3481c02c <lmb_add>:
/* This routine may be called with relocation disabled. */
long lmb_add(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
3481c02c:	eaffff85 	b	3481be48 <lmb_add_region>

3481c030 <lmb_free>:
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
3481c030:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481c034:	e3a04000 	mov	r4, #0

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
3481c038:	e082c001 	add	ip, r2, r1
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481c03c:	e5907050 	ldr	r7, [r0, #80]	; 0x50
3481c040:	e1a06000 	mov	r6, r0
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */
3481c044:	e1a03004 	mov	r3, r4
3481c048:	e1a05004 	mov	r5, r4

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481c04c:	ea000007 	b	3481c070 <lmb_free+0x40>
		rgnbegin = rgn->region[i].base;
3481c050:	e5965058 	ldr	r5, [r6, #88]	; 0x58
		rgnend = rgnbegin + rgn->region[i].size;
3481c054:	e596305c 	ldr	r3, [r6, #92]	; 0x5c
3481c058:	e2866008 	add	r6, r6, #8
3481c05c:	e0853003 	add	r3, r5, r3

		if ((rgnbegin <= base) && (end <= rgnend))
3481c060:	e15c0003 	cmp	ip, r3
3481c064:	91550001 	cmpls	r5, r1
3481c068:	9a000003 	bls	3481c07c <lmb_free+0x4c>
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481c06c:	e2844001 	add	r4, r4, #1
3481c070:	e1540007 	cmp	r4, r7
3481c074:	e1a0a004 	mov	sl, r4
3481c078:	3afffff4 	bcc	3481c050 <lmb_free+0x20>
		if ((rgnbegin <= base) && (end <= rgnend))
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
3481c07c:	e1540007 	cmp	r4, r7
3481c080:	0a000032 	beq	3481c150 <lmb_free+0x120>
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
3481c084:	e1550001 	cmp	r5, r1
3481c088:	13a05000 	movne	r5, #0
3481c08c:	03a05001 	moveq	r5, #1
3481c090:	e153000c 	cmp	r3, ip
3481c094:	13a06000 	movne	r6, #0
3481c098:	03a06001 	moveq	r6, #1
3481c09c:	e0169005 	ands	r9, r6, r5
3481c0a0:	0a00000e 	beq	3481c0e0 <lmb_free+0xb0>
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
3481c0a4:	e284400c 	add	r4, r4, #12
3481c0a8:	e0804184 	add	r4, r0, r4, lsl #3

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481c0ac:	e2477001 	sub	r7, r7, #1
3481c0b0:	ea000004 	b	3481c0c8 <lmb_free+0x98>
		rgn->region[i].base = rgn->region[i + 1].base;
3481c0b4:	e5143008 	ldr	r3, [r4, #-8]
3481c0b8:	e28aa001 	add	sl, sl, #1
3481c0bc:	e5043010 	str	r3, [r4, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
3481c0c0:	e5143004 	ldr	r3, [r4, #-4]
3481c0c4:	e504300c 	str	r3, [r4, #-12]

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481c0c8:	e15a0007 	cmp	sl, r7
3481c0cc:	e2844008 	add	r4, r4, #8
3481c0d0:	3afffff7 	bcc	3481c0b4 <lmb_free+0x84>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
3481c0d4:	e5807050 	str	r7, [r0, #80]	; 0x50
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
		lmb_remove_region(rgn, i);
		return 0;
3481c0d8:	e3a00000 	mov	r0, #0
3481c0dc:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if region is matching at the front */
	if (rgnbegin == base) {
3481c0e0:	e3550000 	cmp	r5, #0
3481c0e4:	0a000007 	beq	3481c108 <lmb_free+0xd8>
		rgn->region[i].base = end;
3481c0e8:	e284400b 	add	r4, r4, #11
3481c0ec:	e780c184 	str	ip, [r0, r4, lsl #3]
		rgn->region[i].size -= size;
3481c0f0:	e0800184 	add	r0, r0, r4, lsl #3
3481c0f4:	e5903004 	ldr	r3, [r0, #4]
3481c0f8:	e0622003 	rsb	r2, r2, r3
3481c0fc:	e5802004 	str	r2, [r0, #4]
		return 0;
3481c100:	e1a00009 	mov	r0, r9
3481c104:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
3481c108:	e3560000 	cmp	r6, #0
3481c10c:	e284400b 	add	r4, r4, #11
3481c110:	0a000005 	beq	3481c12c <lmb_free+0xfc>
		rgn->region[i].size -= size;
3481c114:	e0804184 	add	r4, r0, r4, lsl #3
3481c118:	e5943004 	ldr	r3, [r4, #4]
		return 0;
3481c11c:	e1a00005 	mov	r0, r5
		return 0;
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
		rgn->region[i].size -= size;
3481c120:	e0622003 	rsb	r2, r2, r3
3481c124:	e5842004 	str	r2, [r4, #4]
		return 0;
3481c128:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
3481c12c:	e0802184 	add	r2, r0, r4, lsl #3
3481c130:	e7904184 	ldr	r4, [r0, r4, lsl #3]
	return lmb_add_region(rgn, end, rgnend - end);
3481c134:	e2800050 	add	r0, r0, #80	; 0x50

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
3481c138:	e0641001 	rsb	r1, r4, r1
3481c13c:	e5821004 	str	r1, [r2, #4]
	return lmb_add_region(rgn, end, rgnend - end);
3481c140:	e1a0100c 	mov	r1, ip
3481c144:	e06c2003 	rsb	r2, ip, r3
}
3481c148:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
3481c14c:	eaffff3d 	b	3481be48 <lmb_add_region>
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
		return -1;
3481c150:	e3e00000 	mvn	r0, #0
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
}
3481c154:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3481c158 <lmb_reserve>:

long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->reserved);

	return lmb_add_region(_rgn, base, size);
3481c158:	e2800050 	add	r0, r0, #80	; 0x50
3481c15c:	eaffff39 	b	3481be48 <lmb_add_region>

3481c160 <lmb_overlaps_region>:
}

long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
3481c160:	e92d4030 	push	{r4, r5, lr}
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481c164:	e590c000 	ldr	ip, [r0]
3481c168:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481c16c:	e0822001 	add	r2, r2, r1
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481c170:	ea000008 	b	3481c198 <lmb_overlaps_region+0x38>
		phys_addr_t rgnbase = rgn->region[i].base;
3481c174:	e5904008 	ldr	r4, [r0, #8]
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481c178:	e590500c 	ldr	r5, [r0, #12]
3481c17c:	e0845005 	add	r5, r4, r5
3481c180:	e1510005 	cmp	r1, r5
3481c184:	2a000007 	bcs	3481c1a8 <lmb_overlaps_region+0x48>
3481c188:	e1540002 	cmp	r4, r2
3481c18c:	2a000005 	bcs	3481c1a8 <lmb_overlaps_region+0x48>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
3481c190:	e1a00003 	mov	r0, r3
3481c194:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481c198:	e153000c 	cmp	r3, ip
3481c19c:	3afffff4 	bcc	3481c174 <lmb_overlaps_region+0x14>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
3481c1a0:	e3e00000 	mvn	r0, #0
}
3481c1a4:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481c1a8:	e2833001 	add	r3, r3, #1
3481c1ac:	e2800008 	add	r0, r0, #8
3481c1b0:	eafffff8 	b	3481c198 <lmb_overlaps_region+0x38>

3481c1b4 <__lmb_alloc_base>:
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481c1b4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481c1b8:	e5907000 	ldr	r7, [r0]
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481c1bc:	e1a09003 	mov	r9, r3
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481c1c0:	e2803050 	add	r3, r0, #80	; 0x50
3481c1c4:	e58d300c 	str	r3, [sp, #12]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481c1c8:	e2623000 	rsb	r3, r2, #0
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481c1cc:	e1a0c002 	mov	ip, r2
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481c1d0:	e247b001 	sub	fp, r7, #1
3481c1d4:	e1a02003 	mov	r2, r3
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
3481c1d8:	e2877001 	add	r7, r7, #1
{
3481c1dc:	e1a04001 	mov	r4, r1
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
3481c1e0:	e0807187 	add	r7, r0, r7, lsl #3
3481c1e4:	e1a03000 	mov	r3, r0
3481c1e8:	e1a05002 	mov	r5, r2
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481c1ec:	ea000036 	b	3481c2cc <__lmb_alloc_base+0x118>
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;
3481c1f0:	e5176004 	ldr	r6, [r7, #-4]
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
		phys_addr_t lmbbase = lmb->memory.region[i].base;
3481c1f4:	e517a008 	ldr	sl, [r7, #-8]
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
3481c1f8:	e1560004 	cmp	r6, r4
3481c1fc:	3a000030 	bcc	3481c2c4 <__lmb_alloc_base+0x110>
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481c200:	e3590000 	cmp	r9, #0
			base = lmb_align_down(lmbbase + lmbsize - size, align);
3481c204:	0086600a 	addeq	r6, r6, sl
3481c208:	00646006 	rsbeq	r6, r4, r6
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481c20c:	0a000005 	beq	3481c228 <__lmb_alloc_base+0x74>
			base = lmb_align_down(lmbbase + lmbsize - size, align);
		else if (lmbbase < max_addr) {
3481c210:	e15a0009 	cmp	sl, r9
3481c214:	2a00002a 	bcs	3481c2c4 <__lmb_alloc_base+0x110>
			base = min(lmbbase + lmbsize, max_addr);
3481c218:	e086600a 	add	r6, r6, sl
			base = lmb_align_down(base - size, align);
3481c21c:	e1590006 	cmp	r9, r6
3481c220:	90646009 	rsbls	r6, r4, r9
3481c224:	80646006 	rsbhi	r6, r4, r6
3481c228:	e58db008 	str	fp, [sp, #8]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481c22c:	e0066005 	and	r6, r6, r5
3481c230:	e1a0b007 	mov	fp, r7
3481c234:	e1a07003 	mov	r7, r3
3481c238:	ea000017 	b	3481c29c <__lmb_alloc_base+0xe8>
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481c23c:	e59d000c 	ldr	r0, [sp, #12]
3481c240:	e1a01006 	mov	r1, r6
3481c244:	e1a02004 	mov	r2, r4
3481c248:	e58dc004 	str	ip, [sp, #4]
3481c24c:	ebffffc3 	bl	3481c160 <lmb_overlaps_region>
			if (j < 0) {
3481c250:	e3500000 	cmp	r0, #0
3481c254:	e59dc004 	ldr	ip, [sp, #4]
3481c258:	aa000009 	bge	3481c284 <__lmb_alloc_base+0xd0>
	return addr & ~(size - 1);
}

static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
3481c25c:	e2444001 	sub	r4, r4, #1
3481c260:	e26c2000 	rsb	r2, ip, #0
3481c264:	e084c00c 	add	ip, r4, ip

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
			if (j < 0) {
				/* This area isn't reserved, take it */
				if (lmb_add_region(&lmb->reserved, base,
3481c268:	e1a01006 	mov	r1, r6
3481c26c:	e59d000c 	ldr	r0, [sp, #12]
3481c270:	e002200c 	and	r2, r2, ip
3481c274:	ebfffef3 	bl	3481be48 <lmb_add_region>
							lmb_align_up(size,
								align)) < 0)
					return 0;
3481c278:	e3500000 	cmp	r0, #0
3481c27c:	b3a06000 	movlt	r6, #0
3481c280:	ea000014 	b	3481c2d8 <__lmb_alloc_base+0x124>
				return base;
			}
			res_base = lmb->reserved.region[j].base;
3481c284:	e280000b 	add	r0, r0, #11
3481c288:	e7976180 	ldr	r6, [r7, r0, lsl #3]
			if (res_base < size)
3481c28c:	e1560004 	cmp	r6, r4
3481c290:	3a000008 	bcc	3481c2b8 <__lmb_alloc_base+0x104>
				break;
			base = lmb_align_down(res_base - size, align);
3481c294:	e0646006 	rsb	r6, r4, r6
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481c298:	e0056006 	and	r6, r5, r6
			base = min(lmbbase + lmbsize, max_addr);
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
3481c29c:	e15a0006 	cmp	sl, r6
3481c2a0:	83a02000 	movhi	r2, #0
3481c2a4:	93a02001 	movls	r2, #1
3481c2a8:	e3560000 	cmp	r6, #0
3481c2ac:	03a02000 	moveq	r2, #0
3481c2b0:	e3520000 	cmp	r2, #0
3481c2b4:	1affffe0 	bne	3481c23c <__lmb_alloc_base+0x88>
3481c2b8:	e1a03007 	mov	r3, r7
3481c2bc:	e1a0700b 	mov	r7, fp
3481c2c0:	e59db008 	ldr	fp, [sp, #8]
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481c2c4:	e24bb001 	sub	fp, fp, #1
3481c2c8:	e2477008 	sub	r7, r7, #8
3481c2cc:	e35b0000 	cmp	fp, #0
3481c2d0:	aaffffc6 	bge	3481c1f0 <__lmb_alloc_base+0x3c>
			if (res_base < size)
				break;
			base = lmb_align_down(res_base - size, align);
		}
	}
	return 0;
3481c2d4:	e3a06000 	mov	r6, #0
}
3481c2d8:	e1a00006 	mov	r0, r6
3481c2dc:	e28dd010 	add	sp, sp, #16
3481c2e0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481c2e4 <lmb_alloc_base>:
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
}

phys_addr_t lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481c2e4:	e92d4070 	push	{r4, r5, r6, lr}
3481c2e8:	e1a05001 	mov	r5, r1
3481c2ec:	e1a04003 	mov	r4, r3
	phys_addr_t alloc;

	alloc = __lmb_alloc_base(lmb, size, align, max_addr);
3481c2f0:	ebffffaf 	bl	3481c1b4 <__lmb_alloc_base>

	if (alloc == 0)
3481c2f4:	e2506000 	subs	r6, r0, #0
3481c2f8:	1a000003 	bne	3481c30c <lmb_alloc_base+0x28>
		printf("ERROR: Failed to allocate 0x%lx bytes below 0x%lx.\n",
3481c2fc:	e59f0010 	ldr	r0, [pc, #16]	; 3481c314 <lmb_alloc_base+0x30>
3481c300:	e1a01005 	mov	r1, r5
3481c304:	e1a02004 	mov	r2, r4
3481c308:	ebffb62a 	bl	34809bb8 <printf>
		      (ulong)size, (ulong)max_addr);

	return alloc;
}
3481c30c:	e1a00006 	mov	r0, r6
3481c310:	e8bd8070 	pop	{r4, r5, r6, pc}
3481c314:	348282d0 	.word	0x348282d0

3481c318 <lmb_alloc>:
	return (i < rgn->cnt) ? i : -1;
}

phys_addr_t lmb_alloc(struct lmb *lmb, phys_size_t size, ulong align)
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
3481c318:	e3a03000 	mov	r3, #0
3481c31c:	eafffff0 	b	3481c2e4 <lmb_alloc_base>

3481c320 <lmb_is_reserved>:
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
3481c320:	e92d4010 	push	{r4, lr}
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
3481c324:	e590c050 	ldr	ip, [r0, #80]	; 0x50
3481c328:	e3a03000 	mov	r3, #0
3481c32c:	ea00000d 	b	3481c368 <lmb_is_reserved+0x48>
		}
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
3481c330:	e1a04000 	mov	r4, r0
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
3481c334:	e5902058 	ldr	r2, [r0, #88]	; 0x58
3481c338:	e594405c 	ldr	r4, [r4, #92]	; 0x5c
3481c33c:	e2800008 	add	r0, r0, #8
3481c340:	e0824004 	add	r4, r2, r4
3481c344:	e2444001 	sub	r4, r4, #1
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
3481c348:	e1510004 	cmp	r1, r4
3481c34c:	83a04000 	movhi	r4, #0
3481c350:	93a04001 	movls	r4, #1
3481c354:	e1510002 	cmp	r1, r2
3481c358:	33a04000 	movcc	r4, #0
3481c35c:	e3540000 	cmp	r4, #0
3481c360:	1a000004 	bne	3481c378 <lmb_is_reserved+0x58>

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
3481c364:	e2833001 	add	r3, r3, #1
3481c368:	e153000c 	cmp	r3, ip
3481c36c:	3affffef 	bcc	3481c330 <lmb_is_reserved+0x10>
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
	}
	return 0;
3481c370:	e3a00000 	mov	r0, #0
3481c374:	e8bd8010 	pop	{r4, pc}

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
3481c378:	e3a00001 	mov	r0, #1
	}
	return 0;
}
3481c37c:	e8bd8010 	pop	{r4, pc}

3481c380 <__board_lmb_reserve>:

void __board_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific board_lmb_reserve() */
}
3481c380:	e12fff1e 	bx	lr

3481c384 <__arch_lmb_reserve>:
void board_lmb_reserve(struct lmb *lmb) __attribute__((weak, alias("__board_lmb_reserve")));

void __arch_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific arch_lmb_reserve() */
}
3481c384:	e12fff1e 	bx	lr

3481c388 <string_to_ip>:
 */

#include <common.h>

IPaddr_t string_to_ip(const char *s)
{
3481c388:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
3481c38c:	e2504000 	subs	r4, r0, #0
		return(0);
3481c390:	01a00004 	moveq	r0, r4
{
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
3481c394:	0a000014 	beq	3481c3ec <string_to_ip+0x64>
3481c398:	e3a06004 	mov	r6, #4
3481c39c:	e3a05000 	mov	r5, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
3481c3a0:	e08d7006 	add	r7, sp, r6
3481c3a4:	e3540000 	cmp	r4, #0
3481c3a8:	01a00004 	moveq	r0, r4
3481c3ac:	0a000003 	beq	3481c3c0 <string_to_ip+0x38>
3481c3b0:	e1a00004 	mov	r0, r4
3481c3b4:	e1a01007 	mov	r1, r7
3481c3b8:	e3a0200a 	mov	r2, #10
3481c3bc:	eb000441 	bl	3481d4c8 <simple_strtoul>
		addr <<= 8;
		addr |= (val & 0xFF);
3481c3c0:	e20000ff 	and	r0, r0, #255	; 0xff
		if (s) {
3481c3c4:	e3540000 	cmp	r4, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
		addr <<= 8;
		addr |= (val & 0xFF);
3481c3c8:	e1805405 	orr	r5, r0, r5, lsl #8
		if (s) {
3481c3cc:	0a000003 	beq	3481c3e0 <string_to_ip+0x58>
			s = (*e) ? e+1 : e;
3481c3d0:	e59d4004 	ldr	r4, [sp, #4]
3481c3d4:	e5d43000 	ldrb	r3, [r4]
3481c3d8:	e3530000 	cmp	r3, #0
3481c3dc:	12844001 	addne	r4, r4, #1
	int i;

	if (s == NULL)
		return(0);

	for (addr=0, i=0; i<4; ++i) {
3481c3e0:	e2566001 	subs	r6, r6, #1
3481c3e4:	1affffee 	bne	3481c3a4 <string_to_ip+0x1c>
3481c3e8:	e6bf0f35 	rev	r0, r5
			s = (*e) ? e+1 : e;
		}
	}

	return (htonl(addr));
}
3481c3ec:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481c3f0 <qsort>:

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
3481c3f0:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481c3f4:	e3520000 	cmp	r2, #0
3481c3f8:	13510001 	cmpne	r1, #1

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
3481c3fc:	e58d0008 	str	r0, [sp, #8]
3481c400:	e1a06001 	mov	r6, r1
3481c404:	e58d300c 	str	r3, [sp, #12]
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481c408:	e1a04002 	mov	r4, r2
3481c40c:	9a000031 	bls	3481c4d8 <qsort+0xe8>
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
3481c410:	e2410001 	sub	r0, r1, #1
3481c414:	e3a01003 	mov	r1, #3
3481c418:	eb000ea3 	bl	3481feac <__udivsi3>
3481c41c:	e3a05000 	mov	r5, #0

	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
3481c420:	e0855085 	add	r5, r5, r5, lsl #1
3481c424:	e2855001 	add	r5, r5, #1
		} while (wgap < (nel-1)/3);
3481c428:	e1550000 	cmp	r5, r0
3481c42c:	3afffffb 	bcc	3481c420 <qsort+0x30>
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
3481c430:	e0060496 	mul	r6, r6, r4
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
3481c434:	e0050594 	mul	r5, r4, r5
		nel *= width;			/* Convert nel to 'wnel' */
3481c438:	e58d6004 	str	r6, [sp, #4]

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
3481c43c:	e2653000 	rsb	r3, r5, #0
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
3481c440:	e0859004 	add	r9, r5, r4
	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
3481c444:	e3a07000 	mov	r7, #0

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
3481c448:	e1a0b003 	mov	fp, r3
3481c44c:	e59d2008 	ldr	r2, [sp, #8]
3481c450:	e1a03007 	mov	r3, r7
3481c454:	e0826007 	add	r6, r2, r7
3481c458:	e086a005 	add	sl, r6, r5
					register char *b;

					j -= wgap;
					a = j + ((char *)base);
					b = a + wgap;
					if ((*comp)(a, b) <= 0) {
3481c45c:	e58d3000 	str	r3, [sp]
3481c460:	e1a00006 	mov	r0, r6
3481c464:	e1a0100a 	mov	r1, sl
3481c468:	e59d200c 	ldr	r2, [sp, #12]
3481c46c:	e12fff32 	blx	r2
3481c470:	e3500000 	cmp	r0, #0
3481c474:	e59d3000 	ldr	r3, [sp]
3481c478:	da00000b 	ble	3481c4ac <qsort+0xbc>
3481c47c:	e3a02000 	mov	r2, #0
						break;
					}
					k = width;
					do {
						tmp = *a;
3481c480:	e7d61002 	ldrb	r1, [r6, r2]
						*a++ = *b;
3481c484:	e7da0002 	ldrb	r0, [sl, r2]
3481c488:	e7c60002 	strb	r0, [r6, r2]
						*b++ = tmp;
3481c48c:	e7ca1002 	strb	r1, [sl, r2]
3481c490:	e2822001 	add	r2, r2, #1
					} while (--k);
3481c494:	e1540002 	cmp	r4, r2
3481c498:	1afffff8 	bne	3481c480 <qsort+0x90>
3481c49c:	e087700b 	add	r7, r7, fp
				} while (j >= wgap);
3481c4a0:	e1770005 	cmn	r7, r5
					k = width;
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
3481c4a4:	e086600b 	add	r6, r6, fp
				} while (j >= wgap);
3481c4a8:	3affffea 	bcc	3481c458 <qsort+0x68>
3481c4ac:	e0899004 	add	r9, r9, r4
				i += width;
			} while (i < nel);
3481c4b0:	e59d2004 	ldr	r2, [sp, #4]
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
				} while (j >= wgap);
3481c4b4:	e0837004 	add	r7, r3, r4
				i += width;
			} while (i < nel);
3481c4b8:	e0643009 	rsb	r3, r4, r9
3481c4bc:	e1530002 	cmp	r3, r2
3481c4c0:	3affffe1 	bcc	3481c44c <qsort+0x5c>
			wgap = (wgap - width)/3;
3481c4c4:	e0640005 	rsb	r0, r4, r5
3481c4c8:	e3a01003 	mov	r1, #3
3481c4cc:	eb000e76 	bl	3481feac <__udivsi3>
		} while (wgap);
3481c4d0:	e2505000 	subs	r5, r0, #0
3481c4d4:	1affffd8 	bne	3481c43c <qsort+0x4c>
	}
}
3481c4d8:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3481c4dc <strcmp_compar>:

int strcmp_compar(const void *p1, const void *p2)
{
	return strcmp(*(const char **)p1, *(const char **)p2);
3481c4dc:	e5900000 	ldr	r0, [r0]
3481c4e0:	e5911000 	ldr	r1, [r1]
3481c4e4:	ea000030 	b	3481c5ac <strcmp>

3481c4e8 <strcpy>:
 */
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
3481c4e8:	e3a03000 	mov	r3, #0
3481c4ec:	e7d12003 	ldrb	r2, [r1, r3]
3481c4f0:	e3520000 	cmp	r2, #0
3481c4f4:	e7c02003 	strb	r2, [r0, r3]
3481c4f8:	e2833001 	add	r3, r3, #1
3481c4fc:	1afffffa 	bne	3481c4ec <strcpy+0x4>
		/* nothing */;
	return tmp;
}
3481c500:	e12fff1e 	bx	lr

3481c504 <strncpy>:
 */
char * strncpy(char * dest,const char *src,size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
3481c504:	e3a03000 	mov	r3, #0
3481c508:	e3520000 	cmp	r2, #0
3481c50c:	012fff1e 	bxeq	lr
3481c510:	e7d1c003 	ldrb	ip, [r1, r3]
3481c514:	e2422001 	sub	r2, r2, #1
3481c518:	e35c0000 	cmp	ip, #0
3481c51c:	e7c0c003 	strb	ip, [r0, r3]
3481c520:	e2833001 	add	r3, r3, #1
3481c524:	1afffff7 	bne	3481c508 <strncpy+0x4>
		/* nothing */;

	return tmp;
}
3481c528:	e12fff1e 	bx	lr

3481c52c <strcat>:
 */
char * strcat(char * dest, const char * src)
{
	char *tmp = dest;

	while (*dest)
3481c52c:	e1a0c000 	mov	ip, r0
3481c530:	e5dc3000 	ldrb	r3, [ip]
3481c534:	e1a0200c 	mov	r2, ip
3481c538:	e3530000 	cmp	r3, #0
3481c53c:	e28cc001 	add	ip, ip, #1
3481c540:	1afffffa 	bne	3481c530 <strcat+0x4>
		dest++;
	while ((*dest++ = *src++) != '\0')
3481c544:	e7d1c003 	ldrb	ip, [r1, r3]
3481c548:	e35c0000 	cmp	ip, #0
3481c54c:	e7c2c003 	strb	ip, [r2, r3]
3481c550:	e2833001 	add	r3, r3, #1
3481c554:	1afffffa 	bne	3481c544 <strcat+0x18>
		;

	return tmp;
}
3481c558:	e12fff1e 	bx	lr

3481c55c <strncat>:
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;

	if (count) {
3481c55c:	e3520000 	cmp	r2, #0
 *
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
3481c560:	e92d4010 	push	{r4, lr}
	char *tmp = dest;

	if (count) {
3481c564:	08bd8010 	popeq	{r4, pc}
3481c568:	e1a04000 	mov	r4, r0
3481c56c:	e1a0c004 	mov	ip, r4
		while (*dest)
3481c570:	e4d43001 	ldrb	r3, [r4], #1
3481c574:	e3530000 	cmp	r3, #0
3481c578:	1afffffb 	bne	3481c56c <strncat+0x10>
3481c57c:	ea000005 	b	3481c598 <strncat+0x3c>
3481c580:	e2833001 	add	r3, r3, #1
			dest++;
		while ((*dest++ = *src++)) {
			if (--count == 0) {
3481c584:	e1520003 	cmp	r2, r3
3481c588:	1a000002 	bne	3481c598 <strncat+0x3c>
				*dest = '\0';
3481c58c:	e3a03000 	mov	r3, #0
3481c590:	e5cc3000 	strb	r3, [ip]
				break;
3481c594:	e8bd8010 	pop	{r4, pc}
	char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++)) {
3481c598:	e7d14003 	ldrb	r4, [r1, r3]
3481c59c:	e3540000 	cmp	r4, #0
3481c5a0:	e4cc4001 	strb	r4, [ip], #1
3481c5a4:	1afffff5 	bne	3481c580 <strncat+0x24>
			}
		}
	}

	return tmp;
}
3481c5a8:	e8bd8010 	pop	{r4, pc}

3481c5ac <strcmp>:
 * strcmp - Compare two strings
 * @cs: One string
 * @ct: Another string
 */
int strcmp(const char * cs,const char * ct)
{
3481c5ac:	e3a03000 	mov	r3, #0
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481c5b0:	e7d0c003 	ldrb	ip, [r0, r3]
3481c5b4:	e7d12003 	ldrb	r2, [r1, r3]
3481c5b8:	e062200c 	rsb	r2, r2, ip
3481c5bc:	e6ef2072 	uxtb	r2, r2
3481c5c0:	e3520000 	cmp	r2, #0
3481c5c4:	1a000002 	bne	3481c5d4 <strcmp+0x28>
3481c5c8:	e35c0000 	cmp	ip, #0
3481c5cc:	e2833001 	add	r3, r3, #1
3481c5d0:	1afffff6 	bne	3481c5b0 <strcmp+0x4>
			break;
	}

	return __res;
}
3481c5d4:	e6af0072 	sxtb	r0, r2
3481c5d8:	e12fff1e 	bx	lr

3481c5dc <strncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
3481c5dc:	e92d4010 	push	{r4, lr}
	register signed char __res = 0;

	while (count) {
3481c5e0:	e3a03000 	mov	r3, #0
3481c5e4:	ea000009 	b	3481c610 <strncmp+0x34>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481c5e8:	e7d04003 	ldrb	r4, [r0, r3]
3481c5ec:	e7d1c003 	ldrb	ip, [r1, r3]
3481c5f0:	e06cc004 	rsb	ip, ip, r4
3481c5f4:	e6efc07c 	uxtb	ip, ip
3481c5f8:	e35c0000 	cmp	ip, #0
3481c5fc:	1a000006 	bne	3481c61c <strncmp+0x40>
3481c600:	e3540000 	cmp	r4, #0
3481c604:	e2833001 	add	r3, r3, #1
3481c608:	0a000003 	beq	3481c61c <strncmp+0x40>
			break;
		count--;
3481c60c:	e2422001 	sub	r2, r2, #1
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
	register signed char __res = 0;

	while (count) {
3481c610:	e3520000 	cmp	r2, #0
3481c614:	1afffff3 	bne	3481c5e8 <strncmp+0xc>
3481c618:	e1a0c002 	mov	ip, r2
			break;
		count--;
	}

	return __res;
}
3481c61c:	e6af007c 	sxtb	r0, ip
3481c620:	e8bd8010 	pop	{r4, pc}

3481c624 <strchr>:
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
		if (*s == '\0')
			return NULL;
3481c624:	e1a03000 	mov	r3, r0
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481c628:	e6ef1071 	uxtb	r1, r1
3481c62c:	ea000001 	b	3481c638 <strchr+0x14>
		if (*s == '\0')
3481c630:	e3520000 	cmp	r2, #0
3481c634:	0a000005 	beq	3481c650 <strchr+0x2c>
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481c638:	e5d32000 	ldrb	r2, [r3]
		if (*s == '\0')
3481c63c:	e1a00003 	mov	r0, r3
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481c640:	e1520001 	cmp	r2, r1
3481c644:	e2833001 	add	r3, r3, #1
3481c648:	1afffff8 	bne	3481c630 <strchr+0xc>
3481c64c:	e12fff1e 	bx	lr
		if (*s == '\0')
			return NULL;
3481c650:	e1a00002 	mov	r0, r2
	return (char *) s;
}
3481c654:	e12fff1e 	bx	lr

3481c658 <skip_spaces>:
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
	while (isspace(*str))
3481c658:	e59f2018 	ldr	r2, [pc, #24]	; 3481c678 <skip_spaces+0x20>
 * @str: The string to be stripped.
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
3481c65c:	e1a03000 	mov	r3, r0
	while (isspace(*str))
3481c660:	e1a00003 	mov	r0, r3
3481c664:	e4d31001 	ldrb	r1, [r3], #1
3481c668:	e7d21001 	ldrb	r1, [r2, r1]
3481c66c:	e3110020 	tst	r1, #32
3481c670:	1afffffa 	bne	3481c660 <skip_spaces+0x8>
		++str;
	return (char *)str;
}
3481c674:	e12fff1e 	bx	lr
3481c678:	34821fe0 	.word	0x34821fe0

3481c67c <strlen>:
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
3481c67c:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
3481c680:	e1a02003 	mov	r2, r3
3481c684:	e4d31001 	ldrb	r1, [r3], #1
3481c688:	e3510000 	cmp	r1, #0
3481c68c:	1afffffb 	bne	3481c680 <strlen+0x4>
		/* nothing */;
	return sc - s;
}
3481c690:	e0600002 	rsb	r0, r0, r2
3481c694:	e12fff1e 	bx	lr

3481c698 <strim>:
 * Note that the first trailing whitespace is replaced with a %NUL-terminator
 * in the given string @s. Returns a pointer to the first non-whitespace
 * character in @s.
 */
char *strim(char *s)
{
3481c698:	e92d4010 	push	{r4, lr}
	size_t size;
	char *end;

	s = skip_spaces(s);
3481c69c:	ebffffed 	bl	3481c658 <skip_spaces>
3481c6a0:	e1a04000 	mov	r4, r0
	size = strlen(s);
3481c6a4:	ebfffff4 	bl	3481c67c <strlen>
	if (!size)
3481c6a8:	e2503000 	subs	r3, r0, #0
3481c6ac:	0a00000b 	beq	3481c6e0 <strim+0x48>
		return s;

	end = s + size - 1;
3481c6b0:	e2433001 	sub	r3, r3, #1
	while (end >= s && isspace(*end))
3481c6b4:	e59f102c 	ldr	r1, [pc, #44]	; 3481c6e8 <strim+0x50>
	s = skip_spaces(s);
	size = strlen(s);
	if (!size)
		return s;

	end = s + size - 1;
3481c6b8:	e0843003 	add	r3, r4, r3
	while (end >= s && isspace(*end))
3481c6bc:	e1530004 	cmp	r3, r4
3481c6c0:	e1a02003 	mov	r2, r3
3481c6c4:	3a000003 	bcc	3481c6d8 <strim+0x40>
3481c6c8:	e4530001 	ldrb	r0, [r3], #-1
3481c6cc:	e7d10000 	ldrb	r0, [r1, r0]
3481c6d0:	e3100020 	tst	r0, #32
3481c6d4:	1afffff8 	bne	3481c6bc <strim+0x24>
		end--;
	*(end + 1) = '\0';
3481c6d8:	e3a03000 	mov	r3, #0
3481c6dc:	e5c23001 	strb	r3, [r2, #1]

	return s;
}
3481c6e0:	e1a00004 	mov	r0, r4
3481c6e4:	e8bd8010 	pop	{r4, pc}
3481c6e8:	34821fe0 	.word	0x34821fe0

3481c6ec <strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
3481c6ec:	e92d4038 	push	{r3, r4, r5, lr}
3481c6f0:	e1a04000 	mov	r4, r0
3481c6f4:	e1a05001 	mov	r5, r1
       const char *p = s + strlen(s);
3481c6f8:	ebffffdf 	bl	3481c67c <strlen>
       do {
	   if (*p == (char)c)
3481c6fc:	e6ef5075 	uxtb	r5, r5
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
3481c700:	e0843000 	add	r3, r4, r0
       do {
	   if (*p == (char)c)
3481c704:	e5d32000 	ldrb	r2, [r3]
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
3481c708:	e1a00003 	mov	r0, r3
       do {
	   if (*p == (char)c)
3481c70c:	e1520005 	cmp	r2, r5
3481c710:	e2433001 	sub	r3, r3, #1
3481c714:	08bd8038 	popeq	{r3, r4, r5, pc}
	       return (char *)p;
       } while (--p >= s);
3481c718:	e1540003 	cmp	r4, r3
3481c71c:	9afffff8 	bls	3481c704 <strrchr+0x18>
       return NULL;
3481c720:	e3a00000 	mov	r0, #0
}
3481c724:	e8bd8038 	pop	{r3, r4, r5, pc}

3481c728 <strnlen>:
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
3481c728:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
3481c72c:	e3510000 	cmp	r1, #0
3481c730:	e1a02003 	mov	r2, r3
3481c734:	0a000003 	beq	3481c748 <strnlen+0x20>
3481c738:	e4d3c001 	ldrb	ip, [r3], #1
3481c73c:	e2411001 	sub	r1, r1, #1
3481c740:	e35c0000 	cmp	ip, #0
3481c744:	1afffff8 	bne	3481c72c <strnlen+0x4>
		/* nothing */;
	return sc - s;
}
3481c748:	e0600002 	rsb	r0, r0, r2
3481c74c:	e12fff1e 	bx	lr

3481c750 <strdup>:
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
3481c750:	e92d4038 	push	{r3, r4, r5, lr}
	char *new;

	if ((s == NULL)	||
3481c754:	e2505000 	subs	r5, r0, #0
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
3481c758:	01a04005 	moveq	r4, r5
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
3481c75c:	0a000006 	beq	3481c77c <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
3481c760:	ebffffc5 	bl	3481c67c <strlen>
3481c764:	e2800001 	add	r0, r0, #1
3481c768:	ebffb6d9 	bl	3480a2d4 <malloc>
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
3481c76c:	e2504000 	subs	r4, r0, #0
3481c770:	0a000001 	beq	3481c77c <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
	}

	strcpy (new, s);
3481c774:	e1a01005 	mov	r1, r5
3481c778:	ebffff5a 	bl	3481c4e8 <strcpy>
	return new;
}
3481c77c:	e1a00004 	mov	r0, r4
3481c780:	e8bd8038 	pop	{r3, r4, r5, pc}

3481c784 <strspn>:
 *	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
size_t strspn(const char *s, const char *accept)
{
3481c784:	e1a03000 	mov	r3, r0
3481c788:	e92d4010 	push	{r4, lr}
	const char *p;
	const char *a;
	size_t count = 0;
3481c78c:	e3a00000 	mov	r0, #0

	for (p = s; *p != '\0'; ++p) {
3481c790:	ea000006 	b	3481c7b0 <strspn+0x2c>
		for (a = accept; *a != '\0'; ++a) {
			if (*p == *a)
3481c794:	e15c0004 	cmp	ip, r4
				break;
		}
		if (*a == '\0')
			return count;
		++count;
3481c798:	02800001 	addeq	r0, r0, #1
3481c79c:	0a000003 	beq	3481c7b0 <strspn+0x2c>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
3481c7a0:	e4d24001 	ldrb	r4, [r2], #1
3481c7a4:	e3540000 	cmp	r4, #0
3481c7a8:	1afffff9 	bne	3481c794 <strspn+0x10>
3481c7ac:	e8bd8010 	pop	{r4, pc}
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
3481c7b0:	e7d3c000 	ldrb	ip, [r3, r0]
3481c7b4:	e35c0000 	cmp	ip, #0
3481c7b8:	08bd8010 	popeq	{r4, pc}
3481c7bc:	e1a02001 	mov	r2, r1
3481c7c0:	eafffff6 	b	3481c7a0 <strspn+0x1c>

3481c7c4 <strpbrk>:
 * strpbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
char * strpbrk(const char * cs,const char * ct)
{
3481c7c4:	e92d4010 	push	{r4, lr}
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
3481c7c8:	e1a02000 	mov	r2, r0
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3481c7cc:	ea000004 	b	3481c7e4 <strpbrk+0x20>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
3481c7d0:	e1530004 	cmp	r3, r4
3481c7d4:	08bd8010 	popeq	{r4, pc}
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3481c7d8:	e4dc4001 	ldrb	r4, [ip], #1
3481c7dc:	e3540000 	cmp	r4, #0
3481c7e0:	1afffffa 	bne	3481c7d0 <strpbrk+0xc>
3481c7e4:	e1a00002 	mov	r0, r2
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3481c7e8:	e4d23001 	ldrb	r3, [r2], #1
3481c7ec:	e3530000 	cmp	r3, #0
3481c7f0:	11a0c001 	movne	ip, r1
3481c7f4:	1afffff7 	bne	3481c7d8 <strpbrk+0x14>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
3481c7f8:	e1a00003 	mov	r0, r3
}
3481c7fc:	e8bd8010 	pop	{r4, pc}

3481c800 <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
3481c800:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
3481c804:	e2504000 	subs	r4, r0, #0
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
3481c808:	e1a05001 	mov	r5, r1
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
3481c80c:	1a000003 	bne	3481c820 <strtok+0x20>
3481c810:	e59f3060 	ldr	r3, [pc, #96]	; 3481c878 <strtok+0x78>
3481c814:	e5934000 	ldr	r4, [r3]
	if (!sbegin) {
3481c818:	e3540000 	cmp	r4, #0
3481c81c:	0a000013 	beq	3481c870 <strtok+0x70>
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
3481c820:	e1a00004 	mov	r0, r4
3481c824:	e1a01005 	mov	r1, r5
3481c828:	ebffffd5 	bl	3481c784 <strspn>
	if (*sbegin == '\0') {
3481c82c:	e7f43000 	ldrb	r3, [r4, r0]!
3481c830:	e3530000 	cmp	r3, #0
		___strtok = NULL;
3481c834:	059f203c 	ldreq	r2, [pc, #60]	; 3481c878 <strtok+0x78>
		return( NULL );
3481c838:	01a04003 	moveq	r4, r3
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
		___strtok = NULL;
3481c83c:	05823000 	streq	r3, [r2]
		return( NULL );
3481c840:	0a00000a 	beq	3481c870 <strtok+0x70>
	}
	send = strpbrk( sbegin, ct);
3481c844:	e1a00004 	mov	r0, r4
3481c848:	e1a01005 	mov	r1, r5
3481c84c:	ebffffdc 	bl	3481c7c4 <strpbrk>
	if (send && *send != '\0')
3481c850:	e3500000 	cmp	r0, #0
3481c854:	0a000003 	beq	3481c868 <strtok+0x68>
3481c858:	e5d03000 	ldrb	r3, [r0]
3481c85c:	e3530000 	cmp	r3, #0
		*send++ = '\0';
3481c860:	13a03000 	movne	r3, #0
3481c864:	14c03001 	strbne	r3, [r0], #1
	___strtok = send;
3481c868:	e59f3008 	ldr	r3, [pc, #8]	; 3481c878 <strtok+0x78>
3481c86c:	e5830000 	str	r0, [r3]
	return (sbegin);
}
3481c870:	e1a00004 	mov	r0, r4
3481c874:	e8bd8038 	pop	{r3, r4, r5, pc}
3481c878:	3482beec 	.word	0x3482beec

3481c87c <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
3481c87c:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin = *s, *end;
3481c880:	e5904000 	ldr	r4, [r0]
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
3481c884:	e1a05000 	mov	r5, r0
	char *sbegin = *s, *end;

	if (sbegin == NULL)
3481c888:	e3540000 	cmp	r4, #0
3481c88c:	0a000005 	beq	3481c8a8 <strsep+0x2c>
		return NULL;

	end = strpbrk(sbegin, ct);
3481c890:	e1a00004 	mov	r0, r4
3481c894:	ebffffca 	bl	3481c7c4 <strpbrk>
	if (end)
3481c898:	e3500000 	cmp	r0, #0
		*end++ = '\0';
3481c89c:	13a03000 	movne	r3, #0
3481c8a0:	14c03001 	strbne	r3, [r0], #1
	*s = end;
3481c8a4:	e5850000 	str	r0, [r5]

	return sbegin;
}
3481c8a8:	e1a00004 	mov	r0, r4
3481c8ac:	e8bd8038 	pop	{r3, r4, r5, pc}

3481c8b0 <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
3481c8b0:	e3500000 	cmp	r0, #0
3481c8b4:	012fff1e 	bxeq	lr
3481c8b8:	e5d03000 	ldrb	r3, [r0]
3481c8bc:	e3530000 	cmp	r3, #0
3481c8c0:	11a03000 	movne	r3, r0
3481c8c4:	1a000002 	bne	3481c8d4 <strswab+0x24>
3481c8c8:	ea000009 	b	3481c8f4 <strswab+0x44>

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
		char  tmp;

		tmp = *p;
		*p  = *q;
3481c8cc:	e5432002 	strb	r2, [r3, #-2]
		*q  = tmp;
3481c8d0:	e5431001 	strb	r1, [r3, #-1]

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
3481c8d4:	e5d31000 	ldrb	r1, [r3]
3481c8d8:	e3510000 	cmp	r1, #0
3481c8dc:	012fff1e 	bxeq	lr
3481c8e0:	e5d32001 	ldrb	r2, [r3, #1]
3481c8e4:	e2833002 	add	r3, r3, #2
3481c8e8:	e3520000 	cmp	r2, #0
3481c8ec:	1afffff6 	bne	3481c8cc <strswab+0x1c>
3481c8f0:	e12fff1e 	bx	lr
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
3481c8f4:	e1a00003 	mov	r0, r3
		*p  = *q;
		*q  = tmp;
	}

	return (char *) s;
}
3481c8f8:	e12fff1e 	bx	lr

3481c8fc <memset>:
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481c8fc:	e210c003 	ands	ip, r0, #3
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
3481c900:	e92d4010 	push	{r4, lr}
	unsigned long *sl = (unsigned long *) s;
3481c904:	e1a03000 	mov	r3, r0
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481c908:	1a000012 	bne	3481c958 <memset+0x5c>
3481c90c:	e1a0300c 	mov	r3, ip
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
3481c910:	e20140ff 	and	r4, r1, #255	; 0xff
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
3481c914:	e2833001 	add	r3, r3, #1
3481c918:	e3530004 	cmp	r3, #4
			cl <<= 8;
			cl |= c & 0xff;
3481c91c:	e184c40c 	orr	ip, r4, ip, lsl #8
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
3481c920:	1afffffb 	bne	3481c914 <memset+0x18>
3481c924:	e1a04000 	mov	r4, r0
3481c928:	e1a03002 	mov	r3, r2
3481c92c:	ea000001 	b	3481c938 <memset+0x3c>
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
			*sl++ = cl;
3481c930:	e484c004 	str	ip, [r4], #4
			count -= sizeof(*sl);
3481c934:	e2433004 	sub	r3, r3, #4
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
3481c938:	e3530003 	cmp	r3, #3
3481c93c:	8afffffb 	bhi	3481c930 <memset+0x34>
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
3481c940:	e3c23003 	bic	r3, r2, #3
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
3481c944:	e0803003 	add	r3, r0, r3
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
3481c948:	e2022003 	and	r2, r2, #3
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
3481c94c:	ea000001 	b	3481c958 <memset+0x5c>
		*s8++ = c;
3481c950:	e4c31001 	strb	r1, [r3], #1
3481c954:	e2422001 	sub	r2, r2, #1
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
3481c958:	e3520000 	cmp	r2, #0
3481c95c:	1afffffb 	bne	3481c950 <memset+0x54>
		*s8++ = c;

	return s;
}
3481c960:	e8bd8010 	pop	{r4, pc}

3481c964 <bcopy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
3481c964:	e1a03000 	mov	r3, r0
	char *tmp = dest;

	while (count--)
3481c968:	e3a00000 	mov	r0, #0
3481c96c:	ea000002 	b	3481c97c <bcopy+0x18>
		*tmp++ = *src++;
3481c970:	e7d3c000 	ldrb	ip, [r3, r0]
3481c974:	e7c1c000 	strb	ip, [r1, r0]
3481c978:	e2800001 	add	r0, r0, #1
 */
char * bcopy(const char * src, char * dest, int count)
{
	char *tmp = dest;

	while (count--)
3481c97c:	e2522001 	subs	r2, r2, #1
3481c980:	2afffffa 	bcs	3481c970 <bcopy+0xc>
		*tmp++ = *src++;

	return dest;
}
3481c984:	e1a00001 	mov	r0, r1
3481c988:	e12fff1e 	bx	lr

3481c98c <memcpy>:
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
3481c98c:	e1510000 	cmp	r1, r0
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
3481c990:	e92d4010 	push	{r4, lr}
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
3481c994:	08bd8010 	popeq	{r4, pc}
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481c998:	e1813000 	orr	r3, r1, r0
3481c99c:	e2133003 	ands	r3, r3, #3
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
3481c9a0:	e1a0c000 	mov	ip, r0
3481c9a4:	e1a04001 	mov	r4, r1

	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481c9a8:	01a0c002 	moveq	ip, r2
3481c9ac:	0a000004 	beq	3481c9c4 <memcpy+0x38>
3481c9b0:	ea000009 	b	3481c9dc <memcpy+0x50>
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
3481c9b4:	e7914003 	ldr	r4, [r1, r3]
			count -= sizeof(*dl);
3481c9b8:	e24cc004 	sub	ip, ip, #4
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
3481c9bc:	e7804003 	str	r4, [r0, r3]
			count -= sizeof(*dl);
3481c9c0:	e2833004 	add	r3, r3, #4
	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
3481c9c4:	e35c0003 	cmp	ip, #3
3481c9c8:	8afffff9 	bhi	3481c9b4 <memcpy+0x28>
 * @count: The size of the area.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
3481c9cc:	e3c24003 	bic	r4, r2, #3
3481c9d0:	e080c004 	add	ip, r0, r4
3481c9d4:	e2022003 	and	r2, r2, #3
3481c9d8:	e0814004 	add	r4, r1, r4
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
3481c9dc:	e3a03000 	mov	r3, #0
3481c9e0:	ea000003 	b	3481c9f4 <memcpy+0x68>
		*d8++ = *s8++;
3481c9e4:	e7d41003 	ldrb	r1, [r4, r3]
3481c9e8:	e2422001 	sub	r2, r2, #1
3481c9ec:	e7cc1003 	strb	r1, [ip, r3]
3481c9f0:	e2833001 	add	r3, r3, #1
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
3481c9f4:	e3520000 	cmp	r2, #0
3481c9f8:	1afffff9 	bne	3481c9e4 <memcpy+0x58>
		*d8++ = *s8++;

	return dest;
}
3481c9fc:	e8bd8010 	pop	{r4, pc}

3481ca00 <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (src == dest)
3481ca00:	e1510000 	cmp	r1, r0
3481ca04:	012fff1e 	bxeq	lr
		return dest;

	if (dest <= src) {
3481ca08:	e1500001 	cmp	r0, r1
3481ca0c:	93a03000 	movls	r3, #0
3481ca10:	9a000004 	bls	3481ca28 <memmove+0x28>
3481ca14:	ea000006 	b	3481ca34 <memmove+0x34>
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
3481ca18:	e7d1c003 	ldrb	ip, [r1, r3]
3481ca1c:	e2422001 	sub	r2, r2, #1
3481ca20:	e7c0c003 	strb	ip, [r0, r3]
3481ca24:	e2833001 	add	r3, r3, #1
		return dest;

	if (dest <= src) {
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
3481ca28:	e3520000 	cmp	r2, #0
3481ca2c:	1afffff9 	bne	3481ca18 <memmove+0x18>
3481ca30:	e12fff1e 	bx	lr
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
3481ca34:	e0811002 	add	r1, r1, r2
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
3481ca38:	e0803002 	add	r3, r0, r2
		s = (char *) src + count;
		while (count--)
3481ca3c:	ea000002 	b	3481ca4c <memmove+0x4c>
			*--tmp = *--s;
3481ca40:	e571c001 	ldrb	ip, [r1, #-1]!
3481ca44:	e2422001 	sub	r2, r2, #1
3481ca48:	e563c001 	strb	ip, [r3, #-1]!
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
		while (count--)
3481ca4c:	e3520000 	cmp	r2, #0
3481ca50:	1afffffa 	bne	3481ca40 <memmove+0x40>
			*--tmp = *--s;
		}

	return dest;
}
3481ca54:	e12fff1e 	bx	lr

3481ca58 <memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
3481ca58:	e92d4010 	push	{r4, lr}
3481ca5c:	e1a03000 	mov	r3, r0
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481ca60:	e3a0c000 	mov	ip, #0
3481ca64:	ea000005 	b	3481ca80 <memcmp+0x28>
		if ((res = *su1 - *su2) != 0)
3481ca68:	e7d3400c 	ldrb	r4, [r3, ip]
3481ca6c:	e7d1000c 	ldrb	r0, [r1, ip]
3481ca70:	e28cc001 	add	ip, ip, #1
3481ca74:	e0540000 	subs	r0, r4, r0
3481ca78:	18bd8010 	popne	{r4, pc}
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481ca7c:	e2422001 	sub	r2, r2, #1
3481ca80:	e3520000 	cmp	r2, #0
3481ca84:	1afffff7 	bne	3481ca68 <memcmp+0x10>
3481ca88:	e1a00002 	mov	r0, r2
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
3481ca8c:	e8bd8010 	pop	{r4, pc}

3481ca90 <memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
3481ca90:	e1a03000 	mov	r3, r0
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481ca94:	ea000003 	b	3481caa8 <memscan+0x18>
		if (*p == c)
3481ca98:	e4d3c001 	ldrb	ip, [r3], #1
3481ca9c:	e15c0001 	cmp	ip, r1
3481caa0:	012fff1e 	bxeq	lr
			return (void *) p;
		p++;
		size--;
3481caa4:	e2422001 	sub	r2, r2, #1
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481caa8:	e3520000 	cmp	r2, #0
		if (*p == c)
			return (void *) p;
		p++;
		size--;
3481caac:	e1a00003 	mov	r0, r3
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481cab0:	1afffff8 	bne	3481ca98 <memscan+0x8>
			return (void *) p;
		p++;
		size--;
	}
	return (void *) p;
}
3481cab4:	e12fff1e 	bx	lr

3481cab8 <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
3481cab8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481cabc:	e1a04000 	mov	r4, r0
	int l1, l2;

	l2 = strlen(s2);
3481cac0:	e1a00001 	mov	r0, r1
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
3481cac4:	e1a07001 	mov	r7, r1
	int l1, l2;

	l2 = strlen(s2);
3481cac8:	ebfffeeb 	bl	3481c67c <strlen>
	if (!l2)
3481cacc:	e2506000 	subs	r6, r0, #0
3481cad0:	0a00000e 	beq	3481cb10 <strstr+0x58>
		return (char *) s1;
	l1 = strlen(s1);
3481cad4:	e1a00004 	mov	r0, r4
3481cad8:	ebfffee7 	bl	3481c67c <strlen>
3481cadc:	e1a05000 	mov	r5, r0
	while (l1 >= l2) {
3481cae0:	ea000007 	b	3481cb04 <strstr+0x4c>
		l1--;
		if (!memcmp(s1,s2,l2))
3481cae4:	e1a00004 	mov	r0, r4
3481cae8:	e1a01007 	mov	r1, r7
3481caec:	e1a02006 	mov	r2, r6
3481caf0:	ebffffd8 	bl	3481ca58 <memcmp>
3481caf4:	e3500000 	cmp	r0, #0
3481caf8:	0a000004 	beq	3481cb10 <strstr+0x58>
	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
3481cafc:	e2455001 	sub	r5, r5, #1
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
3481cb00:	e2844001 	add	r4, r4, #1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
3481cb04:	e1550006 	cmp	r5, r6
3481cb08:	aafffff5 	bge	3481cae4 <strstr+0x2c>
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
	}
	return NULL;
3481cb0c:	e3a04000 	mov	r4, #0
}
3481cb10:	e1a00004 	mov	r0, r4
3481cb14:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481cb18 <memchr>:
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
3481cb18:	e6ef1071 	uxtb	r1, r1
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481cb1c:	ea000003 	b	3481cb30 <memchr+0x18>
		if ((unsigned char)c == *p++) {
3481cb20:	e4d0c001 	ldrb	ip, [r0], #1
3481cb24:	e2422001 	sub	r2, r2, #1
3481cb28:	e151000c 	cmp	r1, ip
3481cb2c:	0a000004 	beq	3481cb44 <memchr+0x2c>
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481cb30:	e3520000 	cmp	r2, #0
		if ((unsigned char)c == *p++) {
3481cb34:	e1a03000 	mov	r3, r0
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481cb38:	1afffff8 	bne	3481cb20 <memchr+0x8>
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
		}
	}
	return NULL;
3481cb3c:	e1a00002 	mov	r0, r2
3481cb40:	e12fff1e 	bx	lr
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
3481cb44:	e1a00003 	mov	r0, r3
		}
	}
	return NULL;
}
3481cb48:	e12fff1e 	bx	lr

3481cb4c <strmhz>:
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
3481cb4c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481cb50:	e2815f7d 	add	r5, r1, #500	; 0x1f4
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
3481cb54:	e1a04000 	mov	r4, r0
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481cb58:	e59f1048 	ldr	r1, [pc, #72]	; 3481cba8 <strmhz+0x5c>
3481cb5c:	e1a00005 	mov	r0, r5
3481cb60:	eb000cd1 	bl	3481feac <__udivsi3>
3481cb64:	e1a06000 	mov	r6, r0
	l = sprintf (buf, "%ld", n);
3481cb68:	e1a02006 	mov	r2, r6
3481cb6c:	e59f1038 	ldr	r1, [pc, #56]	; 3481cbac <strmhz+0x60>
3481cb70:	e1a00004 	mov	r0, r4
3481cb74:	eb0002f9 	bl	3481d760 <sprintf>
3481cb78:	e1a07000 	mov	r7, r0

	hz -= n * 1000000L;
	m = DIV_ROUND(hz, 1000L);
3481cb7c:	e59f002c 	ldr	r0, [pc, #44]	; 3481cbb0 <strmhz+0x64>
3481cb80:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3481cb84:	e0205690 	mla	r0, r0, r6, r5
3481cb88:	eb000cc7 	bl	3481feac <__udivsi3>
	if (m != 0)
3481cb8c:	e2502000 	subs	r2, r0, #0
3481cb90:	0a000002 	beq	3481cba0 <strmhz+0x54>
		sprintf (buf + l, ".%03ld", m);
3481cb94:	e0840007 	add	r0, r4, r7
3481cb98:	e59f1014 	ldr	r1, [pc, #20]	; 3481cbb4 <strmhz+0x68>
3481cb9c:	eb0002ef 	bl	3481d760 <sprintf>
	return (buf);
}
3481cba0:	e1a00004 	mov	r0, r4
3481cba4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481cba8:	000f4240 	.word	0x000f4240
3481cbac:	34828168 	.word	0x34828168
3481cbb0:	fff0bdc0 	.word	0xfff0bdc0
3481cbb4:	34828304 	.word	0x34828304

3481cbb8 <udelay>:
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
3481cbb8:	e92d4070 	push	{r4, r5, r6, lr}
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
3481cbbc:	e59f6020 	ldr	r6, [pc, #32]	; 3481cbe4 <udelay+0x2c>
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
3481cbc0:	e1a04000 	mov	r4, r0
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
3481cbc4:	e1540006 	cmp	r4, r6
3481cbc8:	31a05004 	movcc	r5, r4
3481cbcc:	21a05006 	movcs	r5, r6
		__udelay (kv);
3481cbd0:	e1a00005 	mov	r0, r5
3481cbd4:	ebff91f5 	bl	348013b0 <__udelay>
		usec -= kv;
	} while(usec);
3481cbd8:	e0544005 	subs	r4, r4, r5
3481cbdc:	1afffff8 	bne	3481cbc4 <udelay+0xc>
}
3481cbe0:	e8bd8070 	pop	{r4, r5, r6, pc}
3481cbe4:	00989680 	.word	0x00989680

3481cbe8 <mdelay>:

void mdelay(unsigned long msec)
{
3481cbe8:	e92d4010 	push	{r4, lr}
3481cbec:	e1a04000 	mov	r4, r0
	while (msec--)
3481cbf0:	ea000002 	b	3481cc00 <mdelay+0x18>
		udelay(1000);
3481cbf4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
3481cbf8:	ebffffee 	bl	3481cbb8 <udelay>
3481cbfc:	e2444001 	sub	r4, r4, #1
	} while(usec);
}

void mdelay(unsigned long msec)
{
	while (msec--)
3481cc00:	e3540000 	cmp	r4, #0
3481cc04:	1afffffa 	bne	3481cbf4 <mdelay+0xc>
		udelay(1000);
}
3481cc08:	e8bd8010 	pop	{r4, pc}

3481cc0c <put_dec>:
					*buf++ = q + '0';
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
3481cc0c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3481cc10:	e28d5008 	add	r5, sp, #8
3481cc14:	e16520f8 	strd	r2, [r5, #-8]!
3481cc18:	e1a04000 	mov	r4, r0
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481cc1c:	e3a090cd 	mov	r9, #205	; 0xcd
	d0 = d0 - 10*q;
3481cc20:	e3a0a00a 	mov	sl, #10
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
	while (1) {
		unsigned rem;
		if (num < 100000)
3481cc24:	e89d0840 	ldm	sp, {r6, fp}
3481cc28:	e35b0000 	cmp	fp, #0
3481cc2c:	1a00003b 	bne	3481cd20 <put_dec+0x114>
3481cc30:	e59f0198 	ldr	r0, [pc, #408]	; 3481cdd0 <put_dec+0x1c4>
3481cc34:	e1560000 	cmp	r6, r0
3481cc38:	8a00002f 	bhi	3481ccfc <put_dec+0xf0>
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
3481cc3c:	e7e37256 	ubfx	r7, r6, #4, #4
	d2 = (q>>8) & 0xf;
3481cc40:	e7e31456 	ubfx	r1, r6, #8, #4
	d3 = (q>>12);
3481cc44:	e1a03626 	lsr	r3, r6, #12

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481cc48:	e0870001 	add	r0, r7, r1
3481cc4c:	e206200f 	and	r2, r6, #15
3481cc50:	e0800003 	add	r0, r0, r3
3481cc54:	e3a06006 	mov	r6, #6
3481cc58:	e0262096 	mla	r6, r6, r0, r2
	q = (d0 * 0xcd) >> 11;
3481cc5c:	e3a0c0cd 	mov	ip, #205	; 0xcd
3481cc60:	e005069c 	mul	r5, ip, r6
	d0 = d0 - 10*q;
3481cc64:	e3a0200a 	mov	r2, #10
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481cc68:	e1a055a5 	lsr	r5, r5, #11
	d0 = d0 - 10*q;
3481cc6c:	e0666592 	mls	r6, r2, r5, r6
	*buf++ = d0 + '0'; /* least significant digit */
3481cc70:	e1a00004 	mov	r0, r4
3481cc74:	e2866030 	add	r6, r6, #48	; 0x30
3481cc78:	e4c06001 	strb	r6, [r0], #1
	d1 = q + 9*d3 + 5*d2 + d1;
3481cc7c:	e0836183 	add	r6, r3, r3, lsl #3
3481cc80:	e0866007 	add	r6, r6, r7
3481cc84:	e081a101 	add	sl, r1, r1, lsl #2
3481cc88:	e086600a 	add	r6, r6, sl
	if (d1 != 0) {
3481cc8c:	e0965005 	adds	r5, r6, r5
3481cc90:	0a000018 	beq	3481ccf8 <put_dec+0xec>
		q = (d1 * 0xcd) >> 11;
3481cc94:	e006059c 	mul	r6, ip, r5
3481cc98:	e1a065a6 	lsr	r6, r6, #11
		d1 = d1 - 10*q;
3481cc9c:	e0655692 	mls	r5, r2, r6, r5
		*buf++ = d1 + '0'; /* next digit */

		d2 = q + 2*d2;
3481cca0:	e0861081 	add	r1, r6, r1, lsl #1
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
3481cca4:	e2855030 	add	r5, r5, #48	; 0x30
3481cca8:	e5c45001 	strb	r5, [r4, #1]

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
3481ccac:	e1914003 	orrs	r4, r1, r3
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
3481ccb0:	e2800001 	add	r0, r0, #1

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
3481ccb4:	0a00000f 	beq	3481ccf8 <put_dec+0xec>
			q = (d2 * 0xd) >> 7;
3481ccb8:	e3a0400d 	mov	r4, #13
3481ccbc:	e0040194 	mul	r4, r4, r1
3481ccc0:	e1a043a4 	lsr	r4, r4, #7
			d2 = d2 - 10*q;
3481ccc4:	e0611492 	mls	r1, r2, r4, r1
			*buf++ = d2 + '0'; /* next digit */

			d3 = q + 4*d3;
			if (d3 != 0) {
3481ccc8:	e0943103 	adds	r3, r4, r3, lsl #2

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0'; /* next digit */
3481cccc:	e2811030 	add	r1, r1, #48	; 0x30
3481ccd0:	e4c01001 	strb	r1, [r0], #1

			d3 = q + 4*d3;
			if (d3 != 0) {
3481ccd4:	0a000007 	beq	3481ccf8 <put_dec+0xec>
				q = (d3 * 0xcd) >> 11;
3481ccd8:	e001039c 	mul	r1, ip, r3
3481ccdc:	e1a015a1 	lsr	r1, r1, #11
				d3 = d3 - 10*q;
3481cce0:	e0633192 	mls	r3, r2, r1, r3
				*buf++ = d3 + '0';  /* next digit */
				if (q != 0)
3481cce4:	e3510000 	cmp	r1, #0

			d3 = q + 4*d3;
			if (d3 != 0) {
				q = (d3 * 0xcd) >> 11;
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';  /* next digit */
3481cce8:	e2833030 	add	r3, r3, #48	; 0x30
3481ccec:	e4c03001 	strb	r3, [r0], #1
				if (q != 0)
					*buf++ = q + '0';  /* most sign. digit */
3481ccf0:	12811030 	addne	r1, r1, #48	; 0x30
3481ccf4:	14c01001 	strbne	r1, [r0], #1
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
}
3481ccf8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
{
	while (1) {
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
3481ccfc:	e1a00006 	mov	r0, r6
3481cd00:	e59f10cc 	ldr	r1, [pc, #204]	; 3481cdd4 <put_dec+0x1c8>
3481cd04:	eb000ce3 	bl	34820098 <__aeabi_uidivmod>
3481cd08:	e1a00006 	mov	r0, r6
3481cd0c:	e1a07001 	mov	r7, r1
3481cd10:	e59f10bc 	ldr	r1, [pc, #188]	; 3481cdd4 <put_dec+0x1c8>
3481cd14:	eb000c64 	bl	3481feac <__udivsi3>
3481cd18:	e88d0801 	stm	sp, {r0, fp}
3481cd1c:	ea000003 	b	3481cd30 <put_dec+0x124>
3481cd20:	e1a0000d 	mov	r0, sp
3481cd24:	e59f10a8 	ldr	r1, [pc, #168]	; 3481cdd4 <put_dec+0x1c8>
3481cd28:	ebfff852 	bl	3481ae78 <__div64_32>
3481cd2c:	e1a07000 	mov	r7, r0
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
3481cd30:	e7e32457 	ubfx	r2, r7, #8, #4
static char* put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
3481cd34:	e7e30257 	ubfx	r0, r7, #4, #4
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);
3481cd38:	e1a03627 	lsr	r3, r7, #12
	 * (x * 0x34) >> 9:    110100 - same
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481cd3c:	e0801002 	add	r1, r0, r2
3481cd40:	e0811003 	add	r1, r1, r3
3481cd44:	e3a0c006 	mov	ip, #6
3481cd48:	e207700f 	and	r7, r7, #15
3481cd4c:	e027719c 	mla	r7, ip, r1, r7
	q = (d0 * 0xcd) >> 11;
3481cd50:	e0010799 	mul	r1, r9, r7
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481cd54:	e083c183 	add	ip, r3, r3, lsl #3
3481cd58:	e08c0000 	add	r0, ip, r0
3481cd5c:	e082c102 	add	ip, r2, r2, lsl #2
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481cd60:	e1a015a1 	lsr	r1, r1, #11
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481cd64:	e080000c 	add	r0, r0, ip
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
3481cd68:	e067719a 	mls	r7, sl, r1, r7
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481cd6c:	e0801001 	add	r1, r0, r1
		q = (d1 * 0xcd) >> 11;
3481cd70:	e0060199 	mul	r6, r9, r1
3481cd74:	e1a065a6 	lsr	r6, r6, #11
		d1 = d1 - 10*q;
3481cd78:	e061169a 	mls	r1, sl, r6, r1
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
3481cd7c:	e0862082 	add	r2, r6, r2, lsl #1
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';
3481cd80:	e2811030 	add	r1, r1, #48	; 0x30

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
3481cd84:	e3a0000d 	mov	r0, #13
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';
3481cd88:	e5c41001 	strb	r1, [r4, #1]

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
3481cd8c:	e0010290 	mul	r1, r0, r2
3481cd90:	e1a013a1 	lsr	r1, r1, #7
			d2 = d2 - 10*q;
3481cd94:	e062219a 	mls	r2, sl, r1, r2
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
3481cd98:	e0813103 	add	r3, r1, r3, lsl #2
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';
3481cd9c:	e2822030 	add	r2, r2, #48	; 0x30
3481cda0:	e5c42002 	strb	r2, [r4, #2]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
3481cda4:	e0020399 	mul	r2, r9, r3
3481cda8:	e1a025a2 	lsr	r2, r2, #11
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
3481cdac:	e063329a 	mls	r3, sl, r2, r3
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
3481cdb0:	e2877030 	add	r7, r7, #48	; 0x30

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
3481cdb4:	e2833030 	add	r3, r3, #48	; 0x30
					*buf++ = q + '0';
3481cdb8:	e2822030 	add	r2, r2, #48	; 0x30
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
3481cdbc:	e5c47000 	strb	r7, [r4]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
3481cdc0:	e5c43003 	strb	r3, [r4, #3]
					*buf++ = q + '0';
3481cdc4:	e5c42004 	strb	r2, [r4, #4]
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
3481cdc8:	e2844005 	add	r4, r4, #5
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
3481cdcc:	eaffff94 	b	3481cc24 <put_dec+0x18>
3481cdd0:	0001869f 	.word	0x0001869f
3481cdd4:	000186a0 	.word	0x000186a0

3481cdd8 <string.clone.0>:
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481cdd8:	e92d4070 	push	{r4, r5, r6, lr}
		int precision, int flags)
{
	int len, i;

	if (s == 0)
		s = "<NULL>";
3481cddc:	e3510000 	cmp	r1, #0
3481cde0:	e59f607c 	ldr	r6, [pc, #124]	; 3481ce64 <string.clone.0+0x8c>
3481cde4:	11a06001 	movne	r6, r1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481cde8:	e1a04000 	mov	r4, r0
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
3481cdec:	e1a01003 	mov	r1, r3
3481cdf0:	e1a00006 	mov	r0, r6
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481cdf4:	e1a05002 	mov	r5, r2
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
3481cdf8:	ebfffe4a 	bl	3481c728 <strnlen>

	if (!(flags & LEFT))
3481cdfc:	e59d3010 	ldr	r3, [sp, #16]
3481ce00:	e3130010 	tst	r3, #16
3481ce04:	1a000007 	bne	3481ce28 <string.clone.0+0x50>
3481ce08:	ea000001 	b	3481ce14 <string.clone.0+0x3c>
		while (len < field_width--)
			ADDCH(buf, ' ');
3481ce0c:	e4c43001 	strb	r3, [r4], #1
3481ce10:	ea000000 	b	3481ce18 <string.clone.0+0x40>
3481ce14:	e3a03020 	mov	r3, #32
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
3481ce18:	e2455001 	sub	r5, r5, #1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481ce1c:	e2852001 	add	r2, r5, #1
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
3481ce20:	e1500002 	cmp	r0, r2
3481ce24:	bafffff8 	blt	3481ce0c <string.clone.0+0x34>
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481ce28:	e3a03000 	mov	r3, #0
3481ce2c:	ea000002 	b	3481ce3c <string.clone.0+0x64>
		ADDCH(buf, *s++);
3481ce30:	e7d62003 	ldrb	r2, [r6, r3]
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481ce34:	e2833001 	add	r3, r3, #1
		ADDCH(buf, *s++);
3481ce38:	e4c42001 	strb	r2, [r4], #1
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481ce3c:	e1530000 	cmp	r3, r0
3481ce40:	bafffffa 	blt	3481ce30 <string.clone.0+0x58>
		ADDCH(buf, *s++);
	while (len < field_width--)
		ADDCH(buf, ' ');
3481ce44:	e3a03020 	mov	r3, #32
3481ce48:	ea000001 	b	3481ce54 <string.clone.0+0x7c>
3481ce4c:	e4c43001 	strb	r3, [r4], #1
3481ce50:	e2455001 	sub	r5, r5, #1
	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
		ADDCH(buf, *s++);
	while (len < field_width--)
3481ce54:	e1500005 	cmp	r0, r5
3481ce58:	bafffffb 	blt	3481ce4c <string.clone.0+0x74>
		ADDCH(buf, ' ');
	return buf;
}
3481ce5c:	e1a00004 	mov	r0, r4
3481ce60:	e8bd8070 	pop	{r4, r5, r6, pc}
3481ce64:	3482830b 	.word	0x3482830b

3481ce68 <number.clone.1>:
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481ce68:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481ce6c:	e24dd058 	sub	sp, sp, #88	; 0x58
3481ce70:	e59d5084 	ldr	r5, [sp, #132]	; 0x84
3481ce74:	e59d9078 	ldr	r9, [sp, #120]	; 0x78
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481ce78:	e2051020 	and	r1, r5, #32
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
3481ce7c:	e259b00a 	subs	fp, r9, #10
3481ce80:	13a0b001 	movne	fp, #1
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
3481ce84:	e3150010 	tst	r5, #16
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
3481ce88:	e00bb325 	and	fp, fp, r5, lsr #6

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
		type &= ~ZEROPAD;
3481ce8c:	13c55001 	bicne	r5, r5, #1
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481ce90:	e6ef1071 	uxtb	r1, r1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
3481ce94:	e215a002 	ands	sl, r5, #2
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481ce98:	e1a04000 	mov	r4, r0
3481ce9c:	e59d607c 	ldr	r6, [sp, #124]	; 0x7c
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481cea0:	e58d1004 	str	r1, [sp, #4]
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
3481cea4:	0a00000f 	beq	3481cee8 <number.clone.1+0x80>
		if ((signed NUM_TYPE) num < 0) {
3481cea8:	e3530000 	cmp	r3, #0
3481ceac:	ba000002 	blt	3481cebc <number.clone.1+0x54>
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
3481ceb0:	e3150004 	tst	r5, #4
3481ceb4:	0a000008 	beq	3481cedc <number.clone.1+0x74>
3481ceb8:	ea000004 	b	3481ced0 <number.clone.1+0x68>
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
3481cebc:	e2722000 	rsbs	r2, r2, #0
3481cec0:	e2e33000 	rsc	r3, r3, #0
			size--;
3481cec4:	e2466001 	sub	r6, r6, #1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
3481cec8:	e3a0a02d 	mov	sl, #45	; 0x2d
3481cecc:	ea000005 	b	3481cee8 <number.clone.1+0x80>
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
3481ced0:	e2466001 	sub	r6, r6, #1
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
3481ced4:	e3a0a02b 	mov	sl, #43	; 0x2b
3481ced8:	ea000002 	b	3481cee8 <number.clone.1+0x80>
			size--;
		} else if (type & SPACE) {
3481cedc:	e215a008 	ands	sl, r5, #8
			sign = ' ';
			size--;
3481cee0:	12466001 	subne	r6, r6, #1
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
		} else if (type & SPACE) {
			sign = ' ';
3481cee4:	13a0a020 	movne	sl, #32
			size--;
		}
	}
	if (need_pfx) {
3481cee8:	e35b0000 	cmp	fp, #0
3481ceec:	0a000002 	beq	3481cefc <number.clone.1+0x94>
		size--;
3481cef0:	e2466001 	sub	r6, r6, #1
		if (base == 16)
3481cef4:	e3590010 	cmp	r9, #16
			size--;
3481cef8:	02466001 	subeq	r6, r6, #1
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
3481cefc:	e1921003 	orrs	r1, r2, r3
		tmp[i++] = '0';
3481cf00:	03a03030 	moveq	r3, #48	; 0x30
3481cf04:	05cd3014 	strbeq	r3, [sp, #20]
3481cf08:	03a07001 	moveq	r7, #1
			size--;
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
3481cf0c:	0a000023 	beq	3481cfa0 <number.clone.1+0x138>
	/* Generic code, for any base:
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
3481cf10:	e359000a 	cmp	r9, #10
3481cf14:	0a00001d 	beq	3481cf90 <number.clone.1+0x128>
		int mask = base - 1;
		int shift = 3;
3481cf18:	e3590010 	cmp	r9, #16
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
3481cf1c:	e2491001 	sub	r1, r9, #1
		int shift = 3;
3481cf20:	03a0c004 	moveq	ip, #4
3481cf24:	13a0c003 	movne	ip, #3
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
3481cf28:	e58d1008 	str	r1, [sp, #8]
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481cf2c:	e58db00c 	str	fp, [sp, #12]
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
3481cf30:	e3a07000 	mov	r7, #0
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481cf34:	e1a0b00a 	mov	fp, sl
3481cf38:	e1a00002 	mov	r0, r2
3481cf3c:	e1a0a004 	mov	sl, r4
3481cf40:	e1a01003 	mov	r1, r3
3481cf44:	e1a0400c 	mov	r4, ip
3481cf48:	e59d3008 	ldr	r3, [sp, #8]
3481cf4c:	e6ef2070 	uxtb	r2, r0
3481cf50:	e0022003 	and	r2, r2, r3
3481cf54:	e59f311c 	ldr	r3, [pc, #284]	; 3481d078 <number.clone.1+0x210>
3481cf58:	e7d3c002 	ldrb	ip, [r3, r2]
3481cf5c:	e59d3004 	ldr	r3, [sp, #4]
3481cf60:	e28d2014 	add	r2, sp, #20
3481cf64:	e183c00c 	orr	ip, r3, ip
3481cf68:	e7c2c007 	strb	ip, [r2, r7]
			num >>= shift;
3481cf6c:	e1a02004 	mov	r2, r4
3481cf70:	eb000ce0 	bl	348202f8 <__lshrdi3>
		} while (num);
3481cf74:	e1903001 	orrs	r3, r0, r1
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481cf78:	e2877001 	add	r7, r7, #1
			num >>= shift;
		} while (num);
3481cf7c:	1afffff1 	bne	3481cf48 <number.clone.1+0xe0>
3481cf80:	e1a0400a 	mov	r4, sl
3481cf84:	e1a0a00b 	mov	sl, fp
3481cf88:	e59db00c 	ldr	fp, [sp, #12]
3481cf8c:	ea000003 	b	3481cfa0 <number.clone.1+0x138>
	} else { /* base 10 */
		i = put_dec(tmp, num) - tmp;
3481cf90:	e28d7014 	add	r7, sp, #20
3481cf94:	e1a00007 	mov	r0, r7
3481cf98:	ebffff1b 	bl	3481cc0c <put_dec>
3481cf9c:	e0677000 	rsb	r7, r7, r0
3481cfa0:	e59d3080 	ldr	r3, [sp, #128]	; 0x80
3481cfa4:	e1570003 	cmp	r7, r3
3481cfa8:	a1a03007 	movge	r3, r7
3481cfac:	b1a03003 	movlt	r3, r3
	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
3481cfb0:	e3150011 	tst	r5, #17

	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
3481cfb4:	e0636006 	rsb	r6, r3, r6
	if (!(type & (ZEROPAD + LEFT))) {
3481cfb8:	1a000005 	bne	3481cfd4 <number.clone.1+0x16c>
3481cfbc:	ea000001 	b	3481cfc8 <number.clone.1+0x160>
		while (--size >= 0)
			ADDCH(buf, ' ');
3481cfc0:	e4c42001 	strb	r2, [r4], #1
3481cfc4:	ea000000 	b	3481cfcc <number.clone.1+0x164>
3481cfc8:	e3a02020 	mov	r2, #32
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
		while (--size >= 0)
3481cfcc:	e2566001 	subs	r6, r6, #1
3481cfd0:	5afffffa 	bpl	3481cfc0 <number.clone.1+0x158>
			ADDCH(buf, ' ');
	}
	/* sign */
	if (sign)
3481cfd4:	e35a0000 	cmp	sl, #0
		ADDCH(buf, sign);
3481cfd8:	14c4a001 	strbne	sl, [r4], #1
	/* "0x" / "0" prefix */
	if (need_pfx) {
3481cfdc:	e35b0000 	cmp	fp, #0
3481cfe0:	0a000005 	beq	3481cffc <number.clone.1+0x194>
		ADDCH(buf, '0');
3481cfe4:	e3a02030 	mov	r2, #48	; 0x30
3481cfe8:	e4c42001 	strb	r2, [r4], #1
		if (base == 16)
3481cfec:	e3590010 	cmp	r9, #16
			ADDCH(buf, 'X' | locase);
3481cff0:	059d1004 	ldreq	r1, [sp, #4]
3481cff4:	03812058 	orreq	r2, r1, #88	; 0x58
3481cff8:	04c42001 	strbeq	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
3481cffc:	e3150010 	tst	r5, #16
3481d000:	1a000009 	bne	3481d02c <number.clone.1+0x1c4>
		char c = (type & ZEROPAD) ? '0' : ' ';
3481d004:	e3150001 	tst	r5, #1
3481d008:	03a02020 	moveq	r2, #32
3481d00c:	13a02030 	movne	r2, #48	; 0x30
3481d010:	ea000000 	b	3481d018 <number.clone.1+0x1b0>

		while (--size >= 0)
			ADDCH(buf, c);
3481d014:	e4c42001 	strb	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
		char c = (type & ZEROPAD) ? '0' : ' ';

		while (--size >= 0)
3481d018:	e2566001 	subs	r6, r6, #1
3481d01c:	5afffffc 	bpl	3481d014 <number.clone.1+0x1ac>
3481d020:	ea000001 	b	3481d02c <number.clone.1+0x1c4>
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
3481d024:	e4c42001 	strb	r2, [r4], #1
3481d028:	ea000000 	b	3481d030 <number.clone.1+0x1c8>
3481d02c:	e3a02030 	mov	r2, #48	; 0x30

		while (--size >= 0)
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
3481d030:	e2433001 	sub	r3, r3, #1
3481d034:	e1570003 	cmp	r7, r3
3481d038:	dafffff9 	ble	3481d024 <number.clone.1+0x1bc>
3481d03c:	ea000002 	b	3481d04c <number.clone.1+0x1e4>
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
3481d040:	e28d3014 	add	r3, sp, #20
3481d044:	e7d33007 	ldrb	r3, [r3, r7]
3481d048:	e4c43001 	strb	r3, [r4], #1
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
3481d04c:	e2577001 	subs	r7, r7, #1
3481d050:	5afffffa 	bpl	3481d040 <number.clone.1+0x1d8>
3481d054:	ea000001 	b	3481d060 <number.clone.1+0x1f8>
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
		ADDCH(buf, ' ');
3481d058:	e4c43001 	strb	r3, [r4], #1
3481d05c:	ea000000 	b	3481d064 <number.clone.1+0x1fc>
3481d060:	e3a03020 	mov	r3, #32
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
3481d064:	e2566001 	subs	r6, r6, #1
3481d068:	5afffffa 	bpl	3481d058 <number.clone.1+0x1f0>
		ADDCH(buf, ' ');
	return buf;
}
3481d06c:	e1a00004 	mov	r0, r4
3481d070:	e28dd058 	add	sp, sp, #88	; 0x58
3481d074:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481d078:	348220e8 	.word	0x348220e8

3481d07c <vsnprintf_internal.clone.3>:
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481d07c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
3481d080:	e1a0a000 	mov	sl, r0
3481d084:	e1a06001 	mov	r6, r1
				++fmt;
			}
		}

		/* default base */
		base = 10;
3481d088:	e3a0900a 	mov	r9, #10

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
3481d08c:	e3a0b020 	mov	fp, #32
3481d090:	ea000103 	b	3481d4a4 <vsnprintf_internal.clone.3+0x428>
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
3481d094:	e3530025 	cmp	r3, #37	; 0x25
3481d098:	1a0000cc 	bne	3481d3d0 <vsnprintf_internal.clone.3+0x354>
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481d09c:	e286c001 	add	ip, r6, #1
3481d0a0:	e3a01000 	mov	r1, #0
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
			ADDCH(str, *fmt);
3481d0a4:	e1a0600c 	mov	r6, ip

		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
3481d0a8:	e4dc3001 	ldrb	r3, [ip], #1
3481d0ac:	e353002b 	cmp	r3, #43	; 0x2b
3481d0b0:	0a00000c 	beq	3481d0e8 <vsnprintf_internal.clone.3+0x6c>
3481d0b4:	8a000004 	bhi	3481d0cc <vsnprintf_internal.clone.3+0x50>
3481d0b8:	e3530020 	cmp	r3, #32
3481d0bc:	0a00000b 	beq	3481d0f0 <vsnprintf_internal.clone.3+0x74>
3481d0c0:	e3530023 	cmp	r3, #35	; 0x23
3481d0c4:	1a00000f 	bne	3481d108 <vsnprintf_internal.clone.3+0x8c>
3481d0c8:	ea00000a 	b	3481d0f8 <vsnprintf_internal.clone.3+0x7c>
3481d0cc:	e353002d 	cmp	r3, #45	; 0x2d
3481d0d0:	0a000002 	beq	3481d0e0 <vsnprintf_internal.clone.3+0x64>
3481d0d4:	e3530030 	cmp	r3, #48	; 0x30
3481d0d8:	1a00000a 	bne	3481d108 <vsnprintf_internal.clone.3+0x8c>
3481d0dc:	ea000007 	b	3481d100 <vsnprintf_internal.clone.3+0x84>
				case '-': flags |= LEFT; goto repeat;
3481d0e0:	e3811010 	orr	r1, r1, #16
3481d0e4:	eaffffee 	b	3481d0a4 <vsnprintf_internal.clone.3+0x28>
				case '+': flags |= PLUS; goto repeat;
3481d0e8:	e3811004 	orr	r1, r1, #4
3481d0ec:	eaffffec 	b	3481d0a4 <vsnprintf_internal.clone.3+0x28>
				case ' ': flags |= SPACE; goto repeat;
3481d0f0:	e3811008 	orr	r1, r1, #8
3481d0f4:	eaffffea 	b	3481d0a4 <vsnprintf_internal.clone.3+0x28>
				case '#': flags |= SPECIAL; goto repeat;
3481d0f8:	e3811040 	orr	r1, r1, #64	; 0x40
3481d0fc:	eaffffe8 	b	3481d0a4 <vsnprintf_internal.clone.3+0x28>
				case '0': flags |= ZEROPAD; goto repeat;
3481d100:	e3811001 	orr	r1, r1, #1
3481d104:	eaffffe6 	b	3481d0a4 <vsnprintf_internal.clone.3+0x28>
			}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
3481d108:	e243c030 	sub	ip, r3, #48	; 0x30
3481d10c:	e6efc07c 	uxtb	ip, ip
3481d110:	e35c0009 	cmp	ip, #9
3481d114:	91a03006 	movls	r3, r6
3481d118:	93a0c000 	movls	ip, #0
3481d11c:	9a000001 	bls	3481d128 <vsnprintf_internal.clone.3+0xac>
3481d120:	ea000007 	b	3481d144 <vsnprintf_internal.clone.3+0xc8>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
3481d124:	e02c4c99 	mla	ip, r9, ip, r4
3481d128:	e1a06003 	mov	r6, r3

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481d12c:	e4d34001 	ldrb	r4, [r3], #1
3481d130:	e2444030 	sub	r4, r4, #48	; 0x30
3481d134:	e6ef5074 	uxtb	r5, r4
3481d138:	e3550009 	cmp	r5, #9
3481d13c:	9afffff8 	bls	3481d124 <vsnprintf_internal.clone.3+0xa8>
3481d140:	ea000009 	b	3481d16c <vsnprintf_internal.clone.3+0xf0>

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3481d144:	e353002a 	cmp	r3, #42	; 0x2a
				case '#': flags |= SPECIAL; goto repeat;
				case '0': flags |= ZEROPAD; goto repeat;
			}

		/* get field width */
		field_width = -1;
3481d148:	13e0c000 	mvnne	ip, #0
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3481d14c:	1a000006 	bne	3481d16c <vsnprintf_internal.clone.3+0xf0>
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
3481d150:	e592c000 	ldr	ip, [r2]
3481d154:	e2823004 	add	r3, r2, #4
			if (field_width < 0) {
3481d158:	e35c0000 	cmp	ip, #0
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
3481d15c:	e2866001 	add	r6, r6, #1
			/* it's the next argument */
			field_width = va_arg(args, int);
			if (field_width < 0) {
				field_width = -field_width;
3481d160:	b26cc000 	rsblt	ip, ip, #0
				flags |= LEFT;
3481d164:	b3811010 	orrlt	r1, r1, #16
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
3481d168:	e1a02003 	mov	r2, r3
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
3481d16c:	e5d63000 	ldrb	r3, [r6]
3481d170:	e353002e 	cmp	r3, #46	; 0x2e
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
3481d174:	13e03000 	mvnne	r3, #0
		if (*fmt == '.') {
3481d178:	1a00001c 	bne	3481d1f0 <vsnprintf_internal.clone.3+0x174>
			++fmt;
			if (is_digit(*fmt))
3481d17c:	e5f63001 	ldrb	r3, [r6, #1]!
3481d180:	e2434030 	sub	r4, r3, #48	; 0x30
3481d184:	e6ef4074 	uxtb	r4, r4
3481d188:	e3540009 	cmp	r4, #9
3481d18c:	91a07006 	movls	r7, r6
3481d190:	93a03000 	movls	r3, #0
3481d194:	9a000001 	bls	3481d1a0 <vsnprintf_internal.clone.3+0x124>
3481d198:	ea000009 	b	3481d1c4 <vsnprintf_internal.clone.3+0x148>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
3481d19c:	e0235399 	mla	r3, r9, r3, r5

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481d1a0:	e5d75000 	ldrb	r5, [r7]
		i = i*10 + *((*s)++) - '0';
3481d1a4:	e1a06007 	mov	r6, r7

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481d1a8:	e2455030 	sub	r5, r5, #48	; 0x30
3481d1ac:	e6ef4075 	uxtb	r4, r5
3481d1b0:	e3540009 	cmp	r4, #9
3481d1b4:	e2877001 	add	r7, r7, #1
3481d1b8:	9afffff7 	bls	3481d19c <vsnprintf_internal.clone.3+0x120>
3481d1bc:	e1a04002 	mov	r4, r2
3481d1c0:	ea000006 	b	3481d1e0 <vsnprintf_internal.clone.3+0x164>
		precision = -1;
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
3481d1c4:	e353002a 	cmp	r3, #42	; 0x2a
3481d1c8:	1a000007 	bne	3481d1ec <vsnprintf_internal.clone.3+0x170>
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481d1cc:	e5923000 	ldr	r3, [r2]
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
3481d1d0:	e2866001 	add	r6, r6, #1
				/* it's the next argument */
				precision = va_arg(args, int);
			}
			if (precision < 0)
3481d1d4:	e3530000 	cmp	r3, #0
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481d1d8:	e2824004 	add	r4, r2, #4
			}
			if (precision < 0)
3481d1dc:	ba000001 	blt	3481d1e8 <vsnprintf_internal.clone.3+0x16c>
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
3481d1e0:	e1a02004 	mov	r2, r4
3481d1e4:	ea000001 	b	3481d1f0 <vsnprintf_internal.clone.3+0x174>
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481d1e8:	e1a02004 	mov	r2, r4
			}
			if (precision < 0)
				precision = 0;
3481d1ec:	e3a03000 	mov	r3, #0
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
3481d1f0:	e5d64000 	ldrb	r4, [r6]
3481d1f4:	e3540068 	cmp	r4, #104	; 0x68
3481d1f8:	1354006c 	cmpne	r4, #108	; 0x6c
3481d1fc:	0a000008 	beq	3481d224 <vsnprintf_internal.clone.3+0x1a8>
3481d200:	e354004c 	cmp	r4, #76	; 0x4c
3481d204:	0a000006 	beq	3481d224 <vsnprintf_internal.clone.3+0x1a8>
3481d208:	e354005a 	cmp	r4, #90	; 0x5a
3481d20c:	0a000004 	beq	3481d224 <vsnprintf_internal.clone.3+0x1a8>
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481d210:	e354007a 	cmp	r4, #122	; 0x7a
3481d214:	0a000002 	beq	3481d224 <vsnprintf_internal.clone.3+0x1a8>
3481d218:	e3540074 	cmp	r4, #116	; 0x74
			if (precision < 0)
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
3481d21c:	13e04000 	mvnne	r4, #0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481d220:	1a000006 	bne	3481d240 <vsnprintf_internal.clone.3+0x1c4>
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
3481d224:	e354006c 	cmp	r4, #108	; 0x6c
		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
3481d228:	e2866001 	add	r6, r6, #1
			if (qualifier == 'l' && *fmt == 'l') {
3481d22c:	1a000003 	bne	3481d240 <vsnprintf_internal.clone.3+0x1c4>
3481d230:	e5d65000 	ldrb	r5, [r6]
3481d234:	e355006c 	cmp	r5, #108	; 0x6c
				qualifier = 'L';
				++fmt;
3481d238:	02866001 	addeq	r6, r6, #1
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
				qualifier = 'L';
3481d23c:	03a0404c 	moveq	r4, #76	; 0x4c
		}

		/* default base */
		base = 10;

		switch (*fmt) {
3481d240:	e5d65000 	ldrb	r5, [r6]
3481d244:	e355006e 	cmp	r5, #110	; 0x6e
3481d248:	0a00004f 	beq	3481d38c <vsnprintf_internal.clone.3+0x310>
3481d24c:	8a00000d 	bhi	3481d288 <vsnprintf_internal.clone.3+0x20c>
3481d250:	e3550063 	cmp	r5, #99	; 0x63
3481d254:	0a000018 	beq	3481d2bc <vsnprintf_internal.clone.3+0x240>
3481d258:	8a000005 	bhi	3481d274 <vsnprintf_internal.clone.3+0x1f8>
3481d25c:	e3550025 	cmp	r5, #37	; 0x25
				*ip = (str - buf);
			}
			continue;

		case '%':
			ADDCH(str, '%');
3481d260:	04c05001 	strbeq	r5, [r0], #1
		}

		/* default base */
		base = 10;

		switch (*fmt) {
3481d264:	0a00008d 	beq	3481d4a0 <vsnprintf_internal.clone.3+0x424>
3481d268:	e3550058 	cmp	r5, #88	; 0x58
3481d26c:	1a000051 	bne	3481d3b8 <vsnprintf_internal.clone.3+0x33c>
3481d270:	ea00005a 	b	3481d3e0 <vsnprintf_internal.clone.3+0x364>
3481d274:	e3550064 	cmp	r5, #100	; 0x64
3481d278:	0a00004c 	beq	3481d3b0 <vsnprintf_internal.clone.3+0x334>
3481d27c:	e3550069 	cmp	r5, #105	; 0x69
3481d280:	1a00004c 	bne	3481d3b8 <vsnprintf_internal.clone.3+0x33c>
3481d284:	ea000049 	b	3481d3b0 <vsnprintf_internal.clone.3+0x334>
3481d288:	e3550073 	cmp	r5, #115	; 0x73
3481d28c:	0a00001b 	beq	3481d300 <vsnprintf_internal.clone.3+0x284>
3481d290:	8a000004 	bhi	3481d2a8 <vsnprintf_internal.clone.3+0x22c>
3481d294:	e355006f 	cmp	r5, #111	; 0x6f
3481d298:	0a000040 	beq	3481d3a0 <vsnprintf_internal.clone.3+0x324>
3481d29c:	e3550070 	cmp	r5, #112	; 0x70
3481d2a0:	1a000044 	bne	3481d3b8 <vsnprintf_internal.clone.3+0x33c>
3481d2a4:	ea00001b 	b	3481d318 <vsnprintf_internal.clone.3+0x29c>
3481d2a8:	e3550075 	cmp	r5, #117	; 0x75
3481d2ac:	0a000049 	beq	3481d3d8 <vsnprintf_internal.clone.3+0x35c>
3481d2b0:	e3550078 	cmp	r5, #120	; 0x78
3481d2b4:	1a00003f 	bne	3481d3b8 <vsnprintf_internal.clone.3+0x33c>
3481d2b8:	ea00003a 	b	3481d3a8 <vsnprintf_internal.clone.3+0x32c>
		case 'c':
			if (!(flags & LEFT)) {
3481d2bc:	e3110010 	tst	r1, #16
3481d2c0:	1a000004 	bne	3481d2d8 <vsnprintf_internal.clone.3+0x25c>
3481d2c4:	ea000000 	b	3481d2cc <vsnprintf_internal.clone.3+0x250>
				while (--field_width > 0)
					ADDCH(str, ' ');
3481d2c8:	e4c0b001 	strb	fp, [r0], #1
		base = 10;

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
3481d2cc:	e24cc001 	sub	ip, ip, #1
3481d2d0:	e35c0000 	cmp	ip, #0
3481d2d4:	cafffffb 	bgt	3481d2c8 <vsnprintf_internal.clone.3+0x24c>
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
3481d2d8:	e2823004 	add	r3, r2, #4
3481d2dc:	e5922000 	ldr	r2, [r2]
3481d2e0:	ea000000 	b	3481d2e8 <vsnprintf_internal.clone.3+0x26c>
			while (--field_width > 0)
				ADDCH(str, ' ');
3481d2e4:	e1a0200b 	mov	r2, fp
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
3481d2e8:	e24cc001 	sub	ip, ip, #1
3481d2ec:	e35c0000 	cmp	ip, #0
				ADDCH(str, ' ');
3481d2f0:	e4c02001 	strb	r2, [r0], #1
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
3481d2f4:	cafffffa 	bgt	3481d2e4 <vsnprintf_internal.clone.3+0x268>
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
3481d2f8:	e1a02003 	mov	r2, r3
3481d2fc:	ea000067 	b	3481d4a0 <vsnprintf_internal.clone.3+0x424>
			while (--field_width > 0)
				ADDCH(str, ' ');
			continue;

		case 's':
			str = string(str, end, va_arg(args, char *),
3481d300:	e58d1000 	str	r1, [sp]
3481d304:	e2824004 	add	r4, r2, #4
3481d308:	e5921000 	ldr	r1, [r2]
3481d30c:	e1a0200c 	mov	r2, ip
3481d310:	ebfffeb0 	bl	3481cdd8 <string.clone.0>
3481d314:	ea00001a 	b	3481d384 <vsnprintf_internal.clone.3+0x308>
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
3481d318:	e2824004 	add	r4, r2, #4
3481d31c:	e5922000 	ldr	r2, [r2]
 * pointer to the real address.
 */
static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
		int field_width, int precision, int flags)
{
	if (!ptr)
3481d320:	e3520000 	cmp	r2, #0
3481d324:	1a000004 	bne	3481d33c <vsnprintf_internal.clone.3+0x2c0>
		return string(buf, end, "(null)", field_width, precision,
3481d328:	e58d1000 	str	r1, [sp]
3481d32c:	e1a0200c 	mov	r2, ip
3481d330:	e59f1188 	ldr	r1, [pc, #392]	; 3481d4c0 <vsnprintf_internal.clone.3+0x444>
3481d334:	ebfffea7 	bl	3481cdd8 <string.clone.0>
3481d338:	ea000009 	b	3481d364 <vsnprintf_internal.clone.3+0x2e8>
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
	if (field_width == -1) {
3481d33c:	e37c0001 	cmn	ip, #1
					       precision, flags);
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
3481d340:	e381e020 	orr	lr, r1, #32
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
3481d344:	028cc009 	addeq	ip, ip, #9
		flags |= ZEROPAD;
3481d348:	0381e021 	orreq	lr, r1, #33	; 0x21
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
3481d34c:	e58d3008 	str	r3, [sp, #8]
3481d350:	e3a01010 	mov	r1, #16
3481d354:	e3a03000 	mov	r3, #0
3481d358:	e88d1002 	stm	sp, {r1, ip}
3481d35c:	e58de00c 	str	lr, [sp, #12]
3481d360:	ebfffec0 	bl	3481ce68 <number.clone.1>
3481d364:	e1a03006 	mov	r3, r6
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
3481d368:	e5d32001 	ldrb	r2, [r3, #1]
3481d36c:	e59f1150 	ldr	r1, [pc, #336]	; 3481d4c4 <vsnprintf_internal.clone.3+0x448>
	flags |= SMALL;
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
		flags |= ZEROPAD;
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
3481d370:	e1a06003 	mov	r6, r3
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
3481d374:	e7d12002 	ldrb	r2, [r1, r2]
3481d378:	e2833001 	add	r3, r3, #1
3481d37c:	e3120007 	tst	r2, #7
3481d380:	1afffff8 	bne	3481d368 <vsnprintf_internal.clone.3+0x2ec>
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
3481d384:	e1a02004 	mov	r2, r4
3481d388:	ea000044 	b	3481d4a0 <vsnprintf_internal.clone.3+0x424>
3481d38c:	e2827004 	add	r7, r2, #4
			if (qualifier == 'l') {
				long * ip = va_arg(args, long *);
				*ip = (str - buf);
			} else {
				int * ip = va_arg(args, int *);
				*ip = (str - buf);
3481d390:	e5922000 	ldr	r2, [r2]
3481d394:	e06a3000 	rsb	r3, sl, r0
3481d398:	e5823000 	str	r3, [r2]
3481d39c:	ea00003e 	b	3481d49c <vsnprintf_internal.clone.3+0x420>
			ADDCH(str, '%');
			continue;

		/* integer number formats - set up the flags and "break" */
		case 'o':
			base = 8;
3481d3a0:	e3a0e008 	mov	lr, #8
3481d3a4:	ea00000e 	b	3481d3e4 <vsnprintf_internal.clone.3+0x368>
			break;

		case 'x':
			flags |= SMALL;
3481d3a8:	e3811020 	orr	r1, r1, #32
3481d3ac:	ea00000b 	b	3481d3e0 <vsnprintf_internal.clone.3+0x364>
			base = 16;
			break;

		case 'd':
		case 'i':
			flags |= SIGN;
3481d3b0:	e3811002 	orr	r1, r1, #2
3481d3b4:	ea000007 	b	3481d3d8 <vsnprintf_internal.clone.3+0x35c>
		case 'u':
			break;

		default:
			ADDCH(str, '%');
3481d3b8:	e3a03025 	mov	r3, #37	; 0x25
3481d3bc:	e4c03001 	strb	r3, [r0], #1
			if (*fmt)
3481d3c0:	e5d63000 	ldrb	r3, [r6]
3481d3c4:	e3530000 	cmp	r3, #0
				ADDCH(str, *fmt);
			else
				--fmt;
3481d3c8:	02466001 	subeq	r6, r6, #1
		case 'u':
			break;

		default:
			ADDCH(str, '%');
			if (*fmt)
3481d3cc:	0a000033 	beq	3481d4a0 <vsnprintf_internal.clone.3+0x424>
				ADDCH(str, *fmt);
3481d3d0:	e4c03001 	strb	r3, [r0], #1
3481d3d4:	ea000031 	b	3481d4a0 <vsnprintf_internal.clone.3+0x424>
				++fmt;
			}
		}

		/* default base */
		base = 10;
3481d3d8:	e3a0e00a 	mov	lr, #10
3481d3dc:	ea000000 	b	3481d3e4 <vsnprintf_internal.clone.3+0x368>
			break;

		case 'x':
			flags |= SMALL;
		case 'X':
			base = 16;
3481d3e0:	e3a0e010 	mov	lr, #16
				ADDCH(str, *fmt);
			else
				--fmt;
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
3481d3e4:	e354004c 	cmp	r4, #76	; 0x4c
			num = va_arg(args, unsigned long long);
3481d3e8:	02822007 	addeq	r2, r2, #7
3481d3ec:	03c22007 	biceq	r2, r2, #7
3481d3f0:	02827008 	addeq	r7, r2, #8
3481d3f4:	01c240d0 	ldrdeq	r4, [r2]
3481d3f8:	0a000020 	beq	3481d480 <vsnprintf_internal.clone.3+0x404>
		else if (qualifier == 'l') {
3481d3fc:	e354006c 	cmp	r4, #108	; 0x6c
3481d400:	1a000005 	bne	3481d41c <vsnprintf_internal.clone.3+0x3a0>
			num = va_arg(args, unsigned long);
3481d404:	e5924000 	ldr	r4, [r2]
			if (flags & SIGN)
3481d408:	e3110002 	tst	r1, #2
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
3481d40c:	e2827004 	add	r7, r2, #4
3481d410:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481d414:	0a000019 	beq	3481d480 <vsnprintf_internal.clone.3+0x404>
3481d418:	ea000017 	b	3481d47c <vsnprintf_internal.clone.3+0x400>
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481d41c:	e354005a 	cmp	r4, #90	; 0x5a
3481d420:	1354007a 	cmpne	r4, #122	; 0x7a
			num = va_arg(args, size_t);
3481d424:	05924000 	ldreq	r4, [r2]
3481d428:	02827004 	addeq	r7, r2, #4
3481d42c:	03a05000 	moveq	r5, #0
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481d430:	0a000012 	beq	3481d480 <vsnprintf_internal.clone.3+0x404>
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
3481d434:	e3540074 	cmp	r4, #116	; 0x74
			num = va_arg(args, ptrdiff_t);
3481d438:	02827004 	addeq	r7, r2, #4
3481d43c:	05924000 	ldreq	r4, [r2]
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
3481d440:	0a00000d 	beq	3481d47c <vsnprintf_internal.clone.3+0x400>
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
3481d444:	e3540068 	cmp	r4, #104	; 0x68
3481d448:	e2827004 	add	r7, r2, #4
3481d44c:	e5924000 	ldr	r4, [r2]
3481d450:	e2012002 	and	r2, r1, #2
3481d454:	1a000005 	bne	3481d470 <vsnprintf_internal.clone.3+0x3f4>
			num = (unsigned short) va_arg(args, int);
3481d458:	e6ff4074 	uxth	r4, r4
3481d45c:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481d460:	e3520000 	cmp	r2, #0
				num = (signed short) num;
3481d464:	16bf4074 	sxthne	r4, r4
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
3481d468:	1a000003 	bne	3481d47c <vsnprintf_internal.clone.3+0x400>
3481d46c:	ea000003 	b	3481d480 <vsnprintf_internal.clone.3+0x404>
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
			if (flags & SIGN)
3481d470:	e3520000 	cmp	r2, #0
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
3481d474:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481d478:	0a000000 	beq	3481d480 <vsnprintf_internal.clone.3+0x404>
				num = (signed int) num;
3481d47c:	e1a05fc4 	asr	r5, r4, #31
		}
		str = number(str, end, num, base, field_width, precision,
3481d480:	e58d3008 	str	r3, [sp, #8]
3481d484:	e1a02004 	mov	r2, r4
3481d488:	e1a03005 	mov	r3, r5
3481d48c:	e58de000 	str	lr, [sp]
3481d490:	e58dc004 	str	ip, [sp, #4]
3481d494:	e58d100c 	str	r1, [sp, #12]
3481d498:	ebfffe72 	bl	3481ce68 <number.clone.1>
3481d49c:	e1a02007 	mov	r2, r7
		size = end - buf;
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
3481d4a0:	e2866001 	add	r6, r6, #1
3481d4a4:	e5d63000 	ldrb	r3, [r6]
3481d4a8:	e3530000 	cmp	r3, #0
3481d4ac:	1afffef8 	bne	3481d094 <vsnprintf_internal.clone.3+0x18>
		ADDCH(str, '\0');
		if (str > end)
			end[-1] = '\0';
	}
#else
	*str = '\0';
3481d4b0:	e5c03000 	strb	r3, [r0]
#endif
	/* the trailing null byte doesn't count towards the total */
	return str-buf;
}
3481d4b4:	e06a0000 	rsb	r0, sl, r0
3481d4b8:	e28dd010 	add	sp, sp, #16
3481d4bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481d4c0:	34828312 	.word	0x34828312
3481d4c4:	34821fe0 	.word	0x34821fe0

3481d4c8 <simple_strtoul>:
	*buf++ = hex_asc_lo(byte);
	return buf;
}

unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
{
3481d4c8:	e92d4070 	push	{r4, r5, r6, lr}
	unsigned long result = 0,value;

	if (*cp == '0') {
3481d4cc:	e5d03000 	ldrb	r3, [r0]
3481d4d0:	e3530030 	cmp	r3, #48	; 0x30
3481d4d4:	1a00000d 	bne	3481d510 <simple_strtoul+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481d4d8:	e5f03001 	ldrb	r3, [r0, #1]!
3481d4dc:	e3530078 	cmp	r3, #120	; 0x78
3481d4e0:	1a000007 	bne	3481d504 <simple_strtoul+0x3c>
3481d4e4:	e5d0c001 	ldrb	ip, [r0, #1]
3481d4e8:	e59f4080 	ldr	r4, [pc, #128]	; 3481d570 <simple_strtoul+0xa8>
3481d4ec:	e2803001 	add	r3, r0, #1
3481d4f0:	e7d4c00c 	ldrb	ip, [r4, ip]
3481d4f4:	e31c0044 	tst	ip, #68	; 0x44
3481d4f8:	11a00003 	movne	r0, r3
			base = 16;
3481d4fc:	13a02010 	movne	r2, #16
{
	unsigned long result = 0,value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481d500:	1a000004 	bne	3481d518 <simple_strtoul+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
3481d504:	e3520000 	cmp	r2, #0
3481d508:	03a02008 	moveq	r2, #8
3481d50c:	ea000001 	b	3481d518 <simple_strtoul+0x50>
		}
	}
	if (!base) {
		base = 10;
3481d510:	e3520000 	cmp	r2, #0
3481d514:	03a0200a 	moveq	r2, #10
		}
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
3481d518:	e1a0c000 	mov	ip, r0
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481d51c:	e59f604c 	ldr	r6, [pc, #76]	; 3481d570 <simple_strtoul+0xa8>
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
		base = 10;
3481d520:	e3a00000 	mov	r0, #0
3481d524:	ea000000 	b	3481d52c <simple_strtoul+0x64>
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
3481d528:	e0203092 	mla	r0, r2, r0, r3
3481d52c:	e1a0500c 	mov	r5, ip
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481d530:	e4dc3001 	ldrb	r3, [ip], #1
3481d534:	e7d64003 	ldrb	r4, [r6, r3]
3481d538:	e3140044 	tst	r4, #68	; 0x44
3481d53c:	0a000008 	beq	3481d564 <simple_strtoul+0x9c>
3481d540:	e3140004 	tst	r4, #4
3481d544:	12433030 	subne	r3, r3, #48	; 0x30
3481d548:	1a000003 	bne	3481d55c <simple_strtoul+0x94>
3481d54c:	e3140002 	tst	r4, #2
}

static inline unsigned char __toupper(unsigned char c)
{
	if (islower(c))
		c -= 'a'-'A';
3481d550:	12433020 	subne	r3, r3, #32
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
3481d554:	16ef3073 	uxtbne	r3, r3
3481d558:	e2433037 	sub	r3, r3, #55	; 0x37
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481d55c:	e1530002 	cmp	r3, r2
3481d560:	3afffff0 	bcc	3481d528 <simple_strtoul+0x60>
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
		cp++;
	}
	if (endp)
3481d564:	e3510000 	cmp	r1, #0
		*endp = (char *)cp;
3481d568:	15815000 	strne	r5, [r1]
	return result;
}
3481d56c:	e8bd8070 	pop	{r4, r5, r6, pc}
3481d570:	34821fe0 	.word	0x34821fe0

3481d574 <strict_strtoul>:
{
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
3481d574:	e3a03000 	mov	r3, #0
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
3481d578:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
3481d57c:	e5823000 	str	r3, [r2]
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
3481d580:	e1a04000 	mov	r4, r0
3481d584:	e1a07001 	mov	r7, r1
3481d588:	e1a05002 	mov	r5, r2
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
	len = strlen(cp);
3481d58c:	ebfffc3a 	bl	3481c67c <strlen>
	if (len == 0)
3481d590:	e2506000 	subs	r6, r0, #0
3481d594:	0a000012 	beq	3481d5e4 <strict_strtoul+0x70>
		return -EINVAL;

	val = simple_strtoul(cp, &tail, base);
3481d598:	e1a00004 	mov	r0, r4
3481d59c:	e28d1004 	add	r1, sp, #4
3481d5a0:	e1a02007 	mov	r2, r7
3481d5a4:	ebffffc7 	bl	3481d4c8 <simple_strtoul>
	if (tail == cp)
3481d5a8:	e59d3004 	ldr	r3, [sp, #4]
3481d5ac:	e1530004 	cmp	r3, r4
3481d5b0:	0a00000b 	beq	3481d5e4 <strict_strtoul+0x70>
		return -EINVAL;

	if ((*tail == '\0') ||
3481d5b4:	e5d32000 	ldrb	r2, [r3]
3481d5b8:	e3520000 	cmp	r2, #0
3481d5bc:	0a000005 	beq	3481d5d8 <strict_strtoul+0x64>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
3481d5c0:	e0643003 	rsb	r3, r4, r3
3481d5c4:	e2833001 	add	r3, r3, #1

	val = simple_strtoul(cp, &tail, base);
	if (tail == cp)
		return -EINVAL;

	if ((*tail == '\0') ||
3481d5c8:	e1560003 	cmp	r6, r3
3481d5cc:	1a000004 	bne	3481d5e4 <strict_strtoul+0x70>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
3481d5d0:	e352000a 	cmp	r2, #10
3481d5d4:	1a000002 	bne	3481d5e4 <strict_strtoul+0x70>
		*res = val;
3481d5d8:	e5850000 	str	r0, [r5]
		return 0;
3481d5dc:	e3a00000 	mov	r0, #0
3481d5e0:	ea000000 	b	3481d5e8 <strict_strtoul+0x74>
	}

	return -EINVAL;
3481d5e4:	e3e00015 	mvn	r0, #21
}
3481d5e8:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481d5ec <simple_strtol>:

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
3481d5ec:	e92d4010 	push	{r4, lr}
	if(*cp=='-')
3481d5f0:	e5d0c000 	ldrb	ip, [r0]
3481d5f4:	e35c002d 	cmp	ip, #45	; 0x2d
3481d5f8:	1a000003 	bne	3481d60c <simple_strtol+0x20>
		return -simple_strtoul(cp+1,endp,base);
3481d5fc:	e2800001 	add	r0, r0, #1
3481d600:	ebffffb0 	bl	3481d4c8 <simple_strtoul>
	return simple_strtoul(cp,endp,base);
}
3481d604:	e2600000 	rsb	r0, r0, #0
3481d608:	e8bd8010 	pop	{r4, pc}
3481d60c:	e8bd4010 	pop	{r4, lr}

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
	if(*cp=='-')
		return -simple_strtoul(cp+1,endp,base);
	return simple_strtoul(cp,endp,base);
3481d610:	eaffffac 	b	3481d4c8 <simple_strtoul>

3481d614 <ustrtoul>:
}

int ustrtoul(const char *cp, char **endp, unsigned int base)
{
3481d614:	e92d4010 	push	{r4, lr}
3481d618:	e1a04001 	mov	r4, r1
	unsigned long result = simple_strtoul(cp, endp, base);
3481d61c:	ebffffa9 	bl	3481d4c8 <simple_strtoul>
	switch (**endp) {
3481d620:	e5943000 	ldr	r3, [r4]
3481d624:	e5d32000 	ldrb	r2, [r3]
3481d628:	e352004b 	cmp	r2, #75	; 0x4b
3481d62c:	0a00000a 	beq	3481d65c <ustrtoul+0x48>
3481d630:	8a000002 	bhi	3481d640 <ustrtoul+0x2c>
3481d634:	e3520047 	cmp	r2, #71	; 0x47
3481d638:	18bd8010 	popne	{r4, pc}
3481d63c:	ea000004 	b	3481d654 <ustrtoul+0x40>
3481d640:	e352004d 	cmp	r2, #77	; 0x4d
3481d644:	0a000003 	beq	3481d658 <ustrtoul+0x44>
3481d648:	e352006b 	cmp	r2, #107	; 0x6b
3481d64c:	18bd8010 	popne	{r4, pc}
3481d650:	ea000001 	b	3481d65c <ustrtoul+0x48>
	case 'G' :
		result *= 1024;
3481d654:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'M':
		result *= 1024;
3481d658:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
		if ((*endp)[1] == 'i') {
3481d65c:	e5d32001 	ldrb	r2, [r3, #1]
	case 'M':
		result *= 1024;
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
3481d660:	e1a00500 	lsl	r0, r0, #10
		if ((*endp)[1] == 'i') {
3481d664:	e3520069 	cmp	r2, #105	; 0x69
3481d668:	18bd8010 	popne	{r4, pc}
			if ((*endp)[2] == 'B')
3481d66c:	e5d31002 	ldrb	r1, [r3, #2]
3481d670:	e2832002 	add	r2, r3, #2
3481d674:	e3510042 	cmp	r1, #66	; 0x42
				(*endp) += 3;
3481d678:	02833003 	addeq	r3, r3, #3
3481d67c:	05843000 	streq	r3, [r4]
			else
				(*endp) += 2;
3481d680:	15842000 	strne	r2, [r4]
		}
	}
	return result;
}
3481d684:	e8bd8010 	pop	{r4, pc}

3481d688 <simple_strtoull>:

unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
{
3481d688:	e92d4cf0 	push	{r4, r5, r6, r7, sl, fp, lr}
	unsigned long long result = 0, value;

	if (*cp == '0') {
3481d68c:	e5d03000 	ldrb	r3, [r0]
3481d690:	e3530030 	cmp	r3, #48	; 0x30
3481d694:	1a00000d 	bne	3481d6d0 <simple_strtoull+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481d698:	e5f03001 	ldrb	r3, [r0, #1]!
3481d69c:	e3530078 	cmp	r3, #120	; 0x78
3481d6a0:	1a000007 	bne	3481d6c4 <simple_strtoull+0x3c>
3481d6a4:	e5d0c001 	ldrb	ip, [r0, #1]
3481d6a8:	e59f40a8 	ldr	r4, [pc, #168]	; 3481d758 <simple_strtoull+0xd0>
3481d6ac:	e2803001 	add	r3, r0, #1
3481d6b0:	e7d4c00c 	ldrb	ip, [r4, ip]
3481d6b4:	e31c0044 	tst	ip, #68	; 0x44
3481d6b8:	11a00003 	movne	r0, r3
			base = 16;
3481d6bc:	13a02010 	movne	r2, #16
{
	unsigned long long result = 0, value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481d6c0:	1a000004 	bne	3481d6d8 <simple_strtoull+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
3481d6c4:	e3520000 	cmp	r2, #0
3481d6c8:	03a02008 	moveq	r2, #8
3481d6cc:	ea000001 	b	3481d6d8 <simple_strtoull+0x50>
		}
	}
	if (!base) {
		base = 10;
3481d6d0:	e3520000 	cmp	r2, #0
3481d6d4:	03a0200a 	moveq	r2, #10
3481d6d8:	e3a04000 	mov	r4, #0
3481d6dc:	e3a05000 	mov	r5, #0
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481d6e0:	e59fc070 	ldr	ip, [pc, #112]	; 3481d758 <simple_strtoull+0xd0>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481d6e4:	e3a03000 	mov	r3, #0
3481d6e8:	ea000003 	b	3481d6fc <simple_strtoull+0x74>
		result = result * base + value;
3481d6ec:	e0876294 	umull	r6, r7, r4, r2
3481d6f0:	e0277592 	mla	r7, r2, r5, r7
3481d6f4:	e09a4006 	adds	r4, sl, r6
3481d6f8:	e0ab5007 	adc	r5, fp, r7
3481d6fc:	e1a07000 	mov	r7, r0
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481d700:	e4d06001 	ldrb	r6, [r0], #1
3481d704:	e7dca006 	ldrb	sl, [ip, r6]
3481d708:	e31a0044 	tst	sl, #68	; 0x44
3481d70c:	0a00000c 	beq	3481d744 <simple_strtoull+0xbc>
3481d710:	e31a0004 	tst	sl, #4
3481d714:	12466030 	subne	r6, r6, #48	; 0x30
3481d718:	1a000003 	bne	3481d72c <simple_strtoull+0xa4>
3481d71c:	e31a0002 	tst	sl, #2
3481d720:	12466020 	subne	r6, r6, #32
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481d724:	16ef6076 	uxtbne	r6, r6
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481d728:	e2466037 	sub	r6, r6, #55	; 0x37
3481d72c:	e1a0a006 	mov	sl, r6
3481d730:	e1a0bfca 	asr	fp, sl, #31
3481d734:	e153000b 	cmp	r3, fp
3481d738:	1a000001 	bne	3481d744 <simple_strtoull+0xbc>
3481d73c:	e1520006 	cmp	r2, r6
3481d740:	8affffe9 	bhi	3481d6ec <simple_strtoull+0x64>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
		result = result * base + value;
		cp++;
	}
	if (endp)
3481d744:	e3510000 	cmp	r1, #0
		*endp = (char *) cp;
3481d748:	15817000 	strne	r7, [r1]
	return result;
}
3481d74c:	e1a00004 	mov	r0, r4
3481d750:	e1a01005 	mov	r1, r5
3481d754:	e8bd8cf0 	pop	{r4, r5, r6, r7, sl, fp, pc}
3481d758:	34821fe0 	.word	0x34821fe0

3481d75c <vsprintf>:
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481d75c:	eafffe46 	b	3481d07c <vsnprintf_internal.clone.3>

3481d760 <sprintf>:
}

int sprintf(char * buf, const char *fmt, ...)
{
3481d760:	e92d000e 	push	{r1, r2, r3}
3481d764:	e92d4003 	push	{r0, r1, lr}
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481d768:	e59d100c 	ldr	r1, [sp, #12]
int sprintf(char * buf, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
3481d76c:	e28d2010 	add	r2, sp, #16
3481d770:	e58d2004 	str	r2, [sp, #4]
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481d774:	ebfffe40 	bl	3481d07c <vsnprintf_internal.clone.3>

	va_start(args, fmt);
	i=vsprintf(buf,fmt,args);
	va_end(args);
	return i;
}
3481d778:	e8bd400c 	pop	{r2, r3, lr}
3481d77c:	e28dd00c 	add	sp, sp, #12
3481d780:	e12fff1e 	bx	lr

3481d784 <panic>:

void panic(const char *fmt, ...)
{
3481d784:	e92d000f 	push	{r0, r1, r2, r3}
3481d788:	e92d4007 	push	{r0, r1, r2, lr}
	va_list	args;
	va_start(args, fmt);
	vprintf(fmt, args);
3481d78c:	e59d0010 	ldr	r0, [sp, #16]
}

void panic(const char *fmt, ...)
{
	va_list	args;
	va_start(args, fmt);
3481d790:	e28d1014 	add	r1, sp, #20
3481d794:	e58d1004 	str	r1, [sp, #4]
	vprintf(fmt, args);
3481d798:	ebffb11a 	bl	34809c08 <vprintf>
	putc('\n');
3481d79c:	e3a0000a 	mov	r0, #10
3481d7a0:	ebffb0f0 	bl	34809b68 <putc>
	va_end(args);
#if defined (CONFIG_PANIC_HANG)
	hang();
#else
	udelay (100000);	/* allow messages to go out */
3481d7a4:	e59f0018 	ldr	r0, [pc, #24]	; 3481d7c4 <panic+0x40>
3481d7a8:	ebfffd02 	bl	3481cbb8 <udelay>
	do_reset (NULL, 0, 0, NULL);
3481d7ac:	e3a00000 	mov	r0, #0
3481d7b0:	e1a01000 	mov	r1, r0
3481d7b4:	e1a02000 	mov	r2, r0
3481d7b8:	e1a03000 	mov	r3, r0
3481d7bc:	ebff929e 	bl	3480223c <do_reset>
3481d7c0:	eafffffe 	b	3481d7c0 <panic+0x3c>
3481d7c4:	000186a0 	.word	0x000186a0

3481d7c8 <__assert_fail>:
		;
}

void __assert_fail(const char *assertion, const char *file, unsigned line,
		   const char *function)
{
3481d7c8:	e92d4007 	push	{r0, r1, r2, lr}
	/* This will not return */
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
3481d7cc:	e58d0000 	str	r0, [sp]
3481d7d0:	e59f0000 	ldr	r0, [pc, #0]	; 3481d7d8 <__assert_fail+0x10>
3481d7d4:	ebffffea 	bl	3481d784 <panic>
3481d7d8:	34828319 	.word	0x34828319

3481d7dc <simple_itoa>:
	      assertion);
}

char *simple_itoa(ulong i)
{
3481d7dc:	e92d4070 	push	{r4, r5, r6, lr}
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
3481d7e0:	e59f4048 	ldr	r4, [pc, #72]	; 3481d830 <simple_itoa+0x54>
3481d7e4:	e3a03000 	mov	r3, #0
3481d7e8:	e5c43015 	strb	r3, [r4, #21]
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
	      assertion);
}

char *simple_itoa(ulong i)
{
3481d7ec:	e1a05000 	mov	r5, r0
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
3481d7f0:	e2844014 	add	r4, r4, #20
3481d7f4:	ea000000 	b	3481d7fc <simple_itoa+0x20>
	do {
		*p-- = '0' + i % 10;
3481d7f8:	e1a04006 	mov	r4, r6
3481d7fc:	e1a00005 	mov	r0, r5
3481d800:	e3a0100a 	mov	r1, #10
3481d804:	eb000a23 	bl	34820098 <__aeabi_uidivmod>
3481d808:	e1a06004 	mov	r6, r4
3481d80c:	e2811030 	add	r1, r1, #48	; 0x30
3481d810:	e4461001 	strb	r1, [r6], #-1
		i /= 10;
3481d814:	e1a00005 	mov	r0, r5
3481d818:	e3a0100a 	mov	r1, #10
3481d81c:	eb0009a2 	bl	3481feac <__udivsi3>
	} while (i > 0);
3481d820:	e2505000 	subs	r5, r0, #0
3481d824:	1afffff3 	bne	3481d7f8 <simple_itoa+0x1c>
	return p + 1;
}
3481d828:	e1a00004 	mov	r0, r4
3481d82c:	e8bd8070 	pop	{r4, r5, r6, pc}
3481d830:	3482bef0 	.word	0x3482bef0

3481d834 <zcfree>:
void  zcfree (opaque, ptr, nb)
	voidpf opaque;
	voidpf ptr;
	unsigned nb;
{
	free(ptr);
3481d834:	e1a00001 	mov	r0, r1
3481d838:	eaffb21c 	b	3480a0b0 <free>

3481d83c <zcalloc>:
	unsigned items;
	unsigned size;
{
	if (opaque)
		items += size - size; /* make compiler happy */
	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
3481d83c:	e0000291 	mul	r0, r1, r2
3481d840:	eaffb2a3 	b	3480a2d4 <malloc>

3481d844 <inflate_fast>:
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
3481d844:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
3481d848:	e5903004 	ldr	r3, [r0, #4]
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
3481d84c:	e5904000 	ldr	r4, [r0]
    last = in + (strm->avail_in - 5);
3481d850:	e2432005 	sub	r2, r3, #5
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
3481d854:	e2444001 	sub	r4, r4, #1
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
3481d858:	e24dd048 	sub	sp, sp, #72	; 0x48

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
3481d85c:	e0942002 	adds	r2, r4, r2
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
3481d860:	e590501c 	ldr	r5, [r0, #28]
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
3481d864:	e58d201c 	str	r2, [sp, #28]
3481d868:	3a000005 	bcc	3481d884 <inflate_fast+0x40>
3481d86c:	e3530005 	cmp	r3, #5
        /*
         * overflow detected, limit strm->avail_in to the
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
3481d870:	81e03004 	mvnhi	r3, r4
3481d874:	85803004 	strhi	r3, [r0, #4]
        last = in + (strm->avail_in - 5);
3481d878:	82433005 	subhi	r3, r3, #5
3481d87c:	80843003 	addhi	r3, r4, r3
3481d880:	858d301c 	strhi	r3, [sp, #28]
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
3481d884:	e595602c 	ldr	r6, [r5, #44]	; 0x2c
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
3481d888:	e595c050 	ldr	ip, [r5, #80]	; 0x50
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
3481d88c:	e58d6038 	str	r6, [sp, #56]	; 0x38
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
3481d890:	e5956054 	ldr	r6, [r5, #84]	; 0x54
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
3481d894:	e58dc024 	str	ip, [sp, #36]	; 0x24
    lmask = (1U << state->lenbits) - 1;
3481d898:	e3a0c001 	mov	ip, #1
3481d89c:	e1a0661c 	lsl	r6, ip, r6
3481d8a0:	e2466001 	sub	r6, r6, #1
3481d8a4:	e58d603c 	str	r6, [sp, #60]	; 0x3c
    dmask = (1U << state->distbits) - 1;
3481d8a8:	e5956058 	ldr	r6, [r5, #88]	; 0x58
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481d8ac:	e5902010 	ldr	r2, [r0, #16]
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481d8b0:	e1a0661c 	lsl	r6, ip, r6
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
3481d8b4:	e590300c 	ldr	r3, [r0, #12]
    beg = out - (start - strm->avail_out);
3481d8b8:	e0611002 	rsb	r1, r1, r2
    end = out + (strm->avail_out - 257);
3481d8bc:	e2422c01 	sub	r2, r2, #256	; 0x100
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
3481d8c0:	e2433001 	sub	r3, r3, #1
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
3481d8c4:	e2422001 	sub	r2, r2, #1
3481d8c8:	e0832002 	add	r2, r3, r2
3481d8cc:	e58d2028 	str	r2, [sp, #40]	; 0x28
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481d8d0:	e5952028 	ldr	r2, [r5, #40]	; 0x28
    whave = state->whave;
    write = state->write;
    window = state->window;
3481d8d4:	e5959034 	ldr	r9, [r5, #52]	; 0x34
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481d8d8:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481d8dc:	e2466001 	sub	r6, r6, #1
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
3481d8e0:	e5957030 	ldr	r7, [r5, #48]	; 0x30
    window = state->window;
3481d8e4:	e58d9030 	str	r9, [sp, #48]	; 0x30
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481d8e8:	e58d6040 	str	r6, [sp, #64]	; 0x40
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481d8ec:	e2496001 	sub	r6, r9, #1
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d8f0:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481d8f4:	e0831001 	add	r1, r3, r1
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
3481d8f8:	e595a04c 	ldr	sl, [r5, #76]	; 0x4c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481d8fc:	e58d1034 	str	r1, [sp, #52]	; 0x34
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d900:	e0879009 	add	r9, r7, r9
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
3481d904:	e5951038 	ldr	r1, [r5, #56]	; 0x38
    bits = state->bits;
3481d908:	e595203c 	ldr	r2, [r5, #60]	; 0x3c
    lcode = state->lencode;
3481d90c:	e58da020 	str	sl, [sp, #32]
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481d910:	e58d600c 	str	r6, [sp, #12]
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d914:	e58d9044 	str	r9, [sp, #68]	; 0x44
3481d918:	e58d5010 	str	r5, [sp, #16]
3481d91c:	e58d0014 	str	r0, [sp, #20]
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
3481d920:	e352000e 	cmp	r2, #14
3481d924:	8a000007 	bhi	3481d948 <inflate_fast+0x104>
            hold += (unsigned long)(PUP(in)) << bits;
3481d928:	e5d4c001 	ldrb	ip, [r4, #1]
3481d92c:	e2840001 	add	r0, r4, #1
3481d930:	e081121c 	add	r1, r1, ip, lsl r2
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
3481d934:	e2804001 	add	r4, r0, #1
3481d938:	e5d00001 	ldrb	r0, [r0, #1]
    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
3481d93c:	e2822008 	add	r2, r2, #8
            hold += (unsigned long)(PUP(in)) << bits;
3481d940:	e0811210 	add	r1, r1, r0, lsl r2
            bits += 8;
3481d944:	e2822008 	add	r2, r2, #8
        }
        this = lcode[hold & lmask];
3481d948:	e59da03c 	ldr	sl, [sp, #60]	; 0x3c
3481d94c:	e59d5020 	ldr	r5, [sp, #32]
3481d950:	e001000a 	and	r0, r1, sl
3481d954:	e085c100 	add	ip, r5, r0, lsl #2
3481d958:	e7d56100 	ldrb	r6, [r5, r0, lsl #2]
3481d95c:	e5dc0001 	ldrb	r0, [ip, #1]
3481d960:	e1dcc0b2 	ldrh	ip, [ip, #2]
3481d964:	e1a0a005 	mov	sl, r5
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
3481d968:	e3560000 	cmp	r6, #0
            bits += 8;
        }
        this = lcode[hold & lmask];
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
3481d96c:	e1a01031 	lsr	r1, r1, r0
        bits -= op;
3481d970:	e0602002 	rsb	r2, r0, r2
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
3481d974:	05e3c001 	strbeq	ip, [r3, #1]!
3481d978:	0a0000ed 	beq	3481dd34 <inflate_fast+0x4f0>
        }
        else if (op & 16) {                     /* length base */
3481d97c:	e3160010 	tst	r6, #16
3481d980:	0a0000d8 	beq	3481dce8 <inflate_fast+0x4a4>
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
3481d984:	e216600f 	ands	r6, r6, #15
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
3481d988:	e1a0000c 	mov	r0, ip
            op &= 15;                           /* number of extra bits */
            if (op) {
3481d98c:	0a00000a 	beq	3481d9bc <inflate_fast+0x178>
                if (bits < op) {
3481d990:	e1520006 	cmp	r2, r6
                    hold += (unsigned long)(PUP(in)) << bits;
3481d994:	35f40001 	ldrbcc	r0, [r4, #1]!
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481d998:	e3a09001 	mov	r9, #1
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
3481d99c:	30811210 	addcc	r1, r1, r0, lsl r2
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481d9a0:	e1a00619 	lsl	r0, r9, r6
3481d9a4:	e2400001 	sub	r0, r0, #1
3481d9a8:	e0010000 	and	r0, r1, r0
                hold >>= op;
3481d9ac:	e1a01631 	lsr	r1, r1, r6
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
3481d9b0:	32822008 	addcc	r2, r2, #8
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481d9b4:	e08c0000 	add	r0, ip, r0
                hold >>= op;
                bits -= op;
3481d9b8:	e0662002 	rsb	r2, r6, r2
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
3481d9bc:	e352000e 	cmp	r2, #14
3481d9c0:	8a000007 	bhi	3481d9e4 <inflate_fast+0x1a0>
                hold += (unsigned long)(PUP(in)) << bits;
3481d9c4:	e284c001 	add	ip, r4, #1
3481d9c8:	e5d44001 	ldrb	r4, [r4, #1]
3481d9cc:	e0811214 	add	r1, r1, r4, lsl r2
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
3481d9d0:	e28c4001 	add	r4, ip, #1
3481d9d4:	e5dcc001 	ldrb	ip, [ip, #1]
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
3481d9d8:	e2822008 	add	r2, r2, #8
                hold += (unsigned long)(PUP(in)) << bits;
3481d9dc:	e081121c 	add	r1, r1, ip, lsl r2
                bits += 8;
3481d9e0:	e2822008 	add	r2, r2, #8
            }
            this = dcode[hold & dmask];
3481d9e4:	e59da040 	ldr	sl, [sp, #64]	; 0x40
3481d9e8:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
3481d9ec:	e001c00a 	and	ip, r1, sl
3481d9f0:	e085610c 	add	r6, r5, ip, lsl #2
3481d9f4:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
3481d9f8:	e7d5c10c 	ldrb	ip, [r5, ip, lsl #2]
3481d9fc:	e5d65001 	ldrb	r5, [r6, #1]
3481da00:	e1d660b2 	ldrh	r6, [r6, #2]
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481da04:	e31c0010 	tst	ip, #16
                bits += 8;
            }
            this = dcode[hold & dmask];
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
3481da08:	e1a01531 	lsr	r1, r1, r5
            bits -= op;
3481da0c:	e0652002 	rsb	r2, r5, r2
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481da10:	0a0000a1 	beq	3481dc9c <inflate_fast+0x458>
                dist = (unsigned)(this.val);
                op &= 15;                       /* number of extra bits */
3481da14:	e20cc00f 	and	ip, ip, #15
                if (bits < op) {
3481da18:	e152000c 	cmp	r2, ip
3481da1c:	2a000006 	bcs	3481da3c <inflate_fast+0x1f8>
                    hold += (unsigned long)(PUP(in)) << bits;
3481da20:	e5f45001 	ldrb	r5, [r4, #1]!
3481da24:	e0811215 	add	r1, r1, r5, lsl r2
                    bits += 8;
3481da28:	e2822008 	add	r2, r2, #8
                    if (bits < op) {
3481da2c:	e152000c 	cmp	r2, ip
                        hold += (unsigned long)(PUP(in)) << bits;
3481da30:	35f45001 	ldrbcc	r5, [r4, #1]!
3481da34:	30811215 	addcc	r1, r1, r5, lsl r2
                        bits += 8;
3481da38:	32822008 	addcc	r2, r2, #8
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481da3c:	e3a09001 	mov	r9, #1
3481da40:	e1a05c19 	lsl	r5, r9, ip
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481da44:	e59da034 	ldr	sl, [sp, #52]	; 0x34
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481da48:	e2455001 	sub	r5, r5, #1
3481da4c:	e0015005 	and	r5, r1, r5
3481da50:	e0855006 	add	r5, r5, r6
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
3481da54:	e1a01c31 	lsr	r1, r1, ip
                bits -= op;
3481da58:	e06c2002 	rsb	r2, ip, r2
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481da5c:	e06ac003 	rsb	ip, sl, r3
                if (dist > op) {                /* see if copy from window */
3481da60:	e155000c 	cmp	r5, ip
3481da64:	9a000062 	bls	3481dbf4 <inflate_fast+0x3b0>
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
3481da68:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
3481da6c:	e06cc005 	rsb	ip, ip, r5
                    if (op > whave) {
3481da70:	e15c0006 	cmp	ip, r6
3481da74:	859d5010 	ldrhi	r5, [sp, #16]
3481da78:	859d0014 	ldrhi	r0, [sp, #20]
                        strm->msg = (char *)"invalid distance too far back";
3481da7c:	859fc328 	ldrhi	ip, [pc, #808]	; 3481ddac <inflate_fast+0x568>
3481da80:	8a000094 	bhi	3481dcd8 <inflate_fast+0x494>
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
3481da84:	e3570000 	cmp	r7, #0
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481da88:	e59da00c 	ldr	sl, [sp, #12]
                    if (write == 0) {           /* very common case */
3481da8c:	1a000010 	bne	3481dad4 <inflate_fast+0x290>
                        from += wsize - op;
3481da90:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
3481da94:	e59d600c 	ldr	r6, [sp, #12]
3481da98:	e06ca009 	rsb	sl, ip, r9
                        if (op < len) {         /* some from window */
3481da9c:	e15c0000 	cmp	ip, r0
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
3481daa0:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481daa4:	2a000008 	bcs	3481dacc <inflate_fast+0x288>
                            len -= op;
3481daa8:	e06c0000 	rsb	r0, ip, r0
3481daac:	e1a06003 	mov	r6, r3
3481dab0:	e1a0b00c 	mov	fp, ip
3481dab4:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481dab8:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481dabc:	e25bb001 	subs	fp, fp, #1
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481dac0:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481dac4:	1afffffb 	bne	3481dab8 <inflate_fast+0x274>
3481dac8:	ea000033 	b	3481db9c <inflate_fast+0x358>
                            from = out - dist;  /* rest from output */
3481dacc:	e1a0c003 	mov	ip, r3
3481dad0:	ea00003b 	b	3481dbc4 <inflate_fast+0x380>
                        }
                    }
                    else if (write < op) {      /* wrap around window */
3481dad4:	e157000c 	cmp	r7, ip
3481dad8:	2a000022 	bcs	3481db68 <inflate_fast+0x324>
                        from += wsize + write - op;
3481dadc:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
3481dae0:	e59d600c 	ldr	r6, [sp, #12]
3481dae4:	e06cb009 	rsb	fp, ip, r9
                        op -= write;
3481dae8:	e067c00c 	rsb	ip, r7, ip
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481daec:	e086b00b 	add	fp, r6, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481daf0:	e15c0000 	cmp	ip, r0
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481daf4:	21a0a00b 	movcs	sl, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481daf8:	2afffff3 	bcs	3481dacc <inflate_fast+0x288>
                            len -= op;
3481dafc:	e06c0000 	rsb	r0, ip, r0
3481db00:	e58d3018 	str	r3, [sp, #24]
3481db04:	e1a0600c 	mov	r6, ip
3481db08:	e1a09004 	mov	r9, r4
3481db0c:	e58d3004 	str	r3, [sp, #4]
                            do {
                                PUP(out) = PUP(from);
3481db10:	e5fb4001 	ldrb	r4, [fp, #1]!
3481db14:	e59d3018 	ldr	r3, [sp, #24]
                            } while (--op);
3481db18:	e2566001 	subs	r6, r6, #1
                        from += wsize + write - op;
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481db1c:	e5e34001 	strb	r4, [r3, #1]!
3481db20:	e58d3018 	str	r3, [sp, #24]
                            } while (--op);
3481db24:	1afffff9 	bne	3481db10 <inflate_fast+0x2cc>
3481db28:	e59d3004 	ldr	r3, [sp, #4]
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481db2c:	e1570000 	cmp	r7, r0
3481db30:	e1a04009 	mov	r4, r9
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
3481db34:	e083300c 	add	r3, r3, ip
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481db38:	2affffe3 	bcs	3481dacc <inflate_fast+0x288>
                                op = write;
                                len -= op;
3481db3c:	e0670000 	rsb	r0, r7, r0
3481db40:	e1a0c003 	mov	ip, r3
                                do {
                                    PUP(out) = PUP(from);
3481db44:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
3481db48:	e7d9a006 	ldrb	sl, [r9, r6]
3481db4c:	e2866001 	add	r6, r6, #1
                                } while (--op);
3481db50:	e1570006 	cmp	r7, r6
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
                                op = write;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
3481db54:	e5eca001 	strb	sl, [ip, #1]!
                                } while (--op);
3481db58:	1afffff9 	bne	3481db44 <inflate_fast+0x300>
3481db5c:	e0833007 	add	r3, r3, r7
                                from = out - dist;      /* rest from output */
3481db60:	e065a003 	rsb	sl, r5, r3
3481db64:	eaffffd8 	b	3481dacc <inflate_fast+0x288>
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481db68:	e59d600c 	ldr	r6, [sp, #12]
3481db6c:	e06ca007 	rsb	sl, ip, r7
                        if (op < len) {         /* some from window */
3481db70:	e15c0000 	cmp	ip, r0
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481db74:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481db78:	2affffd3 	bcs	3481dacc <inflate_fast+0x288>
                            len -= op;
3481db7c:	e06c0000 	rsb	r0, ip, r0
3481db80:	e1a06003 	mov	r6, r3
3481db84:	e1a0b00c 	mov	fp, ip
3481db88:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481db8c:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481db90:	e25bb001 	subs	fp, fp, #1
                    else {                      /* contiguous in window */
                        from += write - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481db94:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481db98:	1afffffb 	bne	3481db8c <inflate_fast+0x348>
3481db9c:	e1a04009 	mov	r4, r9
3481dba0:	e083300c 	add	r3, r3, ip
3481dba4:	eaffffed 	b	3481db60 <inflate_fast+0x31c>
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481dba8:	e5da3001 	ldrb	r3, [sl, #1]
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481dbac:	e2400003 	sub	r0, r0, #3
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481dbb0:	e5cc3001 	strb	r3, [ip, #1]
                        PUP(out) = PUP(from);
3481dbb4:	e5da3002 	ldrb	r3, [sl, #2]
3481dbb8:	e5cc3002 	strb	r3, [ip, #2]
                        PUP(out) = PUP(from);
3481dbbc:	e5fa3003 	ldrb	r3, [sl, #3]!
3481dbc0:	e5ec3003 	strb	r3, [ip, #3]!
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481dbc4:	e3500002 	cmp	r0, #2
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481dbc8:	e1a0300c 	mov	r3, ip
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481dbcc:	8afffff5 	bhi	3481dba8 <inflate_fast+0x364>
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
3481dbd0:	e3500000 	cmp	r0, #0
3481dbd4:	0a000056 	beq	3481dd34 <inflate_fast+0x4f0>
                        PUP(out) = PUP(from);
3481dbd8:	e5da5001 	ldrb	r5, [sl, #1]
3481dbdc:	e28ac001 	add	ip, sl, #1
3481dbe0:	e5e35001 	strb	r5, [r3, #1]!
                        if (len > 1)
3481dbe4:	e3500002 	cmp	r0, #2
                            PUP(out) = PUP(from);
3481dbe8:	05dc0001 	ldrbeq	r0, [ip, #1]
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
3481dbec:	0a000028 	beq	3481dc94 <inflate_fast+0x450>
3481dbf0:	ea00004f 	b	3481dd34 <inflate_fast+0x4f0>
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
3481dbf4:	e3130001 	tst	r3, #1
                }
                else {
		    unsigned short *sout;
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
3481dbf8:	e0656003 	rsb	r6, r5, r3
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481dbfc:	05f6c001 	ldrbeq	ip, [r6, #1]!
			len--;
3481dc00:	02400001 	subeq	r0, r0, #1

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481dc04:	05e3c001 	strbeq	ip, [r3, #1]!
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
3481dc08:	e3550002 	cmp	r5, #2
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
3481dc0c:	e243c001 	sub	ip, r3, #1
		    if (dist > 2 ) {
3481dc10:	9a000010 	bls	3481dc58 <inflate_fast+0x414>
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481dc14:	e2469001 	sub	r9, r6, #1
			loops = len >> 1;
3481dc18:	e1a030a0 	lsr	r3, r0, #1
3481dc1c:	e1a05006 	mov	r5, r6
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481dc20:	e58d9018 	str	r9, [sp, #24]
			loops = len >> 1;
3481dc24:	e1a0a00c 	mov	sl, ip
3481dc28:	e1a06003 	mov	r6, r3

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
3481dc2c:	e5d5b002 	ldrb	fp, [r5, #2]
3481dc30:	e5d59001 	ldrb	r9, [r5, #1]
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481dc34:	e2566001 	subs	r6, r6, #1
3481dc38:	e189940b 	orr	r9, r9, fp, lsl #8
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
3481dc3c:	e1ea90b2 	strh	r9, [sl, #2]!
			while (--loops);
3481dc40:	e2855002 	add	r5, r5, #2
3481dc44:	1afffff8 	bne	3481dc2c <inflate_fast+0x3e8>
    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void inflate_fast(strm, start)
3481dc48:	e59da018 	ldr	sl, [sp, #24]
3481dc4c:	e08a6083 	add	r6, sl, r3, lsl #1

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481dc50:	e2866001 	add	r6, r6, #1
3481dc54:	ea000009 	b	3481dc80 <inflate_fast+0x43c>
			out = (unsigned char *)sout + OFF;
			from = (unsigned char *)sfrom + OFF;
		    } else { /* dist == 1 or dist == 2 */
			unsigned short pat16;

			pat16 = *(sout-2+2*OFF);
3481dc58:	e153a0b1 	ldrh	sl, [r3, #-1]
			if (dist == 1)
3481dc5c:	e3550001 	cmp	r5, #1
#if defined(__BIG_ENDIAN)
			    pat16 = (pat16 & 0xff) | ((pat16 & 0xff ) << 8);
#elif defined(__LITTLE_ENDIAN)
			    pat16 = (pat16 & 0xff00) | ((pat16 & 0xff00 ) >> 8);
3481dc60:	03ca30ff 	biceq	r3, sl, #255	; 0xff
3481dc64:	0183a42a 	orreq	sl, r3, sl, lsr #8
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
3481dc68:	e1a030a0 	lsr	r3, r0, #1
3481dc6c:	e1a0900c 	mov	r9, ip
3481dc70:	e1a05003 	mov	r5, r3
			do
			    PUP(sout) = pat16;
			while (--loops);
3481dc74:	e2555001 	subs	r5, r5, #1
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
3481dc78:	e1e9a0b2 	strh	sl, [r9, #2]!
			while (--loops);
3481dc7c:	1afffffc 	bne	3481dc74 <inflate_fast+0x430>
			out = (unsigned char *)sout + OFF;
3481dc80:	e08c3083 	add	r3, ip, r3, lsl #1
		    }
		    if (len & 1)
3481dc84:	e3100001 	tst	r0, #1
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
			while (--loops);
			out = (unsigned char *)sout + OFF;
3481dc88:	e2833001 	add	r3, r3, #1
		    }
		    if (len & 1)
3481dc8c:	0a000028 	beq	3481dd34 <inflate_fast+0x4f0>
			PUP(out) = PUP(from);
3481dc90:	e5d60001 	ldrb	r0, [r6, #1]
3481dc94:	e5e30001 	strb	r0, [r3, #1]!
3481dc98:	ea000025 	b	3481dd34 <inflate_fast+0x4f0>
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
3481dc9c:	e31c0040 	tst	ip, #64	; 0x40
3481dca0:	1a000009 	bne	3481dccc <inflate_fast+0x488>
                this = dcode[this.val + (hold & ((1U << op) - 1))];
3481dca4:	e3a05001 	mov	r5, #1
3481dca8:	e1a0cc15 	lsl	ip, r5, ip
3481dcac:	e24cc001 	sub	ip, ip, #1
3481dcb0:	e00cc001 	and	ip, ip, r1
3481dcb4:	e08c6006 	add	r6, ip, r6
3481dcb8:	e089a106 	add	sl, r9, r6, lsl #2
3481dcbc:	e7d9c106 	ldrb	ip, [r9, r6, lsl #2]
3481dcc0:	e5da5001 	ldrb	r5, [sl, #1]
3481dcc4:	e1da60b2 	ldrh	r6, [sl, #2]
                goto dodist;
3481dcc8:	eaffff4d 	b	3481da04 <inflate_fast+0x1c0>
3481dccc:	e59d5010 	ldr	r5, [sp, #16]
3481dcd0:	e59d0014 	ldr	r0, [sp, #20]
            }
            else {
                strm->msg = (char *)"invalid distance code";
3481dcd4:	e59fc0d4 	ldr	ip, [pc, #212]	; 3481ddb0 <inflate_fast+0x56c>
3481dcd8:	e580c018 	str	ip, [r0, #24]
                state->mode = BAD;
3481dcdc:	e3a0c01b 	mov	ip, #27
3481dce0:	e585c000 	str	ip, [r5]
                break;
3481dce4:	ea000019 	b	3481dd50 <inflate_fast+0x50c>
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
3481dce8:	e3160040 	tst	r6, #64	; 0x40
3481dcec:	1a000009 	bne	3481dd18 <inflate_fast+0x4d4>
            this = lcode[this.val + (hold & ((1U << op) - 1))];
3481dcf0:	e3a09001 	mov	r9, #1
3481dcf4:	e1a06619 	lsl	r6, r9, r6
3481dcf8:	e2466001 	sub	r6, r6, #1
3481dcfc:	e0066001 	and	r6, r6, r1
3481dd00:	e086c00c 	add	ip, r6, ip
3481dd04:	e08a510c 	add	r5, sl, ip, lsl #2
3481dd08:	e7da610c 	ldrb	r6, [sl, ip, lsl #2]
3481dd0c:	e5d50001 	ldrb	r0, [r5, #1]
3481dd10:	e1d5c0b2 	ldrh	ip, [r5, #2]
            goto dolen;
3481dd14:	eaffff13 	b	3481d968 <inflate_fast+0x124>
        }
        else if (op & 32) {                     /* end-of-block */
3481dd18:	e3160020 	tst	r6, #32
3481dd1c:	e59d5010 	ldr	r5, [sp, #16]
3481dd20:	e59d0014 	ldr	r0, [sp, #20]
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
3481dd24:	13a0c00b 	movne	ip, #11
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
3481dd28:	059fc084 	ldreq	ip, [pc, #132]	; 3481ddb4 <inflate_fast+0x570>
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            this = lcode[this.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
3481dd2c:	0affffe9 	beq	3481dcd8 <inflate_fast+0x494>
3481dd30:	eaffffea 	b	3481dce0 <inflate_fast+0x49c>
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);
3481dd34:	e59da028 	ldr	sl, [sp, #40]	; 0x28
3481dd38:	e59dc01c 	ldr	ip, [sp, #28]
3481dd3c:	e153000a 	cmp	r3, sl
3481dd40:	3154000c 	cmpcc	r4, ip
3481dd44:	3afffef5 	bcc	3481d920 <inflate_fast+0xdc>
3481dd48:	e59d5010 	ldr	r5, [sp, #16]
3481dd4c:	e59d0014 	ldr	r0, [sp, #20]

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
3481dd50:	e1a0c1a2 	lsr	ip, r2, #3
    in -= len;
3481dd54:	e06c4004 	rsb	r4, ip, r4
    bits -= len << 3;
3481dd58:	e1a0c18c 	lsl	ip, ip, #3
3481dd5c:	e06c2002 	rsb	r2, ip, r2
    hold &= (1U << bits) - 1;
3481dd60:	e3e0c000 	mvn	ip, #0
3481dd64:	e1c1121c 	bic	r1, r1, ip, lsl r2
3481dd68:	e59d601c 	ldr	r6, [sp, #28]

    /* update state and return */
    strm->next_in = in + OFF;
3481dd6c:	e284c001 	add	ip, r4, #1
3481dd70:	e580c000 	str	ip, [r0]
3481dd74:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
    strm->next_out = out + OFF;
3481dd78:	e283c001 	add	ip, r3, #1
3481dd7c:	e580c00c 	str	ip, [r0, #12]
3481dd80:	e286c005 	add	ip, r6, #5
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481dd84:	e064400c 	rsb	r4, r4, ip
3481dd88:	e289cc01 	add	ip, r9, #256	; 0x100
3481dd8c:	e28cc001 	add	ip, ip, #1
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
3481dd90:	e063300c 	rsb	r3, r3, ip
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481dd94:	e5804004 	str	r4, [r0, #4]
    strm->avail_out = (unsigned)(out < end ?
3481dd98:	e5803010 	str	r3, [r0, #16]
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
3481dd9c:	e5851038 	str	r1, [r5, #56]	; 0x38
    state->bits = bits;
3481dda0:	e585203c 	str	r2, [r5, #60]	; 0x3c
    return;
}
3481dda4:	e28dd048 	add	sp, sp, #72	; 0x48
3481dda8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481ddac:	3482833b 	.word	0x3482833b
3481ddb0:	34828359 	.word	0x34828359
3481ddb4:	3482836f 	.word	0x3482836f

3481ddb8 <inflate_table>:
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481ddb8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481ddbc:	e24dd088 	sub	sp, sp, #136	; 0x88
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481ddc0:	e28d4068 	add	r4, sp, #104	; 0x68
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481ddc4:	e58d1030 	str	r1, [sp, #48]	; 0x30
3481ddc8:	e59d10ac 	ldr	r1, [sp, #172]	; 0xac
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481ddcc:	e28dc066 	add	ip, sp, #102	; 0x66
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481ddd0:	e1a05004 	mov	r5, r4
3481ddd4:	e284701e 	add	r7, r4, #30
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
3481ddd8:	e3a06000 	mov	r6, #0
3481dddc:	e1ec60b2 	strh	r6, [ip, #2]!
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
3481dde0:	e15c0007 	cmp	ip, r7
3481dde4:	1afffffb 	bne	3481ddd8 <inflate_table+0x20>
3481dde8:	e59db030 	ldr	fp, [sp, #48]	; 0x30
3481ddec:	e3a0c000 	mov	ip, #0
3481ddf0:	e1a0600b 	mov	r6, fp
3481ddf4:	ea000006 	b	3481de14 <inflate_table+0x5c>
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;
3481ddf8:	e0d690b2 	ldrh	r9, [r6], #2
3481ddfc:	e28da088 	add	sl, sp, #136	; 0x88
3481de00:	e08a9089 	add	r9, sl, r9, lsl #1
3481de04:	e159a2b0 	ldrh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481de08:	e28cc001 	add	ip, ip, #1
        count[lens[sym]]++;
3481de0c:	e28aa001 	add	sl, sl, #1
3481de10:	e149a2b0 	strh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481de14:	e15c0002 	cmp	ip, r2
3481de18:	3afffff6 	bcc	3481ddf8 <inflate_table+0x40>
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
3481de1c:	e59d60a8 	ldr	r6, [sp, #168]	; 0xa8
3481de20:	e28da088 	add	sl, sp, #136	; 0x88
3481de24:	e596c000 	ldr	ip, [r6]
    for (max = MAXBITS; max >= 1; max--)
3481de28:	e3a0600f 	mov	r6, #15
        if (count[max] != 0) break;
3481de2c:	e17a90b2 	ldrh	r9, [sl, #-2]!
3481de30:	e3590000 	cmp	r9, #0
3481de34:	0a000004 	beq	3481de4c <inflate_table+0x94>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
3481de38:	e3560000 	cmp	r6, #0
3481de3c:	11a0a004 	movne	sl, r4
3481de40:	13a04001 	movne	r4, #1
3481de44:	1a000013 	bne	3481de98 <inflate_table+0xe0>
3481de48:	ea000001 	b	3481de54 <inflate_table+0x9c>
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
3481de4c:	e2566001 	subs	r6, r6, #1
3481de50:	1afffff5 	bne	3481de2c <inflate_table+0x74>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481de54:	e5932000 	ldr	r2, [r3]
3481de58:	e3a01001 	mov	r1, #1
3481de5c:	e2820004 	add	r0, r2, #4
3481de60:	e3a0c040 	mov	ip, #64	; 0x40
3481de64:	e5c21001 	strb	r1, [r2, #1]
3481de68:	e5c2c000 	strb	ip, [r2]
3481de6c:	e5c01001 	strb	r1, [r0, #1]
3481de70:	e5c2c004 	strb	ip, [r2, #4]
3481de74:	e3a07000 	mov	r7, #0
        *(*table)++ = this;
        *bits = 1;
3481de78:	e59d90a8 	ldr	r9, [sp, #168]	; 0xa8
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481de7c:	e1c270b2 	strh	r7, [r2, #2]
3481de80:	e1c070b2 	strh	r7, [r0, #2]
        *(*table)++ = this;
3481de84:	e2800004 	add	r0, r0, #4
3481de88:	e5830000 	str	r0, [r3]
        *bits = 1;
3481de8c:	e5891000 	str	r1, [r9]
        return 0;     /* no symbols, but wait for decoding to report error */
3481de90:	e3a00000 	mov	r0, #0
3481de94:	ea00011e 	b	3481e314 <inflate_table+0x55c>
    }
    for (min = 1; min <= MAXBITS; min++)
        if (count[min] != 0) break;
3481de98:	e1fa90b2 	ldrh	r9, [sl, #2]!
3481de9c:	e3590000 	cmp	r9, #0
3481dea0:	1a000004 	bne	3481deb8 <inflate_table+0x100>
        *(*table)++ = this;             /* make a table to force an error */
        *(*table)++ = this;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min <= MAXBITS; min++)
3481dea4:	e2844001 	add	r4, r4, #1
3481dea8:	e3540010 	cmp	r4, #16
3481deac:	1afffff9 	bne	3481de98 <inflate_table+0xe0>
3481deb0:	e1a0c004 	mov	ip, r4
3481deb4:	ea000003 	b	3481dec8 <inflate_table+0x110>
3481deb8:	e156000c 	cmp	r6, ip
3481debc:	31a0c006 	movcc	ip, r6
        if (count[min] != 0) break;
    if (root < min) root = min;
3481dec0:	e15c0004 	cmp	ip, r4
3481dec4:	31a0c004 	movcc	ip, r4

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
3481dec8:	e3a09001 	mov	r9, #1
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
3481decc:	e1a0a089 	lsl	sl, r9, #1
        left -= count[len];
3481ded0:	e1f590b2 	ldrh	r9, [r5, #2]!
        if (left < 0) return -1;        /* over-subscribed */
3481ded4:	e05a9009 	subs	r9, sl, r9
3481ded8:	4a00010a 	bmi	3481e308 <inflate_table+0x550>
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
3481dedc:	e1550007 	cmp	r5, r7
3481dee0:	1afffff9 	bne	3481decc <inflate_table+0x114>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
3481dee4:	e3590000 	cmp	r9, #0
3481dee8:	0a000005 	beq	3481df04 <inflate_table+0x14c>
3481deec:	e2705001 	rsbs	r5, r0, #1
3481def0:	33a05000 	movcc	r5, #0
3481def4:	e3560001 	cmp	r6, #1
3481def8:	13855001 	orrne	r5, r5, #1
3481defc:	e3550000 	cmp	r5, #0
3481df00:	1a000100 	bne	3481e308 <inflate_table+0x550>
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
3481df04:	e3a0a000 	mov	sl, #0
3481df08:	e1cda4ba 	strh	sl, [sp, #74]	; 0x4a
3481df0c:	e28d7048 	add	r7, sp, #72	; 0x48
3481df10:	e3a05000 	mov	r5, #0
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481df14:	e2855002 	add	r5, r5, #2
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];
3481df18:	e28da068 	add	sl, sp, #104	; 0x68
3481df1c:	e19a90b5 	ldrh	r9, [sl, r5]
3481df20:	e1d7a0b2 	ldrh	sl, [r7, #2]
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481df24:	e355001c 	cmp	r5, #28
        offs[len + 1] = offs[len] + count[len];
3481df28:	e089a00a 	add	sl, r9, sl
3481df2c:	e1c7a0b4 	strh	sl, [r7, #4]
3481df30:	e2877002 	add	r7, r7, #2
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481df34:	1afffff6 	bne	3481df14 <inflate_table+0x15c>
3481df38:	e3a05000 	mov	r5, #0
3481df3c:	ea00000a 	b	3481df6c <inflate_table+0x1b4>
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
3481df40:	e0db90b2 	ldrh	r9, [fp], #2
3481df44:	e3590000 	cmp	r9, #0
3481df48:	0a000006 	beq	3481df68 <inflate_table+0x1b0>
3481df4c:	e28d7088 	add	r7, sp, #136	; 0x88
3481df50:	e0879089 	add	r9, r7, r9, lsl #1
3481df54:	e15974b0 	ldrh	r7, [r9, #-64]	; 0xffffffc0
3481df58:	e1a0a087 	lsl	sl, r7, #1
3481df5c:	e2877001 	add	r7, r7, #1
3481df60:	e18150ba 	strh	r5, [r1, sl]
3481df64:	e14974b0 	strh	r7, [r9, #-64]	; 0xffffffc0
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
3481df68:	e2855001 	add	r5, r5, #1
3481df6c:	e1550002 	cmp	r5, r2
3481df70:	3afffff2 	bcc	3481df40 <inflate_table+0x188>
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
3481df74:	e3500000 	cmp	r0, #0
3481df78:	0a00000f 	beq	3481dfbc <inflate_table+0x204>
3481df7c:	e3500001 	cmp	r0, #1
3481df80:	1a000006 	bne	3481dfa0 <inflate_table+0x1e8>
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481df84:	e59fa390 	ldr	sl, [pc, #912]	; 3481e31c <inflate_table+0x564>
        end = 256;
3481df88:	e3a09c01 	mov	r9, #256	; 0x100
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481df8c:	e28a2040 	add	r2, sl, #64	; 0x40
        extra = lext;
        extra -= 257;
        end = 256;
3481df90:	e58d9020 	str	r9, [sp, #32]
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481df94:	e58da010 	str	sl, [sp, #16]
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481df98:	e58d201c 	str	r2, [sp, #28]
3481df9c:	ea00000a 	b	3481dfcc <inflate_table+0x214>
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481dfa0:	e59f7378 	ldr	r7, [pc, #888]	; 3481e320 <inflate_table+0x568>
        end = -1;
3481dfa4:	e3e05000 	mvn	r5, #0
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481dfa8:	e2879040 	add	r9, r7, #64	; 0x40
        extra = dext;
        end = -1;
3481dfac:	e58d5020 	str	r5, [sp, #32]
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481dfb0:	e58d7010 	str	r7, [sp, #16]
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481dfb4:	e58d901c 	str	r9, [sp, #28]
3481dfb8:	ea000003 	b	3481dfcc <inflate_table+0x214>

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
3481dfbc:	e3a0a013 	mov	sl, #19
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
3481dfc0:	e58d1010 	str	r1, [sp, #16]
3481dfc4:	e58d101c 	str	r1, [sp, #28]
        end = 19;
3481dfc8:	e58da020 	str	sl, [sp, #32]
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481dfcc:	e3a0a001 	mov	sl, #1
3481dfd0:	e1a02c1a 	lsl	r2, sl, ip
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481dfd4:	e150000a 	cmp	r0, sl
3481dfd8:	13a00000 	movne	r0, #0
3481dfdc:	03a00001 	moveq	r0, #1

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
3481dfe0:	e5937000 	ldr	r7, [r3]
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481dfe4:	e58d200c 	str	r2, [sp, #12]
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481dfe8:	e58d0038 	str	r0, [sp, #56]	; 0x38
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481dfec:	e2425001 	sub	r5, r2, #1

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481dff0:	e59d900c 	ldr	r9, [sp, #12]
3481dff4:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3481dff8:	e30005af 	movw	r0, #1455	; 0x5af
3481dffc:	e1590000 	cmp	r9, r0
3481e000:	93a02000 	movls	r2, #0
3481e004:	82022001 	andhi	r2, r2, #1
3481e008:	e3520000 	cmp	r2, #0
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481e00c:	e58d5034 	str	r5, [sp, #52]	; 0x34

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
        return 1;
3481e010:	11a0000a 	movne	r0, sl
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481e014:	1a0000be 	bne	3481e314 <inflate_table+0x55c>
3481e018:	e58d1018 	str	r1, [sp, #24]
3481e01c:	e3e01000 	mvn	r1, #0
3481e020:	e58d1014 	str	r1, [sp, #20]
3481e024:	e1a0500c 	mov	r5, ip
3481e028:	e1a01002 	mov	r1, r2
3481e02c:	e1a0b006 	mov	fp, r6
3481e030:	ea000000 	b	3481e038 <inflate_table+0x280>
3481e034:	e58d0014 	str	r0, [sp, #20]

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481e038:	e59d6018 	ldr	r6, [sp, #24]
3481e03c:	e59d9020 	ldr	r9, [sp, #32]
3481e040:	e0d6a0b2 	ldrh	sl, [r6], #2
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481e044:	e0610004 	rsb	r0, r1, r4
        if ((int)(work[sym]) < end) {
3481e048:	e15a0009 	cmp	sl, r9
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481e04c:	e6ef0070 	uxtb	r0, r0
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
3481e050:	b3a09000 	movlt	r9, #0
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481e054:	e58d003c 	str	r0, [sp, #60]	; 0x3c
        if ((int)(work[sym]) < end) {
3481e058:	e58d6018 	str	r6, [sp, #24]
            this.op = (unsigned char)0;
3481e05c:	b58d902c 	strlt	r9, [sp, #44]	; 0x2c

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481e060:	ba000008 	blt	3481e088 <inflate_table+0x2d0>
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481e064:	c59d0010 	ldrgt	r0, [sp, #16]
3481e068:	c1a0a08a 	lslgt	sl, sl, #1
            this.val = base[work[sym]];
3481e06c:	c59d601c 	ldrgt	r6, [sp, #28]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481e070:	c7d0000a 	ldrbgt	r0, [r0, sl]
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481e074:	d3a00060 	movle	r0, #96	; 0x60
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
3481e078:	c196a0ba 	ldrhgt	sl, [r6, sl]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481e07c:	c58d002c 	strgt	r0, [sp, #44]	; 0x2c
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
            this.val = 0;
3481e080:	d3a0a000 	movle	sl, #0
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481e084:	d58d002c 	strle	r0, [sp, #44]	; 0x2c
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
3481e088:	e3a09001 	mov	r9, #1
3481e08c:	e0616004 	rsb	r6, r1, r4
3481e090:	e1a06619 	lsl	r6, r9, r6
        fill = 1U << curr;
3481e094:	e1a00519 	lsl	r0, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481e098:	e2669000 	rsb	r9, r6, #0
3481e09c:	e58d9040 	str	r9, [sp, #64]	; 0x40
3481e0a0:	e3e09003 	mvn	r9, #3
3481e0a4:	e0090699 	mul	r9, r9, r6
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
3481e0a8:	e58d0024 	str	r0, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481e0ac:	e58d9044 	str	r9, [sp, #68]	; 0x44
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481e0b0:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481e0b4:	e0660000 	rsb	r0, r6, r0
3481e0b8:	e58d0028 	str	r0, [sp, #40]	; 0x28
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481e0bc:	e0890132 	add	r0, r9, r2, lsr r1
3481e0c0:	e0660000 	rsb	r0, r6, r0
3481e0c4:	e0870100 	add	r0, r7, r0, lsl #2
3481e0c8:	e1a0900c 	mov	r9, ip
3481e0cc:	e58d3004 	str	r3, [sp, #4]
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481e0d0:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481e0d4:	e5c0c000 	strb	ip, [r0]
3481e0d8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481e0dc:	e1c0a0b2 	strh	sl, [r0, #2]
3481e0e0:	e5c03001 	strb	r3, [r0, #1]
3481e0e4:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
3481e0e8:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3481e0ec:	e08cc003 	add	ip, ip, r3
3481e0f0:	e58dc028 	str	ip, [sp, #40]	; 0x28
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481e0f4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481e0f8:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
3481e0fc:	e080000c 	add	r0, r0, ip
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481e100:	e083c006 	add	ip, r3, r6
3481e104:	e35c0000 	cmp	ip, #0
3481e108:	1afffff0 	bne	3481e0d0 <inflate_table+0x318>

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481e10c:	e2440001 	sub	r0, r4, #1
3481e110:	e3a06001 	mov	r6, #1
3481e114:	e1a0c009 	mov	ip, r9
3481e118:	e59d3004 	ldr	r3, [sp, #4]
3481e11c:	e1a00016 	lsl	r0, r6, r0
        while (huff & incr)
3481e120:	ea000000 	b	3481e128 <inflate_table+0x370>
            incr >>= 1;
3481e124:	e1a000a0 	lsr	r0, r0, #1
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481e128:	e1100002 	tst	r0, r2
3481e12c:	1afffffc 	bne	3481e124 <inflate_table+0x36c>
            incr >>= 1;
        if (incr != 0) {
3481e130:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481e134:	12406001 	subne	r6, r0, #1
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481e138:	e28d9088 	add	r9, sp, #136	; 0x88
        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
3481e13c:	10062002 	andne	r2, r6, r2
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481e140:	e0896084 	add	r6, r9, r4, lsl #1
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
3481e144:	10822000 	addne	r2, r2, r0
        }
        else
            huff = 0;
3481e148:	01a02000 	moveq	r2, r0

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481e14c:	e15602b0 	ldrh	r0, [r6, #-32]	; 0xffffffe0
3481e150:	e2400001 	sub	r0, r0, #1
3481e154:	e6ff0070 	uxth	r0, r0
3481e158:	e3500000 	cmp	r0, #0
3481e15c:	e14602b0 	strh	r0, [r6, #-32]	; 0xffffffe0
3481e160:	1a000006 	bne	3481e180 <inflate_table+0x3c8>
            if (len == max) break;
3481e164:	e154000b 	cmp	r4, fp
3481e168:	0a000058 	beq	3481e2d0 <inflate_table+0x518>
            len = lens[work[sym]];
3481e16c:	e59da018 	ldr	sl, [sp, #24]
3481e170:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3481e174:	e1da00b0 	ldrh	r0, [sl]
3481e178:	e1a00080 	lsl	r0, r0, #1
3481e17c:	e19640b0 	ldrh	r4, [r6, r0]
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
3481e180:	e154000c 	cmp	r4, ip
3481e184:	959d0014 	ldrls	r0, [sp, #20]
3481e188:	9affffa9 	bls	3481e034 <inflate_table+0x27c>
3481e18c:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481e190:	e59da014 	ldr	sl, [sp, #20]
3481e194:	e0020009 	and	r0, r2, r9
3481e198:	e150000a 	cmp	r0, sl
3481e19c:	0affffa4 	beq	3481e034 <inflate_table+0x27c>
            /* if first time, transition to sub-tables */
            if (drop == 0)
3481e1a0:	e3510000 	cmp	r1, #0
3481e1a4:	01a0100c 	moveq	r1, ip

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
3481e1a8:	e0615004 	rsb	r5, r1, r4
            left = (int)(1 << curr);
3481e1ac:	e3a09001 	mov	r9, #1
3481e1b0:	e1a06519 	lsl	r6, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481e1b4:	e2419001 	sub	r9, r1, #1
3481e1b8:	e28da068 	add	sl, sp, #104	; 0x68
3481e1bc:	e0899005 	add	r9, r9, r5
3481e1c0:	e08a9089 	add	r9, sl, r9, lsl #1
3481e1c4:	e1a0a00c 	mov	sl, ip
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481e1c8:	ea000005 	b	3481e1e4 <inflate_table+0x42c>
                left -= count[curr + drop];
3481e1cc:	e1f9c0b2 	ldrh	ip, [r9, #2]!
3481e1d0:	e06c6006 	rsb	r6, ip, r6
                if (left <= 0) break;
3481e1d4:	e3560000 	cmp	r6, #0
3481e1d8:	da000004 	ble	3481e1f0 <inflate_table+0x438>
                curr++;
3481e1dc:	e2855001 	add	r5, r5, #1
                left <<= 1;
3481e1e0:	e1a06086 	lsl	r6, r6, #1
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481e1e4:	e085c001 	add	ip, r5, r1
3481e1e8:	e15c000b 	cmp	ip, fp
3481e1ec:	3afffff6 	bcc	3481e1cc <inflate_table+0x414>
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
3481e1f0:	e59d600c 	ldr	r6, [sp, #12]
3481e1f4:	e3a09001 	mov	r9, #1
3481e1f8:	e0866519 	add	r6, r6, r9, lsl r5
3481e1fc:	e58d600c 	str	r6, [sp, #12]
3481e200:	e1a0c00a 	mov	ip, sl
            if (type == LENS && used >= ENOUGH - MAXD)
3481e204:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
3481e208:	e59da00c 	ldr	sl, [sp, #12]
3481e20c:	e30095af 	movw	r9, #1455	; 0x5af
3481e210:	e15a0009 	cmp	sl, r9
3481e214:	93a06000 	movls	r6, #0
3481e218:	82066001 	andhi	r6, r6, #1
3481e21c:	e3560000 	cmp	r6, #0
3481e220:	1a00003a 	bne	3481e310 <inflate_table+0x558>
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481e224:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481e228:	e59da024 	ldr	sl, [sp, #36]	; 0x24
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481e22c:	e7c65100 	strb	r5, [r6, r0, lsl #2]
            (*table)[low].bits = (unsigned char)root;
3481e230:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481e234:	e087710a 	add	r7, r7, sl, lsl #2
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481e238:	e1a0a100 	lsl	sl, r0, #2
            (*table)[low].bits = (unsigned char)root;
3481e23c:	e086600a 	add	r6, r6, sl
3481e240:	e5c6c001 	strb	ip, [r6, #1]
            (*table)[low].val = (unsigned short)(next - *table);
3481e244:	e5936000 	ldr	r6, [r3]
3481e248:	e086a00a 	add	sl, r6, sl
3481e24c:	e0666007 	rsb	r6, r6, r7
3481e250:	e1a06146 	asr	r6, r6, #2
3481e254:	e1ca60b2 	strh	r6, [sl, #2]
3481e258:	eaffff75 	b	3481e034 <inflate_table+0x27c>
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
3481e25c:	e3510000 	cmp	r1, #0
3481e260:	0a000007 	beq	3481e284 <inflate_table+0x4cc>
3481e264:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481e268:	e0020009 	and	r0, r2, r9
3481e26c:	e59d9014 	ldr	r9, [sp, #20]
3481e270:	e1500009 	cmp	r0, r9
            drop = 0;
            len = root;
            next = *table;
3481e274:	15937000 	ldrne	r7, [r3]
            this.bits = (unsigned char)len;
3481e278:	11a0b00a 	movne	fp, sl
3481e27c:	11a0400c 	movne	r4, ip
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
3481e280:	13a01000 	movne	r1, #0
            next = *table;
            this.bits = (unsigned char)len;
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481e284:	e1a09132 	lsr	r9, r2, r1
3481e288:	e0870109 	add	r0, r7, r9, lsl #2
3481e28c:	e7c76109 	strb	r6, [r7, r9, lsl #2]
3481e290:	e3a09000 	mov	r9, #0
3481e294:	e5c0b001 	strb	fp, [r0, #1]
3481e298:	e1c090b2 	strh	r9, [r0, #2]

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481e29c:	e2440001 	sub	r0, r4, #1
3481e2a0:	e1a00015 	lsl	r0, r5, r0
        while (huff & incr)
3481e2a4:	ea000000 	b	3481e2ac <inflate_table+0x4f4>
            incr >>= 1;
3481e2a8:	e1a000a0 	lsr	r0, r0, #1
        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481e2ac:	e1100002 	tst	r0, r2
3481e2b0:	1afffffc 	bne	3481e2a8 <inflate_table+0x4f0>
            incr >>= 1;
        if (incr != 0) {
3481e2b4:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481e2b8:	12409001 	subne	r9, r0, #1
3481e2bc:	10092002 	andne	r2, r9, r2
            huff += incr;
3481e2c0:	10822000 	addne	r2, r2, r0
3481e2c4:	1a000005 	bne	3481e2e0 <inflate_table+0x528>
        }
        else
            huff = 0;
3481e2c8:	e1a02000 	mov	r2, r0
3481e2cc:	ea000005 	b	3481e2e8 <inflate_table+0x530>

        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481e2d0:	e59db03c 	ldr	fp, [sp, #60]	; 0x3c
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
            len = root;
            next = *table;
            this.bits = (unsigned char)len;
3481e2d4:	e6efa07c 	uxtb	sl, ip
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481e2d8:	e3a06040 	mov	r6, #64	; 0x40

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481e2dc:	e3a05001 	mov	r5, #1
       drops back to the root table to fill in any remaining entries there.
     */
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
3481e2e0:	e3520000 	cmp	r2, #0
3481e2e4:	1affffdc 	bne	3481e25c <inflate_table+0x4a4>
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481e2e8:	e5931000 	ldr	r1, [r3]
3481e2ec:	e59da00c 	ldr	sl, [sp, #12]
    *bits = root;
3481e2f0:	e59d00a8 	ldr	r0, [sp, #168]	; 0xa8
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481e2f4:	e081110a 	add	r1, r1, sl, lsl #2
3481e2f8:	e5831000 	str	r1, [r3]
    *bits = root;
3481e2fc:	e580c000 	str	ip, [r0]
    return 0;
3481e300:	e1a00002 	mov	r0, r2
3481e304:	ea000002 	b	3481e314 <inflate_table+0x55c>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */
3481e308:	e3e00000 	mvn	r0, #0
3481e30c:	ea000000 	b	3481e314 <inflate_table+0x55c>
            }

            /* check for enough space */
            used += 1U << curr;
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;
3481e310:	e3a00001 	mov	r0, #1

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}
3481e314:	e28dd088 	add	sp, sp, #136	; 0x88
3481e318:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481e31c:	34821f0e 	.word	0x34821f0e
3481e320:	34822190 	.word	0x34822190

3481e324 <inflateReset>:
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481e324:	e3500000 	cmp	r0, #0
3481e328:	03e00001 	mvneq	r0, #1
3481e32c:	012fff1e 	bxeq	lr
3481e330:	e590301c 	ldr	r3, [r0, #28]
3481e334:	e3530000 	cmp	r3, #0
3481e338:	0a000017 	beq	3481e39c <inflateReset+0x78>
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481e33c:	e3a02000 	mov	r2, #0
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481e340:	e3a01001 	mov	r1, #1
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481e344:	e583201c 	str	r2, [r3, #28]
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481e348:	e5801034 	str	r1, [r0, #52]	; 0x34
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481e34c:	e3a01902 	mov	r1, #32768	; 0x8000
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481e350:	e5802014 	str	r2, [r0, #20]
3481e354:	e5802008 	str	r2, [r0, #8]
    strm->msg = Z_NULL;
3481e358:	e5802018 	str	r2, [r0, #24]
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481e35c:	e5831014 	str	r1, [r3, #20]
    state->wsize = 0;
    state->whave = 0;
    state->write = 0;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
3481e360:	e2831e53 	add	r1, r3, #1328	; 0x530
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
3481e364:	e5832000 	str	r2, [r3]
    state->last = 0;
3481e368:	e5832004 	str	r2, [r3, #4]
    state->havedict = 0;
3481e36c:	e583200c 	str	r2, [r3, #12]
    state->dmax = 32768U;
    state->head = Z_NULL;
3481e370:	e5832020 	str	r2, [r3, #32]
    state->wsize = 0;
3481e374:	e5832028 	str	r2, [r3, #40]	; 0x28
    state->whave = 0;
3481e378:	e583202c 	str	r2, [r3, #44]	; 0x2c
    state->write = 0;
3481e37c:	e5832030 	str	r2, [r3, #48]	; 0x30
    state->hold = 0;
3481e380:	e5832038 	str	r2, [r3, #56]	; 0x38
    state->bits = 0;
3481e384:	e583203c 	str	r2, [r3, #60]	; 0x3c
    state->lencode = state->distcode = state->next = state->codes;
3481e388:	e583106c 	str	r1, [r3, #108]	; 0x6c
3481e38c:	e5831050 	str	r1, [r3, #80]	; 0x50
3481e390:	e583104c 	str	r1, [r3, #76]	; 0x4c
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
3481e394:	e1a00002 	mov	r0, r2
3481e398:	e12fff1e 	bx	lr
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481e39c:	e3e00001 	mvn	r0, #1
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}
3481e3a0:	e12fff1e 	bx	lr

3481e3a4 <inflateInit2_>:
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481e3a4:	e3520000 	cmp	r2, #0
int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
3481e3a8:	e92d4070 	push	{r4, r5, r6, lr}
3481e3ac:	e1a04000 	mov	r4, r0
3481e3b0:	e1a05001 	mov	r5, r1
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481e3b4:	0a000033 	beq	3481e488 <inflateInit2_+0xe4>
3481e3b8:	e5d22000 	ldrb	r2, [r2]
3481e3bc:	e3520031 	cmp	r2, #49	; 0x31
3481e3c0:	0353003c 	cmpeq	r3, #60	; 0x3c
3481e3c4:	03a03000 	moveq	r3, #0
3481e3c8:	13a03001 	movne	r3, #1
3481e3cc:	1a00002d 	bne	3481e488 <inflateInit2_+0xe4>
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481e3d0:	e3500000 	cmp	r0, #0
3481e3d4:	0a00002d 	beq	3481e490 <inflateInit2_+0xec>
    strm->msg = Z_NULL;                 /* in case we return an error */
3481e3d8:	e5803018 	str	r3, [r0, #24]
    if (strm->zalloc == (alloc_func)0) {
3481e3dc:	e5903020 	ldr	r3, [r0, #32]
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481e3e0:	e3a01001 	mov	r1, #1
    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
3481e3e4:	e3530000 	cmp	r3, #0
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
3481e3e8:	05803028 	streq	r3, [r0, #40]	; 0x28
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481e3ec:	059f20ac 	ldreq	r2, [pc, #172]	; 3481e4a0 <inflateInit2_+0xfc>
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481e3f0:	e5903024 	ldr	r3, [r0, #36]	; 0x24
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481e3f4:	05802020 	streq	r2, [r0, #32]
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481e3f8:	e3530000 	cmp	r3, #0
3481e3fc:	059f30a0 	ldreq	r3, [pc, #160]	; 3481e4a4 <inflateInit2_+0x100>
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481e400:	e3022530 	movw	r2, #9520	; 0x2530
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481e404:	05803024 	streq	r3, [r0, #36]	; 0x24
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481e408:	e5903020 	ldr	r3, [r0, #32]
3481e40c:	e5900028 	ldr	r0, [r0, #40]	; 0x28
3481e410:	e12fff33 	blx	r3
    if (state == Z_NULL) return Z_MEM_ERROR;
3481e414:	e2501000 	subs	r1, r0, #0
3481e418:	0a00001e 	beq	3481e498 <inflateInit2_+0xf4>
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481e41c:	e3550000 	cmp	r5, #0
        state->wrap = 0;
3481e420:	b3a03000 	movlt	r3, #0
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
3481e424:	e584101c 	str	r1, [r4, #28]
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
3481e428:	b2655000 	rsblt	r5, r5, #0
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
        state->wrap = 0;
3481e42c:	b5813008 	strlt	r3, [r1, #8]
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481e430:	ba000004 	blt	3481e448 <inflateInit2_+0xa4>
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481e434:	e1a03245 	asr	r3, r5, #4
3481e438:	e2833001 	add	r3, r3, #1
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481e43c:	e355002f 	cmp	r5, #47	; 0x2f
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481e440:	e5813008 	str	r3, [r1, #8]
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481e444:	d205500f 	andle	r5, r5, #15
#endif
    }
    if (windowBits < 8 || windowBits > 15) {
3481e448:	e2453008 	sub	r3, r5, #8
3481e44c:	e3530007 	cmp	r3, #7
3481e450:	9a000006 	bls	3481e470 <inflateInit2_+0xcc>
        ZFREE(strm, state);
3481e454:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481e458:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481e45c:	e3a02000 	mov	r2, #0
3481e460:	e12fff33 	blx	r3
        strm->state = Z_NULL;
3481e464:	e3a03000 	mov	r3, #0
3481e468:	e584301c 	str	r3, [r4, #28]
3481e46c:	ea000007 	b	3481e490 <inflateInit2_+0xec>
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
3481e470:	e3a03000 	mov	r3, #0
    return inflateReset(strm);
3481e474:	e1a00004 	mov	r0, r4
    if (windowBits < 8 || windowBits > 15) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
3481e478:	e5815024 	str	r5, [r1, #36]	; 0x24
    state->window = Z_NULL;
3481e47c:	e5813034 	str	r3, [r1, #52]	; 0x34
    return inflateReset(strm);
}
3481e480:	e8bd4070 	pop	{r4, r5, r6, lr}
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
3481e484:	eaffffa6 	b	3481e324 <inflateReset>
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
3481e488:	e3e00005 	mvn	r0, #5
3481e48c:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481e490:	e3e00001 	mvn	r0, #1
3481e494:	e8bd8070 	pop	{r4, r5, r6, pc}
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
3481e498:	e3e00003 	mvn	r0, #3
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
}
3481e49c:	e8bd8070 	pop	{r4, r5, r6, pc}
3481e4a0:	3481d83c 	.word	0x3481d83c
3481e4a4:	3481d834 	.word	0x3481d834

3481e4a8 <inflateInit_>:

int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
3481e4a8:	e1a0c001 	mov	ip, r1
3481e4ac:	e1a03002 	mov	r3, r2
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
3481e4b0:	e3a0100f 	mov	r1, #15
3481e4b4:	e1a0200c 	mov	r2, ip
3481e4b8:	eaffffb9 	b	3481e3a4 <inflateInit2_>

3481e4bc <inflateEnd>:
    return ret;
}

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
3481e4bc:	e92d4010 	push	{r4, lr}
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
3481e4c0:	e2504000 	subs	r4, r0, #0
3481e4c4:	0a000013 	beq	3481e518 <inflateEnd+0x5c>
3481e4c8:	e594201c 	ldr	r2, [r4, #28]
3481e4cc:	e3520000 	cmp	r2, #0
3481e4d0:	0a000010 	beq	3481e518 <inflateEnd+0x5c>
3481e4d4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481e4d8:	e3530000 	cmp	r3, #0
3481e4dc:	0a00000f 	beq	3481e520 <inflateEnd+0x64>
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) {
3481e4e0:	e5921034 	ldr	r1, [r2, #52]	; 0x34
3481e4e4:	e3510000 	cmp	r1, #0
3481e4e8:	0a000002 	beq	3481e4f8 <inflateEnd+0x3c>
	WATCHDOG_RESET();
	ZFREE(strm, state->window);
3481e4ec:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481e4f0:	e3a02000 	mov	r2, #0
3481e4f4:	e12fff33 	blx	r3
    }
    ZFREE(strm, strm->state);
3481e4f8:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481e4fc:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481e500:	e594101c 	ldr	r1, [r4, #28]
3481e504:	e3a02000 	mov	r2, #0
3481e508:	e12fff33 	blx	r3
    strm->state = Z_NULL;
3481e50c:	e3a00000 	mov	r0, #0
3481e510:	e584001c 	str	r0, [r4, #28]
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
3481e514:	e8bd8010 	pop	{r4, pc}
int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
3481e518:	e3e00001 	mvn	r0, #1
3481e51c:	e8bd8010 	pop	{r4, pc}
3481e520:	e3e00001 	mvn	r0, #1
    }
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}
3481e524:	e8bd8010 	pop	{r4, pc}

3481e528 <adler32>:
    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481e528:	e3520001 	cmp	r2, #1
/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
3481e52c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481e530:	e1a04001 	mov	r4, r1
3481e534:	e1a07002 	mov	r7, r2
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
3481e538:	e1a06820 	lsr	r6, r0, #16
    adler &= 0xffff;
3481e53c:	e6ff5070 	uxth	r5, r0

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481e540:	1a00000b 	bne	3481e574 <adler32+0x4c>
        adler += buf[0];
3481e544:	e5d13000 	ldrb	r3, [r1]
3481e548:	e0835005 	add	r5, r3, r5
        if (adler >= BASE)
3481e54c:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481e550:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481e554:	82455cff 	subhi	r5, r5, #65280	; 0xff00
3481e558:	824550f1 	subhi	r5, r5, #241	; 0xf1
        sum2 += adler;
3481e55c:	e0856006 	add	r6, r5, r6
        if (sum2 >= BASE)
3481e560:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481e564:	e1560003 	cmp	r6, r3
            sum2 -= BASE;
3481e568:	82466cff 	subhi	r6, r6, #65280	; 0xff00
3481e56c:	824660f1 	subhi	r6, r6, #241	; 0xf1
3481e570:	ea0000a2 	b	3481e800 <adler32+0x2d8>
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
3481e574:	e3510000 	cmp	r1, #0
3481e578:	0a0000a2 	beq	3481e808 <adler32+0x2e0>
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
3481e57c:	e352000f 	cmp	r2, #15
3481e580:	9a000004 	bls	3481e598 <adler32+0x70>
3481e584:	ea000050 	b	3481e6cc <adler32+0x1a4>
        while (len--) {
            adler += *buf++;
3481e588:	e4d43001 	ldrb	r3, [r4], #1
            sum2 += adler;
3481e58c:	e2477001 	sub	r7, r7, #1
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
3481e590:	e0855003 	add	r5, r5, r3
            sum2 += adler;
3481e594:	e0866005 	add	r6, r6, r5
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
3481e598:	e3570000 	cmp	r7, #0
3481e59c:	1afffff9 	bne	3481e588 <adler32+0x60>
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
3481e5a0:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481e5a4:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481e5a8:	82455cff 	subhi	r5, r5, #65280	; 0xff00
        MOD4(sum2);             /* only added so many BASE's */
3481e5ac:	e1a00006 	mov	r0, r6
3481e5b0:	e30f1ff1 	movw	r1, #65521	; 0xfff1
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
3481e5b4:	824550f1 	subhi	r5, r5, #241	; 0xf1
        MOD4(sum2);             /* only added so many BASE's */
3481e5b8:	eb0006b6 	bl	34820098 <__aeabi_uidivmod>
        return adler | (sum2 << 16);
3481e5bc:	e1850801 	orr	r0, r5, r1, lsl #16
3481e5c0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
3481e5c4:	e2477d56 	sub	r7, r7, #5504	; 0x1580
3481e5c8:	e2477030 	sub	r7, r7, #48	; 0x30
3481e5cc:	e1a03004 	mov	r3, r4
        n = NMAX / 16;          /* NMAX is divisible by 16 */
3481e5d0:	e300215b 	movw	r2, #347	; 0x15b
        do {
            DO16(buf);          /* 16 sums unrolled */
3481e5d4:	e5d31000 	ldrb	r1, [r3]
            buf += 16;
        } while (--n);
3481e5d8:	e2522001 	subs	r2, r2, #1
    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
3481e5dc:	e0855001 	add	r5, r5, r1
3481e5e0:	e5d31001 	ldrb	r1, [r3, #1]
3481e5e4:	e0856006 	add	r6, r5, r6
3481e5e8:	e0855001 	add	r5, r5, r1
3481e5ec:	e5d31002 	ldrb	r1, [r3, #2]
3481e5f0:	e0866005 	add	r6, r6, r5
3481e5f4:	e0855001 	add	r5, r5, r1
3481e5f8:	e5d31003 	ldrb	r1, [r3, #3]
3481e5fc:	e0866005 	add	r6, r6, r5
3481e600:	e0855001 	add	r5, r5, r1
3481e604:	e5d31004 	ldrb	r1, [r3, #4]
3481e608:	e0866005 	add	r6, r6, r5
3481e60c:	e0855001 	add	r5, r5, r1
3481e610:	e5d31005 	ldrb	r1, [r3, #5]
3481e614:	e0866005 	add	r6, r6, r5
3481e618:	e0855001 	add	r5, r5, r1
3481e61c:	e5d31006 	ldrb	r1, [r3, #6]
3481e620:	e0866005 	add	r6, r6, r5
3481e624:	e0855001 	add	r5, r5, r1
3481e628:	e5d31007 	ldrb	r1, [r3, #7]
3481e62c:	e0866005 	add	r6, r6, r5
3481e630:	e0855001 	add	r5, r5, r1
3481e634:	e5d31008 	ldrb	r1, [r3, #8]
3481e638:	e0866005 	add	r6, r6, r5
3481e63c:	e0855001 	add	r5, r5, r1
3481e640:	e5d31009 	ldrb	r1, [r3, #9]
3481e644:	e0866005 	add	r6, r6, r5
3481e648:	e0855001 	add	r5, r5, r1
3481e64c:	e5d3100a 	ldrb	r1, [r3, #10]
3481e650:	e0866005 	add	r6, r6, r5
3481e654:	e0855001 	add	r5, r5, r1
3481e658:	e5d3100b 	ldrb	r1, [r3, #11]
3481e65c:	e0866005 	add	r6, r6, r5
3481e660:	e0855001 	add	r5, r5, r1
3481e664:	e5d3100c 	ldrb	r1, [r3, #12]
3481e668:	e0866005 	add	r6, r6, r5
3481e66c:	e0855001 	add	r5, r5, r1
3481e670:	e5d3100d 	ldrb	r1, [r3, #13]
3481e674:	e0866005 	add	r6, r6, r5
3481e678:	e0855001 	add	r5, r5, r1
3481e67c:	e5d3100e 	ldrb	r1, [r3, #14]
3481e680:	e0866005 	add	r6, r6, r5
3481e684:	e0855001 	add	r5, r5, r1
3481e688:	e5d3100f 	ldrb	r1, [r3, #15]
3481e68c:	e0866005 	add	r6, r6, r5
3481e690:	e0855001 	add	r5, r5, r1
3481e694:	e0866005 	add	r6, r6, r5
            buf += 16;
3481e698:	e2833010 	add	r3, r3, #16
        } while (--n);
3481e69c:	1affffcc 	bne	3481e5d4 <adler32+0xac>
        MOD(adler);
3481e6a0:	e1a00005 	mov	r0, r5
3481e6a4:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e6a8:	eb00067a 	bl	34820098 <__aeabi_uidivmod>
        MOD(sum2);
3481e6ac:	e1a00006 	mov	r0, r6
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
3481e6b0:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481e6b4:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e6b8:	eb000676 	bl	34820098 <__aeabi_uidivmod>
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
3481e6bc:	e2844d56 	add	r4, r4, #5504	; 0x1580
3481e6c0:	e2844030 	add	r4, r4, #48	; 0x30
        MOD(adler);
        MOD(sum2);
3481e6c4:	e1a06001 	mov	r6, r1
3481e6c8:	ea000000 	b	3481e6d0 <adler32+0x1a8>
        MOD4(sum2);             /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
3481e6cc:	e301a5af 	movw	sl, #5551	; 0x15af
3481e6d0:	e157000a 	cmp	r7, sl
3481e6d4:	8affffba 	bhi	3481e5c4 <adler32+0x9c>
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
3481e6d8:	e2573000 	subs	r3, r7, #0
3481e6dc:	11a02004 	movne	r2, r4
3481e6e0:	1a000031 	bne	3481e7ac <adler32+0x284>
3481e6e4:	ea000045 	b	3481e800 <adler32+0x2d8>
        while (len >= 16) {
            len -= 16;
            DO16(buf);
3481e6e8:	e5521010 	ldrb	r1, [r2, #-16]
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
3481e6ec:	e2477010 	sub	r7, r7, #16
            DO16(buf);
3481e6f0:	e0855001 	add	r5, r5, r1
3481e6f4:	e552100f 	ldrb	r1, [r2, #-15]
3481e6f8:	e0856006 	add	r6, r5, r6
3481e6fc:	e0855001 	add	r5, r5, r1
3481e700:	e552100e 	ldrb	r1, [r2, #-14]
3481e704:	e0866005 	add	r6, r6, r5
3481e708:	e0855001 	add	r5, r5, r1
3481e70c:	e552100d 	ldrb	r1, [r2, #-13]
3481e710:	e0866005 	add	r6, r6, r5
3481e714:	e0855001 	add	r5, r5, r1
3481e718:	e552100c 	ldrb	r1, [r2, #-12]
3481e71c:	e0866005 	add	r6, r6, r5
3481e720:	e0855001 	add	r5, r5, r1
3481e724:	e552100b 	ldrb	r1, [r2, #-11]
3481e728:	e0866005 	add	r6, r6, r5
3481e72c:	e0855001 	add	r5, r5, r1
3481e730:	e552100a 	ldrb	r1, [r2, #-10]
3481e734:	e0866005 	add	r6, r6, r5
3481e738:	e0855001 	add	r5, r5, r1
3481e73c:	e5521009 	ldrb	r1, [r2, #-9]
3481e740:	e0866005 	add	r6, r6, r5
3481e744:	e0855001 	add	r5, r5, r1
3481e748:	e5521008 	ldrb	r1, [r2, #-8]
3481e74c:	e0866005 	add	r6, r6, r5
3481e750:	e0855001 	add	r5, r5, r1
3481e754:	e5521007 	ldrb	r1, [r2, #-7]
3481e758:	e0866005 	add	r6, r6, r5
3481e75c:	e0855001 	add	r5, r5, r1
3481e760:	e5521006 	ldrb	r1, [r2, #-6]
3481e764:	e0866005 	add	r6, r6, r5
3481e768:	e0855001 	add	r5, r5, r1
3481e76c:	e5521005 	ldrb	r1, [r2, #-5]
3481e770:	e0866005 	add	r6, r6, r5
3481e774:	e0855001 	add	r5, r5, r1
3481e778:	e5521004 	ldrb	r1, [r2, #-4]
3481e77c:	e0866005 	add	r6, r6, r5
3481e780:	e0855001 	add	r5, r5, r1
3481e784:	e5521003 	ldrb	r1, [r2, #-3]
3481e788:	e0866005 	add	r6, r6, r5
3481e78c:	e0855001 	add	r5, r5, r1
3481e790:	e5521002 	ldrb	r1, [r2, #-2]
3481e794:	e0866005 	add	r6, r6, r5
3481e798:	e0855001 	add	r5, r5, r1
3481e79c:	e5521001 	ldrb	r1, [r2, #-1]
3481e7a0:	e0866005 	add	r6, r6, r5
3481e7a4:	e0855001 	add	r5, r5, r1
3481e7a8:	e0866005 	add	r6, r6, r5
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481e7ac:	e357000f 	cmp	r7, #15
            len -= 16;
            DO16(buf);
3481e7b0:	e2822010 	add	r2, r2, #16
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481e7b4:	8affffcb 	bhi	3481e6e8 <adler32+0x1c0>
#  define MOD(a) a %= BASE
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
3481e7b8:	e3c3200f 	bic	r2, r3, #15
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481e7bc:	e0844002 	add	r4, r4, r2
3481e7c0:	e203300f 	and	r3, r3, #15
3481e7c4:	ea000003 	b	3481e7d8 <adler32+0x2b0>
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481e7c8:	e4d42001 	ldrb	r2, [r4], #1
            sum2 += adler;
3481e7cc:	e2433001 	sub	r3, r3, #1
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481e7d0:	e0855002 	add	r5, r5, r2
            sum2 += adler;
3481e7d4:	e0866005 	add	r6, r6, r5
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
3481e7d8:	e3530000 	cmp	r3, #0
3481e7dc:	1afffff9 	bne	3481e7c8 <adler32+0x2a0>
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481e7e0:	e1a00005 	mov	r0, r5
3481e7e4:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e7e8:	eb00062a 	bl	34820098 <__aeabi_uidivmod>
        MOD(sum2);
3481e7ec:	e1a00006 	mov	r0, r6
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481e7f0:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481e7f4:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481e7f8:	eb000626 	bl	34820098 <__aeabi_uidivmod>
3481e7fc:	e1a06001 	mov	r6, r1
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
3481e800:	e1850806 	orr	r0, r5, r6, lsl #16
3481e804:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;
3481e808:	e3a00001 	mov	r0, #1
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}
3481e80c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481e810 <inflate>:
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481e810:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481e814:	e250a000 	subs	sl, r0, #0
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481e818:	e24dd048 	sub	sp, sp, #72	; 0x48
3481e81c:	e58d103c 	str	r1, [sp, #60]	; 0x3c
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481e820:	03e01001 	mvneq	r1, #1
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481e824:	0a00058b 	beq	3481fe58 <inflate+0x1648>
3481e828:	e59a401c 	ldr	r4, [sl, #28]
3481e82c:	e3540000 	cmp	r4, #0
3481e830:	0a00058a 	beq	3481fe60 <inflate+0x1650>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481e834:	e59a9000 	ldr	r9, [sl]
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481e838:	e3590000 	cmp	r9, #0
3481e83c:	1a000003 	bne	3481e850 <inflate+0x40>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481e840:	e59a3004 	ldr	r3, [sl, #4]
3481e844:	e3530000 	cmp	r3, #0
        return Z_STREAM_ERROR;
3481e848:	13e03001 	mvnne	r3, #1
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481e84c:	1a000586 	bne	3481fe6c <inflate+0x165c>
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e850:	e5943000 	ldr	r3, [r4]
    LOAD();
3481e854:	e59a1004 	ldr	r1, [sl, #4]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e858:	e353000b 	cmp	r3, #11
    LOAD();
3481e85c:	e59a000c 	ldr	r0, [sl, #12]
3481e860:	e59ab010 	ldr	fp, [sl, #16]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e864:	02833001 	addeq	r3, r3, #1
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
3481e868:	e3a02000 	mov	r2, #0
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481e86c:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481e870:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481e874:	05843000 	streq	r3, [r4]
    LOAD();
3481e878:	e58d0020 	str	r0, [sp, #32]
3481e87c:	e58d1038 	str	r1, [sp, #56]	; 0x38
    in = have;
    out = left;
3481e880:	e58db02c 	str	fp, [sp, #44]	; 0x2c
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481e884:	e1a07001 	mov	r7, r1
    in = have;
    out = left;
    ret = Z_OK;
3481e888:	e58d201c 	str	r2, [sp, #28]
    for (;;)
        switch (state->mode) {
3481e88c:	e5943000 	ldr	r3, [r4]
3481e890:	e353001c 	cmp	r3, #28
3481e894:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481e898:	ea000575 	b	3481fe74 <inflate+0x1664>
3481e89c:	3481e930 	.word	0x3481e930
3481e8a0:	3481e928 	.word	0x3481e928
3481e8a4:	3481eb0c 	.word	0x3481eb0c
3481e8a8:	3481eb90 	.word	0x3481eb90
3481e8ac:	3481ec10 	.word	0x3481ec10
3481e8b0:	3481eca8 	.word	0x3481eca8
3481e8b4:	3481ed6c 	.word	0x3481ed6c
3481e8b8:	3481ee28 	.word	0x3481ee28
3481e8bc:	3481eedc 	.word	0x3481eedc
3481e8c0:	3481e920 	.word	0x3481e920
3481e8c4:	3481efb8 	.word	0x3481efb8
3481e8c8:	3481f008 	.word	0x3481f008
3481e8cc:	3481f014 	.word	0x3481f014
3481e8d0:	3481f0cc 	.word	0x3481f0cc
3481e8d4:	3481f134 	.word	0x3481f134
3481e8d8:	3481e918 	.word	0x3481e918
3481e8dc:	3481f218 	.word	0x3481f218
3481e8e0:	3481f30c 	.word	0x3481f30c
3481e8e4:	3481f5b4 	.word	0x3481f5b4
3481e8e8:	3481f754 	.word	0x3481f754
3481e8ec:	3481f7b8 	.word	0x3481f7b8
3481e8f0:	3481f8e0 	.word	0x3481f8e0
3481e8f4:	3481f9b4 	.word	0x3481f9b4
3481e8f8:	3481fa5c 	.word	0x3481fa5c
3481e8fc:	3481fa80 	.word	0x3481fa80
3481e900:	3481fb7c 	.word	0x3481fb7c
3481e904:	3481fc08 	.word	0x3481fc08
3481e908:	3481fbfc 	.word	0x3481fbfc
3481e90c:	3481e910 	.word	0x3481e910
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
3481e910:	e3e03003 	mvn	r3, #3
3481e914:	ea000554 	b	3481fe6c <inflate+0x165c>
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
3481e918:	e1a03009 	mov	r3, r9
3481e91c:	ea000223 	b	3481f1b0 <inflate+0x9a0>
3481e920:	e1a03009 	mov	r3, r9
3481e924:	ea000193 	b	3481ef78 <inflate+0x768>
3481e928:	e1a03009 	mov	r3, r9
3481e92c:	ea000058 	b	3481ea94 <inflate+0x284>
        case HEAD:
            if (state->wrap == 0) {
3481e930:	e5943008 	ldr	r3, [r4, #8]
3481e934:	e3530000 	cmp	r3, #0
3481e938:	11a02009 	movne	r2, r9
                state->mode = TYPEDO;
3481e93c:	03a0300c 	moveq	r3, #12
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
3481e940:	1a000006 	bne	3481e960 <inflate+0x150>
3481e944:	ea0004a3 	b	3481fbd8 <inflate+0x13c8>
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
3481e948:	e3570000 	cmp	r7, #0
3481e94c:	0a0004af 	beq	3481fc10 <inflate+0x1400>
3481e950:	e4d21001 	ldrb	r1, [r2], #1
3481e954:	e2477001 	sub	r7, r7, #1
3481e958:	e0866511 	add	r6, r6, r1, lsl r5
3481e95c:	e2855008 	add	r5, r5, #8
3481e960:	e355000f 	cmp	r5, #15
3481e964:	e1a09002 	mov	r9, r2
3481e968:	9afffff6 	bls	3481e948 <inflate+0x138>
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
3481e96c:	e7e020d3 	ubfx	r2, r3, #1, #1
3481e970:	e3081b1f 	movw	r1, #35615	; 0x8b1f
3481e974:	e1560001 	cmp	r6, r1
3481e978:	13a02000 	movne	r2, #0
3481e97c:	02022001 	andeq	r2, r2, #1
3481e980:	e3520000 	cmp	r2, #0
3481e984:	0a000010 	beq	3481e9cc <inflate+0x1bc>
                state->check = crc32(0L, Z_NULL, 0);
3481e988:	e3a00000 	mov	r0, #0
3481e98c:	e1a01000 	mov	r1, r0
3481e990:	e1a02000 	mov	r2, r0
3481e994:	ebfff07a 	bl	3481ab84 <crc32>
                CRC2(state->check, hold);
3481e998:	e3a0301f 	mov	r3, #31
3481e99c:	e5cd3044 	strb	r3, [sp, #68]	; 0x44
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
3481e9a0:	e5840018 	str	r0, [r4, #24]
                CRC2(state->check, hold);
3481e9a4:	e3e03074 	mvn	r3, #116	; 0x74
3481e9a8:	e28d1044 	add	r1, sp, #68	; 0x44
3481e9ac:	e3a02002 	mov	r2, #2
3481e9b0:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481e9b4:	ebfff072 	bl	3481ab84 <crc32>
                INITBITS();
                state->mode = FLAGS;
3481e9b8:	e3a0c001 	mov	ip, #1
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
3481e9bc:	e5840018 	str	r0, [r4, #24]
                INITBITS();
                state->mode = FLAGS;
3481e9c0:	e584c000 	str	ip, [r4]
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
3481e9c4:	e3a05000 	mov	r5, #0
3481e9c8:	ea000029 	b	3481ea74 <inflate+0x264>
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
3481e9cc:	e5842010 	str	r2, [r4, #16]
            if (state->head != Z_NULL)
3481e9d0:	e5942020 	ldr	r2, [r4, #32]
3481e9d4:	e3520000 	cmp	r2, #0
                state->head->done = -1;
3481e9d8:	13e01000 	mvnne	r1, #0
3481e9dc:	15821030 	strne	r1, [r2, #48]	; 0x30
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481e9e0:	e3130001 	tst	r3, #1
3481e9e4:	0a000006 	beq	3481ea04 <inflate+0x1f4>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
3481e9e8:	e1a03426 	lsr	r3, r6, #8
3481e9ec:	e1a00c06 	lsl	r0, r6, #24
3481e9f0:	e0830820 	add	r0, r3, r0, lsr #16
3481e9f4:	e3a0101f 	mov	r1, #31
3481e9f8:	eb0005a6 	bl	34820098 <__aeabi_uidivmod>
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481e9fc:	e2513000 	subs	r3, r1, #0
3481ea00:	0a000001 	beq	3481ea0c <inflate+0x1fc>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
3481ea04:	e59f3ee8 	ldr	r3, [pc, #3816]	; 3481f8f4 <inflate+0x10e4>
3481ea08:	ea000470 	b	3481fbd0 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
3481ea0c:	e206200f 	and	r2, r6, #15
3481ea10:	e3520008 	cmp	r2, #8
3481ea14:	1a000025 	bne	3481eab0 <inflate+0x2a0>
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481ea18:	e1a06226 	lsr	r6, r6, #4
            len = BITS(4) + 8;
3481ea1c:	e206000f 	and	r0, r6, #15
            if (len > state->wbits) {
3481ea20:	e5942024 	ldr	r2, [r4, #36]	; 0x24
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
3481ea24:	e2800008 	add	r0, r0, #8
            if (len > state->wbits) {
3481ea28:	e1500002 	cmp	r0, r2
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481ea2c:	82455004 	subhi	r5, r5, #4
            len = BITS(4) + 8;
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
3481ea30:	859f3ec0 	ldrhi	r3, [pc, #3776]	; 3481f8f8 <inflate+0x10e8>
3481ea34:	8a000465 	bhi	3481fbd0 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481ea38:	e3a02001 	mov	r2, #1
3481ea3c:	e1a00012 	lsl	r0, r2, r0
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481ea40:	e1a02003 	mov	r2, r3
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481ea44:	e5840014 	str	r0, [r4, #20]
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481ea48:	e1a00003 	mov	r0, r3
3481ea4c:	e58d3014 	str	r3, [sp, #20]
3481ea50:	ebfffeb4 	bl	3481e528 <adler32>
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481ea54:	e3160c02 	tst	r6, #512	; 0x200
            INITBITS();
3481ea58:	e59d3014 	ldr	r3, [sp, #20]
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481ea5c:	03a0200b 	moveq	r2, #11
3481ea60:	13a02009 	movne	r2, #9
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481ea64:	e5840018 	str	r0, [r4, #24]
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
3481ea68:	e1a05003 	mov	r5, r3
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481ea6c:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481ea70:	e5842000 	str	r2, [r4]
            INITBITS();
3481ea74:	e1a06005 	mov	r6, r5
            break;
3481ea78:	eaffff83 	b	3481e88c <inflate+0x7c>
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
3481ea7c:	e3570000 	cmp	r7, #0
3481ea80:	0a000462 	beq	3481fc10 <inflate+0x1400>
3481ea84:	e4d32001 	ldrb	r2, [r3], #1
3481ea88:	e2477001 	sub	r7, r7, #1
3481ea8c:	e0866512 	add	r6, r6, r2, lsl r5
3481ea90:	e2855008 	add	r5, r5, #8
3481ea94:	e355000f 	cmp	r5, #15
3481ea98:	e1a09003 	mov	r9, r3
3481ea9c:	9afffff6 	bls	3481ea7c <inflate+0x26c>
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481eaa0:	e20630ff 	and	r3, r6, #255	; 0xff
3481eaa4:	e3530008 	cmp	r3, #8
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
3481eaa8:	e5846010 	str	r6, [r4, #16]
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481eaac:	0a000001 	beq	3481eab8 <inflate+0x2a8>
                strm->msg = (char *)"unknown compression method";
3481eab0:	e59f3e44 	ldr	r3, [pc, #3652]	; 3481f8fc <inflate+0x10ec>
3481eab4:	ea000445 	b	3481fbd0 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481eab8:	e3160a0e 	tst	r6, #57344	; 0xe000
                strm->msg = (char *)"unknown header flags set";
3481eabc:	159f3e3c 	ldrne	r3, [pc, #3644]	; 3481f900 <inflate+0x10f0>
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481eac0:	1a000442 	bne	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
3481eac4:	e5943020 	ldr	r3, [r4, #32]
3481eac8:	e3530000 	cmp	r3, #0
                state->head->text = (int)((hold >> 8) & 1);
3481eacc:	17e02456 	ubfxne	r2, r6, #8, #1
3481ead0:	15832000 	strne	r2, [r3]
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481ead4:	e3160c02 	tst	r6, #512	; 0x200
3481ead8:	0a000007 	beq	3481eafc <inflate+0x2ec>
3481eadc:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481eae0:	e1a06426 	lsr	r6, r6, #8
3481eae4:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481eae8:	e5940018 	ldr	r0, [r4, #24]
3481eaec:	e28d1044 	add	r1, sp, #68	; 0x44
3481eaf0:	e3a02002 	mov	r2, #2
3481eaf4:	ebfff022 	bl	3481ab84 <crc32>
3481eaf8:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = TIME;
3481eafc:	e3a03002 	mov	r3, #2
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481eb00:	e3a05000 	mov	r5, #0
            state->mode = TIME;
3481eb04:	e5843000 	str	r3, [r4]
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481eb08:	e1a06005 	mov	r6, r5
            state->mode = TIME;
3481eb0c:	e1a03009 	mov	r3, r9
3481eb10:	ea000005 	b	3481eb2c <inflate+0x31c>
        case TIME:
            NEEDBITS(32);
3481eb14:	e3570000 	cmp	r7, #0
3481eb18:	0a00043c 	beq	3481fc10 <inflate+0x1400>
3481eb1c:	e4d32001 	ldrb	r2, [r3], #1
3481eb20:	e2477001 	sub	r7, r7, #1
3481eb24:	e0866512 	add	r6, r6, r2, lsl r5
3481eb28:	e2855008 	add	r5, r5, #8
3481eb2c:	e355001f 	cmp	r5, #31
3481eb30:	e1a09003 	mov	r9, r3
3481eb34:	9afffff6 	bls	3481eb14 <inflate+0x304>
            if (state->head != Z_NULL)
3481eb38:	e5943020 	ldr	r3, [r4, #32]
3481eb3c:	e3530000 	cmp	r3, #0
                state->head->time = hold;
3481eb40:	15836004 	strne	r6, [r3, #4]
            if (state->flags & 0x0200) CRC4(state->check, hold);
3481eb44:	e5943010 	ldr	r3, [r4, #16]
3481eb48:	e3130c02 	tst	r3, #512	; 0x200
3481eb4c:	0a00000b 	beq	3481eb80 <inflate+0x370>
3481eb50:	e1a03426 	lsr	r3, r6, #8
3481eb54:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481eb58:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481eb5c:	e1a03826 	lsr	r3, r6, #16
3481eb60:	e1a06c26 	lsr	r6, r6, #24
3481eb64:	e5cd3046 	strb	r3, [sp, #70]	; 0x46
3481eb68:	e5cd6047 	strb	r6, [sp, #71]	; 0x47
3481eb6c:	e5940018 	ldr	r0, [r4, #24]
3481eb70:	e28d1044 	add	r1, sp, #68	; 0x44
3481eb74:	e3a02004 	mov	r2, #4
3481eb78:	ebfff001 	bl	3481ab84 <crc32>
3481eb7c:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = OS;
3481eb80:	e3a03003 	mov	r3, #3
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481eb84:	e3a05000 	mov	r5, #0
            state->mode = OS;
3481eb88:	e5843000 	str	r3, [r4]
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481eb8c:	e1a06005 	mov	r6, r5
            state->mode = OS;
3481eb90:	e1a03009 	mov	r3, r9
3481eb94:	ea000005 	b	3481ebb0 <inflate+0x3a0>
        case OS:
            NEEDBITS(16);
3481eb98:	e3570000 	cmp	r7, #0
3481eb9c:	0a00041b 	beq	3481fc10 <inflate+0x1400>
3481eba0:	e4d32001 	ldrb	r2, [r3], #1
3481eba4:	e2477001 	sub	r7, r7, #1
3481eba8:	e0866512 	add	r6, r6, r2, lsl r5
3481ebac:	e2855008 	add	r5, r5, #8
3481ebb0:	e355000f 	cmp	r5, #15
3481ebb4:	e1a09003 	mov	r9, r3
3481ebb8:	9afffff6 	bls	3481eb98 <inflate+0x388>
            if (state->head != Z_NULL) {
3481ebbc:	e5943020 	ldr	r3, [r4, #32]
3481ebc0:	e3530000 	cmp	r3, #0
                state->head->xflags = (int)(hold & 0xff);
3481ebc4:	120620ff 	andne	r2, r6, #255	; 0xff
3481ebc8:	15832008 	strne	r2, [r3, #8]
                state->head->os = (int)(hold >> 8);
3481ebcc:	11a02426 	lsrne	r2, r6, #8
3481ebd0:	1583200c 	strne	r2, [r3, #12]
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481ebd4:	e5943010 	ldr	r3, [r4, #16]
3481ebd8:	e3130c02 	tst	r3, #512	; 0x200
3481ebdc:	0a000007 	beq	3481ec00 <inflate+0x3f0>
3481ebe0:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481ebe4:	e1a06426 	lsr	r6, r6, #8
3481ebe8:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481ebec:	e5940018 	ldr	r0, [r4, #24]
3481ebf0:	e28d1044 	add	r1, sp, #68	; 0x44
3481ebf4:	e3a02002 	mov	r2, #2
3481ebf8:	ebffefe1 	bl	3481ab84 <crc32>
3481ebfc:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = EXLEN;
3481ec00:	e3a03004 	mov	r3, #4
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481ec04:	e3a05000 	mov	r5, #0
            state->mode = EXLEN;
3481ec08:	e5843000 	str	r3, [r4]
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481ec0c:	e1a06005 	mov	r6, r5
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
3481ec10:	e5943010 	ldr	r3, [r4, #16]
3481ec14:	e2132b01 	ands	r2, r3, #1024	; 0x400
3481ec18:	11a02009 	movne	r2, r9
3481ec1c:	1a000006 	bne	3481ec3c <inflate+0x42c>
3481ec20:	ea000019 	b	3481ec8c <inflate+0x47c>
                NEEDBITS(16);
3481ec24:	e3570000 	cmp	r7, #0
3481ec28:	0a0003f8 	beq	3481fc10 <inflate+0x1400>
3481ec2c:	e4d21001 	ldrb	r1, [r2], #1
3481ec30:	e2477001 	sub	r7, r7, #1
3481ec34:	e0866511 	add	r6, r6, r1, lsl r5
3481ec38:	e2855008 	add	r5, r5, #8
3481ec3c:	e355000f 	cmp	r5, #15
3481ec40:	e1a09002 	mov	r9, r2
3481ec44:	9afffff6 	bls	3481ec24 <inflate+0x414>
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
3481ec48:	e5942020 	ldr	r2, [r4, #32]
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
3481ec4c:	e5846040 	str	r6, [r4, #64]	; 0x40
                if (state->head != Z_NULL)
3481ec50:	e3520000 	cmp	r2, #0
                    state->head->extra_len = (unsigned)hold;
3481ec54:	15826014 	strne	r6, [r2, #20]
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481ec58:	e2133c02 	ands	r3, r3, #512	; 0x200
                INITBITS();
3481ec5c:	01a06003 	moveq	r6, r3
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481ec60:	0a00000d 	beq	3481ec9c <inflate+0x48c>
3481ec64:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481ec68:	e1a06426 	lsr	r6, r6, #8
3481ec6c:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481ec70:	e5940018 	ldr	r0, [r4, #24]
3481ec74:	e28d1044 	add	r1, sp, #68	; 0x44
3481ec78:	e3a02002 	mov	r2, #2
3481ec7c:	ebffefc0 	bl	3481ab84 <crc32>
                INITBITS();
3481ec80:	e3a06000 	mov	r6, #0
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481ec84:	e5840018 	str	r0, [r4, #24]
3481ec88:	ea000003 	b	3481ec9c <inflate+0x48c>
                INITBITS();
            }
            else if (state->head != Z_NULL)
3481ec8c:	e5943020 	ldr	r3, [r4, #32]
3481ec90:	e3530000 	cmp	r3, #0
                state->head->extra = Z_NULL;
3481ec94:	15832010 	strne	r2, [r3, #16]
3481ec98:	ea000000 	b	3481eca0 <inflate+0x490>
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
3481ec9c:	e1a05006 	mov	r5, r6
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
3481eca0:	e3a03005 	mov	r3, #5
3481eca4:	e5843000 	str	r3, [r4]
        case EXTRA:
            if (state->flags & 0x0400) {
3481eca8:	e5943010 	ldr	r3, [r4, #16]
3481ecac:	e3130b01 	tst	r3, #1024	; 0x400
3481ecb0:	0a000029 	beq	3481ed5c <inflate+0x54c>
                copy = state->length;
3481ecb4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
3481ecb8:	e1570002 	cmp	r7, r2
3481ecbc:	31a03007 	movcc	r3, r7
3481ecc0:	21a03002 	movcs	r3, r2
                if (copy > have) copy = have;
                if (copy) {
3481ecc4:	e3530000 	cmp	r3, #0
3481ecc8:	0a000020 	beq	3481ed50 <inflate+0x540>
                    if (state->head != Z_NULL &&
3481eccc:	e5941020 	ldr	r1, [r4, #32]
3481ecd0:	e3510000 	cmp	r1, #0
3481ecd4:	0a00000e 	beq	3481ed14 <inflate+0x504>
                        state->head->extra != Z_NULL) {
3481ecd8:	e5910010 	ldr	r0, [r1, #16]
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
3481ecdc:	e3500000 	cmp	r0, #0
3481ece0:	0a00000b 	beq	3481ed14 <inflate+0x504>
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481ece4:	e591c014 	ldr	ip, [r1, #20]
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481ece8:	e5911018 	ldr	r1, [r1, #24]
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481ecec:	e062200c 	rsb	r2, r2, ip
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481ecf0:	e083c002 	add	ip, r3, r2
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
3481ecf4:	e15c0001 	cmp	ip, r1
3481ecf8:	e0800002 	add	r0, r0, r2
3481ecfc:	80622001 	rsbhi	r2, r2, r1
3481ed00:	91a02003 	movls	r2, r3
3481ed04:	e1a01009 	mov	r1, r9
3481ed08:	e58d3014 	str	r3, [sp, #20]
3481ed0c:	ebfff71e 	bl	3481c98c <memcpy>
3481ed10:	e59d3014 	ldr	r3, [sp, #20]
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
3481ed14:	e5942010 	ldr	r2, [r4, #16]
3481ed18:	e3120c02 	tst	r2, #512	; 0x200
3481ed1c:	0a000006 	beq	3481ed3c <inflate+0x52c>
                        state->check = crc32(state->check, next, copy);
3481ed20:	e5940018 	ldr	r0, [r4, #24]
3481ed24:	e1a02003 	mov	r2, r3
3481ed28:	e1a01009 	mov	r1, r9
3481ed2c:	e58d3014 	str	r3, [sp, #20]
3481ed30:	ebffef93 	bl	3481ab84 <crc32>
3481ed34:	e59d3014 	ldr	r3, [sp, #20]
3481ed38:	e5840018 	str	r0, [r4, #24]
                    have -= copy;
                    next += copy;
                    state->length -= copy;
3481ed3c:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
3481ed40:	e0637007 	rsb	r7, r3, r7
                    next += copy;
3481ed44:	e0899003 	add	r9, r9, r3
                    state->length -= copy;
3481ed48:	e0633002 	rsb	r3, r3, r2
3481ed4c:	e5843040 	str	r3, [r4, #64]	; 0x40
                }
                if (state->length) goto inf_leave;
3481ed50:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481ed54:	e3530000 	cmp	r3, #0
3481ed58:	1a0003ac 	bne	3481fc10 <inflate+0x1400>
            }
            state->length = 0;
3481ed5c:	e3a03000 	mov	r3, #0
3481ed60:	e5843040 	str	r3, [r4, #64]	; 0x40
            state->mode = NAME;
3481ed64:	e2833006 	add	r3, r3, #6
3481ed68:	e5843000 	str	r3, [r4]
        case NAME:
            if (state->flags & 0x0800) {
3481ed6c:	e5942010 	ldr	r2, [r4, #16]
3481ed70:	e2122b02 	ands	r2, r2, #2048	; 0x800
3481ed74:	0a000024 	beq	3481ee0c <inflate+0x5fc>
                if (have == 0) goto inf_leave;
3481ed78:	e3570000 	cmp	r7, #0
3481ed7c:	0a0003a3 	beq	3481fc10 <inflate+0x1400>
3481ed80:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481ed84:	e5941020 	ldr	r1, [r4, #32]
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481ed88:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481ed8c:	e3510000 	cmp	r1, #0
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481ed90:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481ed94:	0a000008 	beq	3481edbc <inflate+0x5ac>
                            state->head->name != Z_NULL &&
3481ed98:	e591001c 	ldr	r0, [r1, #28]
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481ed9c:	e3500000 	cmp	r0, #0
3481eda0:	0a000005 	beq	3481edbc <inflate+0x5ac>
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
3481eda4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
3481eda8:	e5911020 	ldr	r1, [r1, #32]
3481edac:	e1520001 	cmp	r2, r1
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
3481edb0:	37c0c002 	strbcc	ip, [r0, r2]
3481edb4:	32822001 	addcc	r2, r2, #1
3481edb8:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481edbc:	e35c0000 	cmp	ip, #0
3481edc0:	11530007 	cmpne	r3, r7
3481edc4:	3affffee 	bcc	3481ed84 <inflate+0x574>
                if (state->flags & 0x0200)
3481edc8:	e5942010 	ldr	r2, [r4, #16]
3481edcc:	e3120c02 	tst	r2, #512	; 0x200
3481edd0:	0a000008 	beq	3481edf8 <inflate+0x5e8>
                    state->check = crc32(state->check, next, copy);
3481edd4:	e5940018 	ldr	r0, [r4, #24]
3481edd8:	e1a02003 	mov	r2, r3
3481eddc:	e1a01009 	mov	r1, r9
3481ede0:	e58d3014 	str	r3, [sp, #20]
3481ede4:	e58dc018 	str	ip, [sp, #24]
3481ede8:	ebffef65 	bl	3481ab84 <crc32>
3481edec:	e59dc018 	ldr	ip, [sp, #24]
3481edf0:	e59d3014 	ldr	r3, [sp, #20]
3481edf4:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481edf8:	e35c0000 	cmp	ip, #0
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481edfc:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481ee00:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481ee04:	0a000003 	beq	3481ee18 <inflate+0x608>
3481ee08:	ea000380 	b	3481fc10 <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481ee0c:	e5943020 	ldr	r3, [r4, #32]
3481ee10:	e3530000 	cmp	r3, #0
                state->head->name = Z_NULL;
3481ee14:	1583201c 	strne	r2, [r3, #28]
            state->length = 0;
3481ee18:	e3a0c000 	mov	ip, #0
            state->mode = COMMENT;
3481ee1c:	e3a03007 	mov	r3, #7
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
3481ee20:	e584c040 	str	ip, [r4, #64]	; 0x40
            state->mode = COMMENT;
3481ee24:	e5843000 	str	r3, [r4]
        case COMMENT:
            if (state->flags & 0x1000) {
3481ee28:	e5942010 	ldr	r2, [r4, #16]
3481ee2c:	e2122a01 	ands	r2, r2, #4096	; 0x1000
3481ee30:	0a000024 	beq	3481eec8 <inflate+0x6b8>
                if (have == 0) goto inf_leave;
3481ee34:	e3570000 	cmp	r7, #0
3481ee38:	0a000374 	beq	3481fc10 <inflate+0x1400>
3481ee3c:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481ee40:	e5941020 	ldr	r1, [r4, #32]
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481ee44:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481ee48:	e3510000 	cmp	r1, #0
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481ee4c:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481ee50:	0a000008 	beq	3481ee78 <inflate+0x668>
                            state->head->comment != Z_NULL &&
3481ee54:	e5910024 	ldr	r0, [r1, #36]	; 0x24
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481ee58:	e3500000 	cmp	r0, #0
3481ee5c:	0a000005 	beq	3481ee78 <inflate+0x668>
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
3481ee60:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
3481ee64:	e5911028 	ldr	r1, [r1, #40]	; 0x28
3481ee68:	e1520001 	cmp	r2, r1
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
3481ee6c:	37c0c002 	strbcc	ip, [r0, r2]
3481ee70:	32822001 	addcc	r2, r2, #1
3481ee74:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481ee78:	e35c0000 	cmp	ip, #0
3481ee7c:	11530007 	cmpne	r3, r7
3481ee80:	3affffee 	bcc	3481ee40 <inflate+0x630>
                if (state->flags & 0x0200)
3481ee84:	e5942010 	ldr	r2, [r4, #16]
3481ee88:	e3120c02 	tst	r2, #512	; 0x200
3481ee8c:	0a000008 	beq	3481eeb4 <inflate+0x6a4>
                    state->check = crc32(state->check, next, copy);
3481ee90:	e5940018 	ldr	r0, [r4, #24]
3481ee94:	e1a02003 	mov	r2, r3
3481ee98:	e1a01009 	mov	r1, r9
3481ee9c:	e58d3014 	str	r3, [sp, #20]
3481eea0:	e58dc018 	str	ip, [sp, #24]
3481eea4:	ebffef36 	bl	3481ab84 <crc32>
3481eea8:	e59dc018 	ldr	ip, [sp, #24]
3481eeac:	e59d3014 	ldr	r3, [sp, #20]
3481eeb0:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481eeb4:	e35c0000 	cmp	ip, #0
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481eeb8:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481eebc:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481eec0:	0a000003 	beq	3481eed4 <inflate+0x6c4>
3481eec4:	ea000351 	b	3481fc10 <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481eec8:	e5943020 	ldr	r3, [r4, #32]
3481eecc:	e3530000 	cmp	r3, #0
                state->head->comment = Z_NULL;
3481eed0:	15832024 	strne	r2, [r3, #36]	; 0x24
            state->mode = HCRC;
3481eed4:	e3a03008 	mov	r3, #8
3481eed8:	e5843000 	str	r3, [r4]
        case HCRC:
            if (state->flags & 0x0200) {
3481eedc:	e5942010 	ldr	r2, [r4, #16]
3481eee0:	e3120c02 	tst	r2, #512	; 0x200
3481eee4:	11a03009 	movne	r3, r9
3481eee8:	1a000006 	bne	3481ef08 <inflate+0x6f8>
3481eeec:	ea00000e 	b	3481ef2c <inflate+0x71c>
                NEEDBITS(16);
3481eef0:	e3570000 	cmp	r7, #0
3481eef4:	0a000345 	beq	3481fc10 <inflate+0x1400>
3481eef8:	e4d31001 	ldrb	r1, [r3], #1
3481eefc:	e2477001 	sub	r7, r7, #1
3481ef00:	e0866511 	add	r6, r6, r1, lsl r5
3481ef04:	e2855008 	add	r5, r5, #8
3481ef08:	e355000f 	cmp	r5, #15
3481ef0c:	e1a09003 	mov	r9, r3
3481ef10:	9afffff6 	bls	3481eef0 <inflate+0x6e0>
                if (hold != (state->check & 0xffff)) {
3481ef14:	e1d431b8 	ldrh	r3, [r4, #24]
3481ef18:	e1560003 	cmp	r6, r3
                    strm->msg = (char *)"header crc mismatch";
3481ef1c:	159f39e0 	ldrne	r3, [pc, #2528]	; 3481f904 <inflate+0x10f4>
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
3481ef20:	1a00032a 	bne	3481fbd0 <inflate+0x13c0>
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481ef24:	e3a05000 	mov	r5, #0
3481ef28:	e1a06005 	mov	r6, r5
            }
            if (state->head != Z_NULL) {
3481ef2c:	e5943020 	ldr	r3, [r4, #32]
3481ef30:	e3530000 	cmp	r3, #0
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
3481ef34:	13a00001 	movne	r0, #1
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481ef38:	17e024d2 	ubfxne	r2, r2, #9, #1
                state->head->done = 1;
3481ef3c:	15830030 	strne	r0, [r3, #48]	; 0x30
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481ef40:	e3a00000 	mov	r0, #0
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481ef44:	1583202c 	strne	r2, [r3, #44]	; 0x2c
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481ef48:	e1a01000 	mov	r1, r0
3481ef4c:	e1a02000 	mov	r2, r0
3481ef50:	ebffef0b 	bl	3481ab84 <crc32>
3481ef54:	e5840018 	str	r0, [r4, #24]
3481ef58:	e58a0034 	str	r0, [sl, #52]	; 0x34
3481ef5c:	ea0001f3 	b	3481f730 <inflate+0xf20>
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
3481ef60:	e3570000 	cmp	r7, #0
3481ef64:	0a000329 	beq	3481fc10 <inflate+0x1400>
3481ef68:	e4d32001 	ldrb	r2, [r3], #1
3481ef6c:	e2477001 	sub	r7, r7, #1
3481ef70:	e0866512 	add	r6, r6, r2, lsl r5
3481ef74:	e2855008 	add	r5, r5, #8
3481ef78:	e355001f 	cmp	r5, #31
3481ef7c:	e1a09003 	mov	r9, r3
3481ef80:	9afffff6 	bls	3481ef60 <inflate+0x750>
            strm->adler = state->check = REVERSE(hold);
3481ef84:	e1a02c26 	lsr	r2, r6, #24
3481ef88:	e1a03426 	lsr	r3, r6, #8
3481ef8c:	e0822c06 	add	r2, r2, r6, lsl #24
3481ef90:	e2033cff 	and	r3, r3, #65280	; 0xff00
3481ef94:	e2066cff 	and	r6, r6, #65280	; 0xff00
3481ef98:	e0823003 	add	r3, r2, r3
3481ef9c:	e0833406 	add	r3, r3, r6, lsl #8
3481efa0:	e5843018 	str	r3, [r4, #24]
            INITBITS();
3481efa4:	e3a06000 	mov	r6, #0
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
3481efa8:	e58a3034 	str	r3, [sl, #52]	; 0x34
            INITBITS();
            state->mode = DICT;
3481efac:	e3a0300a 	mov	r3, #10
3481efb0:	e5843000 	str	r3, [r4]
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
3481efb4:	e1a05006 	mov	r5, r6
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
3481efb8:	e594300c 	ldr	r3, [r4, #12]
3481efbc:	e3530000 	cmp	r3, #0
3481efc0:	1a000008 	bne	3481efe8 <inflate+0x7d8>
                RESTORE();
3481efc4:	e59d1020 	ldr	r1, [sp, #32]
3481efc8:	e58ab010 	str	fp, [sl, #16]
3481efcc:	e58a100c 	str	r1, [sl, #12]
3481efd0:	e58a9000 	str	r9, [sl]
3481efd4:	e58a7004 	str	r7, [sl, #4]
                return Z_NEED_DICT;
3481efd8:	e3a02002 	mov	r2, #2
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
3481efdc:	e5846038 	str	r6, [r4, #56]	; 0x38
3481efe0:	e584503c 	str	r5, [r4, #60]	; 0x3c
3481efe4:	ea00039e 	b	3481fe64 <inflate+0x1654>
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481efe8:	e3a00000 	mov	r0, #0
3481efec:	e1a01000 	mov	r1, r0
3481eff0:	e1a02000 	mov	r2, r0
3481eff4:	ebfffd4b 	bl	3481e528 <adler32>
            state->mode = TYPE;
3481eff8:	e3a0300b 	mov	r3, #11
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481effc:	e5840018 	str	r0, [r4, #24]
3481f000:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = TYPE;
3481f004:	e5843000 	str	r3, [r4]
        case TYPE:
	    WATCHDOG_RESET();
            if (flush == Z_BLOCK) goto inf_leave;
3481f008:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481f00c:	e3530005 	cmp	r3, #5
3481f010:	0a0002fe 	beq	3481fc10 <inflate+0x1400>
        case TYPEDO:
            if (state->last) {
3481f014:	e5943004 	ldr	r3, [r4, #4]
3481f018:	e3530000 	cmp	r3, #0
3481f01c:	01a03009 	moveq	r3, r9
3481f020:	0a00000a 	beq	3481f050 <inflate+0x840>
                BYTEBITS();
3481f024:	e2053007 	and	r3, r5, #7
3481f028:	e1a06336 	lsr	r6, r6, r3
3481f02c:	e3c55007 	bic	r5, r5, #7
                state->mode = CHECK;
3481f030:	e3a03018 	mov	r3, #24
3481f034:	ea0002e7 	b	3481fbd8 <inflate+0x13c8>
                break;
            }
            NEEDBITS(3);
3481f038:	e3570000 	cmp	r7, #0
3481f03c:	0a0002f3 	beq	3481fc10 <inflate+0x1400>
3481f040:	e4d32001 	ldrb	r2, [r3], #1
3481f044:	e2477001 	sub	r7, r7, #1
3481f048:	e0866512 	add	r6, r6, r2, lsl r5
3481f04c:	e2855008 	add	r5, r5, #8
3481f050:	e3550002 	cmp	r5, #2
3481f054:	e1a09003 	mov	r9, r3
3481f058:	9afffff6 	bls	3481f038 <inflate+0x828>
            state->last = BITS(1);
3481f05c:	e2063001 	and	r3, r6, #1
            DROPBITS(1);
3481f060:	e1a060a6 	lsr	r6, r6, #1
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
3481f064:	e5843004 	str	r3, [r4, #4]
            DROPBITS(1);
            switch (BITS(2)) {
3481f068:	e2063003 	and	r3, r6, #3
3481f06c:	e3530002 	cmp	r3, #2
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
3481f070:	03a0300f 	moveq	r3, #15
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
3481f074:	0a000010 	beq	3481f0bc <inflate+0x8ac>
3481f078:	e3530003 	cmp	r3, #3
3481f07c:	0a00000b 	beq	3481f0b0 <inflate+0x8a0>
3481f080:	e3530001 	cmp	r3, #1

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481f084:	03a03009 	moveq	r3, #9
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481f088:	059fc878 	ldreq	ip, [pc, #2168]	; 3481f908 <inflate+0x10f8>
    state->lenbits = 9;
    state->distcode = distfix;
3481f08c:	059f0878 	ldreq	r0, [pc, #2168]	; 3481f90c <inflate+0x10fc>

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481f090:	05843054 	streq	r3, [r4, #84]	; 0x54
    state->distcode = distfix;
    state->distbits = 5;
3481f094:	03a03005 	moveq	r3, #5
3481f098:	05843058 	streq	r3, [r4, #88]	; 0x58
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
3481f09c:	13a0300d 	movne	r3, #13
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481f0a0:	0584c04c 	streq	ip, [r4, #76]	; 0x4c
    state->lenbits = 9;
    state->distcode = distfix;
3481f0a4:	05840050 	streq	r0, [r4, #80]	; 0x50
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
3481f0a8:	0283300d 	addeq	r3, r3, #13
3481f0ac:	ea000002 	b	3481f0bc <inflate+0x8ac>
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
3481f0b0:	e59f3858 	ldr	r3, [pc, #2136]	; 3481f910 <inflate+0x1100>
3481f0b4:	e58a3018 	str	r3, [sl, #24]
                state->mode = BAD;
3481f0b8:	e3a0301b 	mov	r3, #27
3481f0bc:	e5843000 	str	r3, [r4]
            }
            DROPBITS(2);
3481f0c0:	e1a06126 	lsr	r6, r6, #2
3481f0c4:	e2455003 	sub	r5, r5, #3
            break;
3481f0c8:	eafffdef 	b	3481e88c <inflate+0x7c>
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
3481f0cc:	e2053007 	and	r3, r5, #7
3481f0d0:	e1a06336 	lsr	r6, r6, r3
3481f0d4:	e3c55007 	bic	r5, r5, #7
3481f0d8:	e1a03009 	mov	r3, r9
            NEEDBITS(32);
3481f0dc:	ea000005 	b	3481f0f8 <inflate+0x8e8>
3481f0e0:	e3570000 	cmp	r7, #0
3481f0e4:	0a0002c9 	beq	3481fc10 <inflate+0x1400>
3481f0e8:	e4d32001 	ldrb	r2, [r3], #1
3481f0ec:	e2477001 	sub	r7, r7, #1
3481f0f0:	e0866512 	add	r6, r6, r2, lsl r5
3481f0f4:	e2855008 	add	r5, r5, #8
3481f0f8:	e355001f 	cmp	r5, #31
3481f0fc:	e1a09003 	mov	r9, r3
3481f100:	9afffff6 	bls	3481f0e0 <inflate+0x8d0>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481f104:	e1a02826 	lsr	r2, r6, #16
3481f108:	e2222cff 	eor	r2, r2, #65280	; 0xff00
3481f10c:	e6ff3076 	uxth	r3, r6
3481f110:	e22220ff 	eor	r2, r2, #255	; 0xff
3481f114:	e1530002 	cmp	r3, r2
                strm->msg = (char *)"invalid stored block lengths";
3481f118:	159f37f4 	ldrne	r3, [pc, #2036]	; 3481f914 <inflate+0x1104>
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481f11c:	1a0002ab 	bne	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
3481f120:	e5843040 	str	r3, [r4, #64]	; 0x40
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481f124:	e3a05000 	mov	r5, #0
            state->mode = COPY;
3481f128:	e3a0300e 	mov	r3, #14
3481f12c:	e5843000 	str	r3, [r4]
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481f130:	e1a06005 	mov	r6, r5
            state->mode = COPY;
        case COPY:
            copy = state->length;
3481f134:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy) {
3481f138:	e3530000 	cmp	r3, #0
3481f13c:	0a00017b 	beq	3481f730 <inflate+0xf20>
3481f140:	e15b0003 	cmp	fp, r3
3481f144:	31a0300b 	movcc	r3, fp
3481f148:	e1530007 	cmp	r3, r7
3481f14c:	21a03007 	movcs	r3, r7
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
3481f150:	e3530000 	cmp	r3, #0
3481f154:	0a0002ad 	beq	3481fc10 <inflate+0x1400>
                zmemcpy(put, next, copy);
3481f158:	e1a01009 	mov	r1, r9
3481f15c:	e1a02003 	mov	r2, r3
3481f160:	e59d0020 	ldr	r0, [sp, #32]
3481f164:	e58d3014 	str	r3, [sp, #20]
3481f168:	ebfff607 	bl	3481c98c <memcpy>
                have -= copy;
3481f16c:	e59d3014 	ldr	r3, [sp, #20]
                next += copy;
                left -= copy;
                put += copy;
3481f170:	e59d1020 	ldr	r1, [sp, #32]
                state->length -= copy;
3481f174:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481f178:	e0811003 	add	r1, r1, r3
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
3481f17c:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481f180:	e0899003 	add	r9, r9, r3
                left -= copy;
3481f184:	e063b00b 	rsb	fp, r3, fp
                put += copy;
                state->length -= copy;
3481f188:	e0633002 	rsb	r3, r3, r2
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481f18c:	e58d1020 	str	r1, [sp, #32]
                state->length -= copy;
3481f190:	e5843040 	str	r3, [r4, #64]	; 0x40
                break;
3481f194:	eafffdbc 	b	3481e88c <inflate+0x7c>
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
3481f198:	e3570000 	cmp	r7, #0
3481f19c:	0a00029b 	beq	3481fc10 <inflate+0x1400>
3481f1a0:	e4d32001 	ldrb	r2, [r3], #1
3481f1a4:	e2477001 	sub	r7, r7, #1
3481f1a8:	e0866512 	add	r6, r6, r2, lsl r5
3481f1ac:	e2855008 	add	r5, r5, #8
3481f1b0:	e355000d 	cmp	r5, #13
3481f1b4:	e1a09003 	mov	r9, r3
3481f1b8:	9afffff6 	bls	3481f198 <inflate+0x988>
            state->nlen = BITS(5) + 257;
3481f1bc:	e206201f 	and	r2, r6, #31
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481f1c0:	e7e31556 	ubfx	r1, r6, #10, #4
3481f1c4:	e2811004 	add	r1, r1, #4
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481f1c8:	e2822c01 	add	r2, r2, #256	; 0x100
3481f1cc:	e2822001 	add	r2, r2, #1
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481f1d0:	e7e432d6 	ubfx	r3, r6, #5, #5
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481f1d4:	e584105c 	str	r1, [r4, #92]	; 0x5c
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481f1d8:	e300111e 	movw	r1, #286	; 0x11e
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481f1dc:	e2833001 	add	r3, r3, #1
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481f1e0:	e1520001 	cmp	r2, r1
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481f1e4:	e5842060 	str	r2, [r4, #96]	; 0x60
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481f1e8:	e5843064 	str	r3, [r4, #100]	; 0x64
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
3481f1ec:	e1a06726 	lsr	r6, r6, #14
3481f1f0:	e245500e 	sub	r5, r5, #14
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481f1f4:	8a000001 	bhi	3481f200 <inflate+0x9f0>
3481f1f8:	e353001e 	cmp	r3, #30
3481f1fc:	9a000001 	bls	3481f208 <inflate+0x9f8>
                strm->msg = (char *)"too many length or distance symbols";
3481f200:	e59f3710 	ldr	r3, [pc, #1808]	; 3481f918 <inflate+0x1108>
3481f204:	ea000271 	b	3481fbd0 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481f208:	e3a02000 	mov	r2, #0
            state->mode = LENLENS;
3481f20c:	e3a03010 	mov	r3, #16
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481f210:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = LENLENS;
3481f214:	e5843000 	str	r3, [r4]
        case LENLENS:
            while (state->have < state->ncode) {
3481f218:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
3481f21c:	ea000013 	b	3481f270 <inflate+0xa60>
                NEEDBITS(3);
3481f220:	e3570000 	cmp	r7, #0
3481f224:	0a000279 	beq	3481fc10 <inflate+0x1400>
3481f228:	e4d10001 	ldrb	r0, [r1], #1
3481f22c:	e2477001 	sub	r7, r7, #1
3481f230:	e0866510 	add	r6, r6, r0, lsl r5
3481f234:	e2855008 	add	r5, r5, #8
3481f238:	e3550002 	cmp	r5, #2
3481f23c:	e1a09001 	mov	r9, r1
3481f240:	9afffff6 	bls	3481f220 <inflate+0xa10>
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
3481f244:	e59fc6d0 	ldr	ip, [pc, #1744]	; 3481f91c <inflate+0x110c>
3481f248:	e2060007 	and	r0, r6, #7
3481f24c:	e08c1083 	add	r1, ip, r3, lsl #1
3481f250:	e2811d26 	add	r1, r1, #2432	; 0x980
3481f254:	e1d110b0 	ldrh	r1, [r1]
3481f258:	e2833001 	add	r3, r3, #1
3481f25c:	e0841081 	add	r1, r4, r1, lsl #1
3481f260:	e1c107b0 	strh	r0, [r1, #112]	; 0x70
3481f264:	e5843068 	str	r3, [r4, #104]	; 0x68
                DROPBITS(3);
3481f268:	e1a061a6 	lsr	r6, r6, #3
3481f26c:	e2455003 	sub	r5, r5, #3
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
3481f270:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481f274:	e1530002 	cmp	r3, r2
3481f278:	2a00000a 	bcs	3481f2a8 <inflate+0xa98>
3481f27c:	e1a01009 	mov	r1, r9
3481f280:	eaffffec 	b	3481f238 <inflate+0xa28>
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
3481f284:	e59f0690 	ldr	r0, [pc, #1680]	; 3481f91c <inflate+0x110c>
3481f288:	e3a01000 	mov	r1, #0
3481f28c:	e0802083 	add	r2, r0, r3, lsl #1
3481f290:	e2822d26 	add	r2, r2, #2432	; 0x980
3481f294:	e1d220b0 	ldrh	r2, [r2]
3481f298:	e2833001 	add	r3, r3, #1
3481f29c:	e0842082 	add	r2, r4, r2, lsl #1
3481f2a0:	e1c217b0 	strh	r1, [r2, #112]	; 0x70
3481f2a4:	e5843068 	str	r3, [r4, #104]	; 0x68
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
3481f2a8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481f2ac:	e3530012 	cmp	r3, #18
3481f2b0:	9afffff3 	bls	3481f284 <inflate+0xa74>
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
3481f2b4:	e2843e53 	add	r3, r4, #1328	; 0x530
3481f2b8:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481f2bc:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 7;
3481f2c0:	e3a03007 	mov	r3, #7
3481f2c4:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
3481f2c8:	e2843054 	add	r3, r4, #84	; 0x54
3481f2cc:	e58d3000 	str	r3, [sp]
3481f2d0:	e2843e2f 	add	r3, r4, #752	; 0x2f0
3481f2d4:	e58d3004 	str	r3, [sp, #4]
3481f2d8:	e3a00000 	mov	r0, #0
3481f2dc:	e284306c 	add	r3, r4, #108	; 0x6c
3481f2e0:	e2841070 	add	r1, r4, #112	; 0x70
3481f2e4:	e3a02013 	mov	r2, #19
3481f2e8:	ebfffab2 	bl	3481ddb8 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481f2ec:	e3500000 	cmp	r0, #0
3481f2f0:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid code lengths set";
3481f2f4:	159f3624 	ldrne	r3, [pc, #1572]	; 3481f920 <inflate+0x1110>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481f2f8:	1a000234 	bne	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481f2fc:	e59d201c 	ldr	r2, [sp, #28]
            state->mode = CODELENS;
3481f300:	e3a03011 	mov	r3, #17
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481f304:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = CODELENS;
3481f308:	e5843000 	str	r3, [r4]
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481f30c:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481f310:	e5943060 	ldr	r3, [r4, #96]	; 0x60
3481f314:	e0823003 	add	r3, r2, r3
3481f318:	e58d3024 	str	r3, [sp, #36]	; 0x24
3481f31c:	ea000075 	b	3481f4f8 <inflate+0xce8>
                for (;;) {
                    this = state->lencode[BITS(state->lenbits)];
3481f320:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481f324:	e3a00001 	mov	r0, #1
3481f328:	e1a03310 	lsl	r3, r0, r3
3481f32c:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481f330:	e2433001 	sub	r3, r3, #1
3481f334:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481f338:	e1a02009 	mov	r2, r9
3481f33c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3481f340:	e1a09002 	mov	r9, r2
3481f344:	e0060003 	and	r0, r6, r3
3481f348:	e08c0100 	add	r0, ip, r0, lsl #2
3481f34c:	e5d03001 	ldrb	r3, [r0, #1]
3481f350:	e1d000b2 	ldrh	r0, [r0, #2]
                    if ((unsigned)(this.bits) <= bits) break;
3481f354:	e1530005 	cmp	r3, r5
3481f358:	9a000006 	bls	3481f378 <inflate+0xb68>
                    PULLBYTE();
3481f35c:	e3570000 	cmp	r7, #0
3481f360:	0a00022a 	beq	3481fc10 <inflate+0x1400>
3481f364:	e4d23001 	ldrb	r3, [r2], #1
3481f368:	e2477001 	sub	r7, r7, #1
3481f36c:	e0866513 	add	r6, r6, r3, lsl r5
3481f370:	e2855008 	add	r5, r5, #8
                }
3481f374:	eafffff0 	b	3481f33c <inflate+0xb2c>
                if (this.val < 16) {
3481f378:	e350000f 	cmp	r0, #15
3481f37c:	8a000010 	bhi	3481f3c4 <inflate+0xbb4>
3481f380:	ea000005 	b	3481f39c <inflate+0xb8c>
                    NEEDBITS(this.bits);
3481f384:	e3570000 	cmp	r7, #0
3481f388:	0a000220 	beq	3481fc10 <inflate+0x1400>
3481f38c:	e4d2c001 	ldrb	ip, [r2], #1
3481f390:	e2477001 	sub	r7, r7, #1
3481f394:	e086651c 	add	r6, r6, ip, lsl r5
3481f398:	e2855008 	add	r5, r5, #8
3481f39c:	e1550003 	cmp	r5, r3
3481f3a0:	e1a09002 	mov	r9, r2
3481f3a4:	3afffff6 	bcc	3481f384 <inflate+0xb74>
                    DROPBITS(this.bits);
3481f3a8:	e1a06336 	lsr	r6, r6, r3
3481f3ac:	e0635005 	rsb	r5, r3, r5
                    state->lens[state->have++] = this.val;
3481f3b0:	e0843081 	add	r3, r4, r1, lsl #1
3481f3b4:	e2811001 	add	r1, r1, #1
3481f3b8:	e1c307b0 	strh	r0, [r3, #112]	; 0x70
3481f3bc:	e5841068 	str	r1, [r4, #104]	; 0x68
3481f3c0:	ea00004c 	b	3481f4f8 <inflate+0xce8>
                }
                else {
                    if (this.val == 16) {
3481f3c4:	e3500010 	cmp	r0, #16
                        NEEDBITS(this.bits + 2);
3481f3c8:	02830002 	addeq	r0, r3, #2
                    NEEDBITS(this.bits);
                    DROPBITS(this.bits);
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
3481f3cc:	1a000014 	bne	3481f424 <inflate+0xc14>
3481f3d0:	ea000005 	b	3481f3ec <inflate+0xbdc>
                        NEEDBITS(this.bits + 2);
3481f3d4:	e3570000 	cmp	r7, #0
3481f3d8:	0a00020c 	beq	3481fc10 <inflate+0x1400>
3481f3dc:	e4d2c001 	ldrb	ip, [r2], #1
3481f3e0:	e2477001 	sub	r7, r7, #1
3481f3e4:	e086651c 	add	r6, r6, ip, lsl r5
3481f3e8:	e2855008 	add	r5, r5, #8
3481f3ec:	e1550000 	cmp	r5, r0
3481f3f0:	e1a09002 	mov	r9, r2
3481f3f4:	3afffff6 	bcc	3481f3d4 <inflate+0xbc4>
                        DROPBITS(this.bits);
                        if (state->have == 0) {
3481f3f8:	e3510000 	cmp	r1, #0
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
                        NEEDBITS(this.bits + 2);
                        DROPBITS(this.bits);
3481f3fc:	e1a06336 	lsr	r6, r6, r3
3481f400:	e0635005 	rsb	r5, r3, r5
                        if (state->have == 0) {
3481f404:	0a00002f 	beq	3481f4c8 <inflate+0xcb8>
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
3481f408:	e2062003 	and	r2, r6, #3
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
3481f40c:	e0843081 	add	r3, r4, r1, lsl #1
3481f410:	e1d336be 	ldrh	r3, [r3, #110]	; 0x6e
                        copy = 3 + BITS(2);
3481f414:	e2822003 	add	r2, r2, #3
                        DROPBITS(2);
3481f418:	e1a06126 	lsr	r6, r6, #2
3481f41c:	e2455002 	sub	r5, r5, #2
3481f420:	ea000024 	b	3481f4b8 <inflate+0xca8>
                    }
                    else if (this.val == 17) {
3481f424:	e3500011 	cmp	r0, #17
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481f428:	12830007 	addne	r0, r3, #7
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
3481f42c:	02830003 	addeq	r0, r3, #3
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
3481f430:	1a000015 	bne	3481f48c <inflate+0xc7c>
3481f434:	ea000005 	b	3481f450 <inflate+0xc40>
                        NEEDBITS(this.bits + 3);
3481f438:	e3570000 	cmp	r7, #0
3481f43c:	0a0001f3 	beq	3481fc10 <inflate+0x1400>
3481f440:	e4d2c001 	ldrb	ip, [r2], #1
3481f444:	e2477001 	sub	r7, r7, #1
3481f448:	e086651c 	add	r6, r6, ip, lsl r5
3481f44c:	e2855008 	add	r5, r5, #8
3481f450:	e1550000 	cmp	r5, r0
3481f454:	e1a09002 	mov	r9, r2
3481f458:	3afffff6 	bcc	3481f438 <inflate+0xc28>
                        DROPBITS(this.bits);
3481f45c:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 3 + BITS(3);
3481f460:	e2062007 	and	r2, r6, #7
3481f464:	e2822003 	add	r2, r2, #3
                        DROPBITS(3);
3481f468:	e1a061a6 	lsr	r6, r6, #3
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
                        DROPBITS(this.bits);
3481f46c:	e3e00002 	mvn	r0, #2
3481f470:	ea00000d 	b	3481f4ac <inflate+0xc9c>
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481f474:	e3570000 	cmp	r7, #0
3481f478:	0a0001e4 	beq	3481fc10 <inflate+0x1400>
3481f47c:	e4d2c001 	ldrb	ip, [r2], #1
3481f480:	e2477001 	sub	r7, r7, #1
3481f484:	e086651c 	add	r6, r6, ip, lsl r5
3481f488:	e2855008 	add	r5, r5, #8
3481f48c:	e1550000 	cmp	r5, r0
3481f490:	e1a09002 	mov	r9, r2
3481f494:	3afffff6 	bcc	3481f474 <inflate+0xc64>
                        DROPBITS(this.bits);
3481f498:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 11 + BITS(7);
3481f49c:	e206207f 	and	r2, r6, #127	; 0x7f
3481f4a0:	e282200b 	add	r2, r2, #11
                        DROPBITS(7);
3481f4a4:	e1a063a6 	lsr	r6, r6, #7
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
3481f4a8:	e3e00006 	mvn	r0, #6
3481f4ac:	e0630000 	rsb	r0, r3, r0
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
3481f4b0:	e0855000 	add	r5, r5, r0
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
                        len = 0;
3481f4b4:	e3a03000 	mov	r3, #0
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
3481f4b8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
3481f4bc:	e0821001 	add	r1, r2, r1
3481f4c0:	e151000c 	cmp	r1, ip
3481f4c4:	9a000004 	bls	3481f4dc <inflate+0xccc>
                        strm->msg = (char *)"invalid bit length repeat";
3481f4c8:	e59f3454 	ldr	r3, [pc, #1108]	; 3481f924 <inflate+0x1114>
3481f4cc:	e58a3018 	str	r3, [sl, #24]
                        state->mode = BAD;
3481f4d0:	e3a0301b 	mov	r3, #27
3481f4d4:	e5843000 	str	r3, [r4]
                        break;
3481f4d8:	ea00000a 	b	3481f508 <inflate+0xcf8>
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
3481f4dc:	e5941068 	ldr	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481f4e0:	e2522001 	subs	r2, r2, #1
                        state->lens[state->have++] = (unsigned short)len;
3481f4e4:	e0840081 	add	r0, r4, r1, lsl #1
3481f4e8:	e2811001 	add	r1, r1, #1
3481f4ec:	e1c037b0 	strh	r3, [r0, #112]	; 0x70
3481f4f0:	e5841068 	str	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481f4f4:	1afffff8 	bne	3481f4dc <inflate+0xccc>
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481f4f8:	e5941068 	ldr	r1, [r4, #104]	; 0x68
3481f4fc:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3481f500:	e1510000 	cmp	r1, r0
3481f504:	3affff85 	bcc	3481f320 <inflate+0xb10>
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;
3481f508:	e5943000 	ldr	r3, [r4]
3481f50c:	e353001b 	cmp	r3, #27
3481f510:	0afffcdd 	beq	3481e88c <inflate+0x7c>

            /* build code tables */
            state->next = state->codes;
3481f514:	e2843e53 	add	r3, r4, #1328	; 0x530
3481f518:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481f51c:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 9;
3481f520:	e3a03009 	mov	r3, #9
3481f524:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
3481f528:	e284ce2f 	add	ip, r4, #752	; 0x2f0
3481f52c:	e284106c 	add	r1, r4, #108	; 0x6c
3481f530:	e2843054 	add	r3, r4, #84	; 0x54
3481f534:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481f538:	e88d1008 	stm	sp, {r3, ip}
3481f53c:	e5942060 	ldr	r2, [r4, #96]	; 0x60
3481f540:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481f544:	e3a00001 	mov	r0, #1
3481f548:	e2841070 	add	r1, r4, #112	; 0x70
3481f54c:	e58dc018 	str	ip, [sp, #24]
3481f550:	ebfffa18 	bl	3481ddb8 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481f554:	e3500000 	cmp	r0, #0
3481f558:	e58d001c 	str	r0, [sp, #28]
3481f55c:	e59dc018 	ldr	ip, [sp, #24]
                strm->msg = (char *)"invalid literal/lengths set";
3481f560:	159f33c0 	ldrne	r3, [pc, #960]	; 3481f928 <inflate+0x1118>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481f564:	1a000199 	bne	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481f568:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481f56c:	e5941060 	ldr	r1, [r4, #96]	; 0x60
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481f570:	e5843050 	str	r3, [r4, #80]	; 0x50
            state->distbits = 6;
3481f574:	e3a03006 	mov	r3, #6
3481f578:	e5843058 	str	r3, [r4, #88]	; 0x58
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481f57c:	e2843058 	add	r3, r4, #88	; 0x58
3481f580:	e88d1008 	stm	sp, {r3, ip}
3481f584:	e3a00002 	mov	r0, #2
3481f588:	e2811038 	add	r1, r1, #56	; 0x38
3481f58c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481f590:	e0214091 	mla	r1, r1, r0, r4
3481f594:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481f598:	ebfffa06 	bl	3481ddb8 <inflate_table>
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481f59c:	e3500000 	cmp	r0, #0
3481f5a0:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid distances set";
3481f5a4:	159f3380 	ldrne	r3, [pc, #896]	; 3481f92c <inflate+0x111c>
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481f5a8:	1a000188 	bne	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
3481f5ac:	e3a03012 	mov	r3, #18
3481f5b0:	e5843000 	str	r3, [r4]
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
3481f5b4:	e3003101 	movw	r3, #257	; 0x101
3481f5b8:	e3570005 	cmp	r7, #5
3481f5bc:	815b0003 	cmphi	fp, r3
3481f5c0:	9a000011 	bls	3481f60c <inflate+0xdfc>
                RESTORE();
3481f5c4:	e59d2020 	ldr	r2, [sp, #32]
3481f5c8:	e58ab010 	str	fp, [sl, #16]
3481f5cc:	e58a9000 	str	r9, [sl]
3481f5d0:	e58a7004 	str	r7, [sl, #4]
3481f5d4:	e58a200c 	str	r2, [sl, #12]
                inflate_fast(strm, out);
3481f5d8:	e1a0000a 	mov	r0, sl
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
                RESTORE();
3481f5dc:	e5846038 	str	r6, [r4, #56]	; 0x38
3481f5e0:	e584503c 	str	r5, [r4, #60]	; 0x3c
                inflate_fast(strm, out);
3481f5e4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481f5e8:	ebfff895 	bl	3481d844 <inflate_fast>
                LOAD();
3481f5ec:	e59a300c 	ldr	r3, [sl, #12]
3481f5f0:	e59ab010 	ldr	fp, [sl, #16]
3481f5f4:	e58d3020 	str	r3, [sp, #32]
3481f5f8:	e59a9000 	ldr	r9, [sl]
3481f5fc:	e59a7004 	ldr	r7, [sl, #4]
3481f600:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481f604:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
                break;
3481f608:	eafffc9f 	b	3481e88c <inflate+0x7c>
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481f60c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481f610:	e3a00001 	mov	r0, #1
3481f614:	e1a03310 	lsl	r3, r0, r3
3481f618:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481f61c:	e2433001 	sub	r3, r3, #1
3481f620:	e58dc00c 	str	ip, [sp, #12]
3481f624:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481f628:	e1a00009 	mov	r0, r9
3481f62c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3481f630:	e1a09000 	mov	r9, r0
3481f634:	e0063001 	and	r3, r6, r1
3481f638:	e08c1103 	add	r1, ip, r3, lsl #2
3481f63c:	e5d12001 	ldrb	r2, [r1, #1]
3481f640:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481f644:	e1520005 	cmp	r2, r5
                inflate_fast(strm, out);
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481f648:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481f64c:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                if ((unsigned)(this.bits) <= bits) break;
3481f650:	e1a01002 	mov	r1, r2
3481f654:	9a000006 	bls	3481f674 <inflate+0xe64>
                PULLBYTE();
3481f658:	e3570000 	cmp	r7, #0
3481f65c:	0a00016b 	beq	3481fc10 <inflate+0x1400>
3481f660:	e4d03001 	ldrb	r3, [r0], #1
3481f664:	e2477001 	sub	r7, r7, #1
3481f668:	e0866513 	add	r6, r6, r3, lsl r5
3481f66c:	e2855008 	add	r5, r5, #8
            }
3481f670:	eaffffed 	b	3481f62c <inflate+0xe1c>
3481f674:	e58dc00c 	str	ip, [sp, #12]
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f678:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481f67c:	e3530000 	cmp	r3, #0
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f680:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481f684:	0a000020 	beq	3481f70c <inflate+0xefc>
3481f688:	e31300f0 	tst	r3, #240	; 0xf0
3481f68c:	1a00001e 	bne	3481f70c <inflate+0xefc>
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481f690:	e0823003 	add	r3, r2, r3
3481f694:	e3a02001 	mov	r2, #1
3481f698:	e1a03312 	lsl	r3, r2, r3
3481f69c:	e59dc00c 	ldr	ip, [sp, #12]
3481f6a0:	e2433001 	sub	r3, r3, #1
3481f6a4:	e58d3030 	str	r3, [sp, #48]	; 0x30
3481f6a8:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f6ac:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f6b0:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481f6b4:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f6b8:	e0823133 	add	r3, r2, r3, lsr r1
3481f6bc:	e08c0103 	add	r0, ip, r3, lsl #2
3481f6c0:	e5d02001 	ldrb	r2, [r0, #1]
3481f6c4:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481f6c8:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f6cc:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481f6d0:	e0810002 	add	r0, r1, r2
3481f6d4:	e1500005 	cmp	r0, r5
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481f6d8:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481f6dc:	9a000008 	bls	3481f704 <inflate+0xef4>
                    PULLBYTE();
3481f6e0:	e3570000 	cmp	r7, #0
3481f6e4:	0a000149 	beq	3481fc10 <inflate+0x1400>
3481f6e8:	e1a00009 	mov	r0, r9
3481f6ec:	e4d03001 	ldrb	r3, [r0], #1
3481f6f0:	e2477001 	sub	r7, r7, #1
3481f6f4:	e0866513 	add	r6, r6, r3, lsl r5
3481f6f8:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f6fc:	e2855008 	add	r5, r5, #8
                }
3481f700:	eaffffe9 	b	3481f6ac <inflate+0xe9c>
                DROPBITS(last.bits);
3481f704:	e1a06136 	lsr	r6, r6, r1
3481f708:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
3481f70c:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            if ((int)(this.op) == 0) {
3481f710:	e3530000 	cmp	r3, #0
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481f714:	e1a06236 	lsr	r6, r6, r2
3481f718:	e0625005 	rsb	r5, r2, r5
            state->length = (unsigned)this.val;
3481f71c:	e5841040 	str	r1, [r4, #64]	; 0x40
            if ((int)(this.op) == 0) {
                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
3481f720:	02833017 	addeq	r3, r3, #23
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
            if ((int)(this.op) == 0) {
3481f724:	0a00012b 	beq	3481fbd8 <inflate+0x13c8>
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
                break;
            }
            if (this.op & 32) {
3481f728:	e3130020 	tst	r3, #32
3481f72c:	0a000001 	beq	3481f738 <inflate+0xf28>
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
3481f730:	e3a0300b 	mov	r3, #11
3481f734:	ea000127 	b	3481fbd8 <inflate+0x13c8>
                break;
            }
            if (this.op & 64) {
3481f738:	e3130040 	tst	r3, #64	; 0x40
                strm->msg = (char *)"invalid literal/length code";
3481f73c:	159f31ec 	ldrne	r3, [pc, #492]	; 3481f930 <inflate+0x1120>
            if (this.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }
            if (this.op & 64) {
3481f740:	1a000122 	bne	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(this.op) & 15;
3481f744:	e203300f 	and	r3, r3, #15
3481f748:	e5843048 	str	r3, [r4, #72]	; 0x48
            state->mode = LENEXT;
3481f74c:	e3a03013 	mov	r3, #19
3481f750:	e5843000 	str	r3, [r4]
        case LENEXT:
            if (state->extra) {
3481f754:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481f758:	e3530000 	cmp	r3, #0
3481f75c:	11a02009 	movne	r2, r9
3481f760:	1a000006 	bne	3481f780 <inflate+0xf70>
3481f764:	ea000011 	b	3481f7b0 <inflate+0xfa0>
                NEEDBITS(state->extra);
3481f768:	e3570000 	cmp	r7, #0
3481f76c:	0a000127 	beq	3481fc10 <inflate+0x1400>
3481f770:	e4d21001 	ldrb	r1, [r2], #1
3481f774:	e2477001 	sub	r7, r7, #1
3481f778:	e0866511 	add	r6, r6, r1, lsl r5
3481f77c:	e2855008 	add	r5, r5, #8
3481f780:	e1550003 	cmp	r5, r3
3481f784:	e1a09002 	mov	r9, r2
3481f788:	3afffff6 	bcc	3481f768 <inflate+0xf58>
                state->length += BITS(state->extra);
3481f78c:	e3a0c001 	mov	ip, #1
3481f790:	e1a0231c 	lsl	r2, ip, r3
3481f794:	e2422001 	sub	r2, r2, #1
3481f798:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481f79c:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481f7a0:	e5941040 	ldr	r1, [r4, #64]	; 0x40
                DROPBITS(state->extra);
3481f7a4:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481f7a8:	e0812002 	add	r2, r1, r2
3481f7ac:	e5842040 	str	r2, [r4, #64]	; 0x40
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
3481f7b0:	e3a03014 	mov	r3, #20
3481f7b4:	e5843000 	str	r3, [r4]
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481f7b8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
3481f7bc:	e3a01001 	mov	r1, #1
3481f7c0:	e1a03311 	lsl	r3, r1, r3
3481f7c4:	e5940050 	ldr	r0, [r4, #80]	; 0x50
3481f7c8:	e2433001 	sub	r3, r3, #1
3481f7cc:	e58d000c 	str	r0, [sp, #12]
3481f7d0:	e59dc00c 	ldr	ip, [sp, #12]
3481f7d4:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481f7d8:	e1a00009 	mov	r0, r9
3481f7dc:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3481f7e0:	e1a09000 	mov	r9, r0
3481f7e4:	e0063002 	and	r3, r6, r2
3481f7e8:	e08c1103 	add	r1, ip, r3, lsl #2
3481f7ec:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481f7f0:	e5d13001 	ldrb	r3, [r1, #1]
3481f7f4:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481f7f8:	e1530005 	cmp	r3, r5
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481f7fc:	e58d1024 	str	r1, [sp, #36]	; 0x24
                if ((unsigned)(this.bits) <= bits) break;
3481f800:	e1a01003 	mov	r1, r3
3481f804:	9a000006 	bls	3481f824 <inflate+0x1014>
                PULLBYTE();
3481f808:	e3570000 	cmp	r7, #0
3481f80c:	0a0000ff 	beq	3481fc10 <inflate+0x1400>
3481f810:	e4d03001 	ldrb	r3, [r0], #1
3481f814:	e2477001 	sub	r7, r7, #1
3481f818:	e0866513 	add	r6, r6, r3, lsl r5
3481f81c:	e2855008 	add	r5, r5, #8
            }
3481f820:	eaffffed 	b	3481f7dc <inflate+0xfcc>
3481f824:	e58dc00c 	str	ip, [sp, #12]
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f828:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481f82c:	e31200f0 	tst	r2, #240	; 0xf0
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481f830:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481f834:	1a00001e 	bne	3481f8b4 <inflate+0x10a4>
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481f838:	e0832002 	add	r2, r3, r2
3481f83c:	e3a03001 	mov	r3, #1
3481f840:	e1a02213 	lsl	r2, r3, r2
3481f844:	e59dc00c 	ldr	ip, [sp, #12]
3481f848:	e2422001 	sub	r2, r2, #1
3481f84c:	e58d2030 	str	r2, [sp, #48]	; 0x30
3481f850:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f854:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481f858:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481f85c:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481f860:	e0823133 	add	r3, r2, r3, lsr r1
3481f864:	e08c0103 	add	r0, ip, r3, lsl #2
3481f868:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481f86c:	e5d03001 	ldrb	r3, [r0, #1]
3481f870:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481f874:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481f878:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481f87c:	e0810003 	add	r0, r1, r3
3481f880:	e1500005 	cmp	r0, r5
3481f884:	9a000008 	bls	3481f8ac <inflate+0x109c>
                    PULLBYTE();
3481f888:	e3570000 	cmp	r7, #0
3481f88c:	0a0000df 	beq	3481fc10 <inflate+0x1400>
3481f890:	e1a00009 	mov	r0, r9
3481f894:	e4d03001 	ldrb	r3, [r0], #1
3481f898:	e2477001 	sub	r7, r7, #1
3481f89c:	e0866513 	add	r6, r6, r3, lsl r5
3481f8a0:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481f8a4:	e2855008 	add	r5, r5, #8
                }
3481f8a8:	eaffffe9 	b	3481f854 <inflate+0x1044>
                DROPBITS(last.bits);
3481f8ac:	e1a06136 	lsr	r6, r6, r1
3481f8b0:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481f8b4:	e3120040 	tst	r2, #64	; 0x40
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481f8b8:	e1a06336 	lsr	r6, r6, r3
3481f8bc:	e0635005 	rsb	r5, r3, r5
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
3481f8c0:	159f306c 	ldrne	r3, [pc, #108]	; 3481f934 <inflate+0x1124>
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481f8c4:	1a0000c1 	bne	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481f8c8:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            state->extra = (unsigned)(this.op) & 15;
3481f8cc:	e202200f 	and	r2, r2, #15
            state->mode = DISTEXT;
3481f8d0:	e3a03015 	mov	r3, #21
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481f8d4:	e5841044 	str	r1, [r4, #68]	; 0x44
            state->extra = (unsigned)(this.op) & 15;
3481f8d8:	e5842048 	str	r2, [r4, #72]	; 0x48
            state->mode = DISTEXT;
3481f8dc:	e5843000 	str	r3, [r4]
        case DISTEXT:
            if (state->extra) {
3481f8e0:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481f8e4:	e3530000 	cmp	r3, #0
3481f8e8:	11a02009 	movne	r2, r9
3481f8ec:	1a00001a 	bne	3481f95c <inflate+0x114c>
3481f8f0:	ea000025 	b	3481f98c <inflate+0x117c>
3481f8f4:	3482838b 	.word	0x3482838b
3481f8f8:	348283bd 	.word	0x348283bd
3481f8fc:	348283a2 	.word	0x348283a2
3481f900:	348283d1 	.word	0x348283d1
3481f904:	348283ea 	.word	0x348283ea
3481f908:	34822210 	.word	0x34822210
3481f90c:	34822a10 	.word	0x34822a10
3481f910:	348283fe 	.word	0x348283fe
3481f914:	34828411 	.word	0x34828411
3481f918:	3482842e 	.word	0x3482842e
3481f91c:	34822110 	.word	0x34822110
3481f920:	34828452 	.word	0x34828452
3481f924:	3482846b 	.word	0x3482846b
3481f928:	34828485 	.word	0x34828485
3481f92c:	348284a1 	.word	0x348284a1
3481f930:	3482836f 	.word	0x3482836f
3481f934:	34828359 	.word	0x34828359
3481f938:	3482833b 	.word	0x3482833b
3481f93c:	348284b7 	.word	0x348284b7
3481f940:	348284cc 	.word	0x348284cc
                NEEDBITS(state->extra);
3481f944:	e3570000 	cmp	r7, #0
3481f948:	0a0000b0 	beq	3481fc10 <inflate+0x1400>
3481f94c:	e4d21001 	ldrb	r1, [r2], #1
3481f950:	e2477001 	sub	r7, r7, #1
3481f954:	e0866511 	add	r6, r6, r1, lsl r5
3481f958:	e2855008 	add	r5, r5, #8
3481f95c:	e1550003 	cmp	r5, r3
3481f960:	e1a09002 	mov	r9, r2
3481f964:	3afffff6 	bcc	3481f944 <inflate+0x1134>
                state->offset += BITS(state->extra);
3481f968:	e3a0c001 	mov	ip, #1
3481f96c:	e1a0231c 	lsl	r2, ip, r3
3481f970:	e2422001 	sub	r2, r2, #1
3481f974:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481f978:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481f97c:	e5941044 	ldr	r1, [r4, #68]	; 0x44
                DROPBITS(state->extra);
3481f980:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481f984:	e0812002 	add	r2, r1, r2
3481f988:	e5842044 	str	r2, [r4, #68]	; 0x44
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481f98c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481f990:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
3481f994:	e5942044 	ldr	r2, [r4, #68]	; 0x44
3481f998:	e0803003 	add	r3, r0, r3
3481f99c:	e06b3003 	rsb	r3, fp, r3
3481f9a0:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid distance too far back";
3481f9a4:	851f3074 	ldrhi	r3, [pc, #-116]	; 3481f938 <inflate+0x1128>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481f9a8:	8a000088 	bhi	3481fbd0 <inflate+0x13c0>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
3481f9ac:	e3a03016 	mov	r3, #22
3481f9b0:	e5843000 	str	r3, [r4]
        case MATCH:
            if (left == 0) goto inf_leave;
3481f9b4:	e35b0000 	cmp	fp, #0
3481f9b8:	0a000094 	beq	3481fc10 <inflate+0x1400>
            copy = out - left;
3481f9bc:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481f9c0:	e06b2001 	rsb	r2, fp, r1
            if (state->offset > copy) {         /* copy from window */
3481f9c4:	e5941044 	ldr	r1, [r4, #68]	; 0x44
3481f9c8:	e1510002 	cmp	r1, r2
                else
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
3481f9cc:	959d2020 	ldrls	r2, [sp, #32]
3481f9d0:	90611002 	rsbls	r1, r1, r2
                copy = state->length;
3481f9d4:	95942040 	ldrls	r2, [r4, #64]	; 0x40
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
3481f9d8:	9a00000b 	bls	3481fa0c <inflate+0x11fc>
                copy = state->offset - copy;
                if (copy > state->write) {
3481f9dc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
3481f9e0:	e0622001 	rsb	r2, r2, r1
                if (copy > state->write) {
3481f9e4:	e1520003 	cmp	r2, r3
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481f9e8:	85941028 	ldrhi	r1, [r4, #40]	; 0x28
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
3481f9ec:	80632002 	rsbhi	r2, r3, r2
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->write - copy);
3481f9f0:	90621003 	rsbls	r1, r2, r3
3481f9f4:	e5940034 	ldr	r0, [r4, #52]	; 0x34
                if (copy > state->length) copy = state->length;
3481f9f8:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481f9fc:	80621001 	rsbhi	r1, r2, r1
                }
                else
                    from = state->window + (state->write - copy);
3481fa00:	e0801001 	add	r1, r0, r1
                if (copy > state->length) copy = state->length;
3481fa04:	e1520003 	cmp	r2, r3
3481fa08:	21a02003 	movcs	r2, r3
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481fa0c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
3481fa10:	e152000b 	cmp	r2, fp
3481fa14:	21a0200b 	movcs	r2, fp
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481fa18:	e0623003 	rsb	r3, r2, r3
3481fa1c:	e5843040 	str	r3, [r4, #64]	; 0x40
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
3481fa20:	e062b00b 	rsb	fp, r2, fp
            state->length -= copy;
3481fa24:	e3a03000 	mov	r3, #0
            do {
                *put++ = *from++;
3481fa28:	e7d10003 	ldrb	r0, [r1, r3]
3481fa2c:	e59dc020 	ldr	ip, [sp, #32]
3481fa30:	e7cc0003 	strb	r0, [ip, r3]
3481fa34:	e2833001 	add	r3, r3, #1
            } while (--copy);
3481fa38:	e1520003 	cmp	r2, r3
3481fa3c:	1afffff9 	bne	3481fa28 <inflate+0x1218>
            if (state->length == 0) state->mode = LEN;
3481fa40:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481fa44:	e08cc002 	add	ip, ip, r2
            if (state->length == 0) state->mode = LEN;
3481fa48:	e3530000 	cmp	r3, #0
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481fa4c:	e58dc020 	str	ip, [sp, #32]
            if (state->length == 0) state->mode = LEN;
3481fa50:	02833012 	addeq	r3, r3, #18
3481fa54:	0a00005f 	beq	3481fbd8 <inflate+0x13c8>
3481fa58:	eafffb8b 	b	3481e88c <inflate+0x7c>
            break;
        case LIT:
            if (left == 0) goto inf_leave;
3481fa5c:	e35b0000 	cmp	fp, #0
3481fa60:	0a00006a 	beq	3481fc10 <inflate+0x1400>
            *put++ = (unsigned char)(state->length);
3481fa64:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481fa68:	e59d0020 	ldr	r0, [sp, #32]
            left--;
3481fa6c:	e24bb001 	sub	fp, fp, #1
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
3481fa70:	e4c03001 	strb	r3, [r0], #1
3481fa74:	e58d0020 	str	r0, [sp, #32]
            left--;
            state->mode = LEN;
3481fa78:	e3a03012 	mov	r3, #18
3481fa7c:	ea000055 	b	3481fbd8 <inflate+0x13c8>
            break;
        case CHECK:
            if (state->wrap) {
3481fa80:	e5943008 	ldr	r3, [r4, #8]
3481fa84:	e3530000 	cmp	r3, #0
3481fa88:	11a03009 	movne	r3, r9
3481fa8c:	1a000006 	bne	3481faac <inflate+0x129c>
3481fa90:	ea000037 	b	3481fb74 <inflate+0x1364>
                NEEDBITS(32);
3481fa94:	e3570000 	cmp	r7, #0
3481fa98:	0a00005c 	beq	3481fc10 <inflate+0x1400>
3481fa9c:	e4d32001 	ldrb	r2, [r3], #1
3481faa0:	e2477001 	sub	r7, r7, #1
3481faa4:	e0866512 	add	r6, r6, r2, lsl r5
3481faa8:	e2855008 	add	r5, r5, #8
3481faac:	e355001f 	cmp	r5, #31
3481fab0:	e1a09003 	mov	r9, r3
3481fab4:	9afffff6 	bls	3481fa94 <inflate+0x1284>
                out -= left;
3481fab8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
                strm->total_out += out;
3481fabc:	e59a3014 	ldr	r3, [sl, #20]
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
3481fac0:	e06b2001 	rsb	r2, fp, r1
                strm->total_out += out;
3481fac4:	e0833002 	add	r3, r3, r2
3481fac8:	e58a3014 	str	r3, [sl, #20]
                state->total += out;
3481facc:	e594301c 	ldr	r3, [r4, #28]
                if (out)
3481fad0:	e3520000 	cmp	r2, #0
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
3481fad4:	e0833002 	add	r3, r3, r2
3481fad8:	e584301c 	str	r3, [r4, #28]
                if (out)
3481fadc:	0a00000e 	beq	3481fb1c <inflate+0x130c>
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
3481fae0:	e5943010 	ldr	r3, [r4, #16]
3481fae4:	e2621000 	rsb	r1, r2, #0
3481fae8:	e3530000 	cmp	r3, #0
3481faec:	0a000004 	beq	3481fb04 <inflate+0x12f4>
3481faf0:	e59d3020 	ldr	r3, [sp, #32]
3481faf4:	e5940018 	ldr	r0, [r4, #24]
3481faf8:	e0831001 	add	r1, r3, r1
3481fafc:	ebffec20 	bl	3481ab84 <crc32>
3481fb00:	ea000003 	b	3481fb14 <inflate+0x1304>
3481fb04:	e59dc020 	ldr	ip, [sp, #32]
3481fb08:	e5940018 	ldr	r0, [r4, #24]
3481fb0c:	e08c1001 	add	r1, ip, r1
3481fb10:	ebfffa84 	bl	3481e528 <adler32>
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
3481fb14:	e5840018 	str	r0, [r4, #24]
3481fb18:	e58a0034 	str	r0, [sl, #52]	; 0x34
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481fb1c:	e5943010 	ldr	r3, [r4, #16]
3481fb20:	e3530000 	cmp	r3, #0
#endif
                     REVERSE(hold)) != state->check) {
3481fb24:	01a02426 	lsreq	r2, r6, #8
3481fb28:	01a01c26 	lsreq	r1, r6, #24
3481fb2c:	02022cff 	andeq	r2, r2, #65280	; 0xff00
3481fb30:	00811c06 	addeq	r1, r1, r6, lsl #24
3481fb34:	02063cff 	andeq	r3, r6, #65280	; 0xff00
3481fb38:	00812002 	addeq	r2, r1, r2
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481fb3c:	00823403 	addeq	r3, r2, r3, lsl #8
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481fb40:	e5942018 	ldr	r2, [r4, #24]
#ifdef GUNZIP
                     state->flags ? hold :
3481fb44:	11a03006 	movne	r3, r6
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481fb48:	e1530002 	cmp	r3, r2
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481fb4c:	03a05000 	moveq	r5, #0
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481fb50:	058db02c 	streq	fp, [sp, #44]	; 0x2c
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481fb54:	01a06005 	moveq	r6, r5
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481fb58:	0a000005 	beq	3481fb74 <inflate+0x1364>
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481fb5c:	e51f3228 	ldr	r3, [pc, #-552]	; 3481f93c <inflate+0x112c>
                    state->mode = BAD;
                    break;
3481fb60:	e58db02c 	str	fp, [sp, #44]	; 0x2c
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481fb64:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481fb68:	e3a0301b 	mov	r3, #27
3481fb6c:	e5843000 	str	r3, [r4]
                    break;
3481fb70:	eafffb45 	b	3481e88c <inflate+0x7c>
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
3481fb74:	e3a03019 	mov	r3, #25
3481fb78:	e5843000 	str	r3, [r4]
        case LENGTH:
            if (state->wrap && state->flags) {
3481fb7c:	e5943008 	ldr	r3, [r4, #8]
3481fb80:	e3530000 	cmp	r3, #0
3481fb84:	0a000017 	beq	3481fbe8 <inflate+0x13d8>
3481fb88:	e5943010 	ldr	r3, [r4, #16]
3481fb8c:	e3530000 	cmp	r3, #0
3481fb90:	0a000014 	beq	3481fbe8 <inflate+0x13d8>
3481fb94:	e1a03009 	mov	r3, r9
3481fb98:	ea000005 	b	3481fbb4 <inflate+0x13a4>
                NEEDBITS(32);
3481fb9c:	e3570000 	cmp	r7, #0
3481fba0:	0a00001a 	beq	3481fc10 <inflate+0x1400>
3481fba4:	e4d32001 	ldrb	r2, [r3], #1
3481fba8:	e2477001 	sub	r7, r7, #1
3481fbac:	e0866512 	add	r6, r6, r2, lsl r5
3481fbb0:	e2855008 	add	r5, r5, #8
3481fbb4:	e355001f 	cmp	r5, #31
3481fbb8:	e1a09003 	mov	r9, r3
3481fbbc:	9afffff6 	bls	3481fb9c <inflate+0x138c>
                if (hold != (state->total & 0xffffffffUL)) {
3481fbc0:	e594301c 	ldr	r3, [r4, #28]
3481fbc4:	e1560003 	cmp	r6, r3
3481fbc8:	0a000004 	beq	3481fbe0 <inflate+0x13d0>
                    strm->msg = (char *)"incorrect length check";
3481fbcc:	e51f3294 	ldr	r3, [pc, #-660]	; 3481f940 <inflate+0x1130>
3481fbd0:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481fbd4:	e3a0301b 	mov	r3, #27
3481fbd8:	e5843000 	str	r3, [r4]
3481fbdc:	eafffb2a 	b	3481e88c <inflate+0x7c>
                    break;
                }
                INITBITS();
3481fbe0:	e3a05000 	mov	r5, #0
3481fbe4:	e1a06005 	mov	r6, r5
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481fbe8:	e3a0301a 	mov	r3, #26
        case DONE:
            ret = Z_STREAM_END;
3481fbec:	e3a00001 	mov	r0, #1
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481fbf0:	e5843000 	str	r3, [r4]
        case DONE:
            ret = Z_STREAM_END;
3481fbf4:	e58d001c 	str	r0, [sp, #28]
3481fbf8:	ea000004 	b	3481fc10 <inflate+0x1400>
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
3481fbfc:	e3e01002 	mvn	r1, #2
3481fc00:	e58d101c 	str	r1, [sp, #28]
3481fc04:	ea000001 	b	3481fc10 <inflate+0x1400>
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
3481fc08:	e3a02001 	mov	r2, #1
3481fc0c:	e58d201c 	str	r2, [sp, #28]
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481fc10:	e59d3020 	ldr	r3, [sp, #32]
3481fc14:	e58ab010 	str	fp, [sl, #16]
3481fc18:	e58a300c 	str	r3, [sl, #12]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481fc1c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481fc20:	e58a9000 	str	r9, [sl]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481fc24:	e3530000 	cmp	r3, #0
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481fc28:	e58a7004 	str	r7, [sl, #4]
3481fc2c:	e5846038 	str	r6, [r4, #56]	; 0x38
3481fc30:	e584503c 	str	r5, [r4, #60]	; 0x3c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481fc34:	1a000005 	bne	3481fc50 <inflate+0x1440>
3481fc38:	e5943000 	ldr	r3, [r4]
3481fc3c:	e3530017 	cmp	r3, #23
3481fc40:	8a000048 	bhi	3481fd68 <inflate+0x1558>
3481fc44:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481fc48:	e15c000b 	cmp	ip, fp
3481fc4c:	0a000045 	beq	3481fd68 <inflate+0x1558>
unsigned out;
{
    struct inflate_state FAR *state;
    unsigned copy, dist;

    state = (struct inflate_state FAR *)strm->state;
3481fc50:	e59a501c 	ldr	r5, [sl, #28]

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
3481fc54:	e5953034 	ldr	r3, [r5, #52]	; 0x34
3481fc58:	e3530000 	cmp	r3, #0
3481fc5c:	1a000008 	bne	3481fc84 <inflate+0x1474>
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
3481fc60:	e5951024 	ldr	r1, [r5, #36]	; 0x24
3481fc64:	e3a02001 	mov	r2, #1
3481fc68:	e59a3020 	ldr	r3, [sl, #32]
3481fc6c:	e59a0028 	ldr	r0, [sl, #40]	; 0x28
3481fc70:	e1a01112 	lsl	r1, r2, r1
3481fc74:	e12fff33 	blx	r3
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481fc78:	e3500000 	cmp	r0, #0

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
3481fc7c:	e5850034 	str	r0, [r5, #52]	; 0x34
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481fc80:	0a000034 	beq	3481fd58 <inflate+0x1548>
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
3481fc84:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481fc88:	e3530000 	cmp	r3, #0
3481fc8c:	1a000005 	bne	3481fca8 <inflate+0x1498>
        state->wsize = 1U << state->wbits;
3481fc90:	e5952024 	ldr	r2, [r5, #36]	; 0x24
3481fc94:	e3a01001 	mov	r1, #1
3481fc98:	e1a02211 	lsl	r2, r1, r2
        state->write = 0;
3481fc9c:	e5853030 	str	r3, [r5, #48]	; 0x30
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
3481fca0:	e5852028 	str	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
3481fca4:	e585302c 	str	r3, [r5, #44]	; 0x2c
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481fca8:	e59a6010 	ldr	r6, [sl, #16]
3481fcac:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    if (copy >= state->wsize) {
3481fcb0:	e5952028 	ldr	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481fcb4:	e0666000 	rsb	r6, r6, r0
    if (copy >= state->wsize) {
3481fcb8:	e1560002 	cmp	r6, r2
3481fcbc:	e59a100c 	ldr	r1, [sl, #12]
3481fcc0:	3a000005 	bcc	3481fcdc <inflate+0x14cc>
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
3481fcc4:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481fcc8:	e0621001 	rsb	r1, r2, r1
3481fccc:	ebfff32e 	bl	3481c98c <memcpy>
        state->write = 0;
3481fcd0:	e3a03000 	mov	r3, #0
3481fcd4:	e5853030 	str	r3, [r5, #48]	; 0x30
3481fcd8:	ea000010 	b	3481fd20 <inflate+0x1510>
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481fcdc:	e5953030 	ldr	r3, [r5, #48]	; 0x30
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481fce0:	e5950034 	ldr	r0, [r5, #52]	; 0x34
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
        state->write = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481fce4:	e0637002 	rsb	r7, r3, r2
3481fce8:	e1560007 	cmp	r6, r7
3481fcec:	31a07006 	movcc	r7, r6
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481fcf0:	e0661001 	rsb	r1, r6, r1
3481fcf4:	e0800003 	add	r0, r0, r3
3481fcf8:	e1a02007 	mov	r2, r7
3481fcfc:	ebfff322 	bl	3481c98c <memcpy>
        copy -= dist;
        if (copy) {
3481fd00:	e0566007 	subs	r6, r6, r7
3481fd04:	0a000008 	beq	3481fd2c <inflate+0x151c>
            zmemcpy(state->window, strm->next_out - copy, copy);
3481fd08:	e59a100c 	ldr	r1, [sl, #12]
3481fd0c:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481fd10:	e0661001 	rsb	r1, r6, r1
3481fd14:	e1a02006 	mov	r2, r6
3481fd18:	ebfff31b 	bl	3481c98c <memcpy>
            state->write = copy;
3481fd1c:	e5856030 	str	r6, [r5, #48]	; 0x30
            state->whave = state->wsize;
3481fd20:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481fd24:	e585302c 	str	r3, [r5, #44]	; 0x2c
3481fd28:	ea00000e 	b	3481fd68 <inflate+0x1558>
        }
        else {
            state->write += dist;
3481fd2c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
3481fd30:	e5952028 	ldr	r2, [r5, #40]	; 0x28
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481fd34:	e0873003 	add	r3, r7, r3
            if (state->write == state->wsize) state->write = 0;
3481fd38:	e1530002 	cmp	r3, r2
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481fd3c:	e5853030 	str	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
            if (state->whave < state->wsize) state->whave += dist;
3481fd40:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
            if (state->write == state->wsize) state->write = 0;
3481fd44:	05856030 	streq	r6, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
3481fd48:	e1530002 	cmp	r3, r2
3481fd4c:	30877003 	addcc	r7, r7, r3
3481fd50:	3585702c 	strcc	r7, [r5, #44]	; 0x2c
3481fd54:	ea000003 	b	3481fd68 <inflate+0x1558>
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
3481fd58:	e3a0301c 	mov	r3, #28
3481fd5c:	e5843000 	str	r3, [r4]
            return Z_MEM_ERROR;
3481fd60:	e3e01003 	mvn	r1, #3
3481fd64:	ea00003b 	b	3481fe58 <inflate+0x1648>
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
3481fd68:	e59a6010 	ldr	r6, [sl, #16]
3481fd6c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481fd70:	e59a5004 	ldr	r5, [sl, #4]
3481fd74:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    out -= strm->avail_out;
3481fd78:	e0666003 	rsb	r6, r6, r3
    strm->total_in += in;
3481fd7c:	e59a3008 	ldr	r3, [sl, #8]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481fd80:	e0655002 	rsb	r5, r5, r2
    out -= strm->avail_out;
    strm->total_in += in;
3481fd84:	e0833005 	add	r3, r3, r5
3481fd88:	e58a3008 	str	r3, [sl, #8]
    strm->total_out += out;
3481fd8c:	e59a3014 	ldr	r3, [sl, #20]
3481fd90:	e0833006 	add	r3, r3, r6
3481fd94:	e58a3014 	str	r3, [sl, #20]
    state->total += out;
3481fd98:	e594301c 	ldr	r3, [r4, #28]
3481fd9c:	e0833006 	add	r3, r3, r6
3481fda0:	e584301c 	str	r3, [r4, #28]
    if (state->wrap && out)
3481fda4:	e5943008 	ldr	r3, [r4, #8]
3481fda8:	e3560000 	cmp	r6, #0
3481fdac:	13530000 	cmpne	r3, #0
3481fdb0:	0a00000f 	beq	3481fdf4 <inflate+0x15e4>
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
3481fdb4:	e5943010 	ldr	r3, [r4, #16]
3481fdb8:	e59a100c 	ldr	r1, [sl, #12]
3481fdbc:	e3530000 	cmp	r3, #0
3481fdc0:	e2663000 	rsb	r3, r6, #0
3481fdc4:	0a000004 	beq	3481fddc <inflate+0x15cc>
3481fdc8:	e5940018 	ldr	r0, [r4, #24]
3481fdcc:	e0811003 	add	r1, r1, r3
3481fdd0:	e1a02006 	mov	r2, r6
3481fdd4:	ebffeb6a 	bl	3481ab84 <crc32>
3481fdd8:	ea000003 	b	3481fdec <inflate+0x15dc>
3481fddc:	e5940018 	ldr	r0, [r4, #24]
3481fde0:	e0811003 	add	r1, r1, r3
3481fde4:	e1a02006 	mov	r2, r6
3481fde8:	ebfff9ce 	bl	3481e528 <adler32>
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
3481fdec:	e5840018 	str	r0, [r4, #24]
3481fdf0:	e58a0034 	str	r0, [sl, #52]	; 0x34
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481fdf4:	e5943004 	ldr	r3, [r4, #4]
3481fdf8:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
3481fdfc:	e3530000 	cmp	r3, #0
3481fe00:	13a03040 	movne	r3, #64	; 0x40
3481fe04:	03a03000 	moveq	r3, #0
3481fe08:	e0833002 	add	r3, r3, r2
3481fe0c:	e5942000 	ldr	r2, [r4]
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481fe10:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481fe14:	e352000b 	cmp	r2, #11
3481fe18:	03a02080 	moveq	r2, #128	; 0x80
3481fe1c:	13a02000 	movne	r2, #0
3481fe20:	e0833002 	add	r3, r3, r2
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481fe24:	e1966005 	orrs	r6, r6, r5
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481fe28:	e58a302c 	str	r3, [sl, #44]	; 0x2c
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481fe2c:	13a03000 	movne	r3, #0
3481fe30:	03a03001 	moveq	r3, #1
3481fe34:	e35c0004 	cmp	ip, #4
3481fe38:	03833001 	orreq	r3, r3, #1
3481fe3c:	e3530000 	cmp	r3, #0
3481fe40:	0a00000d 	beq	3481fe7c <inflate+0x166c>
        ret = Z_BUF_ERROR;
3481fe44:	e59d001c 	ldr	r0, [sp, #28]
3481fe48:	e3500000 	cmp	r0, #0
3481fe4c:	03e00004 	mvneq	r0, #4
3481fe50:	e58d001c 	str	r0, [sp, #28]
3481fe54:	ea000008 	b	3481fe7c <inflate+0x166c>
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481fe58:	e58d101c 	str	r1, [sp, #28]
3481fe5c:	ea000006 	b	3481fe7c <inflate+0x166c>
3481fe60:	e3e02001 	mvn	r2, #1
3481fe64:	e58d201c 	str	r2, [sp, #28]
3481fe68:	ea000003 	b	3481fe7c <inflate+0x166c>
3481fe6c:	e58d301c 	str	r3, [sp, #28]
3481fe70:	ea000001 	b	3481fe7c <inflate+0x166c>
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
3481fe74:	e3e0c001 	mvn	ip, #1
3481fe78:	e58dc01c 	str	ip, [sp, #28]
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}
3481fe7c:	e59d001c 	ldr	r0, [sp, #28]
3481fe80:	e28dd048 	add	sp, sp, #72	; 0x48
3481fe84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481fe88 <raise>:
 */

#include <common.h>

int raise (int signum)
{
3481fe88:	e1a01000 	mov	r1, r0
3481fe8c:	e92d4008 	push	{r3, lr}
	/* Even if printf() is available, it's large. Punt it for SPL builds */
#if !defined(CONFIG_SPL_BUILD)
	printf("raise: Signal # %d caught\n", signum);
3481fe90:	e59f0008 	ldr	r0, [pc, #8]	; 3481fea0 <raise+0x18>
3481fe94:	ebffa747 	bl	34809bb8 <printf>
#endif
	return 0;
}
3481fe98:	e3a00000 	mov	r0, #0
3481fe9c:	e8bd8008 	pop	{r3, pc}
3481fea0:	34828557 	.word	0x34828557

3481fea4 <__aeabi_unwind_cpp_pr0>:

/* Dummy function to avoid linker complaints */
void __aeabi_unwind_cpp_pr0(void)
{
};
3481fea4:	e12fff1e 	bx	lr

3481fea8 <__aeabi_unwind_cpp_pr1>:

void __aeabi_unwind_cpp_pr1(void)
{
};
3481fea8:	e12fff1e 	bx	lr

3481feac <__udivsi3>:
3481feac:	e2512001 	subs	r2, r1, #1
3481feb0:	012fff1e 	bxeq	lr
3481feb4:	3a000074 	bcc	3482008c <__udivsi3+0x1e0>
3481feb8:	e1500001 	cmp	r0, r1
3481febc:	9a00006b 	bls	34820070 <__udivsi3+0x1c4>
3481fec0:	e1110002 	tst	r1, r2
3481fec4:	0a00006c 	beq	3482007c <__udivsi3+0x1d0>
3481fec8:	e16f3f10 	clz	r3, r0
3481fecc:	e16f2f11 	clz	r2, r1
3481fed0:	e0423003 	sub	r3, r2, r3
3481fed4:	e273301f 	rsbs	r3, r3, #31
3481fed8:	10833083 	addne	r3, r3, r3, lsl #1
3481fedc:	e3a02000 	mov	r2, #0
3481fee0:	108ff103 	addne	pc, pc, r3, lsl #2
3481fee4:	e320f000 	nop	{0}
3481fee8:	e1500f81 	cmp	r0, r1, lsl #31
3481feec:	e0a22002 	adc	r2, r2, r2
3481fef0:	20400f81 	subcs	r0, r0, r1, lsl #31
3481fef4:	e1500f01 	cmp	r0, r1, lsl #30
3481fef8:	e0a22002 	adc	r2, r2, r2
3481fefc:	20400f01 	subcs	r0, r0, r1, lsl #30
3481ff00:	e1500e81 	cmp	r0, r1, lsl #29
3481ff04:	e0a22002 	adc	r2, r2, r2
3481ff08:	20400e81 	subcs	r0, r0, r1, lsl #29
3481ff0c:	e1500e01 	cmp	r0, r1, lsl #28
3481ff10:	e0a22002 	adc	r2, r2, r2
3481ff14:	20400e01 	subcs	r0, r0, r1, lsl #28
3481ff18:	e1500d81 	cmp	r0, r1, lsl #27
3481ff1c:	e0a22002 	adc	r2, r2, r2
3481ff20:	20400d81 	subcs	r0, r0, r1, lsl #27
3481ff24:	e1500d01 	cmp	r0, r1, lsl #26
3481ff28:	e0a22002 	adc	r2, r2, r2
3481ff2c:	20400d01 	subcs	r0, r0, r1, lsl #26
3481ff30:	e1500c81 	cmp	r0, r1, lsl #25
3481ff34:	e0a22002 	adc	r2, r2, r2
3481ff38:	20400c81 	subcs	r0, r0, r1, lsl #25
3481ff3c:	e1500c01 	cmp	r0, r1, lsl #24
3481ff40:	e0a22002 	adc	r2, r2, r2
3481ff44:	20400c01 	subcs	r0, r0, r1, lsl #24
3481ff48:	e1500b81 	cmp	r0, r1, lsl #23
3481ff4c:	e0a22002 	adc	r2, r2, r2
3481ff50:	20400b81 	subcs	r0, r0, r1, lsl #23
3481ff54:	e1500b01 	cmp	r0, r1, lsl #22
3481ff58:	e0a22002 	adc	r2, r2, r2
3481ff5c:	20400b01 	subcs	r0, r0, r1, lsl #22
3481ff60:	e1500a81 	cmp	r0, r1, lsl #21
3481ff64:	e0a22002 	adc	r2, r2, r2
3481ff68:	20400a81 	subcs	r0, r0, r1, lsl #21
3481ff6c:	e1500a01 	cmp	r0, r1, lsl #20
3481ff70:	e0a22002 	adc	r2, r2, r2
3481ff74:	20400a01 	subcs	r0, r0, r1, lsl #20
3481ff78:	e1500981 	cmp	r0, r1, lsl #19
3481ff7c:	e0a22002 	adc	r2, r2, r2
3481ff80:	20400981 	subcs	r0, r0, r1, lsl #19
3481ff84:	e1500901 	cmp	r0, r1, lsl #18
3481ff88:	e0a22002 	adc	r2, r2, r2
3481ff8c:	20400901 	subcs	r0, r0, r1, lsl #18
3481ff90:	e1500881 	cmp	r0, r1, lsl #17
3481ff94:	e0a22002 	adc	r2, r2, r2
3481ff98:	20400881 	subcs	r0, r0, r1, lsl #17
3481ff9c:	e1500801 	cmp	r0, r1, lsl #16
3481ffa0:	e0a22002 	adc	r2, r2, r2
3481ffa4:	20400801 	subcs	r0, r0, r1, lsl #16
3481ffa8:	e1500781 	cmp	r0, r1, lsl #15
3481ffac:	e0a22002 	adc	r2, r2, r2
3481ffb0:	20400781 	subcs	r0, r0, r1, lsl #15
3481ffb4:	e1500701 	cmp	r0, r1, lsl #14
3481ffb8:	e0a22002 	adc	r2, r2, r2
3481ffbc:	20400701 	subcs	r0, r0, r1, lsl #14
3481ffc0:	e1500681 	cmp	r0, r1, lsl #13
3481ffc4:	e0a22002 	adc	r2, r2, r2
3481ffc8:	20400681 	subcs	r0, r0, r1, lsl #13
3481ffcc:	e1500601 	cmp	r0, r1, lsl #12
3481ffd0:	e0a22002 	adc	r2, r2, r2
3481ffd4:	20400601 	subcs	r0, r0, r1, lsl #12
3481ffd8:	e1500581 	cmp	r0, r1, lsl #11
3481ffdc:	e0a22002 	adc	r2, r2, r2
3481ffe0:	20400581 	subcs	r0, r0, r1, lsl #11
3481ffe4:	e1500501 	cmp	r0, r1, lsl #10
3481ffe8:	e0a22002 	adc	r2, r2, r2
3481ffec:	20400501 	subcs	r0, r0, r1, lsl #10
3481fff0:	e1500481 	cmp	r0, r1, lsl #9
3481fff4:	e0a22002 	adc	r2, r2, r2
3481fff8:	20400481 	subcs	r0, r0, r1, lsl #9
3481fffc:	e1500401 	cmp	r0, r1, lsl #8
34820000:	e0a22002 	adc	r2, r2, r2
34820004:	20400401 	subcs	r0, r0, r1, lsl #8
34820008:	e1500381 	cmp	r0, r1, lsl #7
3482000c:	e0a22002 	adc	r2, r2, r2
34820010:	20400381 	subcs	r0, r0, r1, lsl #7
34820014:	e1500301 	cmp	r0, r1, lsl #6
34820018:	e0a22002 	adc	r2, r2, r2
3482001c:	20400301 	subcs	r0, r0, r1, lsl #6
34820020:	e1500281 	cmp	r0, r1, lsl #5
34820024:	e0a22002 	adc	r2, r2, r2
34820028:	20400281 	subcs	r0, r0, r1, lsl #5
3482002c:	e1500201 	cmp	r0, r1, lsl #4
34820030:	e0a22002 	adc	r2, r2, r2
34820034:	20400201 	subcs	r0, r0, r1, lsl #4
34820038:	e1500181 	cmp	r0, r1, lsl #3
3482003c:	e0a22002 	adc	r2, r2, r2
34820040:	20400181 	subcs	r0, r0, r1, lsl #3
34820044:	e1500101 	cmp	r0, r1, lsl #2
34820048:	e0a22002 	adc	r2, r2, r2
3482004c:	20400101 	subcs	r0, r0, r1, lsl #2
34820050:	e1500081 	cmp	r0, r1, lsl #1
34820054:	e0a22002 	adc	r2, r2, r2
34820058:	20400081 	subcs	r0, r0, r1, lsl #1
3482005c:	e1500001 	cmp	r0, r1
34820060:	e0a22002 	adc	r2, r2, r2
34820064:	20400001 	subcs	r0, r0, r1
34820068:	e1a00002 	mov	r0, r2
3482006c:	e12fff1e 	bx	lr
34820070:	03a00001 	moveq	r0, #1
34820074:	13a00000 	movne	r0, #0
34820078:	e12fff1e 	bx	lr
3482007c:	e16f2f11 	clz	r2, r1
34820080:	e262201f 	rsb	r2, r2, #31
34820084:	e1a00230 	lsr	r0, r0, r2
34820088:	e12fff1e 	bx	lr
3482008c:	e3500000 	cmp	r0, #0
34820090:	13e00000 	mvnne	r0, #0
34820094:	ea0000ac 	b	3482034c <__aeabi_ldiv0>

34820098 <__aeabi_uidivmod>:
34820098:	e3510000 	cmp	r1, #0
3482009c:	0afffffa 	beq	3482008c <__udivsi3+0x1e0>
348200a0:	e92d4003 	push	{r0, r1, lr}
348200a4:	ebffff80 	bl	3481feac <__udivsi3>
348200a8:	e8bd4006 	pop	{r1, r2, lr}
348200ac:	e0030092 	mul	r3, r2, r0
348200b0:	e0411003 	sub	r1, r1, r3
348200b4:	e12fff1e 	bx	lr

348200b8 <__divsi3>:
348200b8:	e3510000 	cmp	r1, #0
348200bc:	0a000081 	beq	348202c8 <.divsi3_skip_div0_test+0x208>

348200c0 <.divsi3_skip_div0_test>:
348200c0:	e020c001 	eor	ip, r0, r1
348200c4:	42611000 	rsbmi	r1, r1, #0
348200c8:	e2512001 	subs	r2, r1, #1
348200cc:	0a000070 	beq	34820294 <.divsi3_skip_div0_test+0x1d4>
348200d0:	e1b03000 	movs	r3, r0
348200d4:	42603000 	rsbmi	r3, r0, #0
348200d8:	e1530001 	cmp	r3, r1
348200dc:	9a00006f 	bls	348202a0 <.divsi3_skip_div0_test+0x1e0>
348200e0:	e1110002 	tst	r1, r2
348200e4:	0a000071 	beq	348202b0 <.divsi3_skip_div0_test+0x1f0>
348200e8:	e16f2f13 	clz	r2, r3
348200ec:	e16f0f11 	clz	r0, r1
348200f0:	e0402002 	sub	r2, r0, r2
348200f4:	e272201f 	rsbs	r2, r2, #31
348200f8:	10822082 	addne	r2, r2, r2, lsl #1
348200fc:	e3a00000 	mov	r0, #0
34820100:	108ff102 	addne	pc, pc, r2, lsl #2
34820104:	e320f000 	nop	{0}
34820108:	e1530f81 	cmp	r3, r1, lsl #31
3482010c:	e0a00000 	adc	r0, r0, r0
34820110:	20433f81 	subcs	r3, r3, r1, lsl #31
34820114:	e1530f01 	cmp	r3, r1, lsl #30
34820118:	e0a00000 	adc	r0, r0, r0
3482011c:	20433f01 	subcs	r3, r3, r1, lsl #30
34820120:	e1530e81 	cmp	r3, r1, lsl #29
34820124:	e0a00000 	adc	r0, r0, r0
34820128:	20433e81 	subcs	r3, r3, r1, lsl #29
3482012c:	e1530e01 	cmp	r3, r1, lsl #28
34820130:	e0a00000 	adc	r0, r0, r0
34820134:	20433e01 	subcs	r3, r3, r1, lsl #28
34820138:	e1530d81 	cmp	r3, r1, lsl #27
3482013c:	e0a00000 	adc	r0, r0, r0
34820140:	20433d81 	subcs	r3, r3, r1, lsl #27
34820144:	e1530d01 	cmp	r3, r1, lsl #26
34820148:	e0a00000 	adc	r0, r0, r0
3482014c:	20433d01 	subcs	r3, r3, r1, lsl #26
34820150:	e1530c81 	cmp	r3, r1, lsl #25
34820154:	e0a00000 	adc	r0, r0, r0
34820158:	20433c81 	subcs	r3, r3, r1, lsl #25
3482015c:	e1530c01 	cmp	r3, r1, lsl #24
34820160:	e0a00000 	adc	r0, r0, r0
34820164:	20433c01 	subcs	r3, r3, r1, lsl #24
34820168:	e1530b81 	cmp	r3, r1, lsl #23
3482016c:	e0a00000 	adc	r0, r0, r0
34820170:	20433b81 	subcs	r3, r3, r1, lsl #23
34820174:	e1530b01 	cmp	r3, r1, lsl #22
34820178:	e0a00000 	adc	r0, r0, r0
3482017c:	20433b01 	subcs	r3, r3, r1, lsl #22
34820180:	e1530a81 	cmp	r3, r1, lsl #21
34820184:	e0a00000 	adc	r0, r0, r0
34820188:	20433a81 	subcs	r3, r3, r1, lsl #21
3482018c:	e1530a01 	cmp	r3, r1, lsl #20
34820190:	e0a00000 	adc	r0, r0, r0
34820194:	20433a01 	subcs	r3, r3, r1, lsl #20
34820198:	e1530981 	cmp	r3, r1, lsl #19
3482019c:	e0a00000 	adc	r0, r0, r0
348201a0:	20433981 	subcs	r3, r3, r1, lsl #19
348201a4:	e1530901 	cmp	r3, r1, lsl #18
348201a8:	e0a00000 	adc	r0, r0, r0
348201ac:	20433901 	subcs	r3, r3, r1, lsl #18
348201b0:	e1530881 	cmp	r3, r1, lsl #17
348201b4:	e0a00000 	adc	r0, r0, r0
348201b8:	20433881 	subcs	r3, r3, r1, lsl #17
348201bc:	e1530801 	cmp	r3, r1, lsl #16
348201c0:	e0a00000 	adc	r0, r0, r0
348201c4:	20433801 	subcs	r3, r3, r1, lsl #16
348201c8:	e1530781 	cmp	r3, r1, lsl #15
348201cc:	e0a00000 	adc	r0, r0, r0
348201d0:	20433781 	subcs	r3, r3, r1, lsl #15
348201d4:	e1530701 	cmp	r3, r1, lsl #14
348201d8:	e0a00000 	adc	r0, r0, r0
348201dc:	20433701 	subcs	r3, r3, r1, lsl #14
348201e0:	e1530681 	cmp	r3, r1, lsl #13
348201e4:	e0a00000 	adc	r0, r0, r0
348201e8:	20433681 	subcs	r3, r3, r1, lsl #13
348201ec:	e1530601 	cmp	r3, r1, lsl #12
348201f0:	e0a00000 	adc	r0, r0, r0
348201f4:	20433601 	subcs	r3, r3, r1, lsl #12
348201f8:	e1530581 	cmp	r3, r1, lsl #11
348201fc:	e0a00000 	adc	r0, r0, r0
34820200:	20433581 	subcs	r3, r3, r1, lsl #11
34820204:	e1530501 	cmp	r3, r1, lsl #10
34820208:	e0a00000 	adc	r0, r0, r0
3482020c:	20433501 	subcs	r3, r3, r1, lsl #10
34820210:	e1530481 	cmp	r3, r1, lsl #9
34820214:	e0a00000 	adc	r0, r0, r0
34820218:	20433481 	subcs	r3, r3, r1, lsl #9
3482021c:	e1530401 	cmp	r3, r1, lsl #8
34820220:	e0a00000 	adc	r0, r0, r0
34820224:	20433401 	subcs	r3, r3, r1, lsl #8
34820228:	e1530381 	cmp	r3, r1, lsl #7
3482022c:	e0a00000 	adc	r0, r0, r0
34820230:	20433381 	subcs	r3, r3, r1, lsl #7
34820234:	e1530301 	cmp	r3, r1, lsl #6
34820238:	e0a00000 	adc	r0, r0, r0
3482023c:	20433301 	subcs	r3, r3, r1, lsl #6
34820240:	e1530281 	cmp	r3, r1, lsl #5
34820244:	e0a00000 	adc	r0, r0, r0
34820248:	20433281 	subcs	r3, r3, r1, lsl #5
3482024c:	e1530201 	cmp	r3, r1, lsl #4
34820250:	e0a00000 	adc	r0, r0, r0
34820254:	20433201 	subcs	r3, r3, r1, lsl #4
34820258:	e1530181 	cmp	r3, r1, lsl #3
3482025c:	e0a00000 	adc	r0, r0, r0
34820260:	20433181 	subcs	r3, r3, r1, lsl #3
34820264:	e1530101 	cmp	r3, r1, lsl #2
34820268:	e0a00000 	adc	r0, r0, r0
3482026c:	20433101 	subcs	r3, r3, r1, lsl #2
34820270:	e1530081 	cmp	r3, r1, lsl #1
34820274:	e0a00000 	adc	r0, r0, r0
34820278:	20433081 	subcs	r3, r3, r1, lsl #1
3482027c:	e1530001 	cmp	r3, r1
34820280:	e0a00000 	adc	r0, r0, r0
34820284:	20433001 	subcs	r3, r3, r1
34820288:	e35c0000 	cmp	ip, #0
3482028c:	42600000 	rsbmi	r0, r0, #0
34820290:	e12fff1e 	bx	lr
34820294:	e13c0000 	teq	ip, r0
34820298:	42600000 	rsbmi	r0, r0, #0
3482029c:	e12fff1e 	bx	lr
348202a0:	33a00000 	movcc	r0, #0
348202a4:	01a00fcc 	asreq	r0, ip, #31
348202a8:	03800001 	orreq	r0, r0, #1
348202ac:	e12fff1e 	bx	lr
348202b0:	e16f2f11 	clz	r2, r1
348202b4:	e262201f 	rsb	r2, r2, #31
348202b8:	e35c0000 	cmp	ip, #0
348202bc:	e1a00233 	lsr	r0, r3, r2
348202c0:	42600000 	rsbmi	r0, r0, #0
348202c4:	e12fff1e 	bx	lr
348202c8:	e3500000 	cmp	r0, #0
348202cc:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
348202d0:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
348202d4:	ea00001c 	b	3482034c <__aeabi_ldiv0>

348202d8 <__aeabi_idivmod>:
348202d8:	e3510000 	cmp	r1, #0
348202dc:	0afffff9 	beq	348202c8 <.divsi3_skip_div0_test+0x208>
348202e0:	e92d4003 	push	{r0, r1, lr}
348202e4:	ebffff75 	bl	348200c0 <.divsi3_skip_div0_test>
348202e8:	e8bd4006 	pop	{r1, r2, lr}
348202ec:	e0030092 	mul	r3, r2, r0
348202f0:	e0411003 	sub	r1, r1, r3
348202f4:	e12fff1e 	bx	lr

348202f8 <__lshrdi3>:
348202f8:	e2523020 	subs	r3, r2, #32
348202fc:	e262c020 	rsb	ip, r2, #32
34820300:	41a00230 	lsrmi	r0, r0, r2
34820304:	51a00331 	lsrpl	r0, r1, r3
34820308:	41800c11 	orrmi	r0, r0, r1, lsl ip
3482030c:	e1a01231 	lsr	r1, r1, r2
34820310:	e12fff1e 	bx	lr

34820314 <__ashrdi3>:
34820314:	e2523020 	subs	r3, r2, #32
34820318:	e262c020 	rsb	ip, r2, #32
3482031c:	41a00230 	lsrmi	r0, r0, r2
34820320:	51a00351 	asrpl	r0, r1, r3
34820324:	41800c11 	orrmi	r0, r0, r1, lsl ip
34820328:	e1a01251 	asr	r1, r1, r2
3482032c:	e12fff1e 	bx	lr

34820330 <__ashldi3>:
34820330:	e2523020 	subs	r3, r2, #32
34820334:	e262c020 	rsb	ip, r2, #32
34820338:	41a01211 	lslmi	r1, r1, r2
3482033c:	51a01310 	lslpl	r1, r0, r3
34820340:	41811c30 	orrmi	r1, r1, r0, lsr ip
34820344:	e1a00210 	lsl	r0, r0, r2
34820348:	e12fff1e 	bx	lr

3482034c <__aeabi_ldiv0>:
3482034c:	e92d4002 	push	{r1, lr}
34820350:	e3a00008 	mov	r0, #8
34820354:	ebfffecb 	bl	3481fe88 <raise>
34820358:	e8bd8002 	pop	{r1, pc}
